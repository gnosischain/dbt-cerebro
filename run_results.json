{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.4", "generated_at": "2025-06-06T11:21:01.131811Z", "invocation_id": "7e7117a1-8981-4f78-ac24-b39396db1270", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.333117Z", "completed_at": "2025-06-06T11:21:00.492069Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.559239Z", "completed_at": "2025-06-06T11:21:00.559263Z"}], "thread_id": "Thread-1", "execution_time": 0.2483198642730713, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.consensus_validators_balances_dist_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q_balance[1] AS q05,\n    q_balance[2] AS q10,\n    q_balance[3] AS q25,\n    q_balance[4] AS q50,\n    q_balance[5] AS q75,\n    q_balance[6] AS q90,\n    q_balance[7] AS q95\nFROM (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n        quantilesExactExclusive(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(balance/POWER(10,9)) AS q_balance\n    FROM `consensus`.`validators`\n    WHERE \n        status = 'active_ongoing'\n        AND\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`consensus_validators_balances_dist_daily`\n    )\n  \n\n    GROUP BY date\n)", "relation_name": "`dbt`.`consensus_validators_balances_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.453799Z", "completed_at": "2025-06-06T11:21:00.509138Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.582685Z", "completed_at": "2025-06-06T11:21:00.582700Z"}], "thread_id": "Thread-2", "execution_time": 0.26895785331726074, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.consensus_validators_status_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,status\n    ,COUNT(*) AS cnt\nFROM `consensus`.`validators`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`consensus_validators_status_daily`\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`consensus_validators_status_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.467967Z", "completed_at": "2025-06-06T11:21:00.522957Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.612062Z", "completed_at": "2025-06-06T11:21:00.612079Z"}], "thread_id": "Thread-3", "execution_time": 0.2963545322418213, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_GBCDeposit_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_GBCDeposit_calls`)\n      \n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arrayMap(x -> JSONExtractString(x, 'name'),\n             arraySort(x -> toInt32OrZero(JSONExtractRaw(x, 'position')),\n                       JSONExtractArrayRaw(input_params))) AS names,\n    arrayMap(x -> JSONExtractString(x, 'type'),\n             arraySort(x -> toInt32OrZero(JSONExtractRaw(x, 'position')),\n                       JSONExtractArrayRaw(input_params))) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input, '0x', ''),1,8) AS call_selector,\n      substring(replaceAll(t.input, '0x', ''),9) AS args_raw_hex,\n      a.names AS param_names,\n      a.types AS param_types,\n\n      -- flags for dynamic params\n      arrayMap(i ->\n        if(\n          param_types[i+1] = 'bytes' OR\n          param_types[i+1] = 'string' OR\n          endsWith(param_types[i+1],'[]') OR\n          (startsWith(param_types[i+1],'bytes') AND param_types[i+1] != 'bytes32'),\n          1,\n          0\n        ),\n        range(length(param_types))\n      ) AS is_dynamic,\n\n      -- decode each param\n      arrayMap(i ->\n        if(i < length(param_types),\n          if(is_dynamic[i+1] = 1,\n            -- dynamic: offset in head + length + data\n            (\n              if(\n                toUInt32(reinterpretAsUInt256(reverse(unhex(substring(args_raw_hex,1+i*64,64))))) IS NOT NULL\n                AND (toUInt32(reinterpretAsUInt256(reverse(unhex(substring(args_raw_hex,1+i*64,64)))))/32+1)*64 < length(args_raw_hex),\n                concat(\n                  '0x',\n                  substring(\n                    args_raw_hex,\n                    1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(substring(args_raw_hex,1+i*64,64)))))/32+1)*64,\n                    toUInt32(\n                      reinterpretAsUInt256(\n                        reverse(unhex(\n                          substring(\n                            args_raw_hex,\n                            1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(substring(args_raw_hex,1+i*64,64)))))/32)*64,\n                            64\n                          )\n                        ))\n                      )\n                    ) * 2\n                  )\n                ),\n                NULL\n              )\n            ),\n            -- static: bytes32, address, uint\n            if(i*64 < length(args_raw_hex),\n              multiIf(\n                param_types[i+1] = 'bytes32',\n                  concat('0x', substring(args_raw_hex,1+i*64,64)),\n                param_types[i+1] = 'address',\n                  concat('0x', substring(substring(args_raw_hex,1+i*64,64),25,40)),\n                startsWith(param_types[i+1],'uint'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(unhex(substring(args_raw_hex,1+i*64,64)))\n                    )\n                  ),\n                NULL\n              ),\n              NULL\n            )\n          ),\n          NULL\n        ),\n        range(length(param_types))\n      ) AS param_values,\n\n      -- output\n      \n        mapFromArrays(param_names,param_values) AS decoded_input\n      \n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_GBCDeposit_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.483559Z", "completed_at": "2025-06-06T11:21:00.547792Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.684663Z", "completed_at": "2025-06-06T11:21:00.684682Z"}], "thread_id": "Thread-4", "execution_time": 0.36547255516052246, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_GBCDeposit_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_GBCDeposit_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_GBCDeposit_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.548405Z", "completed_at": "2025-06-06T11:21:00.703869Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.804458Z", "completed_at": "2025-06-06T11:21:00.804469Z"}], "thread_id": "Thread-10", "execution_time": 0.359619140625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bCOIN_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = '69b2d456e8830847f488afdde2a636bfb26218c6'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bCOIN_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '69b2d456e8830847f488afdde2a636bfb26218c6'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bCOIN_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.496521Z", "completed_at": "2025-06-06T11:21:00.580764Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.733838Z", "completed_at": "2025-06-06T11:21:00.733853Z"}], "thread_id": "Thread-5", "execution_time": 0.4124329090118408, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_aaveV3_PoolConfigurator_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = '7304979ec9e4eaa0273b6a037a31c4e9e5a75d16'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_aaveV3_PoolConfigurator_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '7304979ec9e4eaa0273b6a037a31c4e9e5a75d16'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_aaveV3_PoolConfigurator_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.514310Z", "completed_at": "2025-06-06T11:21:00.613109Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.787342Z", "completed_at": "2025-06-06T11:21:00.787355Z"}], "thread_id": "Thread-6", "execution_time": 0.46254801750183105, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_aaveV3_PoolInstance_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = 'b50201558b00496a145fe76f7424749556e326d8'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_aaveV3_PoolInstance_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'b50201558b00496a145fe76f7424749556e326d8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_aaveV3_PoolInstance_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.524422Z", "completed_at": "2025-06-06T11:21:00.642571Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.788855Z", "completed_at": "2025-06-06T11:21:00.788864Z"}], "thread_id": "Thread-7", "execution_time": 0.46027088165283203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_abi", "compiled": true, "compiled_code": "\n\nSELECT \n    '' AS contract_address,          -- The contract address (proxy or regular)\n    '' AS implementation_address,    -- For proxy contracts, the implementation address; NULL for regular/implementation contracts\n    '' AS abi_json,                  -- The ABI JSON\n    '' AS contract_name,             -- Contract name from blockscout\n    '' AS source,                    -- ABI source (e.g., 'blockscout')\n    toDateTime('1970-01-01 00:00:00') AS updated_at  -- Last updated timestamp\nWHERE 0=1", "relation_name": "`dbt`.`contracts_abi`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.530063Z", "completed_at": "2025-06-06T11:21:00.659513Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.794324Z", "completed_at": "2025-06-06T11:21:00.794343Z"}], "thread_id": "Thread-8", "execution_time": 0.4644620418548584, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_TSLAx_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = '19972d1750f959dd14cf436da6360185bd54cea0'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_TSLAx_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '19972d1750f959dd14cf436da6360185bd54cea0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_TSLAx_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.539914Z", "completed_at": "2025-06-06T11:21:00.675640Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.798417Z", "completed_at": "2025-06-06T11:21:00.798429Z"}], "thread_id": "Thread-9", "execution_time": 0.3598654270172119, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bC3M_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = '83ec02059f686e747392a22ddfed7833ba0d7ce3'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bC3M_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83ec02059f686e747392a22ddfed7833ba0d7ce3'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bC3M_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.561594Z", "completed_at": "2025-06-06T11:21:00.720600Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.808678Z", "completed_at": "2025-06-06T11:21:00.808688Z"}], "thread_id": "Thread-11", "execution_time": 0.3609800338745117, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bCSPX_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = '1332d2b4dc83238b621b7f7d0f72fec58bb81a9b'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bCSPX_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '1332d2b4dc83238b621b7f7d0f72fec58bb81a9b'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bCSPX_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.574078Z", "completed_at": "2025-06-06T11:21:00.735033Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.812632Z", "completed_at": "2025-06-06T11:21:00.812640Z"}], "thread_id": "Thread-12", "execution_time": 0.3610239028930664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bHIGH_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = '9e8e794ad6ecdb6d5c7eabe059d30e907f58859b'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bHIGH_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9e8e794ad6ecdb6d5c7eabe059d30e907f58859b'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bHIGH_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.584538Z", "completed_at": "2025-06-06T11:21:00.764747Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.816950Z", "completed_at": "2025-06-06T11:21:00.816965Z"}], "thread_id": "Thread-13", "execution_time": 0.35477232933044434, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bIB01_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = '788d911ae7c95121a89a0f0306db65d87422e1de'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bIB01_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '788d911ae7c95121a89a0f0306db65d87422e1de'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bIB01_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.592252Z", "completed_at": "2025-06-06T11:21:00.784179Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.819486Z", "completed_at": "2025-06-06T11:21:00.819495Z"}], "thread_id": "Thread-14", "execution_time": 0.35516834259033203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bIBTA_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = '9f9953d8a2c5366f098754d48f2d69b144ce03da'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bIBTA_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9f9953d8a2c5366f098754d48f2d69b144ce03da'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bIBTA_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.604558Z", "completed_at": "2025-06-06T11:21:00.785002Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.821819Z", "completed_at": "2025-06-06T11:21:00.821829Z"}], "thread_id": "Thread-16", "execution_time": 0.35483217239379883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bNVDA_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = '1d3be4d05eba2aa6c4eede85a74f491c31766e64'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bNVDA_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '1d3be4d05eba2aa6c4eede85a74f491c31766e64'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bNVDA_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.598663Z", "completed_at": "2025-06-06T11:21:00.785664Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.823669Z", "completed_at": "2025-06-06T11:21:00.823679Z"}], "thread_id": "Thread-15", "execution_time": 0.3573629856109619, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bMSTR_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = 'c8429803dcda7df86822ab173ea285c10bf1eb66'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bMSTR_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'c8429803dcda7df86822ab173ea285c10bf1eb66'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bMSTR_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.628720Z", "completed_at": "2025-06-06T11:21:00.789787Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.825504Z", "completed_at": "2025-06-06T11:21:00.825513Z"}], "thread_id": "Thread-18", "execution_time": 0.3500063419342041, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_Hub_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = 'c12c1e50abb450d6205ea2c3fa861b3b834d13e8'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_Hub_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'c12c1e50abb450d6205ea2c3fa861b3b834d13e8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_Hub_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.613767Z", "completed_at": "2025-06-06T11:21:00.790588Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.826384Z", "completed_at": "2025-06-06T11:21:00.826392Z"}], "thread_id": "Thread-17", "execution_time": 0.35248732566833496, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v1_Hub_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = '29b9a7fbb8995b2423a71cc17cf9810798f6c543'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v1_Hub_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '29b9a7fbb8995b2423a71cc17cf9810798f6c543'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v1_Hub_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.637475Z", "completed_at": "2025-06-06T11:21:00.792471Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.827723Z", "completed_at": "2025-06-06T11:21:00.827785Z"}], "thread_id": "Thread-19", "execution_time": 0.3508150577545166, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_NameRegistry_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = 'a27566fd89162cc3d40cb59c87aaaa49b85f3474'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_NameRegistry_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a27566fd89162cc3d40cb59c87aaaa49b85f3474'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_NameRegistry_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.650888Z", "completed_at": "2025-06-06T11:21:00.796075Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.828901Z", "completed_at": "2025-06-06T11:21:00.828910Z"}], "thread_id": "Thread-21", "execution_time": 0.35044431686401367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_wxdai_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_wxdai_calls`)\n      \n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arrayMap(x -> JSONExtractString(x, 'name'),\n             arraySort(x -> toInt32OrZero(JSONExtractRaw(x, 'position')),\n                       JSONExtractArrayRaw(input_params))) AS names,\n    arrayMap(x -> JSONExtractString(x, 'type'),\n             arraySort(x -> toInt32OrZero(JSONExtractRaw(x, 'position')),\n                       JSONExtractArrayRaw(input_params))) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input, '0x', ''),1,8) AS call_selector,\n      substring(replaceAll(t.input, '0x', ''),9) AS args_raw_hex,\n      a.names AS param_names,\n      a.types AS param_types,\n\n      -- flags for dynamic params\n      arrayMap(i ->\n        if(\n          param_types[i+1] = 'bytes' OR\n          param_types[i+1] = 'string' OR\n          endsWith(param_types[i+1],'[]') OR\n          (startsWith(param_types[i+1],'bytes') AND param_types[i+1] != 'bytes32'),\n          1,\n          0\n        ),\n        range(length(param_types))\n      ) AS is_dynamic,\n\n      -- decode each param\n      arrayMap(i ->\n        if(i < length(param_types),\n          if(is_dynamic[i+1] = 1,\n            -- dynamic: offset in head + length + data\n            (\n              if(\n                toUInt32(reinterpretAsUInt256(reverse(unhex(substring(args_raw_hex,1+i*64,64))))) IS NOT NULL\n                AND (toUInt32(reinterpretAsUInt256(reverse(unhex(substring(args_raw_hex,1+i*64,64)))))/32+1)*64 < length(args_raw_hex),\n                concat(\n                  '0x',\n                  substring(\n                    args_raw_hex,\n                    1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(substring(args_raw_hex,1+i*64,64)))))/32+1)*64,\n                    toUInt32(\n                      reinterpretAsUInt256(\n                        reverse(unhex(\n                          substring(\n                            args_raw_hex,\n                            1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(substring(args_raw_hex,1+i*64,64)))))/32)*64,\n                            64\n                          )\n                        ))\n                      )\n                    ) * 2\n                  )\n                ),\n                NULL\n              )\n            ),\n            -- static: bytes32, address, uint\n            if(i*64 < length(args_raw_hex),\n              multiIf(\n                param_types[i+1] = 'bytes32',\n                  concat('0x', substring(args_raw_hex,1+i*64,64)),\n                param_types[i+1] = 'address',\n                  concat('0x', substring(substring(args_raw_hex,1+i*64,64),25,40)),\n                startsWith(param_types[i+1],'uint'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(unhex(substring(args_raw_hex,1+i*64,64)))\n                    )\n                  ),\n                NULL\n              ),\n              NULL\n            )\n          ),\n          NULL\n        ),\n        range(length(param_types))\n      ) AS param_values,\n\n      -- output\n      \n        mapFromArrays(param_names,param_values) AS decoded_input\n      \n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_wxdai_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.644554Z", "completed_at": "2025-06-06T11:21:00.796796Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.829808Z", "completed_at": "2025-06-06T11:21:00.829820Z"}], "thread_id": "Thread-20", "execution_time": 0.35212039947509766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_sdai_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = 'af204776c7245bf4147c2612bf6e5972ee483701'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_sdai_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'af204776c7245bf4147c2612bf6e5972ee483701'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_sdai_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.660247Z", "completed_at": "2025-06-06T11:21:00.797707Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.830796Z", "completed_at": "2025-06-06T11:21:00.830808Z"}], "thread_id": "Thread-22", "execution_time": 0.3513906002044678, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_wxdai_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE replaceAll(lower(address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_wxdai_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)           AS ni_types,\n    arrayMap(x -> x.3, ni_meta)           AS ni_positions,\n\n    -- split data into words for non-indexed params\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(length(ni_types)*10)\n    )                                    AS data_words,\n\n    -- decode non-indexed values head/tail\n    arrayMap(j ->\n      if(\n        -- dynamic types\n        ni_types[j+1] = 'bytes'\n        OR ni_types[j+1] = 'string'\n        OR endsWith(ni_types[j+1],'[]')\n        OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n        -- dynamic: extract offset, length, and data chunk\n        (\n          if(\n            toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) IS NOT NULL\n            AND (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64 < length(data_hex),\n            \n            -- Extract the raw hex data first\n            substring(\n              data_hex,\n              1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32 + 1) * 64,\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(unhex(\n                    substring(\n                      data_hex,\n                      1 + (toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) / 32) * 64,\n                      64\n                    )\n                  ))\n                )\n              ) * 2\n            ),\n            NULL\n          )\n        ),\n\n        -- static types: bytes32, address, uint\n        (\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat(\n                  '0x',\n                  substring(data_words[j+1], 25, 40)\n                ),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(data_words[j+1]))\n                  )\n                ),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_decoded_values,\n\n    -- Convert string types from hex to text\n    arrayMap(j ->\n      if(\n        ni_types[j+1] = 'string' AND raw_decoded_values[j+1] IS NOT NULL,\n        -- Convert hex to UTF-8 string, removing null bytes\n        replaceRegexpAll(\n          reinterpretAsString(unhex(raw_decoded_values[j+1])),\n          '\\0',\n          ''\n        ),\n        -- For non-string types, keep the original value but add 0x prefix for bytes\n        if(\n          (ni_types[j+1] = 'bytes' OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_decoded_values[j+1] IS NOT NULL,\n          concat('0x', raw_decoded_values[j+1]),\n          raw_decoded_values[j+1]\n        )\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- stitch back into full order\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        -- indexed: decode topic value\n        multiIf(\n          param_types[i+1] = 'address',\n          concat(\n            '0x',\n            substring(\n              replaceAll(raw_topics[i+1],'0x',''),\n              25,\n              40\n            )\n          ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n          toString(\n                  reinterpretAsUInt256(\n                    reverse(unhex(raw_topics[i+1]))\n                  )\n                ),\n          concat('0x', substring(replaceAll(raw_topics[i+1],'0x',''),1,64))\n        ),\n\n        -- non-indexed: pick correct decoded value\n        decoded_ni_values[\n          indexOf(ni_positions, i)\n        ]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_wxdai_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.676376Z", "completed_at": "2025-06-06T11:21:00.799799Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.831892Z", "completed_at": "2025-06-06T11:21:00.831900Z"}], "thread_id": "Thread-25", "execution_time": 0.3492739200592041, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.esg_hardware_config", "compiled": true, "compiled_code": "WITH hardware_config AS (\n    SELECT\n        type\n        ,cpu\n        ,cores_threads\n        ,architecture\n        ,ram\n        ,storage\n        ,gpu\n        ,psu\n        ,\"case\"\n        ,os\n    FROM (\n        SELECT\n            arrayJoin([4, 5, 6]) AS type,\n            arrayJoin(['Intel i5-1135G7', 'Intel i5-10400', 'AMD 3970X']) AS cpu,\n            arrayJoin(['4/8', '6/12', '32/64']) AS cores_threads,\n            arrayJoin(['x86/x64', 'x86/x64', 'x86/x64']) AS architecture,\n            arrayJoin(['16 GB', '64 GB', '256 GB']) AS ram,\n            arrayJoin(['2 TB SSD', '2TB SSD', '2TB SSD']) AS storage,\n            arrayJoin(['Onboard', 'Onboard', 'AM 6970']) AS gpu,\n            arrayJoin(['65 Watt', '650 Watt', '1000 Watt']) AS psu,\n            arrayJoin(['Integrated', 'Custom', 'Custom']) AS \"case\",\n            arrayJoin(['Ubuntu 20.04', 'Ubuntu 21', 'Ubuntu 20.04']) AS os\n    )\n)\n\nSELECT * FROM hardware_config", "relation_name": "`dbt`.`esg_hardware_config`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.672519Z", "completed_at": "2025-06-06T11:21:00.801336Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.833732Z", "completed_at": "2025-06-06T11:21:00.833741Z"}], "thread_id": "Thread-24", "execution_time": 0.35190796852111816, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.esg_execution_power", "compiled": true, "compiled_code": "WITH execution_power AS (\n    SELECT \n        type,\n        client,\n        mean\n    FROM (\n        SELECT\n            arrayJoin([4, 5, 6, 4, 5, 6]) AS type,\n            arrayJoin(['Erigon', 'Erigon', 'Erigon', 'Nethermind', 'Nethermind', 'Nethermind']) AS client,\n            arrayJoin([18.6, 17.59, 44.62, 18.6, 17.59, 44.62]) AS mean\n            \n    )\n)\n\nSELECT * FROM execution_power", "relation_name": "`dbt`.`esg_execution_power`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.681292Z", "completed_at": "2025-06-06T11:21:00.801897Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.834725Z", "completed_at": "2025-06-06T11:21:00.834734Z"}], "thread_id": "Thread-26", "execution_time": 0.3450605869293213, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.esg_idle_electric_power", "compiled": true, "compiled_code": "WITH idle_electric_power AS (\n    SELECT \n        type\n        ,mean\n    FROM (\n        SELECT\n            arrayJoin([4, 5, 6]) AS type,\n            arrayJoin([3.66, 25.04, 78.17]) AS mean\n    )\n)\n\nSELECT * FROM idle_electric_power", "relation_name": "`dbt`.`esg_idle_electric_power`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.685938Z", "completed_at": "2025-06-06T11:21:00.803522Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.836294Z", "completed_at": "2025-06-06T11:21:00.836303Z"}], "thread_id": "Thread-27", "execution_time": 0.3451669216156006, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.esg_node_distribution", "compiled": true, "compiled_code": "WITH node_distribution AS (\n    SELECT \n        type\n        ,distribution\n    FROM (\n        SELECT\n            arrayJoin([4, 5, 6]) AS type,\n            arrayJoin([0.25, 0.50, 0.25]) AS distribution\n    )\n)\n\nSELECT * FROM node_distribution", "relation_name": "`dbt`.`esg_node_distribution`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.667112Z", "completed_at": "2025-06-06T11:21:00.805431Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.837470Z", "completed_at": "2025-06-06T11:21:00.837479Z"}], "thread_id": "Thread-23", "execution_time": 0.3571770191192627, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.esg_consensus_power", "compiled": true, "compiled_code": "WITH consensus_power AS (\n    SELECT\n        type,\n        client,\n        mean\n    FROM (\n        SELECT\n            arrayJoin([4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]) AS type,\n            arrayJoin(['Lighthouse', 'Lighthouse', 'Lighthouse', 'Teku', 'Teku', 'Teku', 'Lodestar', 'Lodestar', 'Lodestar', 'Nimbus', 'Nimbus', 'Nimbus', 'Prysm', 'Prysm', 'Prysm']) AS client,\n            arrayJoin([2.75, 3.14, 18.84, 3.71, 3.32, 27.46, 3.14, 3.89, 33.55, 1.67, 2.08, 17.11, 3.51, 2.87, 24.33]) AS mean\n    )\n)\n\nSELECT * FROM consensus_power", "relation_name": "`dbt`.`esg_consensus_power`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.690051Z", "completed_at": "2025-06-06T11:21:00.806924Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.843275Z", "completed_at": "2025-06-06T11:21:00.843286Z"}], "thread_id": "Thread-28", "execution_time": 0.3506128787994385, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.execution_blocks_production", "compiled": true, "compiled_code": "\n\n\nWITH\n\n\nblocks_extra_data AS (\n    SELECT \n        block_timestamp\n        ,extra_data\n    FROM \n        `execution`.`blocks`\n    WHERE \n        block_timestamp > '1970-01-01' -- remove genesis\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(block_timestamp))\n      FROM `dbt`.`execution_blocks_production`\n    )\n  \n\n)\n\nSELECT\n    *\nFROM blocks_extra_data\nWHERE block_timestamp < today()", "relation_name": "`dbt`.`execution_blocks_production`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.695305Z", "completed_at": "2025-06-06T11:21:00.807989Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.845085Z", "completed_at": "2025-06-06T11:21:00.845095Z"}], "thread_id": "Thread-29", "execution_time": 0.3516833782196045, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.execution_state_size_diff", "compiled": true, "compiled_code": "\n\n\nWITH\n\n\nstate_size_diff AS (\n    SELECT \n        address\n        ,block_timestamp \n        ,SUM(IF(to_value!='0x0000000000000000000000000000000000000000000000000000000000000000',32,-32)) AS bytes_diff\n    FROM \n        `execution`.`storage_diffs`\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(block_timestamp))\n      FROM `dbt`.`execution_state_size_diff`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT\n    *\nFROM state_size_diff\nWHERE block_timestamp < today()", "relation_name": "`dbt`.`execution_state_size_diff`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.715497Z", "completed_at": "2025-06-06T11:21:00.810197Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.846197Z", "completed_at": "2025-06-06T11:21:00.846207Z"}], "thread_id": "Thread-32", "execution_time": 0.34380555152893066, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.probelab_peers_clients_cloud_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\n\nprobelab_agent_cloud AS (\n    SELECT \n        toStartOfDay(max_crawl_created_at) AS date\n        ,agent_version_type AS client\n        ,cloud_provider AS cloud\n        ,toInt32(floor(__count)) AS value\n    FROM \n        `crawlers_data`.`probelab_cloud_provider_avg_1d` \n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(max_crawl_created_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`probelab_peers_clients_cloud_daily`\n    )\n  \n\n)\n\nSELECT\n    *\nFROM probelab_agent_cloud \nWHERE date < today()", "relation_name": "`dbt`.`probelab_peers_clients_cloud_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.709878Z", "completed_at": "2025-06-06T11:21:00.810875Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.847216Z", "completed_at": "2025-06-06T11:21:00.847228Z"}], "thread_id": "Thread-31", "execution_time": 0.3515322208404541, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.p2p_peers_info", "compiled": true, "compiled_code": "\n\n\nWITH\n\nfork_digests AS (\n    SELECT \n        tupleElement(tup, 1) AS fork_digest,\n        tupleElement(tup, 2) AS cl_fork_name\n    FROM (\n        SELECT arrayJoin([\n            ('0xbc9a6864','Phase0'),\n            ('0x56fdb5e0','Altair'),\n            ('0x824be431','Bellatrix'),\n            ('0x21a6f836','Capella'),\n            ('0x3ebfd484','Deneb'),\n            ('0x7d5aab40','Electra'),\n            ('0xf9ab5f85','Fulu')\n        ]) AS tup\n    )\n),\n\nfork_version AS (\n    SELECT \n        tupleElement(tup, 1) AS fork_version,\n        tupleElement(tup, 2) AS cl_fork_name\n    FROM (\n        SELECT arrayJoin([\n            ('0x00000064','Phase0'),\n            ('0x01000064','Altair'),\n            ('0x02000064','Bellatrix'),\n            ('0x03000064','Capella'),\n            ('0x04000064','Deneb'),\n            ('0x05000064','Electra'),\n            ('0x06000064','Fulu')\n        ]) AS tup\n    )\n),\n\ngnosis_peers AS (\n    SELECT \n        visit_ended_at\n        ,peer_id\n        ,agent_version\n        ,CAST(peer_properties.fork_digest AS String) AS fork_digest\n        ,t2.cl_fork_name AS cl_fork_name\n        ,COALESCE(t3.cl_fork_name,peer_properties.next_fork_version) AS cl_next_fork_name\n        ,peer_properties\n        ,crawl_error\n        ,dial_errors\n    FROM \n        `nebula`.`visits` t1\n    LEFT JOIN \n        fork_digests t2\n        ON t1.peer_properties.fork_digest = t2.fork_digest\n    LEFT JOIN \n        fork_version t3\n        ON t1.peer_properties.next_fork_version = t3.fork_version\n    WHERE\n        (   peer_properties.fork_digest IN (SELECT fork_digest FROM fork_digests) \n            OR\n            peer_properties.next_fork_version LIKE '%064'\n        )\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(visit_ended_at))\n      FROM `dbt`.`p2p_peers_info`\n    )\n  \n\n     SETTINGS\n        join_use_nulls=1\n)\n\nSELECT\n    *\nFROM gnosis_peers\nWHERE visit_ended_at < today()", "relation_name": "`dbt`.`p2p_peers_info`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.721619Z", "completed_at": "2025-06-06T11:21:00.811615Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.848226Z", "completed_at": "2025-06-06T11:21:00.848238Z"}], "thread_id": "Thread-33", "execution_time": 0.34511780738830566, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.probelab_peers_clients_country_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\n\nprobelab_agent_country AS (\n    SELECT \n        toStartOfDay(max_crawl_created_at) AS date\n        ,agent_version_type AS client\n        ,country\n        ,toInt32(floor(__count)) AS value\n    FROM \n        `crawlers_data`.`probelab_countries_avg_1d` \n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(max_crawl_created_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`probelab_peers_clients_country_daily`\n    )\n  \n\n)\n\nSELECT\n    *\nFROM probelab_agent_country \nWHERE date < today()", "relation_name": "`dbt`.`probelab_peers_clients_country_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.726995Z", "completed_at": "2025-06-06T11:21:00.813516Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.849400Z", "completed_at": "2025-06-06T11:21:00.849409Z"}], "thread_id": "Thread-34", "execution_time": 0.34273266792297363, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.probelab_peers_clients_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\n\nprobelab_agent AS (\n    SELECT \n        toStartOfDay(max_crawl_created_at) AS date\n        ,agent_version_type AS client\n        ,any_value(toInt32(floor(__total))) AS value\n    FROM \n        `crawlers_data`.`probelab_agent_semvers_avg_1d` \n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(max_crawl_created_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`probelab_peers_clients_daily`\n    )\n  \n\n    GROUP BY\n        1, 2\n)\n\nSELECT\n    *\nFROM probelab_agent \nWHERE date < today()", "relation_name": "`dbt`.`probelab_peers_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.741919Z", "completed_at": "2025-06-06T11:21:00.815234Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.851059Z", "completed_at": "2025-06-06T11:21:00.851070Z"}], "thread_id": "Thread-36", "execution_time": 0.3427767753601074, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.probelab_peers_clients_version_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\n\nprobelab_agent_version AS (\n    SELECT \n        toStartOfDay(max_crawl_created_at) AS date\n        ,agent_version_type AS client\n        ,agent_version_semver_str AS version\n        ,toInt32(floor(__count)) AS value\n    FROM \n        `crawlers_data`.`probelab_agent_semvers_avg_1d` \n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(max_crawl_created_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`probelab_peers_clients_version_daily`\n    )\n  \n\n)\n\nSELECT\n    *\nFROM probelab_agent_version \nWHERE date < today()", "relation_name": "`dbt`.`probelab_peers_clients_version_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.735783Z", "completed_at": "2025-06-06T11:21:00.816137Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.852045Z", "completed_at": "2025-06-06T11:21:00.852054Z"}], "thread_id": "Thread-35", "execution_time": 0.34459567070007324, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.probelab_peers_clients_quic_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\n\nprobelab_agent_quic AS (\n    SELECT \n        toStartOfDay(max_crawl_created_at) AS date\n        ,agent_version_type AS client\n        ,quic_support AS quic\n        ,__count AS value\n    FROM \n        `crawlers_data`.`probelab_quic_support_over_7d` \n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(max_crawl_created_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`probelab_peers_clients_quic_daily`\n    )\n  \n\n)\n\nSELECT\n    *\nFROM probelab_agent_quic \nWHERE date < today()", "relation_name": "`dbt`.`probelab_peers_clients_quic_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.748320Z", "completed_at": "2025-06-06T11:21:00.818698Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.853182Z", "completed_at": "2025-06-06T11:21:00.853193Z"}], "thread_id": "Thread-37", "execution_time": 0.34351468086242676, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.transfers_erc20_bluechips", "compiled": true, "compiled_code": "\n\n\nSELECT\n    block_number\n    ,block_timestamp\n    ,transaction_index\n    ,log_index\n    ,transaction_hash\n    ,address AS token_address\n    ,concat('0x',substring(topic1,25,40)) AS \"from\"\n    ,concat('0x',substring(topic2,25,40) ) AS \"to\"\n    ,toString(\n        reinterpretAsUInt256(\n            reverse(unhex(data))\n        )\n    ) AS \"value\"\nFROM `execution`.`logs`\nWHERE\n    topic0 = 'ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n    AND address = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n    AND block_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(block_timestamp))\n      FROM `dbt`.`transfers_erc20_bluechips`\n    )\n  \n", "relation_name": "`dbt`.`transfers_erc20_bluechips`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.754102Z", "completed_at": "2025-06-06T11:21:00.820539Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.854564Z", "completed_at": "2025-06-06T11:21:00.854573Z"}], "thread_id": "Thread-38", "execution_time": 0.34346580505371094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.source_not_null_raw_abi_contract_abis_abi_json.455012a6a1", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect abi_json\nfrom `dbt`.`contract_abis`\nwhere abi_json is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.759668Z", "completed_at": "2025-06-06T11:21:00.821107Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.855609Z", "completed_at": "2025-06-06T11:21:00.855623Z"}], "thread_id": "Thread-39", "execution_time": 0.34356236457824707, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.source_not_null_raw_abi_contract_abis_contract_address.b603d52605", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect contract_address\nfrom `dbt`.`contract_abis`\nwhere contract_address is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.776678Z", "completed_at": "2025-06-06T11:21:00.822996Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.856686Z", "completed_at": "2025-06-06T11:21:00.856694Z"}], "thread_id": "Thread-40", "execution_time": 0.34319424629211426, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.source_not_null_raw_abi_event_signatures_contract_address.21e1331121", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect contract_address\nfrom `dbt`.`event_signatures`\nwhere contract_address is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.704512Z", "completed_at": "2025-06-06T11:21:00.844303Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.869708Z", "completed_at": "2025-06-06T11:21:00.869722Z"}], "thread_id": "Thread-30", "execution_time": 0.37476277351379395, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.execution_txs_info_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(block_timestamp) AS date\n    ,toString(transaction_type) AS transaction_type\n    ,success\n    ,COUNT(*) AS n_txs\n    ,SUM(COALESCE(gas_used,0)) AS gas_used\n    ,CAST(AVG(COALESCE(gas_price,0)) AS Int32) AS gas_price_avg\n    ,CAST(median(COALESCE(gas_price,0)) AS Int32) AS gas_price_median\nFROM `execution`.`transactions`\nWHERE block_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`execution_txs_info_daily`\n    )\n  \n\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`execution_txs_info_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.861801Z", "completed_at": "2025-06-06T11:21:00.901302Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.918067Z", "completed_at": "2025-06-06T11:21:00.918083Z"}], "thread_id": "Thread-1", "execution_time": 0.11551427841186523, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.source_not_null_raw_abi_event_signatures_event_name.8114fcab41", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect event_name\nfrom `dbt`.`event_signatures`\nwhere event_name is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.875649Z", "completed_at": "2025-06-06T11:21:00.913729Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.929590Z", "completed_at": "2025-06-06T11:21:00.929601Z"}], "thread_id": "Thread-2", "execution_time": 0.11517047882080078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.source_not_null_raw_abi_event_signatures_signature.f84f3d98c3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect signature\nfrom `dbt`.`event_signatures`\nwhere signature is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.883454Z", "completed_at": "2025-06-06T11:21:00.915429Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.944212Z", "completed_at": "2025-06-06T11:21:00.944230Z"}], "thread_id": "Thread-3", "execution_time": 0.11975646018981934, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.source_not_null_raw_abi_function_signatures_contract_address.b86e96ce0a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect contract_address\nfrom `dbt`.`function_signatures`\nwhere contract_address is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.890137Z", "completed_at": "2025-06-06T11:21:00.919667Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.956804Z", "completed_at": "2025-06-06T11:21:00.956816Z"}], "thread_id": "Thread-4", "execution_time": 0.12399458885192871, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.source_not_null_raw_abi_function_signatures_function_name.18d9874c92", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect function_name\nfrom `dbt`.`function_signatures`\nwhere function_name is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.895174Z", "completed_at": "2025-06-06T11:21:00.922099Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:00.964177Z", "completed_at": "2025-06-06T11:21:00.964189Z"}], "thread_id": "Thread-10", "execution_time": 0.12179684638977051, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.source_not_null_raw_abi_function_signatures_signature.e4fc7e2bd5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect signature\nfrom `dbt`.`function_signatures`\nwhere signature is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.950740Z", "completed_at": "2025-06-06T11:21:01.007997Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.018788Z", "completed_at": "2025-06-06T11:21:01.018804Z"}], "thread_id": "Thread-8", "execution_time": 0.11859822273254395, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.execution_blocks_clients_version_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nblocks_clients AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date\n        ,\narrayFilter(\n    x -> x != '',\n    /* split on every \u201cnon word-ish\u201d character (dash, @, space, etc.) */\n    splitByRegexp(\n        '[^A-Za-z0-9\\\\.]+',            -- \u21fd anything that isn\u2019t a\u2013z, 0\u20139 or \u201c.\u201d\n        arrayStringConcat(\n            arrayMap(\n                i -> if(\n                    reinterpretAsUInt8(substring(unhex(extra_data), i, 1)) BETWEEN 32 AND 126,\n                    reinterpretAsString(substring(unhex(extra_data), i, 1)),\n                    ' '\n                ),\n                range(1, length(unhex(extra_data)) + 1)\n            ),\n            ''\n        )\n    )\n)\n AS decoded_extra_data\n        ,COUNT(*) AS cnt\n    FROM `dbt`.`execution_blocks_production`\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`execution_blocks_clients_version_daily`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    , multiIf(\n        lower(decoded_extra_data[1]) = 'choose' \n         OR lower(decoded_extra_data[1]) = 'mysticryuujin'  \n         OR lower(decoded_extra_data[1]) = 'sanae.io'\n         OR decoded_extra_data[1] = ''  , 'Unknown',\n        decoded_extra_data[1]\n    )   AS client\n    ,IF(length(decoded_extra_data)>1, \n        IF(decoded_extra_data[2]='Ethereum',decoded_extra_data[3],decoded_extra_data[2]), \n        ''\n    ) AS version\n    ,SUM(cnt) AS value\nFROM blocks_clients\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`execution_blocks_clients_version_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.930637Z", "completed_at": "2025-06-06T11:21:01.009233Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.020420Z", "completed_at": "2025-06-06T11:21:01.020450Z"}], "thread_id": "Thread-5", "execution_time": 0.1318657398223877, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.rwa_backedfi_prices", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n\n\n        SELECT\n            'bC3M' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bC3M_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bCOIN' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bCOIN_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bCSPX' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bCSPX_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bHIGH' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bHIGH_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bIB01' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bIB01_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bIBTA' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bIBTA_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bMSTR' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bMSTR_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bNVDA' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bNVDA_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'TSLAx' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_TSLAx_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    ", "relation_name": "`dbt`.`rwa_backedfi_prices`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.945233Z", "completed_at": "2025-06-06T11:21:01.010227Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.021353Z", "completed_at": "2025-06-06T11:21:01.021361Z"}], "thread_id": "Thread-22", "execution_time": 0.13207507133483887, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.yields_sdai_rate_daily", "compiled": true, "compiled_code": "\n\n\nWITH \n\nsdai_rate_sparse_daily AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date\n        ,median(toUInt256OrNull(decoded_params['assets']) / toUInt256OrNull(decoded_params['shares']))  AS sdai_conversion\n    FROM \n        `dbt`.`contracts_sdai_events`\n    WHERE \n        event_name = 'Deposit'\n        AND toUInt256OrNull(decoded_params['shares']) != 0\n        AND block_timestamp < today()\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`yields_sdai_rate_daily`\n    )\n  \n\n    GROUP BY 1\n),\n\ncalendar AS (\n    SELECT\n        arrayJoin(\n            arrayMap(\n                x -> toStartOfDay(start_date + x),\n                range(toUInt32(end_date - start_date) + 1)\n            )\n        ) AS date\n    FROM (\n        SELECT \n          min(toDate(date)) AS start_date\n          ,max(toDate(date)) AS end_date\n        FROM sdai_rate_sparse_daily\n    )\n),\n\n\nlast_partition_value AS (\n    SELECT \n        sdai_conversion\n    FROM \n        `dbt`.`yields_sdai_rate_daily`\n    WHERE\n        toStartOfMonth(date) = (\n            SELECT addMonths(max(toStartOfMonth(date)), -1)\n            FROM `dbt`.`yields_sdai_rate_daily`\n        )\n    ORDER BY date DESC\n    LIMIT 1\n),\n\n\nsdai_daily_rate AS (\n  SELECT\n      date\n      ,sdai_conversion\n      ,floor(\n          sdai_conversion \n          - (\n            \n            COALESCE(\n                lagInFrame(sdai_conversion) OVER (\n                    ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n                ),\n                (SELECT sdai_conversion FROM last_partition_value)\n            )\n            \n            )\n      ,12) AS rate\n  FROM (\n    SELECT \n      t1.date\n      ,last_value(t2.sdai_conversion) ignore nulls OVER (ORDER BY t1.date) AS sdai_conversion\n    FROM calendar t1\n    LEFT JOIN\n      sdai_rate_sparse_daily t2\n      ON t2.date = t1.date\n  )\n)\n\n\nSELECT \n  date\n  ,sdai_conversion\n  ,rate\nFROM sdai_daily_rate\nWHERE rate IS NOT NULL", "relation_name": "`dbt`.`yields_sdai_rate_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.959801Z", "completed_at": "2025-06-06T11:21:01.010869Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.022240Z", "completed_at": "2025-06-06T11:21:01.022248Z"}], "thread_id": "Thread-11", "execution_time": 0.11475086212158203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.execution_state_address_current", "compiled": true, "compiled_code": "\n\nSELECT\n    address\n    ,SUM(bytes_diff) AS bytes\nFROM \n    `dbt`.`execution_state_size_diff`\nGROUP BY 1", "relation_name": "`dbt`.`execution_state_address_current`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.965153Z", "completed_at": "2025-06-06T11:21:01.011665Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.023133Z", "completed_at": "2025-06-06T11:21:01.023141Z"}], "thread_id": "Thread-12", "execution_time": 0.11468219757080078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.execution_state_size_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\nstate_size_diff_daily AS (\n    SELECT \n        toStartOfDay(block_timestamp) AS date\n        ,SUM(bytes_diff) AS bytes_diff\n    FROM \n        `dbt`.`execution_state_size_diff`\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`execution_state_size_daily`\n    )\n  \n\n    GROUP BY 1\n),\n\n\nlast_partition_value AS (\n    SELECT \n        bytes\n    FROM \n        `dbt`.`execution_state_size_daily`\n    WHERE\n        toStartOfMonth(date) = (\n            SELECT addMonths(max(toStartOfMonth(date)), -1)\n            FROM `dbt`.`execution_state_size_daily`\n        )\n    ORDER BY date DESC\n    LIMIT 1\n),\n\n\nfinal AS (\n    SELECT\n        date\n        ,SUM(bytes_diff) OVER (ORDER BY date ASC) \n        \n            + (SELECT bytes FROM last_partition_value)\n        \n        AS bytes\n    FROM state_size_diff_daily\n)\n\nSELECT * FROM final", "relation_name": "`dbt`.`execution_state_size_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.979277Z", "completed_at": "2025-06-06T11:21:01.012726Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.024143Z", "completed_at": "2025-06-06T11:21:01.024152Z"}], "thread_id": "Thread-13", "execution_time": 0.11420845985412598, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.p2p_peers_clients_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,any(splitByChar('/', agent_version)[1]) AS client\n    FROM `dbt`.`p2p_peers_info`\n    WHERE\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`p2p_peers_clients_daily`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,IF(client='','Unknown',client) AS client\n    ,COUNT(*) AS value\nFROM peers\nGROUP BY 1, 2", "relation_name": "`dbt`.`p2p_peers_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.973640Z", "completed_at": "2025-06-06T11:21:01.013533Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.025056Z", "completed_at": "2025-06-06T11:21:01.025065Z"}], "thread_id": "Thread-33", "execution_time": 0.11580514907836914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.p2p_peers_cl_fork_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,toString(any(cl_fork_name)) AS fork\n        ,toString(any(cl_next_fork_name)) AS next_fork\n    FROM `dbt`.`p2p_peers_info`\n    WHERE\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`p2p_peers_cl_fork_daily`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,'Current Fork' AS label\n    ,fork AS fork\n    ,COUNT(*) AS cnt\nFROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL\n\nSELECT\n    date\n    ,'Next Fork' AS label\n    ,next_fork AS fork\n    ,COUNT(*) AS cnt\nFROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`p2p_peers_cl_fork_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.984550Z", "completed_at": "2025-06-06T11:21:01.016241Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.025960Z", "completed_at": "2025-06-06T11:21:01.025967Z"}], "thread_id": "Thread-34", "execution_time": 0.11528515815734863, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.p2p_peers_geo_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers_ip AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,any(peer_properties.ip) AS ip\n    FROM `dbt`.`p2p_peers_info`\n    WHERE\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`p2p_peers_geo_daily`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT\n    t1.date\n    ,IF(t2.country='','Unknown', t2.country) AS country\n    ,COUNT(*) AS cnt\nFROM peers_ip t1\nLEFT JOIN\n    `crawlers_data`.`ipinfo` t2\n    ON t1.ip = t2.ip\nGROUP BY 1, 2", "relation_name": "`dbt`.`p2p_peers_geo_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.989945Z", "completed_at": "2025-06-06T11:21:01.017193Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.026841Z", "completed_at": "2025-06-06T11:21:01.026852Z"}], "thread_id": "Thread-14", "execution_time": 0.11549758911132812, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.p2p_peers_geo_hourly", "compiled": true, "compiled_code": "\n\nWITH\n\npeers_ip AS (\n    SELECT\n        toStartOfHour(visit_ended_at) AS date\n        ,peer_id\n        ,any(peer_properties.ip) AS ip\n    FROM `dbt`.`p2p_peers_info`\n    WHERE\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`p2p_peers_geo_hourly`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\n\nSELECT\n    date\n    ,splitByString(',',loc)[1] AS lat\n    ,splitByString(',',loc)[2] AS long\n    ,IF(country='','Unknown', country) AS country\n    ,cnt\nFROM (\n    SELECT\n        t1.date\n        ,t2.loc\n        ,t2.country\n        ,COUNT(*) AS cnt\n    FROM peers_ip t1\n    LEFT JOIN\n        `crawlers_data`.`ipinfo` t2\n        ON t1.ip = t2.ip\n    GROUP BY 1, 2, 3\n)", "relation_name": "`dbt`.`p2p_peers_geo_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:00.995637Z", "completed_at": "2025-06-06T11:21:01.017935Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.027735Z", "completed_at": "2025-06-06T11:21:01.027742Z"}], "thread_id": "Thread-16", "execution_time": 0.11556243896484375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.p2p_peers_geo_latest", "compiled": true, "compiled_code": "\n\nWITH\n\npeers_ip AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,any(peer_properties.ip) AS ip\n    FROM `dbt`.`p2p_peers_info`\n    WHERE\n        empty(dial_errors) = 1 \n        AND \n        crawl_error IS NULL \n        AND \n        date = least((SELECT MAX(toStartOfDay(visit_ended_at)) FROM `dbt`.`p2p_peers_info`),today())\n    GROUP BY 1, 2\n)\n\nSELECT\n    splitByString(',',loc)[1] AS lat\n    ,splitByString(',',loc)[2] AS long\n    ,IF(country='','Unknown', country) AS country\n    ,cnt\nFROM (\n    SELECT\n        t2.loc\n        ,t2.country\n        ,COUNT(*) AS cnt\n    FROM peers_ip t1\n    LEFT JOIN\n        `crawlers_data`.`ipinfo` t2\n        ON t1.ip = t2.ip\n    GROUP BY 1, 2\n)", "relation_name": "`dbt`.`p2p_peers_geo_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:01.000316Z", "completed_at": "2025-06-06T11:21:01.019819Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.029105Z", "completed_at": "2025-06-06T11:21:01.029114Z"}], "thread_id": "Thread-36", "execution_time": 0.1161949634552002, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.p2p_peers_geo_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\n-- 1) First CTE: basic peer info\ngnosis_peers AS (\n    SELECT \n        peer_id,\n        cl_fork_name,\n        cl_next_fork_name,\n        peer_properties.ip AS ip,\n        any(splitByChar('/', agent_version)[1]) AS client\n    FROM `dbt`.`p2p_peers_info`\n    WHERE\n        toStartOfDay(visit_ended_at) = today() - INTERVAL 1 DAY\n        AND empty(dial_errors) = 1\n        AND crawl_error IS NULL\n    GROUP BY\n        peer_id,\n        cl_fork_name,\n        cl_next_fork_name,\n        ip\n),\n\n-- 2) Second CTE: attach discovery_id_prefix to each peer\ngnosis_prefixes AS (\n    SELECT \n        d.discovery_id_prefix,\n        d.peer_id,\n        p.ip,\n        p.cl_fork_name,\n        p.cl_next_fork_name,\n        IF(p.client='', 'Unknown', p.client) AS client\n    FROM `nebula`.`discovery_id_prefixes_x_peer_ids` AS d\n    INNER JOIN gnosis_peers AS p\n      ON p.peer_id = d.peer_id\n)\n\nSELECT\n    t1.date,\n\n    -- Peer columns from the subquery t1\n    t1.peer_ip,\n    t1.peer_discovery_id_prefix,\n    t1.peer_cl_fork_name,\n    t1.peer_cl_next_fork_name,\n    t1.peer_client,\n\n    -- Geographical info for peer (from crawlers_data.ipinfo)\n    peer_info.hostname   AS peer_hostname,\n    peer_info.city       AS peer_city,\n    peer_info.country    AS peer_country,\n    peer_info.org        AS peer_org,\n    peer_info.loc        AS peer_loc,\n\n    -- Neighbor columns from subquery t1\n    t1.neighbor_ip,\n    t1.neighbor_discovery_id_prefix,\n    t1.neighbor_cl_fork_name,\n    t1.neighbor_cl_next_fork_name,\n    t1.neighbor_client,\n\n    -- Geographical info for neighbor (from crawlers_data.ipinfo)\n    neighbor_info.city    AS neighbor_city,\n    neighbor_info.country AS neighbor_country,\n    neighbor_info.org     AS neighbor_org,\n    neighbor_info.loc     AS neighbor_loc,\n\n    -- Finally, the count of edges\n    t1.cnt\nFROM (\n    SELECT\n        toStartOfDay(n.crawl_created_at) AS date,\n\n        -- \u201cPeer\u201d side of the edge\n        peer_p.ip                      AS peer_ip,\n        peer_p.discovery_id_prefix     AS peer_discovery_id_prefix,\n        peer_p.cl_fork_name            AS peer_cl_fork_name,\n        peer_p.cl_next_fork_name       AS peer_cl_next_fork_name,\n        peer_p.client                  AS peer_client,\n\n        -- \u201cNeighbor\u201d side of the edge\n        neighbor_p.ip                      AS neighbor_ip,\n        neighbor_p.discovery_id_prefix     AS neighbor_discovery_id_prefix,\n        neighbor_p.cl_fork_name            AS neighbor_cl_fork_name,\n        neighbor_p.cl_next_fork_name       AS neighbor_cl_next_fork_name,\n        neighbor_p.client                  AS neighbor_client,\n\n        COUNT(*) AS cnt\n    FROM `nebula`.`neighbors` AS n\n\n    -- join to get the discovery_prefix + client/fork info for \u201cpeer\u201d\n    INNER JOIN gnosis_prefixes AS peer_p\n      ON peer_p.discovery_id_prefix = n.peer_discovery_id_prefix\n\n    -- join to get the discovery_prefix + client/fork info for \u201cneighbor\u201d\n    INNER JOIN gnosis_prefixes AS neighbor_p\n      ON neighbor_p.discovery_id_prefix = n.neighbor_discovery_id_prefix\n\n    WHERE\n        toStartOfDay(n.crawl_created_at) = today() - INTERVAL 1 DAY\n\n    GROUP BY\n        date,\n        peer_p.ip,\n        peer_p.discovery_id_prefix,\n        peer_p.cl_fork_name,\n        peer_p.cl_next_fork_name,\n        peer_p.client,\n        neighbor_p.ip,\n        neighbor_p.discovery_id_prefix,\n        neighbor_p.cl_fork_name,\n        neighbor_p.cl_next_fork_name,\n        neighbor_p.client\n) AS t1\n\n-- LEFT JOIN to ipinfo for \u201cpeer\u201d\nLEFT JOIN crawlers_data.ipinfo AS peer_info\n  ON peer_info.ip = t1.peer_ip\n\n-- LEFT JOIN to ipinfo for \u201cneighbor\u201d\nLEFT JOIN crawlers_data.ipinfo AS neighbor_info\n  ON neighbor_info.ip = t1.neighbor_ip", "relation_name": "`dbt`.`p2p_peers_geo_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:01.056798Z", "completed_at": "2025-06-06T11:21:01.071830Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.074702Z", "completed_at": "2025-06-06T11:21:01.074722Z"}], "thread_id": "Thread-21", "execution_time": 0.03710603713989258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.yields_sdai_apy_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nsdai_apy_daily AS (\n    SELECT\n        date,\n        floor(POWER((1+rate),365) - 1,4) * 100 AS apy,\n        floor(\n            avg(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 6  PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_7DMA,\n        floor(\n            avg(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_30DMA,\n         floor(\n            median(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 6  PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_7DMM,\n        floor(\n            median(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_30DMM\n    FROM `dbt`.`yields_sdai_rate_daily`\n)\n\nSELECT date, apy, 'Daily' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_7DMA, '7DMA' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_30DMA, '30DMA' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_7DMM, '7DMM' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_30DMM, '30DMM' AS label FROM sdai_apy_daily", "relation_name": "`dbt`.`yields_sdai_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:01.047332Z", "completed_at": "2025-06-06T11:21:01.072521Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.076049Z", "completed_at": "2025-06-06T11:21:01.076062Z"}], "thread_id": "Thread-17", "execution_time": 0.039756059646606445, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.execution_blocks_clients_pct_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\nclients_blocks AS (\n    SELECT\n        date\n        ,client\n        ,SUM(value) AS value\n    FROM `dbt`.`execution_blocks_clients_version_daily`\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,client\n    ,ROUND(value/(SUM(value) OVER (PARTITION BY date)),4) AS pct\nFROM \n    clients_blocks", "relation_name": "`dbt`.`execution_blocks_clients_pct_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:01.042692Z", "completed_at": "2025-06-06T11:21:01.073206Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.077977Z", "completed_at": "2025-06-06T11:21:01.077989Z"}], "thread_id": "Thread-18", "execution_time": 0.04246664047241211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.execution_blocks_clients_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,client\n    ,SUM(value) AS value\nFROM `dbt`.`execution_blocks_clients_version_daily`\nGROUP BY 1, 2", "relation_name": "`dbt`.`execution_blocks_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:01.051555Z", "completed_at": "2025-06-06T11:21:01.079320Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.081122Z", "completed_at": "2025-06-06T11:21:01.081130Z"}], "thread_id": "Thread-19", "execution_time": 0.04406118392944336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.rwa_backedfi_prices_1d", "compiled": true, "compiled_code": "\n\n\n\n   -- safely before any token was listed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bC3M'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`rwa_backedfi_prices`\n        WHERE bticker = 'bC3M'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL           -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bCOIN'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`rwa_backedfi_prices`\n        WHERE bticker = 'bCOIN'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL           -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bCSPX'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`rwa_backedfi_prices`\n        WHERE bticker = 'bCSPX'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL           -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bHIGH'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`rwa_backedfi_prices`\n        WHERE bticker = 'bHIGH'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL           -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bIB01'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`rwa_backedfi_prices`\n        WHERE bticker = 'bIB01'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL           -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bIBTA'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`rwa_backedfi_prices`\n        WHERE bticker = 'bIBTA'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL           -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bMSTR'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`rwa_backedfi_prices`\n        WHERE bticker = 'bMSTR'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL           -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bNVDA'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`rwa_backedfi_prices`\n        WHERE bticker = 'bNVDA'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL           -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'TSLAx'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`rwa_backedfi_prices`\n        WHERE bticker = 'TSLAx'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL           -- drop rows before first real point\n\nORDER BY bticker, date", "relation_name": "`dbt`.`rwa_backedfi_prices_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:01.065159Z", "completed_at": "2025-06-06T11:21:01.080358Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.082038Z", "completed_at": "2025-06-06T11:21:01.082046Z"}], "thread_id": "Thread-7", "execution_time": 0.04341626167297363, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.esg_country_power_consumption", "compiled": true, "compiled_code": "\n\n\nWITH\n\nconsensus_power AS (\n    SELECT\n        type\n        ,client\n        ,mean\n    FROM\n        `dbt`.`esg_consensus_power`\n),\n\nexecution_power AS (\n    SELECT\n        type\n        ,client\n        ,mean\n    FROM\n        `dbt`.`esg_execution_power`\n),\n\nidle_electric_power AS (\n    SELECT\n        type\n        ,mean\n    FROM\n        `dbt`.`esg_idle_electric_power`\n),\n\nnode_distribution AS (\n    SELECT\n        type\n        ,distribution\n    FROM\n        `dbt`.`esg_node_distribution`\n),\n\nnode_config_power AS (\n    SELECT\n        t1.type\n        ,t1.client AS consensus_client\n        ,t2.client AS execution_client\n        ,t1.mean + t2.mean + t3.mean AS mean\n    FROM\n        consensus_power t1\n    INNER JOIN\n        execution_power t2\n        ON \n        t2.type = t1.type\n    INNER JOIN\n        idle_electric_power t3\n        ON \n        t3.type = t1.type\n\n),\n\nbest_guess_per_client AS (\n    SELECT\n        t1.consensus_client\n        ,t1.execution_client\n        ,AVG(t1.mean * t2.distribution) AS mean\n    FROM\n        node_config_power t1\n    INNER JOIN\n        node_distribution t2\n        ON \n        t2.type = t1.type\n    GROUP BY\n        t1.consensus_client\n        ,t1.execution_client\n),\n\nconfiguration_distribution AS (\n    SELECT \n        execution_client\n        ,consensus_client\n        ,frac\n    FROM (\n        SELECT\n            arrayJoin(['Erigon', 'Erigon', 'Erigon', 'Erigon', 'Nethermind', 'Nethermind', 'Nethermind', 'Nethermind']) AS execution_client,\n            arrayJoin(['Lighthouse', 'Teku', 'Lodestar', 'Nimbus', 'Lighthouse', 'Teku', 'Lodestar', 'Nimbus']) AS consensus_client,\n            arrayJoin([0.340, 0.114, 0.044, 0.002, 0.340, 0.114, 0.044, 0.002]) AS frac\n    )\n),\n\npower_best_guess AS (\n    SELECT \n        SUM(t1.mean * t2.frac) AS mean\n    FROM \n        best_guess_per_client t1\n    INNER JOIN\n        configuration_distribution t2\n        ON\n        t2.execution_client = t1.execution_client\n        AND\n        t2.consensus_client = t1.consensus_client\n)\n\n\nSELECT\n    t1.date\n    ,t1.country\n    ,t1.cnt * t2.mean AS power\nFROM\n    `dbt`.`p2p_peers_geo_daily` t1\nCROSS JOIN \n    power_best_guess t2", "relation_name": "`dbt`.`esg_country_power_consumption`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:01.097489Z", "completed_at": "2025-06-06T11:21:01.102184Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.102806Z", "completed_at": "2025-06-06T11:21:01.102819Z"}], "thread_id": "Thread-26", "execution_time": 0.016125202178955078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.esg_power_consumption_top10", "compiled": true, "compiled_code": "\n\n\nWITH\n\ngnosis_power_consumption AS (\n    SELECT\n        t1.date\n        ,IF(t1.country='' OR t1.country='Unknown', 'Unknown', t2.name) AS country\n        ,t1.power\n        ,ROW_NUMBER() OVER (PARTITION BY t1.date ORDER BY t1.power DESC) AS rank\n    FROM\n        `dbt`.`esg_country_power_consumption` t1\n    LEFT JOIN\n        `crawlers_data`.`country_codes` t2\n        ON\n        t2.\"alpha-2\" = t1.country\n)\n\nSELECT\n    date\n    ,IF(rank>10, 'Other', country) AS country\n    ,SUM(power) AS power\nFROM\n    gnosis_power_consumption\nGROUP BY \n    1, 2", "relation_name": "`dbt`.`esg_power_consumption_top10`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-06T11:21:01.088694Z", "completed_at": "2025-06-06T11:21:01.103855Z"}, {"name": "execute", "started_at": "2025-06-06T11:21:01.104534Z", "completed_at": "2025-06-06T11:21:01.104541Z"}], "thread_id": "Thread-24", "execution_time": 0.019487857818603516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.esg_carbon_emissions", "compiled": true, "compiled_code": "\n\n\nWITH\n\ngnosis_power_consumption AS (\n    SELECT\n        date\n        ,country\n        ,power\n    FROM\n        `dbt`.`esg_country_power_consumption`\n),\n\nember_data AS (\n    SELECT\n        \"Date\" AS month_date\n        ,\"Value\" AS value\n        ,lagInFrame(\"Value\") OVER (PARTITION BY \"Country code\" ORDER BY \"Date\" ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)  AS lag_value\n        ,\"Country code\" AS country\n    FROM\n        `crawlers_data`.`ember_electricity_data`\n    WHERE   \n        \"Unit\" = 'gCO2/kWh'\n\n)\n\nSELECT\n    t1.date\n    ,SUM(t1.power * 24)/POWER(10,6) AS energy -- MWh\n    ,SUM(\n        t1.power/POWER(10,3)  -- power in kW\n        * 24 -- hours in day\n        * COALESCE(t3.value,t3.lag_value) -- CIF in gCO2/kWh\n        )/POWER(10,6) AS co2_emissions -- in tCO2e\n    ,AVG(COALESCE(t3.value,t3.lag_value)) AS mean_cif\nFROM\n    gnosis_power_consumption t1\nLEFT JOIN\n    `crawlers_data`.`country_codes` t2\n    ON\n    t2.\"alpha-2\" = t1.country\nINNER JOIN\n    ember_data t3\n    ON\n    t3.country = t2.\"alpha-3\"\n    AND\n    t3.month_date = toStartOfMonth(t1.date)\nGROUP BY \n    1", "relation_name": "`dbt`.`esg_carbon_emissions`", "batch_results": null}], "elapsed_time": 4.993689775466919, "args": {"printer_width": 80, "quiet": false, "populate_cache": true, "empty_catalog": false, "favor_state": false, "require_nested_cumulative_type_params": false, "state_modified_compare_vars": false, "state_modified_compare_more_unrendered_values": false, "version_check": true, "log_path": "/home/runner/work/dbt-cerebro/dbt-cerebro/logs", "log_file_max_bytes": 10485760, "log_level_file": "debug", "introspect": true, "partial_parse": true, "invocation_command": "dbt docs generate", "partial_parse_file_diff": true, "log_format": "default", "indirect_selection": "eager", "static_parser": true, "profiles_dir": "/home/runner/work/dbt-cerebro/dbt-cerebro", "require_batched_execution_for_custom_microbatch_strategy": false, "use_colors": true, "static": false, "defer": false, "write_json": true, "vars": {}, "warn_error_options": {"include": [], "exclude": []}, "print": true, "cache_selected_only": false, "require_yaml_configuration_for_mf_time_spines": false, "macro_debugging": false, "strict_mode": false, "select": [], "exclude": [], "send_anonymous_usage_stats": true, "log_format_file": "debug", "require_explicit_package_overrides_for_builtin_materializations": true, "require_resource_names_without_spaces": false, "which": "generate", "log_level": "info", "show_resource_report": false, "project_dir": "/home/runner/work/dbt-cerebro/dbt-cerebro", "skip_nodes_if_on_run_start_fails": false, "source_freshness_run_project_hooks": false, "compile": true, "use_colors_file": true}}