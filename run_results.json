{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.4", "generated_at": "2025-09-04T07:25:40.492869Z", "invocation_id": "259886b0-b9e0-40a6-8b1f-d4defe43c09f", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.773458Z", "completed_at": "2025-09-04T07:25:38.811845Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:38.852073Z", "completed_at": "2025-09-04T07:25:38.852091Z"}], "thread_id": "Thread-1", "execution_time": 0.09384918212890625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_topology_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    protocol,\n    date,\n    peer_discovery_id_prefix,\n    peer_client,\n    peer_city,\n    peer_country,\n    peer_org,\n    peer_lat,\n    peer_lon,\n    neighbor_discovery_id_prefix,\n    neighbor_client,\n    neighbor_city,\n    neighbor_country,\n    neighbor_org,\n    neighbor_lat,\n    neighbor_lon,\n    cnt\nFROM dbt.fct_p2p_topology_latest\nWHERE peer_lat != '' AND neighbor_lat != ''\nORDER BY protocol DESC", "relation_name": "`dbt`.`api_p2p_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.796780Z", "completed_at": "2025-09-04T07:25:38.833177Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:38.948106Z", "completed_at": "2025-09-04T07:25:38.948120Z"}], "thread_id": "Thread-2", "execution_time": 0.18807268142700195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__attestations", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    attestation_index,\n    aggregation_bits,\n    signature,\n    attestation_slot,\n    committee_index,\n    beacon_block_root,\n    source_epoch,\n    source_root,\n    target_epoch,\n    target_root,\n    slot_timestamp\nFROM \n    `consensus`.`attestations` FINAL", "relation_name": "`dbt`.`stg_consensus__attestations`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.813113Z", "completed_at": "2025-09-04T07:25:38.858126Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:38.999068Z", "completed_at": "2025-09-04T07:25:38.999079Z"}], "thread_id": "Thread-3", "execution_time": 0.23524117469787598, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__blob_commitments", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    commitment_index,\n    commitment,\n    slot_timestamp\nFROM \n    `consensus`.`blob_commitments` FINAL", "relation_name": "`dbt`.`stg_consensus__blob_commitments`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.821236Z", "completed_at": "2025-09-04T07:25:38.865094Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.013177Z", "completed_at": "2025-09-04T07:25:39.013190Z"}], "thread_id": "Thread-4", "execution_time": 0.24738860130310059, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__blocks", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    proposer_index,\n    parent_root,\n    state_root,\n    signature,\n    version,\n    randao_reveal,\n    graffiti,\n    eth1_deposit_root,\n    eth1_deposit_count,\n    eth1_block_hash,\n    sync_aggregate_participation,\n    withdrawals_count,\n    blob_kzg_commitments_count,\n    execution_requests_count,\n    slot_timestamp\nFROM \n    `consensus`.`blocks` FINAL", "relation_name": "`dbt`.`stg_consensus__blocks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.829198Z", "completed_at": "2025-09-04T07:25:38.949331Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.016800Z", "completed_at": "2025-09-04T07:25:39.016809Z"}], "thread_id": "Thread-5", "execution_time": 0.2466416358947754, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__deposits", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    deposit_index,\n    pubkey,\n    withdrawal_credentials,\n    amount,\n    signature,\n    proof,\n    slot_timestamp\nFROM \n    `consensus`.`deposits` FINAL", "relation_name": "`dbt`.`stg_consensus__deposits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.834959Z", "completed_at": "2025-09-04T07:25:38.962272Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.021884Z", "completed_at": "2025-09-04T07:25:39.021891Z"}], "thread_id": "Thread-6", "execution_time": 0.24988389015197754, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__execution_requests", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    payload,\n    deposits_count,\n    withdrawals_count,\n    consolidations_count,\n    slot_timestamp\nFROM \n    `consensus`.`execution_requests` FINAL", "relation_name": "`dbt`.`stg_consensus__execution_requests`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.841366Z", "completed_at": "2025-09-04T07:25:38.980569Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.024205Z", "completed_at": "2025-09-04T07:25:39.024216Z"}], "thread_id": "Thread-7", "execution_time": 0.2388925552368164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__rewards", "compiled": true, "compiled_code": "\n\nSELECT\n    slot\n    proposer_index,\n    total,\n    attestations,\n    sync_aggregate,\n    proposer_slashings,\n    attester_slashings,\n    slot_timestamp\nFROM \n    `consensus`.`rewards` FINAL", "relation_name": "`dbt`.`stg_consensus__rewards`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.846595Z", "completed_at": "2025-09-04T07:25:38.994223Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.028683Z", "completed_at": "2025-09-04T07:25:39.028690Z"}], "thread_id": "Thread-8", "execution_time": 0.24153923988342285, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__specs", "compiled": true, "compiled_code": "\n\nSELECT\n    parameter_name,\n    parameter_value,\nFROM \n    `consensus`.`specs` FINAL", "relation_name": "`dbt`.`stg_consensus__specs`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.854333Z", "completed_at": "2025-09-04T07:25:39.000196Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.030609Z", "completed_at": "2025-09-04T07:25:39.030617Z"}], "thread_id": "Thread-9", "execution_time": 0.24039173126220703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__time_helpers", "compiled": true, "compiled_code": "\n\nSELECT\n    genesis_time_unix,\n    seconds_per_slot,\n    slots_per_epoch\nFROM \n    `consensus`.`time_helpers` FINAL", "relation_name": "`dbt`.`stg_consensus__time_helpers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.004712Z", "completed_at": "2025-09-04T07:25:39.006768Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.033330Z", "completed_at": "2025-09-04T07:25:39.033340Z"}], "thread_id": "Thread-28", "execution_time": 0.21419262886047363, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.contracts_abi", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.007540Z", "completed_at": "2025-09-04T07:25:39.009406Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.034806Z", "completed_at": "2025-09-04T07:25:39.034813Z"}], "thread_id": "Thread-29", "execution_time": 0.21433758735656738, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.event_signatures", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.859905Z", "completed_at": "2025-09-04T07:25:39.009967Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.035671Z", "completed_at": "2025-09-04T07:25:39.035678Z"}], "thread_id": "Thread-10", "execution_time": 0.24360036849975586, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__validators", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    validator_index,\n    balance,\n    status,\n    pubkey,\n    withdrawal_credentials,\n    effective_balance,\n    slashed,\n    activation_eligibility_epoch,\n    activation_epoch,\n    exit_epoch,\n    withdrawable_epoch,\n    slot_timestamp\nFROM \n    `consensus`.`validators` FINAL", "relation_name": "`dbt`.`stg_consensus__validators`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.010610Z", "completed_at": "2025-09-04T07:25:39.012574Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.036559Z", "completed_at": "2025-09-04T07:25:39.036566Z"}], "thread_id": "Thread-30", "execution_time": 0.211395263671875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.function_signatures", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.865730Z", "completed_at": "2025-09-04T07:25:39.014557Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.038196Z", "completed_at": "2025-09-04T07:25:39.038206Z"}], "thread_id": "Thread-11", "execution_time": 0.2436835765838623, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__withdrawals", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    block_number,\n    block_hash,\n    withdrawal_index,\n    validator_index,\n    address,\n    amount,\n    slot_timestamp\nFROM \n    `consensus`.`withdrawals` FINAL", "relation_name": "`dbt`.`stg_consensus__withdrawals`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.869592Z", "completed_at": "2025-09-04T07:25:39.016007Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.039095Z", "completed_at": "2025-09-04T07:25:39.039106Z"}], "thread_id": "Thread-12", "execution_time": 0.2438507080078125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__country_codes", "compiled": true, "compiled_code": "\n\n\nSELECT\n    \"name\",\n    \"alpha-2\",\n    \"alpha-3\",\n    \"country-code\",\n    \"iso_3166-2\",\n    \"region\",\n    \"sub-region\",\n    \"intermediate-region\",\n    \"region-code\",\n    \"sub-region-code\",\n    \"intermediate-region-code\"\nFROM\n    `crawlers_data`.`country_codes`", "relation_name": "`dbt`.`stg_crawlers_data__country_codes`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.878718Z", "completed_at": "2025-09-04T07:25:39.017672Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.040813Z", "completed_at": "2025-09-04T07:25:39.040820Z"}], "thread_id": "Thread-14", "execution_time": 0.23946690559387207, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__ipinfo", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    ip,\n    hostname,\n    city,\n    region,\n    country,\n    loc,\n    org,\n    postal,\n    timezone,\n    asn,\n    company,\n    carrier,\n    is_bogon,\n    is_mobile,\n    multiIf(\n      lowerUTF8(org) ILIKE '%amazon web services%' OR lowerUTF8(org) ILIKE '%amazon data services%' OR lowerUTF8(org) ILIKE '%aws%' OR lowerUTF8(org) ILIKE '%amazon.com%', 'AWS',\n      (lowerUTF8(org) ILIKE '%google cloud%' OR lowerUTF8(org) ILIKE '%google llc%' OR lowerUTF8(org) ILIKE '%gcp%' OR lowerUTF8(org) ILIKE '%google%') AND lowerUTF8(org) NOT ILIKE '%fiber%', 'Google',\n      lowerUTF8(org) ILIKE '%microsoft azure%' OR lowerUTF8(org) ILIKE '%azure%' OR lowerUTF8(org) ILIKE '%microsoft corporation%' OR lowerUTF8(org) ILIKE '%msft%', 'Azure',\n      lowerUTF8(org) ILIKE '%oracle cloud%' OR lowerUTF8(org) ILIKE '%oracle america%' OR lowerUTF8(org) ILIKE '%oci%', 'Oracle Cloud',\n      lowerUTF8(org) ILIKE '%alibaba cloud%' OR lowerUTF8(org) ILIKE '%aliyun%' OR lowerUTF8(org) ILIKE '%alibaba%', 'Alibaba Cloud',\n\n      lowerUTF8(org) ILIKE '%cloudflare%', 'Cloudflare',\n      (lowerUTF8(org) ILIKE '%akamai%' AND lowerUTF8(org) NOT ILIKE '%linode%'), 'Akamai',\n      lowerUTF8(org) ILIKE '%fastly%', 'Fastly',\n\n      lowerUTF8(org) ILIKE '%digitalocean%' OR lowerUTF8(org) ILIKE '%digital ocean%', 'DigitalOcean',\n      lowerUTF8(org) ILIKE '%ovh%', 'OVHcloud',\n      lowerUTF8(org) ILIKE '%hetzner%', 'Hetzner',\n      lowerUTF8(org) ILIKE '%scaleway%' OR lowerUTF8(org) ILIKE '%online s.a.s%' OR lowerUTF8(org) ILIKE '%iliad%', 'Scaleway',\n      lowerUTF8(org) ILIKE '%linode%', 'Linode',\n      lowerUTF8(org) ILIKE '%vultr%' OR lowerUTF8(org) ILIKE '%choopa%', 'Vultr',\n      lowerUTF8(org) ILIKE '%equinix metal%' OR lowerUTF8(org) ILIKE '%packet host%' OR lowerUTF8(org) ILIKE '%packet, inc%', 'Equinix Metal',\n      lowerUTF8(org) ILIKE '%fly.io%' OR lowerUTF8(org) ILIKE '%fly io%', 'Fly.io',\n      lowerUTF8(org) ILIKE '%netlify%', 'Netlify',\n      lowerUTF8(org) ILIKE '%vercel%' OR lowerUTF8(org) ILIKE '%zeit%', 'Vercel',\n      lowerUTF8(org) ILIKE '%heroku%', 'Heroku',\n      lowerUTF8(org) ILIKE '%render.com%' OR lowerUTF8(org) ILIKE '% render %', 'Render',\n\n      -- Carrier / transit networks (keep as its own bucket; change to 'Public ISP (Home/Office)' if you prefer)\n      lowerUTF8(org) ILIKE '%cogent%' OR lowerUTF8(org) ILIKE '%lumen%' OR lowerUTF8(org) ILIKE '%level 3%' OR lowerUTF8(org) ILIKE '%centurylink%' OR\n      lowerUTF8(org) ILIKE '%telia carrier%' OR lowerUTF8(org) ILIKE '%arelion%' OR lowerUTF8(org) ILIKE '%gtt%' OR lowerUTF8(org) ILIKE '%hurricane electric%' OR\n      lowerUTF8(org) ILIKE '%he.net%' OR lowerUTF8(org) ILIKE '%ntt communications%' OR lowerUTF8(org) ILIKE '%tata communications%' OR lowerUTF8(org) ILIKE '%zayo%' OR\n      lowerUTF8(org) ILIKE '%kddi%' OR lowerUTF8(org) ILIKE '%sparkle%' OR lowerUTF8(org) ILIKE '%backbone%' OR lowerUTF8(org) ILIKE '%chinanet-backbone%', 'Carrier/Transit',\n\n      -- Education / government \u2192 treat like public access\n      lowerUTF8(org) ILIKE '%university%' OR lowerUTF8(org) ILIKE '%college%' OR lowerUTF8(org) ILIKE '%school%' OR lowerUTF8(org) ILIKE '%ministry%' OR lowerUTF8(org) ILIKE '%government%', 'Public ISP (Home/Office)',\n\n      -- Generic hosting/CDN hints\n      lowerUTF8(org) ILIKE '%datacenter%' OR lowerUTF8(org) ILIKE '%data center%' OR lowerUTF8(org) ILIKE '%colo%' OR lowerUTF8(org) ILIKE '%hosting%' OR lowerUTF8(org) ILIKE '%vps%' OR lowerUTF8(org) ILIKE '%server%' OR lowerUTF8(org) ILIKE '%incapsula%' OR lowerUTF8(org) ILIKE '%imperva%', 'Hosting/CDN (Other)',\n\n      -- Fallback for residential & office ISPs\n      lowerUTF8(org) ILIKE '%telecom%' OR lowerUTF8(org) ILIKE '%telekom%' OR lowerUTF8(org) ILIKE '%telecommunications%' OR lowerUTF8(org) ILIKE '%communications%' OR lowerUTF8(org) ILIKE '%wireless%' OR\n      lowerUTF8(org) ILIKE '%cable%' OR lowerUTF8(org) ILIKE '%broadband%' OR lowerUTF8(org) ILIKE '%internet%' OR lowerUTF8(org) ILIKE '%fibre%' OR lowerUTF8(org) ILIKE '%fiber%' OR lowerUTF8(org) ILIKE '%mobile%', 'Public ISP (Home/Office)',\n      lowerUTF8(org) = '', 'Unknown',\n      'Public ISP (Home/Office)'\n  ) AS generic_provider\n  FROM `crawlers_data`.`ipinfo` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_crawlers_data__ipinfo`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.943713Z", "completed_at": "2025-09-04T07:25:39.019129Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.042437Z", "completed_at": "2025-09-04T07:25:39.042448Z"}], "thread_id": "Thread-15", "execution_time": 0.24041175842285156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_agent_semvers_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    agent_version_semver,\n    agent_version_semver_str,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_agent_semvers_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.873635Z", "completed_at": "2025-09-04T07:25:39.019711Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.043310Z", "completed_at": "2025-09-04T07:25:39.043317Z"}], "thread_id": "Thread-13", "execution_time": 0.24738240242004395, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__ember_electricity_data", "compiled": true, "compiled_code": "\n\n\nSELECT\n    \"Area\",\n    \"ISO 3 code\",\n    \"Date\",\n    \"Area type\",\n    \"Continent\",\n    \"Ember region\",\n    \"EU\" ,\n    \"OECD\",\n    \"G20\",\n    \"G7\",\n    \"ASEAN\",\n    \"Category\",\n    \"Subcategory\",\n    \"Variable\",\n    \"Unit\",\n    \"Value\",\n    \"YoY absolute change\",\n    \"YoY % change\" \nFROM\n    `crawlers_data`.`ember_electricity_data`", "relation_name": "`dbt`.`stg_crawlers_data__ember_electricity_data`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.953848Z", "completed_at": "2025-09-04T07:25:39.020679Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.044172Z", "completed_at": "2025-09-04T07:25:39.044182Z"}], "thread_id": "Thread-17", "execution_time": 0.24016690254211426, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_countries_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    country_name,\n    country,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_countries_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_countries_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.949973Z", "completed_at": "2025-09-04T07:25:39.021246Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.045056Z", "completed_at": "2025-09-04T07:25:39.045064Z"}], "thread_id": "Thread-16", "execution_time": 0.24172282218933105, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_cloud_provider_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    cloud_provider,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_cloud_provider_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.958095Z", "completed_at": "2025-09-04T07:25:39.022741Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.046065Z", "completed_at": "2025-09-04T07:25:39.046074Z"}], "thread_id": "Thread-18", "execution_time": 0.2407698631286621, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_quic_support_over_7d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    crawl_created_at,\n    quic_support,\n    __count,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_quic_support_over_7d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_quic_support_over_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.972304Z", "completed_at": "2025-09-04T07:25:39.025091Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.047073Z", "completed_at": "2025-09-04T07:25:39.047083Z"}], "thread_id": "Thread-21", "execution_time": 0.23948884010314941, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__transactions", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n    SELECT\n        block_number,\n        transaction_index,\n        transaction_hash,\n        nonce,\n        from_address,\n        to_address,\n        value_string,\n        input,\n        gas_limit,\n        gas_used,\n        gas_price,\n        transaction_type,\n        max_priority_fee_per_gas,\n        max_fee_per_gas,\n        success,\n        n_input_bytes,\n        n_input_zero_bytes,\n        n_input_nonzero_bytes,\n        n_rlp_bytes,\n        r,\n        s,\n        v,\n        block_hash,\n        block_timestamp\n    FROM `execution`.`transactions` FINAL\n)\n\nSELECT\n    block_number,\n    transaction_index,\n    transaction_hash,\n    nonce,\n    CONCAT('0x',from_address) AS from_address,\n    IF(to_address IS NULL, NULL, CONCAT('0x',to_address)) AS to_address,\n    CAST(value_string AS UInt256) AS value,\n    input,\n    gas_limit,\n    gas_used,\n    gas_price,\n    transaction_type,\n    max_priority_fee_per_gas,\n    max_fee_per_gas,\n    success,\n    n_input_bytes,\n    n_input_zero_bytes,\n    n_input_nonzero_bytes,\n    n_rlp_bytes,\n    r,\n    s,\n    v,\n    block_hash,\n    block_timestamp\nFROM source", "relation_name": "`dbt`.`stg_execution__transactions`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.976757Z", "completed_at": "2025-09-04T07:25:39.025743Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.047979Z", "completed_at": "2025-09-04T07:25:39.047987Z"}], "thread_id": "Thread-22", "execution_time": 0.23904705047607422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__discovery_id_prefixes_x_peer_ids", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    discovery_id_prefix,\n    peer_id\n  FROM `nebula_discv4`.`discovery_id_prefixes_x_peer_ids` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.962874Z", "completed_at": "2025-09-04T07:25:39.026370Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.048861Z", "completed_at": "2025-09-04T07:25:39.048868Z"}], "thread_id": "Thread-19", "execution_time": 0.24288654327392578, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__blocks", "compiled": true, "compiled_code": "\n\n\nWITH\n\nsource AS (\n    SELECT \n        block_number,\n        block_hash,\n        parent_hash,\n        uncles_hash,\n        author,\n        state_root,\n        transactions_root,\n        receipts_root,\n        gas_used,\n        gas_limit,\n        extra_data,\n        size,\n        mix_hash,\n        nonce,\n        base_fee_per_gas,\n        withdrawals_root,\n        block_timestamp\n    FROM \n        `execution`.`blocks`\n    WHERE \n        block_timestamp > '1970-01-01' -- remove genesis\n)\n\nSELECT\n    block_number,\n    block_hash,\n    parent_hash,\n    uncles_hash,\n    CONCAT('0x',author) AS author,\n    state_root,\n    transactions_root,\n    receipts_root,\n    gas_used,\n    gas_limit,\n    extra_data,\n    \narrayFilter(\n    x -> x != '',\n    /* split on every \u201cnon word-ish\u201d character (dash, @, space, etc.) */\n    splitByRegexp(\n        '[^A-Za-z0-9\\\\.]+',            -- \u21fd anything that isn\u2019t a\u2013z, 0\u20139 or \u201c.\u201d\n        arrayStringConcat(\n            arrayMap(\n                i -> if(\n                    reinterpretAsUInt8(substring(unhex(coalesce(extra_data, '')), i, 1)) BETWEEN 32 AND 126,\n                    reinterpretAsString(substring(unhex(coalesce(extra_data, '')), i, 1)),\n                    ' '\n                ),\n                range(1, length(unhex(coalesce(extra_data, ''))) + 1)\n            ),\n            ''\n        )\n    )\n)\n AS decoded_extra_data,\n    size,\n    mix_hash,\n    nonce,\n    base_fee_per_gas,\n    withdrawals_root,\n    block_timestamp\nFROM source", "relation_name": "`dbt`.`stg_execution__blocks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.981285Z", "completed_at": "2025-09-04T07:25:39.027229Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.049725Z", "completed_at": "2025-09-04T07:25:39.049732Z"}], "thread_id": "Thread-23", "execution_time": 0.24004364013671875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__neighbors", "compiled": true, "compiled_code": "\n\nWITH \n\nsource AS (\n  SELECT \n    crawl_id,\n    crawl_created_at,\n    peer_discovery_id_prefix,\n    neighbor_discovery_id_prefix,\n    error_bits\n  FROM `nebula_discv4`.`neighbors` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__neighbors`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.967095Z", "completed_at": "2025-09-04T07:25:39.027883Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.050587Z", "completed_at": "2025-09-04T07:25:39.050594Z"}], "thread_id": "Thread-20", "execution_time": 0.2437455654144287, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__storage_diffs", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n    SELECT \n        block_number,\n        transaction_index,\n        CONCAT('0x', transaction_hash) AS transaction_hash,\n        CONCAT('0x', address) AS address,\n        slot,\n        from_value,\n        to_value,\n        block_timestamp\n    FROM \n        `execution`.`storage_diffs`\n)\n\nSELECT\n    *\nFROM source", "relation_name": "`dbt`.`stg_execution__storage_diffs`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.985229Z", "completed_at": "2025-09-04T07:25:39.029531Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.051544Z", "completed_at": "2025-09-04T07:25:39.051551Z"}], "thread_id": "Thread-24", "execution_time": 0.24050545692443848, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__visits", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    crawl_id,\n    peer_id,\n    agent_version,\n    protocols,\n    dial_maddrs,\n    filtered_maddrs,\n    extra_maddrs,\n    dial_errors,\n    connect_maddr,\n    crawl_error,\n    visit_started_at,\n    visit_ended_at,\n    peer_properties\n  FROM `nebula_discv4`.`visits` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__visits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.994985Z", "completed_at": "2025-09-04T07:25:39.031472Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.052669Z", "completed_at": "2025-09-04T07:25:39.052678Z"}], "thread_id": "Thread-26", "execution_time": 0.2356123924255371, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__neighbors", "compiled": true, "compiled_code": "\n\nWITH \n\nsource AS (\n  SELECT \n    crawl_id,\n    crawl_created_at,\n    peer_discovery_id_prefix,\n    neighbor_discovery_id_prefix,\n    error_bits\n  FROM `nebula`.`neighbors` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__neighbors`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:38.989386Z", "completed_at": "2025-09-04T07:25:39.032018Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.054858Z", "completed_at": "2025-09-04T07:25:39.054865Z"}], "thread_id": "Thread-25", "execution_time": 0.24253106117248535, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__discovery_id_prefixes_x_peer_ids", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    discovery_id_prefix,\n    peer_id\n  FROM `nebula`.`discovery_id_prefixes_x_peer_ids` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.000772Z", "completed_at": "2025-09-04T07:25:39.034197Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.056562Z", "completed_at": "2025-09-04T07:25:39.056570Z"}], "thread_id": "Thread-27", "execution_time": 0.23807287216186523, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__visits", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    crawl_id,\n    peer_id,\n    agent_version,\n    protocols,\n    dial_maddrs,\n    filtered_maddrs,\n    extra_maddrs,\n    dial_errors,\n    connect_maddr,\n    crawl_error,\n    visit_started_at,\n    visit_ended_at,\n    peer_properties\n  FROM `nebula`.`visits` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__visits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.094393Z", "completed_at": "2025-09-04T07:25:39.143049Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.236830Z", "completed_at": "2025-09-04T07:25:39.236844Z"}], "thread_id": "Thread-32", "execution_time": 0.19524908065795898, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_attestations_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,slot - attestation_slot AS inclusion_delay\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__attestations`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_attestations_daily`\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_attestations_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.118571Z", "completed_at": "2025-09-04T07:25:39.167988Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.361918Z", "completed_at": "2025-09-04T07:25:39.361932Z"}], "thread_id": "Thread-34", "execution_time": 0.30631017684936523, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_blob_commitments_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__blob_commitments`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_blob_commitments_daily`\n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_consensus_blob_commitments_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.124740Z", "completed_at": "2025-09-04T07:25:39.179514Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.363766Z", "completed_at": "2025-09-04T07:25:39.363775Z"}], "thread_id": "Thread-36", "execution_time": 0.3052690029144287, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_graffiti_daily", "compiled": true, "compiled_code": "\n\nWITH\n    -- Canonical lists\n    ['nethermind','erigon','geth','besu','reth'] AS el_keys,\n    ['Nethermind','Erigon','Geth','Besu','Reth'] AS el_names,\n    ['lighthouse','teku','prysm','lodestar','nimbus'] AS cl_keys,\n    ['Lighthouse','Teku','Prysm','Lodestar','Nimbus'] AS cl_names,\n\n    -- Platform/hosting brands \n    ['dappnode','avado','allnodes','twinstake','stakewise','gateway','kleros',\n     'filoozom','kpk-validators','hopr','digitalconsultantsllc',\n     'synthex'] AS brand_keys,\n    ['DappNode','Avado','Allnodes','Twinstake','StakeWise','gateway.fm','kleros.io',\n     'filoozom.eth','kpk-validators','HOPR','DigitalConsultantsLLC.xyz',\n     'Synthex'] AS brand_names,\n\n\nfinal AS (\n    SELECT\n        date\n        ,graffiti\n        ,cnt\n        -- Lowercased text to search in\n        ,lowerUTF8(graffiti) AS g\n\n        -- Detect any brand first (highest precedence)\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, brand_keys) AS brands_found\n        ,if(length(brands_found) > 0,\n            arrayElement(brand_names, indexOf(brand_keys, brands_found[1])),\n            null) AS brand_label\n\n        -- Detect EL/CL clients (order-insensitive, separator-agnostic)\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, el_keys) AS el_found\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, cl_keys) AS cl_found\n\n        -- Pick the first match per side by priority order above\n        ,if(length(el_found) > 0,\n            arrayElement(el_names, indexOf(el_keys, el_found[1])),\n            null) AS el_label\n\n        ,if(length(cl_found) > 0,\n            arrayElement(cl_names, indexOf(cl_keys, cl_found[1])),\n            null) AS cl_label\n\n        -- Final label priority:\n        -- 1) Brand/platform if any\n        -- 2) EL+CL combo if both found\n        -- 3) Single client if only one side found\n        -- 4) Other\n        ,coalesce(\n            brand_label,\n            if(el_label IS NOT NULL AND cl_label IS NOT NULL, concat(el_label, '+', cl_label), null),\n            el_label,\n            cl_label,\n            if(graffiti = 'None', graffiti, null),\n            'Other'\n        ) AS label\n    FROM (\n        SELECT\n            toStartOfDay(slot_timestamp) AS date\n            ,IF(graffiti='0x0000000000000000000000000000000000000000000000000000000000000000', \n                'None', \n                unhex(right(graffiti,-2))\n            ) AS graffiti\n            ,COUNT(*) AS cnt\n        FROM `dbt`.`stg_consensus__blocks`\n        WHERE\n            slot_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_graffiti_daily`\n    )\n  \n\n        GROUP BY 1, 2\n    )\n)\n\nSELECT\n    date\n    ,graffiti\n    ,label\n    ,cnt\nFROM final", "relation_name": "`dbt`.`int_consensus_graffiti_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.133338Z", "completed_at": "2025-09-04T07:25:39.202831Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.368112Z", "completed_at": "2025-09-04T07:25:39.368123Z"}], "thread_id": "Thread-38", "execution_time": 0.3054678440093994, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_deposits_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,SUM(amount/POWER(10,9)) AS total_amount\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__deposits`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_deposits_daily`\n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_consensus_deposits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.160826Z", "completed_at": "2025-09-04T07:25:39.361142Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.392478Z", "completed_at": "2025-09-04T07:25:39.392489Z"}], "thread_id": "Thread-31", "execution_time": 0.3079836368560791, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_blocks_daily", "compiled": true, "compiled_code": "\n\nWITH\n\ntime_helpers AS (\n    SELECT\n        genesis_time_unix,\n        seconds_per_slot\n    FROM \n        `dbt`.`stg_consensus__time_helpers`\n)\n\nSELECT\n    date\n    ,cnt AS blocks_produced\n    ,CASE\n        WHEN toStartOfDay(toDateTime(genesis_time_unix)) = date \n            THEN CAST((86400 - toUnixTimestamp(toDateTime(genesis_time_unix)) % 86400) / seconds_per_slot - cnt AS UInt64)\n        ELSE CAST(86400 / seconds_per_slot - cnt AS UInt64)\n    END AS blocks_missed\nFROM (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date\n        ,COUNT(*) AS cnt\n    FROM `dbt`.`stg_consensus__blocks`\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_blocks_daily`\n    )\n  \n\n    GROUP BY 1\n) t1\nCROSS JOIN time_helpers t2", "relation_name": "`dbt`.`int_consensus_blocks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.155221Z", "completed_at": "2025-09-04T07:25:39.362839Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.394697Z", "completed_at": "2025-09-04T07:25:39.394704Z"}], "thread_id": "Thread-40", "execution_time": 0.3123188018798828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_forks", "compiled": true, "compiled_code": "\n\nWITH\n\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\nfork_version AS (\n    SELECT\n        IF(fork_name='GENESIS', 'PHASE0', fork_name) AS fork_name\n        ,parameter_value\n    FROM (\n        SELECT\n            arrayElement(splitByChar('_', ifNull(parameter_name, '')), 1) AS fork_name\n            ,parameter_value\n        FROM `dbt`.`stg_consensus__specs`\n        WHERE parameter_name LIKE '%_FORK_VERSION'\n    )\n),\n\nfork_epoch AS (\n    SELECT\n        arrayElement(splitByChar('_', ifNull(parameter_name, '')), 1) AS fork_name\n        ,parameter_value\n    FROM `dbt`.`stg_consensus__specs`\n    WHERE parameter_name LIKE '%_FORK_EPOCH'\n\n    UNION ALL \n\n    SELECT 'PHASE0' AS fork_name, '0' AS parameter_value \n)\n\nSELECT \n  t1.cl_fork_name AS fork_name\n  ,t2.parameter_value AS fork_version \n  ,t1.fork_digest AS fork_digest\n  ,t3.parameter_value AS fork_epoch \n  ,IF(CAST(t3.parameter_value AS Int) = -1, NULL,\n    addSeconds(\n          toDateTime(t4.genesis_time_unix, 'UTC'),\n          CAST(t3.parameter_value AS Int) * (t4.seconds_per_slot * t4.slots_per_epoch )\n      )\n   ) AS fork_time\nFROM \n  fork_digests t1\nINNER JOIN\n  fork_version t2\n  ON LOWER(t2.fork_name) = LOWER(t1.cl_fork_name)\nINNER JOIN\n  fork_epoch t3\n  ON LOWER(t3.fork_name) = LOWER(t1.cl_fork_name)\nCROSS JOIN `dbt`.`stg_consensus__time_helpers` t4", "relation_name": "`dbt`.`fct_consensus_forks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.168582Z", "completed_at": "2025-09-04T07:25:39.364967Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.396187Z", "completed_at": "2025-09-04T07:25:39.396195Z"}], "thread_id": "Thread-2", "execution_time": 0.30834341049194336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_AgentResultMapping_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '99c43743a2dbd406160cc43cf08113b17178789c'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2025-06-10'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_AgentResultMapping_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_AgentResultMapping_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.174029Z", "completed_at": "2025-09-04T07:25:39.365720Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.397221Z", "completed_at": "2025-09-04T07:25:39.397229Z"}], "thread_id": "Thread-11", "execution_time": 0.3087334632873535, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_ConditionalTokens_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-01'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_ConditionalTokens_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_ConditionalTokens_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.180119Z", "completed_at": "2025-09-04T07:25:39.366792Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.398141Z", "completed_at": "2025-09-04T07:25:39.398152Z"}], "thread_id": "Thread-33", "execution_time": 0.3090503215789795, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_FPMMDeterministicFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-04'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_FPMMDeterministicFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_FPMMDeterministicFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.185591Z", "completed_at": "2025-09-04T07:25:39.367479Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.399044Z", "completed_at": "2025-09-04T07:25:39.399054Z"}], "thread_id": "Thread-12", "execution_time": 0.30922627449035645, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_GBCDeposit_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '0b98057ea310f4d31f2a452b414647007d1645d9'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_GBCDeposit_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_GBCDeposit_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.197550Z", "completed_at": "2025-09-04T07:25:39.369090Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.400624Z", "completed_at": "2025-09-04T07:25:39.400635Z"}], "thread_id": "Thread-35", "execution_time": 0.3089728355407715, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Realitio_v2_1_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2021-01-13'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Realitio_v2_1_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Realitio_v2_1_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.190864Z", "completed_at": "2025-09-04T07:25:39.369848Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.401553Z", "completed_at": "2025-09-04T07:25:39.401561Z"}], "thread_id": "Thread-3", "execution_time": 0.31110501289367676, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_OmenAgentResultMapping_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-09-30'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_OmenAgentResultMapping_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_OmenAgentResultMapping_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.208838Z", "completed_at": "2025-09-04T07:25:39.370917Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.402417Z", "completed_at": "2025-09-04T07:25:39.402428Z"}], "thread_id": "Thread-14", "execution_time": 0.3094613552093506, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_Wrapped1155Factory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-02-07'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Seer_Wrapped1155Factory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_Wrapped1155Factory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.203446Z", "completed_at": "2025-09-04T07:25:39.371614Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.403259Z", "completed_at": "2025-09-04T07:25:39.403266Z"}], "thread_id": "Thread-4", "execution_time": 0.31089258193969727, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_MarketFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-10-08'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Seer_MarketFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_MarketFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.214146Z", "completed_at": "2025-09-04T07:25:39.372169Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.404129Z", "completed_at": "2025-09-04T07:25:39.404138Z"}], "thread_id": "Thread-37", "execution_time": 0.3105320930480957, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-09-22'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.219285Z", "completed_at": "2025-09-04T07:25:39.373054Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.405008Z", "completed_at": "2025-09-04T07:25:39.405015Z"}], "thread_id": "Thread-5", "execution_time": 0.30263352394104004, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraPool_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-11-30'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraPool_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.224887Z", "completed_at": "2025-09-04T07:25:39.374494Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.406526Z", "completed_at": "2025-09-04T07:25:39.406533Z"}], "thread_id": "Thread-39", "execution_time": 0.30352187156677246, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_aaveV3_PoolConfigurator_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '7304979ec9e4eaa0273b6a037a31c4e9e5a75d16'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-10-04'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_aaveV3_PoolConfigurator_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '7304979ec9e4eaa0273b6a037a31c4e9e5a75d16'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_aaveV3_PoolConfigurator_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.230052Z", "completed_at": "2025-09-04T07:25:39.375529Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.407352Z", "completed_at": "2025-09-04T07:25:39.407362Z"}], "thread_id": "Thread-15", "execution_time": 0.3035850524902344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_aaveV3_PoolInstance_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'b50201558b00496a145fe76f7424749556e326d8'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-10-04'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_aaveV3_PoolInstance_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'b50201558b00496a145fe76f7424749556e326d8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_aaveV3_PoolInstance_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.237869Z", "completed_at": "2025-09-04T07:25:39.376357Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.408223Z", "completed_at": "2025-09-04T07:25:39.408230Z"}], "thread_id": "Thread-6", "execution_time": 0.30379581451416016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_TSLAx_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '19972d1750f959dd14cf436da6360185bd54cea0'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_TSLAx_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '19972d1750f959dd14cf436da6360185bd54cea0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_TSLAx_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.243063Z", "completed_at": "2025-09-04T07:25:39.377154Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.409084Z", "completed_at": "2025-09-04T07:25:39.409091Z"}], "thread_id": "Thread-13", "execution_time": 0.30403566360473633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bC3M_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '83ec02059f686e747392a22ddfed7833ba0d7ce3'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bC3M_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83ec02059f686e747392a22ddfed7833ba0d7ce3'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bC3M_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.248310Z", "completed_at": "2025-09-04T07:25:39.377989Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.409951Z", "completed_at": "2025-09-04T07:25:39.409959Z"}], "thread_id": "Thread-7", "execution_time": 0.30417847633361816, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bCOIN_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '69b2d456e8830847f488afdde2a636bfb26218c6'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bCOIN_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '69b2d456e8830847f488afdde2a636bfb26218c6'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bCOIN_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.253646Z", "completed_at": "2025-09-04T07:25:39.378581Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.410809Z", "completed_at": "2025-09-04T07:25:39.410817Z"}], "thread_id": "Thread-17", "execution_time": 0.3044137954711914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bCSPX_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '1332d2b4dc83238b621b7f7d0f72fec58bb81a9b'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bCSPX_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '1332d2b4dc83238b621b7f7d0f72fec58bb81a9b'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bCSPX_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.270797Z", "completed_at": "2025-09-04T07:25:39.379623Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.411665Z", "completed_at": "2025-09-04T07:25:39.411671Z"}], "thread_id": "Thread-16", "execution_time": 0.30346035957336426, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bIBTA_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '9f9953d8a2c5366f098754d48f2d69b144ce03da'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bIBTA_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9f9953d8a2c5366f098754d48f2d69b144ce03da'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bIBTA_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.260183Z", "completed_at": "2025-09-04T07:25:39.380421Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.412514Z", "completed_at": "2025-09-04T07:25:39.412524Z"}], "thread_id": "Thread-8", "execution_time": 0.3055257797241211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bHIGH_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '9e8e794ad6ecdb6d5c7eabe059d30e907f58859b'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bHIGH_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9e8e794ad6ecdb6d5c7eabe059d30e907f58859b'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bHIGH_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.276108Z", "completed_at": "2025-09-04T07:25:39.381123Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.413350Z", "completed_at": "2025-09-04T07:25:39.413357Z"}], "thread_id": "Thread-1", "execution_time": 0.30455923080444336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bMSTR_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'c8429803dcda7df86822ab173ea285c10bf1eb66'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bMSTR_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'c8429803dcda7df86822ab173ea285c10bf1eb66'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bMSTR_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.265402Z", "completed_at": "2025-09-04T07:25:39.381682Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.414194Z", "completed_at": "2025-09-04T07:25:39.414204Z"}], "thread_id": "Thread-9", "execution_time": 0.3065822124481201, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bIB01_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '788d911ae7c95121a89a0f0306db65d87422e1de'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bIB01_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '788d911ae7c95121a89a0f0306db65d87422e1de'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bIB01_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.281406Z", "completed_at": "2025-09-04T07:25:39.382537Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.415056Z", "completed_at": "2025-09-04T07:25:39.415064Z"}], "thread_id": "Thread-28", "execution_time": 0.3056364059448242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bNVDA_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '1d3be4d05eba2aa6c4eede85a74f491c31766e64'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bNVDA_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '1d3be4d05eba2aa6c4eede85a74f491c31766e64'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bNVDA_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.286861Z", "completed_at": "2025-09-04T07:25:39.383611Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.415919Z", "completed_at": "2025-09-04T07:25:39.415926Z"}], "thread_id": "Thread-18", "execution_time": 0.3059065341949463, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v1_Hub_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '29b9a7fbb8995b2423a71cc17cf9810798f6c543'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v1_Hub_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '29b9a7fbb8995b2423a71cc17cf9810798f6c543'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v1_Hub_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.298699Z", "completed_at": "2025-09-04T07:25:39.384167Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.416771Z", "completed_at": "2025-09-04T07:25:39.416777Z"}], "thread_id": "Thread-10", "execution_time": 0.30553293228149414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_Hub_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'c12c1e50abb450d6205ea2c3fa861b3b834d13e8'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_Hub_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'c12c1e50abb450d6205ea2c3fa861b3b834d13e8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_Hub_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.293457Z", "completed_at": "2025-09-04T07:25:39.385170Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.417624Z", "completed_at": "2025-09-04T07:25:39.417632Z"}], "thread_id": "Thread-29", "execution_time": 0.30698299407958984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_CirclesBackingFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'eced91232c609a42f6016860e8223b8aecaa7bd0'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2025-04-25'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_CirclesBackingFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'eced91232c609a42f6016860e8223b8aecaa7bd0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_CirclesBackingFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.303903Z", "completed_at": "2025-09-04T07:25:39.385748Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.418469Z", "completed_at": "2025-09-04T07:25:39.418480Z"}], "thread_id": "Thread-21", "execution_time": 0.30663537979125977, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_NameRegistry_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'a27566fd89162cc3d40cb59c87aaaa49b85f3474'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_NameRegistry_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a27566fd89162cc3d40cb59c87aaaa49b85f3474'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_NameRegistry_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.309190Z", "completed_at": "2025-09-04T07:25:39.386355Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.419310Z", "completed_at": "2025-09-04T07:25:39.419317Z"}], "thread_id": "Thread-30", "execution_time": 0.3068716526031494, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_sdai_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'af204776c7245bf4147c2612bf6e5972ee483701'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_sdai_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'af204776c7245bf4147c2612bf6e5972ee483701'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_sdai_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.314325Z", "completed_at": "2025-09-04T07:25:39.387391Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.420167Z", "completed_at": "2025-09-04T07:25:39.420174Z"}], "thread_id": "Thread-22", "execution_time": 0.30712389945983887, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_wxdai_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_wxdai_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_wxdai_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.326601Z", "completed_at": "2025-09-04T07:25:39.387997Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.421017Z", "completed_at": "2025-09-04T07:25:39.421023Z"}], "thread_id": "Thread-23", "execution_time": 0.3067920207977295, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_entry_queue_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nqueue_activation AS (\n    SELECT\n        validator_index\n        ,date\n        ,epoch_eligibility\n        ,epoch_activation\n        ,(epoch_activation - epoch_eligibility) * 16 * 5 /(60 * 60 * 24) AS activation_days\n    FROM (\n        SELECT \n            validator_index\n            ,toStartOfDay(argMin(slot_timestamp,slot)) AS date\n            ,argMin(activation_eligibility_epoch,slot) AS epoch_eligibility\n            ,argMin(activation_epoch,slot) AS epoch_activation\n        FROM `dbt`.`stg_consensus__validators`\n        WHERE \n            activation_epoch < 18446744073709551615\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_entry_queue_daily`\n    )\n  \n\n        GROUP BY 1\n    )\n)\n\nSELECT\n    date\n    ,validator_count\n    ,q_activation[1] AS q05\n    ,q_activation[2] AS q10\n    ,q_activation[3] AS q25\n    ,q_activation[4] AS q50\n    ,q_activation[5] AS q75\n    ,q_activation[6] AS q90\n    ,q_activation[7] AS q95\n    ,mean\nFROM (\n    SELECT\n        date,\n        count() AS validator_count\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(activation_days) AS q_activation\n        ,avg(activation_days) AS  mean\n    FROM queue_activation\n    GROUP BY date\n)", "relation_name": "`dbt`.`int_consensus_entry_queue_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.319571Z", "completed_at": "2025-09-04T07:25:39.388616Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.421874Z", "completed_at": "2025-09-04T07:25:39.421882Z"}], "thread_id": "Thread-19", "execution_time": 0.30822300910949707, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_credentials_daily", "compiled": true, "compiled_code": "\n\n\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,leftUTF8(withdrawal_credentials, 4) AS credentials_type\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__validators`\n\n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_credentials_daily`\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_credentials_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.349025Z", "completed_at": "2025-09-04T07:25:39.389811Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.422723Z", "completed_at": "2025-09-04T07:25:39.422732Z"}], "thread_id": "Thread-25", "execution_time": 0.3048744201660156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_AgentResultMapping_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2025-06-30'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_AgentResultMapping_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_AgentResultMapping_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.343086Z", "completed_at": "2025-09-04T07:25:39.390618Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.423596Z", "completed_at": "2025-09-04T07:25:39.423604Z"}], "thread_id": "Thread-26", "execution_time": 0.3075602054595947, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_status_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,status\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__validators`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_status_daily`\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_validators_status_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.337709Z", "completed_at": "2025-09-04T07:25:39.391236Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.424448Z", "completed_at": "2025-09-04T07:25:39.424459Z"}], "thread_id": "Thread-24", "execution_time": 0.3090190887451172, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_balances_dist_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q_balance[1] AS q05,\n    q_balance[2] AS q10,\n    q_balance[3] AS q25,\n    q_balance[4] AS q50,\n    q_balance[5] AS q75,\n    q_balance[6] AS q90,\n    q_balance[7] AS q95\nFROM (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n       quantilesTDigest(-- quantilesExactExclusive(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(balance/POWER(10,9)) AS q_balance\n    FROM `dbt`.`stg_consensus__validators`\n    WHERE \n        status = 'active_ongoing'\n        AND\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_balances_dist_daily`\n    )\n  \n\n    GROUP BY date\n)", "relation_name": "`dbt`.`int_consensus_validators_balances_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.331749Z", "completed_at": "2025-09-04T07:25:39.391884Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.425300Z", "completed_at": "2025-09-04T07:25:39.425307Z"}], "thread_id": "Thread-20", "execution_time": 0.3106663227081299, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_balances_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,SUM(balance/POWER(10,9)) AS balance\n    ,SUM(effective_balance/POWER(10,9)) AS effective_balance\nFROM `dbt`.`stg_consensus__validators`\nWHERE \n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_balances_daily`\n    )\n  \n\nGROUP BY date", "relation_name": "`dbt`.`int_consensus_validators_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.355914Z", "completed_at": "2025-09-04T07:25:39.393319Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.426998Z", "completed_at": "2025-09-04T07:25:39.427005Z"}], "thread_id": "Thread-27", "execution_time": 0.3030247688293457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_ConditionalTokens_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-01'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_ConditionalTokens_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_ConditionalTokens_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.463623Z", "completed_at": "2025-09-04T07:25:39.510162Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.596487Z", "completed_at": "2025-09-04T07:25:39.596499Z"}], "thread_id": "Thread-32", "execution_time": 0.19074678421020508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_FPMMDeterministicFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-04'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_FPMMDeterministicFactory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_FPMMDeterministicFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.484778Z", "completed_at": "2025-09-04T07:25:39.528861Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.725472Z", "completed_at": "2025-09-04T07:25:39.725481Z"}], "thread_id": "Thread-34", "execution_time": 0.2975771427154541, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_GBCDeposit_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_GBCDeposit_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_GBCDeposit_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.490655Z", "completed_at": "2025-09-04T07:25:39.550732Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.728716Z", "completed_at": "2025-09-04T07:25:39.728727Z"}], "thread_id": "Thread-36", "execution_time": 0.2995741367340088, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_OmenAgentResultMapping_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-09-30'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_OmenAgentResultMapping_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_OmenAgentResultMapping_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.498449Z", "completed_at": "2025-09-04T07:25:39.571971Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.732283Z", "completed_at": "2025-09-04T07:25:39.732291Z"}], "thread_id": "Thread-38", "execution_time": 0.2996659278869629, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Realitio_v2_1_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2021-01-13'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Realitio_v2_1_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Realitio_v2_1_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.522764Z", "completed_at": "2025-09-04T07:25:39.724874Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.753779Z", "completed_at": "2025-09-04T07:25:39.753787Z"}], "thread_id": "Thread-31", "execution_time": 0.3000326156616211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_MarketFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-10-08'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Seer_MarketFactory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_MarketFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.534753Z", "completed_at": "2025-09-04T07:25:39.726943Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.757846Z", "completed_at": "2025-09-04T07:25:39.757854Z"}], "thread_id": "Thread-2", "execution_time": 0.30101490020751953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-09-22'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.540275Z", "completed_at": "2025-09-04T07:25:39.727533Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.758757Z", "completed_at": "2025-09-04T07:25:39.758767Z"}], "thread_id": "Thread-11", "execution_time": 0.3013114929199219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraPool_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-11-30'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraPool_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.529456Z", "completed_at": "2025-09-04T07:25:39.728123Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.759661Z", "completed_at": "2025-09-04T07:25:39.759669Z"}], "thread_id": "Thread-40", "execution_time": 0.30401062965393066, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_Wrapped1155Factory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-02-07'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Seer_Wrapped1155Factory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_Wrapped1155Factory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.551485Z", "completed_at": "2025-09-04T07:25:39.730099Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.761157Z", "completed_at": "2025-09-04T07:25:39.761165Z"}], "thread_id": "Thread-12", "execution_time": 0.30246925354003906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_apy_dist", "compiled": true, "compiled_code": "\n\nWITH\n\n/* 1) Daily per-validator balance snapshot (already 1 row/day) */\ndaily_validator_balances AS (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n        pubkey,\n        validator_index,\n        balance\n    FROM `dbt`.`stg_consensus__validators`\n    WHERE \n        balance > 0\n        AND\n        toStartOfDay(slot_timestamp) >= DATE '2023-01-01'\n        AND\n        toStartOfDay(slot_timestamp) < DATE '2023-02-01'\n),\n\n/* 2) True previous-day balance per validator using a window function */\nvalidator_with_prev AS (\n    SELECT\n        date,\n        pubkey,\n        validator_index,\n        balance,\n        -- default value = current balance on first day\n        lagInFrame(balance, 1, balance) OVER (\n            PARTITION BY pubkey, validator_index\n            ORDER BY date\n        ) AS prev_balance\n    FROM daily_validator_balances\n),\n\n/* 3) Get date range to filter other tables - materialize this first */\ndate_range AS (\n    SELECT \n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM validator_with_prev\n),\n\n/* 4) Per-day deposits - direct pubkey and amount columns */\ndeposits AS (\n    SELECT\n        toStartOfDay(d.slot_timestamp) AS dep_date,\n        d.pubkey AS dep_pubkey,\n        sum(d.amount) AS dep_amount\n    FROM `dbt`.`stg_consensus__deposits` d\n    CROSS JOIN date_range dr\n    WHERE toStartOfDay(d.slot_timestamp) >= dr.min_date \n      AND toStartOfDay(d.slot_timestamp) <= dr.max_date\n    GROUP BY toStartOfDay(d.slot_timestamp), d.pubkey\n),\n\n/* 5) Deposit requests - use JSON extraction with explicit date range */\ndeposit_requests AS (\n    SELECT\n        toStartOfDay(dr_table.slot_timestamp) AS dr_date,\n        toString(JSONExtractString(deposit, 'pubkey')) AS dr_pubkey,\n        sum(toUInt64(JSONExtractString(deposit, 'amount'))) AS dep_req_amount\n    FROM `dbt`.`stg_consensus__execution_requests` dr_table\n    ARRAY JOIN JSONExtractArrayRaw(dr_table.payload, 'deposits') AS deposit\n    CROSS JOIN date_range dr\n    WHERE toStartOfDay(dr_table.slot_timestamp) >= dr.min_date \n      AND toStartOfDay(dr_table.slot_timestamp) <= dr.max_date\n    GROUP BY toStartOfDay(dr_table.slot_timestamp), toString(JSONExtractString(deposit, 'pubkey'))\n),\n\n/* 6) Withdrawals - uses validator_index, not pubkey */\nwithdrawals AS (\n    SELECT\n        toStartOfDay(w.slot_timestamp) AS w_date,\n        w.validator_index AS w_validator_index,\n        sum(w.amount) AS wdr_amount\n    FROM `dbt`.`stg_consensus__withdrawals` w\n    CROSS JOIN date_range dr\n    WHERE toStartOfDay(w.slot_timestamp) >= dr.min_date \n      AND toStartOfDay(w.slot_timestamp) <= dr.max_date\n    GROUP BY toStartOfDay(w.slot_timestamp), w.validator_index\n),\n\n/* 7) Withdrawal requests - use JSON extraction with explicit date range */\nwithdrawal_requests AS (\n    SELECT\n        toStartOfDay(wr_table.slot_timestamp) AS wr_date,\n        toString(JSONExtractString(withdrawals, 'validator_pubkey')) AS wr_pubkey,\n        sum(toUInt64(JSONExtractString(withdrawals, 'amount'))) AS wdr_req_amount\n    FROM `dbt`.`stg_consensus__execution_requests` wr_table\n    ARRAY JOIN JSONExtractArrayRaw(wr_table.payload, 'withdrawals') AS withdrawals\n    CROSS JOIN date_range dr\n    WHERE toStartOfDay(wr_table.slot_timestamp) >= dr.min_date \n      AND toStartOfDay(wr_table.slot_timestamp) <= dr.max_date\n    GROUP BY toStartOfDay(wr_table.slot_timestamp), toString(JSONExtractString(withdrawals, 'validator_pubkey'))\n),\n\n/* 8) Per-validator daily net change excluding external flows */\nvalidator_rates AS (\n    SELECT\n        v.date,\n        v.pubkey,\n        v.validator_index,\n        v.prev_balance,\n        v.balance,\n        (v.balance - v.prev_balance) AS raw_diff,\n\n        coalesce(d.dep_amount, 0) AS deposits_amt,\n        coalesce(dr.dep_req_amount, 0) AS deposit_req_amt,\n        coalesce(w.wdr_amount, 0) AS withdrawals_amt,\n        coalesce(wr.wdr_req_amount, 0) AS withdrawal_req_amt,\n\n        /* Adjust for external flows (requests set to 0 unless you want them) */\n        (\n            (v.balance - v.prev_balance)\n            - coalesce(d.dep_amount, 0)   -- deposits increase balance -> subtract to isolate rewards\n            + coalesce(w.wdr_amount, 0)   -- withdrawals decrease balance -> add back\n            - coalesce(dr.dep_req_amount, 0)\n            + coalesce(wr.wdr_req_amount, 0)\n        ) AS adjusted_diff,\n\n        /* Daily rate per validator; guard against division by zero. */\n        CASE \n            WHEN v.prev_balance > 0 \n            THEN toFloat64(adjusted_diff) / toFloat64(v.prev_balance)\n            ELSE toFloat64(0)\n        END AS rate\n    FROM validator_with_prev v\n    LEFT JOIN deposits d ON d.dep_date = v.date AND d.dep_pubkey = v.pubkey\n    LEFT JOIN deposit_requests dr ON dr.dr_date = v.date AND dr.dr_pubkey = v.pubkey\n    LEFT JOIN withdrawals w ON w.w_date = v.date AND w.w_validator_index = v.validator_index\n    LEFT JOIN withdrawal_requests wr ON wr.wr_date = v.date AND wr.wr_pubkey = v.pubkey\n    WHERE v.prev_balance > 0  -- Only consider validators with positive previous balance\n        AND v.date > DATE '2023-01-01'\n)\n\n\nSELECT\n    date,\n    ROUND(q_apy[1],2) AS q05,\n    ROUND(q_apy[2],2) AS q10,\n    ROUND(q_apy[3],2) AS q25,\n    ROUND(q_apy[4],2) AS q50,\n    ROUND(q_apy[5],2) AS q75,\n    ROUND(q_apy[6],2) AS q90,\n    ROUND(q_apy[7],2) AS q95 \nFROM (\n    SELECT\n        toStartOfMonth(date) AS date\n        ,quantilesTDigest(-- quantilesExactExclusive(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )((power(1 + rate, 365) - 1) * 100) AS q_apy\n    FROM validator_rates\n    GROUP BY 1\n)", "relation_name": "`dbt`.`int_consensus_validators_apy_dist`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.545497Z", "completed_at": "2025-09-04T07:25:39.730715Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.762070Z", "completed_at": "2025-09-04T07:25:39.762077Z"}], "thread_id": "Thread-33", "execution_time": 0.3040168285369873, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_wxdai_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_wxdai_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_wxdai_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.558476Z", "completed_at": "2025-09-04T07:25:39.731456Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.762967Z", "completed_at": "2025-09-04T07:25:39.762977Z"}], "thread_id": "Thread-35", "execution_time": 0.3031032085418701, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_withdrawls_dist_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,total_amount\n    ,cnt\n    ,q_amount[1] AS min\n    ,q_amount[2] AS q05\n    ,q_amount[3] AS q10\n    ,q_amount[4] AS q25\n    ,q_amount[5] AS q50\n    ,q_amount[6] AS q75\n    ,q_amount[7] AS q90\n    ,q_amount[8] AS q95\n    ,q_amount[9] AS max\nFROM (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date\n        ,SUM(amount/POWER(10,9)) AS total_amount\n        ,COUNT(*) AS cnt\n        ,quantilesTDigest(\n            0.0, 0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95, 1\n        )(amount/POWER(10,9)) AS q_amount\n    FROM `dbt`.`stg_consensus__withdrawals`\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_withdrawls_dist_daily`\n    )\n  \n\n    GROUP BY 1\n)", "relation_name": "`dbt`.`int_consensus_withdrawls_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.568318Z", "completed_at": "2025-09-04T07:25:39.733205Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.764530Z", "completed_at": "2025-09-04T07:25:39.764538Z"}], "thread_id": "Thread-14", "execution_time": 0.3034482002258301, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_version_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,agent_version_semver_str AS version\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d` \nORDER BY date ASC, client ASC, version ASC", "relation_name": "`dbt`.`api_probelab_clients_version_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.564410Z", "completed_at": "2025-09-04T07:25:39.733894Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.765364Z", "completed_at": "2025-09-04T07:25:39.765386Z"}], "thread_id": "Thread-3", "execution_time": 0.30489253997802734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,any_value(toInt32(floor(__total))) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d` \nGROUP BY 1, 2\nORDER BY date ASC, client ASC", "relation_name": "`dbt`.`api_probelab_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.572731Z", "completed_at": "2025-09-04T07:25:39.734900Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.766248Z", "completed_at": "2025-09-04T07:25:39.766256Z"}], "thread_id": "Thread-4", "execution_time": 0.30454301834106445, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_carbon_intensity_ensemble", "compiled": true, "compiled_code": "\n\nWITH ember_monthly AS (\n    -- Monthly carbon intensity from Ember with enhanced uncertainty\n    SELECT\n        toDate(\"Date\") AS month_date,\n        CASE \n            WHEN \"Area\" = 'World' THEN 'WORLD'  -- World average as special country code\n            ELSE \"ISO 3 code\"\n        END AS country_code,\n        \"Value\" AS carbon_intensity_gco2_kwh,\n        COALESCE(\"Continent\", 'World') AS continent,\n        'ember' AS source,\n        0.85 AS base_confidence\n    FROM `dbt`.`stg_crawlers_data__ember_electricity_data`\n    WHERE   \n        \"Unit\" = 'gCO2/kWh'\n        AND (\n            (\"ISO 3 code\" IS NOT NULL AND \"ISO 3 code\" != '') OR \n            (\"Area\" = 'World')  -- Include World data\n        )\n        AND \"Value\" IS NOT NULL\n        AND \"Value\" > 0\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(\"Date\")) >= (\n      SELECT\n        max(toStartOfMonth(month_date))\n      FROM `dbt`.`int_esg_carbon_intensity_ensemble`\n    )\n  \n\n),\n\n-- Enhanced uncertainty modeling for monthly data\nuncertainty_enhanced AS (\n    SELECT\n        month_date,\n        country_code,\n        continent,\n        carbon_intensity_gco2_kwh AS base_ci,\n        \n        -- Calculate temporal uncertainty based on grid characteristics\n        -- Higher uncertainty for countries with more variable generation\n        carbon_intensity_gco2_kwh * (\n            CASE \n                -- High renewable countries have more temporal variation\n                WHEN carbon_intensity_gco2_kwh < 100 THEN 0.25  -- Low carbon grids (solar/wind heavy)\n                WHEN carbon_intensity_gco2_kwh < 300 THEN 0.20  -- Medium carbon grids  \n                WHEN carbon_intensity_gco2_kwh < 600 THEN 0.15  -- High carbon grids (more stable)\n                ELSE 0.12  -- Very high carbon grids (coal/gas baseload)\n            END\n        ) AS temporal_uncertainty,\n        \n        -- Data quality uncertainty (monthly averages hide daily/hourly variation)\n        carbon_intensity_gco2_kwh * 0.10 AS measurement_uncertainty,\n        \n        -- Continent-based seasonal adjustment factors\n        CASE continent\n            -- Europe & Asia (mostly Northern Hemisphere, heating-dominant)\n            WHEN 'Europe' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.18  -- Winter heating peak\n                    WHEN month(month_date) IN (6, 7, 8) THEN 0.92   -- Summer low + solar\n                    WHEN month(month_date) IN (3, 4, 11) THEN 1.08  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- Asia (mix of climates, but mostly Northern Hemisphere)\n            WHEN 'Asia' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.12  -- Winter (heating + industrial)\n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.08   -- Summer (cooling demand)\n                    WHEN month(month_date) IN (4, 5, 9, 10) THEN 1.05  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- North America (heating-dominant north, cooling-dominant south)\n            WHEN 'North America' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.15  -- Winter heating\n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.12   -- Summer cooling\n                    WHEN month(month_date) IN (4, 5, 9, 10) THEN 1.03  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- Oceania (Southern Hemisphere - reversed seasons)\n            WHEN 'Oceania' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.15   -- Southern winter\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.95  -- Southern summer\n                    WHEN month(month_date) IN (3, 4, 9, 10) THEN 1.05  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- South America (Southern Hemisphere + tropical)\n            WHEN 'South America' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.10   -- Southern winter (milder)\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.98  -- Southern summer\n                    ELSE 1.0\n                END\n                \n            -- Africa (mix of Northern/Southern + tropical, minimal variation)\n            WHEN 'Africa' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.05   -- Slight dry season effect\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.98  -- Wet season\n                    ELSE 1.0\n                END\n                \n            -- World/Default (minimal adjustment)\n            ELSE 1.0\n        END AS seasonal_factor,\n        \n        source,\n        base_confidence\n        \n    FROM ember_monthly\n),\n\n-- Final aggregation with confidence intervals\nfinal_estimates AS (\n    SELECT\n        month_date,\n        country_code,\n        \n        -- Point estimates with seasonal adjustment\n        round(base_ci * seasonal_factor, 2) AS carbon_intensity_mean,\n        \n        -- Combined uncertainty (temporal + measurement)\n        round(sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS carbon_intensity_std,\n        \n        -- Confidence intervals for Monte Carlo sampling\n        round(greatest(0, base_ci * seasonal_factor - 1.96 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2))), 2) AS ci_lower_95,\n        round(base_ci * seasonal_factor + 1.96 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS ci_upper_95,\n        \n        round(greatest(0, base_ci * seasonal_factor - 1.645 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2))), 2) AS ci_lower_90,\n        round(base_ci * seasonal_factor + 1.645 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS ci_upper_90,\n        \n        -- Coefficient of variation for uncertainty assessment\n        round(sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor), 3) AS coefficient_of_variation,\n        \n        -- Raw values for diagnostics\n        round(base_ci, 2) AS base_carbon_intensity,\n        round(temporal_uncertainty, 2) AS temporal_std,\n        round(measurement_uncertainty, 2) AS measurement_std,\n        round(seasonal_factor, 3) AS seasonal_adjustment,\n        continent,\n        \n        -- Data quality indicators\n        arrayPushFront([], source) AS sources_used,\n        base_confidence AS confidence_score,\n        1 AS n_sources,\n        \n        -- Uncertainty category for diagnostics\n        CASE \n            WHEN sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor) < 0.15 THEN 'Low'\n            WHEN sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor) < 0.25 THEN 'Medium' \n            ELSE 'High'\n        END AS uncertainty_category\n        \n    FROM uncertainty_enhanced\n)\n\nSELECT\n    month_date,\n    country_code,\n    \n    -- Core metrics for carbon footprint calculation\n    carbon_intensity_mean,\n    carbon_intensity_std,\n    ci_lower_95,\n    ci_upper_95,\n    ci_lower_90,\n    ci_upper_90,\n    \n    -- Uncertainty analysis\n    coefficient_of_variation,\n    uncertainty_category,\n    \n    -- Component breakdown for diagnostics\n    base_carbon_intensity,\n    temporal_std,\n    measurement_std,\n    seasonal_adjustment,\n    \n    -- Data provenance and quality\n    sources_used,\n    confidence_score,\n    n_sources,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM final_estimates", "relation_name": "`dbt`.`int_esg_carbon_intensity_ensemble`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.578657Z", "completed_at": "2025-09-04T07:25:39.735484Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.767125Z", "completed_at": "2025-09-04T07:25:39.767134Z"}], "thread_id": "Thread-37", "execution_time": 0.30481910705566406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_cloud_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,cloud_provider AS cloud\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d` \nORDER BY date ASC, client ASC, cloud ASC", "relation_name": "`dbt`.`api_probelab_clients_cloud_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.582440Z", "completed_at": "2025-09-04T07:25:39.736045Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.767992Z", "completed_at": "2025-09-04T07:25:39.768000Z"}], "thread_id": "Thread-5", "execution_time": 0.30507564544677734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_country_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,country\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_countries_avg_1d` \nORDER BY date ASC, client ASC, country ASC", "relation_name": "`dbt`.`api_probelab_clients_country_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.587347Z", "completed_at": "2025-09-04T07:25:39.737486Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.769494Z", "completed_at": "2025-09-04T07:25:39.769502Z"}], "thread_id": "Thread-39", "execution_time": 0.3003978729248047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_quic_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,quic_support AS quic\n    ,__count AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_quic_support_over_7d` \nORDER BY date ASC, client ASC, quic ASC", "relation_name": "`dbt`.`api_probelab_clients_quic_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.598069Z", "completed_at": "2025-09-04T07:25:39.738897Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.770327Z", "completed_at": "2025-09-04T07:25:39.770337Z"}], "thread_id": "Thread-6", "execution_time": 0.2999460697174072, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_blocks_clients_version_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nclients_version AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date\n        ,multiIf(\n             lower(decoded_extra_data[1]) = 'choose' \n            OR lower(decoded_extra_data[1]) = 'mysticryuujin'  \n            OR lower(decoded_extra_data[1]) = 'sanae.io'\n            OR decoded_extra_data[1] = ''  , \n            'Unknown',\n            decoded_extra_data[1]\n        )   AS client\n        ,IF(length(decoded_extra_data)>1, \n            IF(decoded_extra_data[2]='Ethereum',decoded_extra_data[3],decoded_extra_data[2]), \n            ''\n        ) AS version\n        ,COUNT(*) AS cnt\n    FROM `dbt`.`stg_execution__blocks`\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_blocks_clients_version_daily`\n    )\n  \n\n    GROUP BY 1, 2, 3\n)\n\nSELECT\n    *\nFROM clients_version", "relation_name": "`dbt`.`int_execution_blocks_clients_version_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.603514Z", "completed_at": "2025-09-04T07:25:39.739486Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.771193Z", "completed_at": "2025-09-04T07:25:39.771203Z"}], "thread_id": "Thread-13", "execution_time": 0.30011439323425293, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_state_size_full_diff_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\n\nstate_size_diff AS (\n    SELECT \n        toStartOfDay(block_timestamp) AS date \n        ,SUM(IF(to_value!='0000000000000000000000000000000000000000000000000000000000000000',32,-32)) AS bytes_diff\n    FROM \n        `dbt`.`stg_execution__storage_diffs`\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_state_size_full_diff_daily`\n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT\n    *\nFROM state_size_diff", "relation_name": "`dbt`.`int_execution_state_size_full_diff_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.608953Z", "completed_at": "2025-09-04T07:25:39.740294Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.772060Z", "completed_at": "2025-09-04T07:25:39.772070Z"}], "thread_id": "Thread-7", "execution_time": 0.3003721237182617, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_peers", "compiled": true, "compiled_code": "\n\nWITH\n\n  peers AS (\n    SELECT \n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors\n  FROM `dbt`.`stg_nebula_discv4__visits` A\n  WHERE\n      toString(peer_properties.network_id) = '100'\n      \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(visit_ended_at))\n      FROM `dbt`.`int_p2p_discv4_peers`\n    )\n  \n\n  ),\n\n  parsed AS (\n    SELECT\n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors,\n      -- break into slash-delimited parts\n      splitByChar('/', agent_version)                        AS slash_parts,\n      length(slash_parts)                                    AS sp_len,\n\n      -- if 4+ parts, take last two as platform+runtime; otherwise only platform\n      IF(\n        length(slash_parts) > 3,\n        arrayElement(slash_parts, sp_len-1),\n        arrayElement(slash_parts, sp_len)\n      )                                                       AS platform,\n\n      IF(\n        length(slash_parts) > 3,\n        arrayElement(slash_parts, sp_len),\n        ''\n      )                                                       AS runtime,\n\n      -- head_parts = everything before the last 1 or 2 elements\n      arraySlice(\n        slash_parts,\n        1,\n        sp_len - IF(sp_len > 3, 2, 1)\n      )                                                       AS head_parts\n\n    FROM peers\n  ),\n\n  exploded AS (\n    SELECT\n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors,\n      head_parts[1]                                          AS client,\n\n      -- if head_parts has 3 elements, the middle is variant\n      IF(\n        length(head_parts) = 3,\n        head_parts[2],\n        ''\n      )                                                       AS variant,\n\n      -- the last element of head_parts is our raw \u201cver_blob\u201d\n      arrayElement(head_parts, length(head_parts))            AS ver_blob,\n\n      platform,\n      runtime,\n\n      -- split out \u201c+\u201d-style metadata\n      IF(ver_blob LIKE '%+%', arrayElement(splitByChar('+', ver_blob), 1), ver_blob) AS pre_blob,\n      IF(ver_blob LIKE '%+%', arrayElement(splitByChar('+', ver_blob), 2), '')        AS plus_build\n\n    FROM parsed\n  ),\n\nbasic_info AS (\n  SELECT\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    --replaceRegexpAll(connect_maddr, '^/ip4/([0-9.]+)/tcp/[0-9]+$', '\\\\1') AS ip,\n    arrayElement(splitByChar('/', ifNull(connect_maddr, '')), 3) AS ip,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    IF(\n      plus_build != '',\n      arrayElement(splitByChar('-', pre_blob), 1),\n      splitByChar('-', ver_blob)[1]\n    )                                                       AS version,\n    IF(\n      plus_build != '',\n      IF(\n        length(splitByChar('-', pre_blob)) >= 2,\n        arrayElement(splitByChar('-', pre_blob), 2),\n        ''\n      ),\n      IF(\n        length(splitByChar('-', ver_blob)) = 3,\n        arrayElement(splitByChar('-', ver_blob), 2),\n        ''\n      )\n    )                                                       AS channel,\n    IF(\n      plus_build != '',\n      plus_build,\n      IF(\n        length(splitByChar('-', ver_blob)) > 1,\n        arrayElement(splitByChar('-', ver_blob), -1),\n        ''\n      )\n    )                                                       AS build,\n    platform,\n    runtime\n  FROM exploded\n)\n\nSELECT\n  t1.visit_ended_at,\n  t1.peer_id,\n  t1.agent_version,\n  t1.ip,\n  t1.peer_properties,\n  t1.crawl_error,\n  t1.dial_errors,\n  t1.client,\n  t1.variant,\n  t1.version,\n  t1.channel,\n  t1.build,\n  t1.platform,\n  t1.runtime,\n  t2.hostname   AS peer_hostname,\n  t2.city       AS peer_city,\n  t2.country    AS peer_country,\n  t2.org        AS peer_org,\n  t2.loc        AS peer_loc,\n  t2.generic_provider AS generic_provider\nFROM\n  basic_info t1\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS t2\n  ON t2.ip = t1.ip", "relation_name": "`dbt`.`int_p2p_discv4_peers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.616757Z", "completed_at": "2025-09-04T07:25:39.741124Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.772925Z", "completed_at": "2025-09-04T07:25:39.772932Z"}], "thread_id": "Thread-17", "execution_time": 0.3006305694580078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_visits_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nvisits_info AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,COUNT(visit_ended_at) AS total_visits\n        ,SUM(IF( empty(dial_errors) = 1 OR crawl_error IS NULL, 1, 0)) AS successful_visits\n        ,COUNT(DISTINCT crawl_id) AS crawls\n    FROM `dbt`.`stg_nebula_discv4__visits`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        toString(peer_properties.network_id) = '100'\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_p2p_discv4_visits_daily`\n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT * FROM visits_info", "relation_name": "`dbt`.`int_p2p_discv4_visits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.591324Z", "completed_at": "2025-09-04T07:25:39.741689Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.773774Z", "completed_at": "2025-09-04T07:25:39.773781Z"}], "thread_id": "Thread-15", "execution_time": 0.3040132522583008, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_info_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(block_timestamp) AS date\n    ,toString(transaction_type) AS transaction_type\n    ,success\n    ,COUNT(*) AS n_txs\n    ,SUM(value/POWER(10,18)) AS xdai_value -- xDai units\n    ,AVG(value/POWER(10,18)) AS xdai_value_avg -- xDai units\n    ,median(value/POWER(10,18)) AS xdai_value_median -- xDai units\n    ,SUM(COALESCE(gas_used/POWER(10,9),0)) AS gas_used -- Gas units in Gwei\n    ,CAST(AVG(COALESCE(gas_price/POWER(10,9),0)) AS Int32) AS gas_price_avg -- Gas units in Gwei\n    ,CAST(median(COALESCE(gas_price/POWER(10,9),0)) AS Int32) AS gas_price_median -- Gas units in Gwei\nFROM `dbt`.`stg_execution__transactions`\nWHERE\n    block_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_transactions_info_daily`\n    )\n  \n\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_execution_transactions_info_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.622259Z", "completed_at": "2025-09-04T07:25:39.742336Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.774635Z", "completed_at": "2025-09-04T07:25:39.774642Z"}], "thread_id": "Thread-16", "execution_time": 0.3017580509185791, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_peers", "compiled": true, "compiled_code": "\n\nWITH\n\n-- Known fork digests \u2192 names\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\n-- Known fork versions \u2192 names\nfork_version AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_version,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0x00000064','Phase0'),\n      ('0x01000064','Altair'),\n      ('0x02000064','Bellatrix'),\n      ('0x03000064','Capella'),\n      ('0x04000064','Deneb'),\n      ('0x05000064','Electra'),\n      ('0x06000064','Fulu')\n    ]) AS tup\n  )\n),\n\n/* Pull only relevant rows from source and normalize Dynamic\u2192String once */\npeers AS (\n  SELECT \n    t1.crawl_id,\n    t1.visit_ended_at,\n    t1.peer_id,\n    t1.connect_maddr,\n    -- Dynamic JSON leaves \u2192 String for safe joins/filters\n    toString(t1.peer_properties.fork_digest)         AS fork_digest,\n    toString(t1.peer_properties.next_fork_version)   AS next_fork_version,\n\n    -- Map to fork names\n    t2.cl_fork_name                                  AS cl_fork_name,\n    coalesce(t3.cl_fork_name, toString(t1.peer_properties.next_fork_version))\n                                                    AS cl_next_fork_name,\n\n    t1.agent_version,\n    t1.peer_properties,\n    t1.crawl_error,\n    t1.dial_errors\n  FROM `dbt`.`stg_nebula_discv5__visits` AS t1\n  LEFT JOIN fork_digests t2\n    ON toString(t1.peer_properties.fork_digest) = t2.fork_digest\n  LEFT JOIN fork_version t3\n    ON toString(t1.peer_properties.next_fork_version) = t3.fork_version\n  WHERE\n    (\n      toString(t1.peer_properties.fork_digest) IN (SELECT fork_digest FROM fork_digests)\n      OR toString(t1.peer_properties.next_fork_version) LIKE '%064'\n    )\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(visit_ended_at))\n      FROM `dbt`.`int_p2p_discv5_peers`\n    )\n  \n\n),\n\n/* Split and locate version token via regex */\nparsed AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    agent_version,\n\n    splitByChar('/', agent_version)                                         AS parts,\n    length(splitByChar('/', agent_version))                                 AS parts_len,\n    arraySlice(splitByChar('/', agent_version), 2)                         AS tail,\n    length(arraySlice(splitByChar('/', agent_version), 2))                 AS tail_len,\n\n    splitByChar('/', agent_version)[1]                                     AS client,\n\n    -- first tail index that looks like a version (v?digits(.digits){0,3}\u2026)\n    arrayFirstIndex(x ->\n        (substring(x, 1, 1) = 'v' OR match(x, '^[0-9]')) AND\n        match(x, '^v?[0-9]+(\\\\.[0-9]+){0,3}([\\\\-\\\\w\\\\.\\\\+]+)?$')\n      , arraySlice(splitByChar('/', agent_version), 2))                    AS ver_idx_tail\n  FROM peers\n),\n\n/* Derive variant, version blob, platform, runtime */\nwith_parts AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    agent_version,\n    parts,\n    parts_len,\n    tail,\n    tail_len,\n    client,\n    ver_idx_tail,\n\n    /* variant: exactly one token between client and version */\n    IF(ver_idx_tail > 1, tail[1], '')                                       AS variant,\n\n    /* raw version token (may include '-' channel and/or '+' build) */\n    IF(ver_idx_tail > 0, tail[ver_idx_tail], '')                            AS ver_blob,\n\n    /* tokens after version for platform/runtime */\n    IF(ver_idx_tail > 0 AND tail_len >= ver_idx_tail + 1, tail[ver_idx_tail + 1], '')\n      AS platform,\n    IF(ver_idx_tail > 0 AND tail_len >= ver_idx_tail + 2, tail[ver_idx_tail + 2], '')\n      AS runtime\n  FROM parsed\n),\n\n/* Split version blob and prep hyphen parts; also clean runtime */\nexploded AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    ver_blob,\n\n    -- strip leading '-' in runtime\n    replaceRegexpOne(runtime, '^-+', '')                                    AS runtime,\n    platform,\n\n    /* version blob split around '+' */\n    IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[1], ver_blob) AS pre_blob,\n    IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[2], '')       AS plus_build,\n\n    /* hyphen parts for channel/build logic (work off pre_blob) */\n    splitByChar('-', IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[1], ver_blob))\n                                                                            AS hy_parts\n  FROM with_parts\n),\n\nbasic_info AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    replaceRegexpAll(connect_maddr, '^/ip4/([0-9.]+)/tcp/[0-9]+$', '\\\\1') AS ip,\n    fork_digest,\n    cl_fork_name,\n    cl_next_fork_name,\n    next_fork_version,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    IF(length(hy_parts) >= 1, hy_parts[1], '')                                AS version,\n    IF(length(hy_parts) >= 3, hy_parts[2], '')                                 AS channel,\n    IF(\n      plus_build != '',\n      plus_build,\n      IF(length(hy_parts) >= 2, hy_parts[length(hy_parts)], '')\n    )                                                                          AS build,\n    platform,\n    runtime\n  FROM exploded\n)\n\nSELECT\n  t1.crawl_id,\n  t1.visit_ended_at,\n  t1.peer_id,\n  t1.agent_version,\n  t1.ip,\n  t1.fork_digest,\n  t1.cl_fork_name,\n  t1.cl_next_fork_name,\n  t1.next_fork_version,\n  t1.peer_properties,\n  t1.crawl_error,\n  t1.dial_errors,\n  t1.client,\n  t1.variant,\n  t1.version,\n  t1.channel,\n  t1.build,\n  CASE\n      WHEN t1.platform = '' THEN 'Unknown'\n      WHEN t1.platform = 'aarch64-linux' THEN 'linux-aarch_64'\n      WHEN t1.platform = 'x86_64-linux' THEN 'linux-x86_64'\n      WHEN t1.platform = 'x86_64-windows' THEN 'windows-x86_64'\n      ELSE t1.platform\n  END AS platform,\n  t1.runtime,\n  t2.hostname   AS peer_hostname,\n  t2.city       AS peer_city,\n  t2.country    AS peer_country,\n  t2.org        AS peer_org,\n  t2.loc        AS peer_loc,\n  t2.generic_provider AS generic_provider\nFROM\n  basic_info t1\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS t2\n  ON t2.ip = t1.ip", "relation_name": "`dbt`.`int_p2p_discv5_peers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.634850Z", "completed_at": "2025-09-04T07:25:39.743333Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.775487Z", "completed_at": "2025-09-04T07:25:39.775494Z"}], "thread_id": "Thread-1", "execution_time": 0.30141663551330566, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_attestations_daily", "compiled": true, "compiled_code": "\nSELECT\n    date\n    ,inclusion_delay\n    ,cnt\nFROM `dbt`.`int_consensus_attestations_daily`\nORDER BY date, inclusion_delay", "relation_name": "`dbt`.`api_consensus_attestations_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.629189Z", "completed_at": "2025-09-04T07:25:39.743918Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.776308Z", "completed_at": "2025-09-04T07:25:39.776315Z"}], "thread_id": "Thread-8", "execution_time": 0.3028428554534912, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_visits_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\nvisits_info AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,COUNT(visit_ended_at) AS total_visits\n        ,SUM(IF( empty(dial_errors) = 1 OR crawl_error IS NULL, 1, 0)) AS successful_visits\n        ,COUNT(DISTINCT crawl_id) AS crawls\n    FROM `dbt`.`stg_nebula_discv5__visits`\n    WHERE\n      toStartOfDay(visit_ended_at) < today()\n      AND\n      (\n        toString(peer_properties.fork_digest) IN (SELECT fork_digest FROM fork_digests)\n        OR toString(peer_properties.next_fork_version) LIKE '%064'\n      )\n      \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_p2p_discv5_visits_daily`\n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT * FROM visits_info", "relation_name": "`dbt`.`int_p2p_discv5_visits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.638662Z", "completed_at": "2025-09-04T07:25:39.744741Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.777157Z", "completed_at": "2025-09-04T07:25:39.777164Z"}], "thread_id": "Thread-9", "execution_time": 0.3024911880493164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_blob_commitments_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,cnt AS value\nFROM `dbt`.`int_consensus_blob_commitments_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_blob_commitments_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.647453Z", "completed_at": "2025-09-04T07:25:39.745749Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.778022Z", "completed_at": "2025-09-04T07:25:39.778028Z"}], "thread_id": "Thread-18", "execution_time": 0.30201292037963867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_graffiti_cloud", "compiled": true, "compiled_code": "\n\n\nWITH base AS (\n  SELECT\n      graffiti,\n      sumIf(cnt, date >= today() - 7)  AS v_7d,\n      sumIf(cnt, date >= today() - 30) AS v_30d,\n      sumIf(cnt, date >= today() - 90) AS v_90d,\n      sum(cnt)                         AS v_all\n  FROM `dbt`.`int_consensus_graffiti_daily`\n  WHERE graffiti != 'None'\n  GROUP BY graffiti\n)\nSELECT\n  label,\n  graffiti,\n  value\nFROM base\nARRAY JOIN\n  ['7D','30D','90D','All'] AS label,\n  [v_7d, v_30d, v_90d, v_all] AS value\nORDER BY label, value DESC\nLIMIT 50 BY label", "relation_name": "`dbt`.`fct_consensus_graffiti_cloud`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.642562Z", "completed_at": "2025-09-04T07:25:39.746306Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.778867Z", "completed_at": "2025-09-04T07:25:39.778876Z"}], "thread_id": "Thread-28", "execution_time": 0.3036010265350342, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_graffiti_label_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,SUM(cnt) AS value\nFROM `dbt`.`int_consensus_graffiti_daily`\nGROUP BY date, label\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_graffiti_label_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.651284Z", "completed_at": "2025-09-04T07:25:39.747153Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.779745Z", "completed_at": "2025-09-04T07:25:39.779752Z"}], "thread_id": "Thread-10", "execution_time": 0.30310773849487305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_blocks_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,label\n    ,value\nFROM (\n    SELECT date, 'produced' AS label, blocks_produced AS value FROM `dbt`.`int_consensus_blocks_daily`\n    UNION ALL \n    SELECT date, 'missed' AS label, blocks_missed AS value FROM `dbt`.`int_consensus_blocks_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_blocks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.655292Z", "completed_at": "2025-09-04T07:25:39.747978Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.780818Z", "completed_at": "2025-09-04T07:25:39.780829Z"}], "thread_id": "Thread-29", "execution_time": 0.3035905361175537, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_forks", "compiled": true, "compiled_code": "\n\nSELECT\n  fork_name\n  ,fork_version \n  ,fork_digest\n  ,fork_epoch \nFROM `dbt`.`fct_consensus_forks`\nORDER BY fork_version ASC", "relation_name": "`dbt`.`api_consensus_forks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.658998Z", "completed_at": "2025-09-04T07:25:39.748758Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.781688Z", "completed_at": "2025-09-04T07:25:39.781695Z"}], "thread_id": "Thread-21", "execution_time": 0.30373668670654297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_GBCDeposit_deposists_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(block_timestamp) AS date\n    ,decoded_params['withdrawal_credentials'] AS withdrawal_credentials\n    ,SUM(reinterpretAsUInt64(unhex(substring(decoded_params['amount'], 3)))) AS amount\nFROM `dbt`.`contracts_GBCDeposit_events`\nWHERE\n    event_name = 'DepositEvent'\n    \n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_GBCDeposit_deposists_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.679885Z", "completed_at": "2025-09-04T07:25:39.749828Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.782536Z", "completed_at": "2025-09-04T07:25:39.782543Z"}], "thread_id": "Thread-22", "execution_time": 0.3033764362335205, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_transitive_transfers", "compiled": true, "compiled_code": "\n\n\nSELECT\n  toStartOfDay(block_timestamp) AS date\n  ,decoded_params['from'] AS from_avatar\n  ,decoded_params['to']   AS  to_avatar\n  ,SUM(\n    toUInt256OrZero(\n      arrayJoin(\n        JSONExtract(\n          ifNull(decoded_params['amounts'], '[]'),   -- remove Nullable\n          'Array(String)'                            -- get Array(String)\n        )\n      )\n    )\n  ) AS total_amount\n  ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE\n  event_name = 'StreamCompleted'\n  \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_circles_transitive_transfers`\n    )\n  \n\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_execution_circles_transitive_transfers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.686954Z", "completed_at": "2025-09-04T07:25:39.750523Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.783385Z", "completed_at": "2025-09-04T07:25:39.783393Z"}], "thread_id": "Thread-23", "execution_time": 0.30359721183776855, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_v1_avatars", "compiled": true, "compiled_code": "\n\n\nSELECT\n    block_timestamp\n    ,decoded_params['avatar'] AS user_address\n    ,decoded_params['inviter'] AS inviter_address\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE \n    event_name = 'RegisterHuman'\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_circles_v1_avatars`\n    )\n  \n", "relation_name": "`dbt`.`int_execution_circles_v1_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.664155Z", "completed_at": "2025-09-04T07:25:39.751086Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.784219Z", "completed_at": "2025-09-04T07:25:39.784226Z"}], "thread_id": "Thread-30", "execution_time": 0.3056483268737793, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_rwa_backedfi_prices", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n\n\n        SELECT\n            'bC3M' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bC3M_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bCOIN' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bCOIN_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bCSPX' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bCSPX_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bHIGH' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bHIGH_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bIB01' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bIB01_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bIBTA' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bIBTA_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bMSTR' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bMSTR_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bNVDA' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bNVDA_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'TSLAx' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_TSLAx_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    ", "relation_name": "`dbt`.`int_execution_rwa_backedfi_prices`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.692670Z", "completed_at": "2025-09-04T07:25:39.751709Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.785085Z", "completed_at": "2025-09-04T07:25:39.785092Z"}], "thread_id": "Thread-19", "execution_time": 0.3046751022338867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_v2_avatars", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(block_timestamp) AS date\n    ,CASE  \n        WHEN event_name = 'RegisterHuman' THEN 'Human' \n        WHEN event_name = 'RegisterGroup' THEN 'Group' \n        WHEN event_name = 'RegisterOrganization' THEN 'Org'\n        ELSE 'Unknown' \n    END AS avatar_type\n    ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE \n    event_name IN ('RegisterHuman','RegisterGroup','RegisterOrganization')\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_circles_v2_avatars`\n    )\n  \n\nGROUP BY 1,2", "relation_name": "`dbt`.`int_execution_circles_v2_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.698494Z", "completed_at": "2025-09-04T07:25:39.752601Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.785944Z", "completed_at": "2025-09-04T07:25:39.785951Z"}], "thread_id": "Thread-25", "execution_time": 0.3049478530883789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_backing", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(block_timestamp) AS date\n    ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_CirclesBackingFactory_events`\nWHERE \n    event_name = 'CirclesBackingCompleted'\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_circles_backing`\n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_execution_circles_backing`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.711934Z", "completed_at": "2025-09-04T07:25:39.754792Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.787491Z", "completed_at": "2025-09-04T07:25:39.787499Z"}], "thread_id": "Thread-24", "execution_time": 0.30529284477233887, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_entry_queue_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,validator_count\n    ,q05\n    ,q10\n    ,q25\n    ,q50\n    ,q75\n    ,q90\n    ,q95\n    ,mean\nFROM `dbt`.`int_consensus_entry_queue_daily`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_entry_queue_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.716872Z", "completed_at": "2025-09-04T07:25:39.756066Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.788963Z", "completed_at": "2025-09-04T07:25:39.788972Z"}], "thread_id": "Thread-20", "execution_time": 0.306107759475708, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_credentials_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,credentials_type\n    ,cnt\n    ,ROUND(cnt/(SUM(cnt) OVER (PARTITION BY date)) * 100,2) AS pct \nFROM `dbt`.`int_consensus_credentials_daily`\nORDER BY date, credentials_type", "relation_name": "`dbt`.`api_consensus_credentials_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.704083Z", "completed_at": "2025-09-04T07:25:39.756618Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.789832Z", "completed_at": "2025-09-04T07:25:39.789842Z"}], "thread_id": "Thread-26", "execution_time": 0.3082146644592285, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_yields_sdai_rate_daily", "compiled": true, "compiled_code": "\n\n\nWITH \n\nsdai_rate_sparse_daily AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date\n        ,argMin(\n          toUInt256OrNull(decoded_params['assets']) / toUInt256OrNull(decoded_params['shares']),\n          block_timestamp\n        ) AS sdai_conversion\n    FROM \n        `dbt`.`contracts_sdai_events`\n    WHERE \n        event_name = 'Deposit'\n        AND toUInt256OrNull(decoded_params['shares']) != 0\n        AND block_timestamp < today()\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_yields_sdai_rate_daily`\n    )\n  \n\n    GROUP BY 1\n),\n\ncalendar AS (\n    SELECT\n        arrayJoin(\n            arrayMap(\n                x -> toStartOfDay(start_date + x),\n                range(toUInt32(end_date - start_date) + 1)\n            )\n        ) AS date\n    FROM (\n        SELECT \n          min(toDate(date)) AS start_date\n          ,max(toDate(date)) AS end_date\n        FROM sdai_rate_sparse_daily\n    )\n),\n\n\nlast_partition_value AS (\n    SELECT \n        sdai_conversion\n    FROM \n        `dbt`.`int_yields_sdai_rate_daily`\n    WHERE\n        toStartOfMonth(date) = (\n            SELECT addMonths(max(toStartOfMonth(date)), -1)\n            FROM `dbt`.`int_yields_sdai_rate_daily`\n        )\n    ORDER BY date DESC\n    LIMIT 1\n),\n\n\nsdai_daily_rate AS (\n  SELECT\n      date\n      ,sdai_conversion\n      ,floor(\n          sdai_conversion \n          - (\n            \n            COALESCE(\n                lagInFrame(sdai_conversion) OVER (\n                    ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n                ),\n                (SELECT sdai_conversion FROM last_partition_value)\n            )\n            \n            )\n      ,12) AS rate\n  FROM (\n    SELECT \n      t1.date\n      ,last_value(t2.sdai_conversion) ignore nulls OVER (ORDER BY t1.date) AS sdai_conversion\n    FROM calendar t1\n    LEFT JOIN\n      sdai_rate_sparse_daily t2\n      ON t2.date = t1.date\n  )\n)\n\n\nSELECT \n  date\n  ,sdai_conversion\n  ,rate\nFROM sdai_daily_rate\nWHERE rate IS NOT NULL", "relation_name": "`dbt`.`int_yields_sdai_rate_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.720730Z", "completed_at": "2025-09-04T07:25:39.757172Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.790718Z", "completed_at": "2025-09-04T07:25:39.790728Z"}], "thread_id": "Thread-27", "execution_time": 0.3066599369049072, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_credentials_latest", "compiled": true, "compiled_code": "\n\nSELECT \n    credentials_type\n    ,cnt\nFROM `dbt`.`int_consensus_credentials_daily`\nWHERE date = (SELECT MAX(date) FROM `dbt`.`int_consensus_credentials_daily`)", "relation_name": "`dbt`.`api_consensus_credentials_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.816275Z", "completed_at": "2025-09-04T07:25:39.848716Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.883087Z", "completed_at": "2025-09-04T07:25:39.883096Z"}], "thread_id": "Thread-32", "execution_time": 0.11434459686279297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_active_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,cnt\nFROM `dbt`.`int_consensus_validators_status_daily`\nWHERE status = 'active_ongoing'\nORDER BY date", "relation_name": "`dbt`.`api_consensus_validators_active_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.836437Z", "completed_at": "2025-09-04T07:25:39.864637Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.995213Z", "completed_at": "2025-09-04T07:25:39.995223Z"}], "thread_id": "Thread-36", "execution_time": 0.20338034629821777, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_status_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,status\n    ,cnt\nFROM `dbt`.`int_consensus_validators_status_daily`\nWHERE status NOT IN ('active_ongoing', 'withdrawal_done')\nORDER BY date, status", "relation_name": "`dbt`.`api_consensus_validators_status_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.832627Z", "completed_at": "2025-09-04T07:25:39.865188Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.996122Z", "completed_at": "2025-09-04T07:25:39.996133Z"}], "thread_id": "Thread-34", "execution_time": 0.20788884162902832, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_balances_dist_daily", "compiled": true, "compiled_code": "\n\n-- in GNO\nSELECT\n    date,\n    q05/32 AS q05,\n    q10/32 AS q10,\n    q25/32 AS q25,\n    q50/32 AS q50,\n    q75/32 AS q75,\n    q90/32 AS q90,\n    q95/32 AS q95\nFROM `dbt`.`int_consensus_validators_balances_dist_daily`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_validators_balances_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.841562Z", "completed_at": "2025-09-04T07:25:39.873509Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:39.997268Z", "completed_at": "2025-09-04T07:25:39.997278Z"}], "thread_id": "Thread-38", "execution_time": 0.20351910591125488, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_staked_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,effective_balance/32 AS value\nFROM `dbt`.`int_consensus_validators_balances_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_staked_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.858441Z", "completed_at": "2025-09-04T07:25:39.994512Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.015036Z", "completed_at": "2025-09-04T07:25:40.015047Z"}], "thread_id": "Thread-31", "execution_time": 0.20541644096374512, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_balances_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,value\nFROM (\n    SELECT\n        date\n        ,'balance' AS label\n        ,balance AS value\n    FROM `dbt`.`int_consensus_validators_balances_daily`\n\n    UNION ALL \n\n    SELECT\n        date\n        ,'eff. balance' AS label\n        ,effective_balance AS value\n    FROM `dbt`.`int_consensus_validators_balances_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_validators_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.869724Z", "completed_at": "2025-09-04T07:25:39.998207Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.016323Z", "completed_at": "2025-09-04T07:25:40.016331Z"}], "thread_id": "Thread-11", "execution_time": 0.2014017105102539, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_withdrawls_dist_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,q05\n    ,q10\n    ,q25\n    ,q50\n    ,q75\n    ,q90\n    ,q95\nFROM \n    `dbt`.`int_consensus_withdrawls_dist_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_withdrawls_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.865808Z", "completed_at": "2025-09-04T07:25:39.998783Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.017842Z", "completed_at": "2025-09-04T07:25:40.017850Z"}], "thread_id": "Thread-35", "execution_time": 0.20410394668579102, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_apy_dist", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q05,\n    q10,\n    q25,\n    q50,\n    q75,\n    q90,\n    q95 \nFROM `dbt`.`int_consensus_validators_apy_dist`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_validators_apy_dist`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.874226Z", "completed_at": "2025-09-04T07:25:39.999658Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.018727Z", "completed_at": "2025-09-04T07:25:40.018733Z"}], "thread_id": "Thread-40", "execution_time": 0.20316433906555176, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_deposits_withdrawls_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,'withdrawls' AS label\n    ,cnt\n    ,total_amount\nFROM \n    `dbt`.`int_consensus_withdrawls_dist_daily`\n\nUNION ALL\n\nSELECT\n    date\n    ,'deposits' AS label\n    ,cnt\n    ,total_amount\nFROM \n    `dbt`.`int_consensus_deposits_daily`", "relation_name": "`dbt`.`fct_consensus_deposits_withdrawls_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.878178Z", "completed_at": "2025-09-04T07:25:40.000587Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.019599Z", "completed_at": "2025-09-04T07:25:40.019606Z"}], "thread_id": "Thread-13", "execution_time": 0.19942688941955566, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_blocks_clients_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\nclients_blocks AS (\n    SELECT\n        date\n        ,client\n        ,SUM(cnt) AS cnt\n    FROM `dbt`.`int_execution_blocks_clients_version_daily`\n    WHERE date < today()\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,client\n    ,cnt\n    ,ROUND(cnt/(SUM(cnt) OVER (PARTITION BY date)),4) AS pct\nFROM \n    clients_blocks", "relation_name": "`dbt`.`fct_execution_blocks_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.893703Z", "completed_at": "2025-09-04T07:25:40.001709Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.020462Z", "completed_at": "2025-09-04T07:25:40.020469Z"}], "thread_id": "Thread-14", "execution_time": 0.19829010963439941, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\n-- 1) First CTE: basic peer info\ngnosis_peers AS (\n    SELECT \n        peer_id,\n        ip,\n        any(client) AS client\n    FROM `dbt`.`int_p2p_discv4_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) = today() - INTERVAL 1 DAY\n        AND empty(dial_errors) = 1\n        AND crawl_error IS NULL\n    GROUP BY\n        peer_id,\n        ip\n),\n\n-- 2) Second CTE: attach discovery_id_prefix to each peer\ngnosis_prefixes AS (\n    SELECT \n        d.discovery_id_prefix,\n        d.peer_id,\n        p.ip,\n        IF(p.client='', 'Unknown', p.client) AS client\n    FROM `dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids` AS d\n    INNER JOIN gnosis_peers AS p\n      ON p.peer_id = d.peer_id\n)\n\nSELECT\n    t1.date,\n\n    -- Peer columns from the subquery t1\n    t1.peer_ip,\n    t1.peer_discovery_id_prefix,\n    t1.peer_client,\n\n    -- Geographical info for peer (from crawlers_data.ipinfo)\n    peer_info.hostname   AS peer_hostname,\n    peer_info.city       AS peer_city,\n    peer_info.country    AS peer_country,\n    peer_info.org        AS peer_org,\n    peer_info.loc        AS peer_loc,\n\n    -- Neighbor columns from subquery t1\n    t1.neighbor_ip,\n    t1.neighbor_discovery_id_prefix,\n    t1.neighbor_client,\n\n    -- Geographical info for neighbor (from crawlers_data.ipinfo)\n    neighbor_info.city    AS neighbor_city,\n    neighbor_info.country AS neighbor_country,\n    neighbor_info.org     AS neighbor_org,\n    neighbor_info.loc     AS neighbor_loc,\n\n    -- Finally, the count of edges\n    t1.cnt\nFROM (\n    SELECT\n        toStartOfDay(n.crawl_created_at) AS date,\n\n        -- \u201cPeer\u201d side of the edge\n        peer_p.ip                      AS peer_ip,\n        peer_p.discovery_id_prefix     AS peer_discovery_id_prefix,\n        peer_p.client                  AS peer_client,\n\n        -- \u201cNeighbor\u201d side of the edge\n        neighbor_p.ip                      AS neighbor_ip,\n        neighbor_p.discovery_id_prefix     AS neighbor_discovery_id_prefix,\n        neighbor_p.client                  AS neighbor_client,\n\n        COUNT(*) AS cnt\n    FROM `dbt`.`stg_nebula_discv4__neighbors` AS n\n\n    -- join to get the discovery_prefix + client/fork info for \u201cpeer\u201d\n    INNER JOIN gnosis_prefixes AS peer_p\n      ON peer_p.discovery_id_prefix = n.peer_discovery_id_prefix\n\n    -- join to get the discovery_prefix + client/fork info for \u201cneighbor\u201d\n    INNER JOIN gnosis_prefixes AS neighbor_p\n      ON neighbor_p.discovery_id_prefix = n.neighbor_discovery_id_prefix\n\n    WHERE\n        toStartOfDay(n.crawl_created_at) = today() - INTERVAL 1 DAY\n\n    GROUP BY\n        date,\n        peer_p.ip,\n        peer_p.discovery_id_prefix,\n        peer_p.client,\n        neighbor_p.ip,\n        neighbor_p.discovery_id_prefix,\n        neighbor_p.client\n) AS t1\n\n-- LEFT JOIN to ipinfo for \u201cpeer\u201d\nLEFT JOIN  `dbt`.`stg_crawlers_data__ipinfo` AS peer_info\n  ON peer_info.ip = t1.peer_ip\n\n-- LEFT JOIN to ipinfo for \u201cneighbor\u201d\nLEFT JOIN  `dbt`.`stg_crawlers_data__ipinfo` AS neighbor_info\n  ON neighbor_info.ip = t1.neighbor_ip", "relation_name": "`dbt`.`int_p2p_discv4_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.887785Z", "completed_at": "2025-09-04T07:25:40.002524Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.021312Z", "completed_at": "2025-09-04T07:25:40.021320Z"}], "thread_id": "Thread-1", "execution_time": 0.19976472854614258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_clients_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,argMax(IF(client='','Unknown',client),visit_ended_at) AS client\n        ,argMax(platform,visit_ended_at) AS platform\n        ,argMax(generic_provider,visit_ended_at) AS generic_provider\n        ,argMax(peer_country,visit_ended_at) AS peer_country\n    FROM `dbt`.`int_p2p_discv4_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_p2p_discv4_clients_daily`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT date , 'Clients' AS metric, client AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Platform' AS metric, platform AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Provider' AS metric, generic_provider AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Country' AS metric, peer_country AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv4_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.883992Z", "completed_at": "2025-09-04T07:25:40.003183Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.022190Z", "completed_at": "2025-09-04T07:25:40.022197Z"}], "thread_id": "Thread-7", "execution_time": 0.2013683319091797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_state_full_size_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,SUM(bytes_diff) OVER (ORDER BY date ASC) AS bytes\nFROM `dbt`.`int_execution_state_size_full_diff_daily`\nWHERE date < today()", "relation_name": "`dbt`.`fct_execution_state_full_size_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.899098Z", "completed_at": "2025-09-04T07:25:40.003913Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.023065Z", "completed_at": "2025-09-04T07:25:40.023075Z"}], "thread_id": "Thread-8", "execution_time": 0.20026922225952148, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_cnt_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,n_txs AS value\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.906797Z", "completed_at": "2025-09-04T07:25:40.004725Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.023973Z", "completed_at": "2025-09-04T07:25:40.023980Z"}], "thread_id": "Thread-9", "execution_time": 0.19995427131652832, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_gas_used_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,gas_used\n    ,gas_price_avg\n    ,gas_price_median\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_gas_used_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.903029Z", "completed_at": "2025-09-04T07:25:40.005274Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.024848Z", "completed_at": "2025-09-04T07:25:40.024856Z"}], "thread_id": "Thread-3", "execution_time": 0.2014169692993164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_cnt_total", "compiled": true, "compiled_code": "\n\nSELECT\n    transaction_type\n    ,SUM(n_txs) AS value\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nGROUP BY transaction_type\nORDER BY transaction_type", "relation_name": "`dbt`.`api_execution_transactions_cnt_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.915696Z", "completed_at": "2025-09-04T07:25:40.006082Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.025712Z", "completed_at": "2025-09-04T07:25:40.025720Z"}], "thread_id": "Thread-18", "execution_time": 0.20047283172607422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_population_chao1", "compiled": true, "compiled_code": "\n\nWITH peer_connection_analysis AS (\n    SELECT\n        toDate(visit_ended_at) AS observation_date,\n        peer_id,\n        crawl_id,\n        \n        -- Categorize connection attempts\n        CASE \n            WHEN empty(dial_errors) = 1 AND crawl_error IS NULL THEN 'successful'\n            WHEN empty(dial_errors) = 0 OR crawl_error IS NOT NULL THEN 'failed'\n            ELSE 'unknown'\n        END AS connection_status,\n        \n        -- More granular failure analysis\n        CASE \n            WHEN empty(dial_errors) = 1 AND crawl_error IS NULL THEN 'successful'\n            WHEN crawl_error LIKE '%timeout%' THEN 'timeout'\n            WHEN crawl_error LIKE '%refused%' OR crawl_error LIKE '%connection refused%' THEN 'refused' \n            WHEN crawl_error LIKE '%unreachable%' THEN 'unreachable'\n            WHEN crawl_error LIKE '%protocol%' THEN 'protocol_mismatch'\n            WHEN NOT empty(dial_errors) THEN 'dial_error'\n            ELSE 'other_failure'\n        END AS failure_type\n        \n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(observation_date))\n      FROM `dbt`.`int_esg_node_population_chao1`\n    )\n  \n\n),\n\n-- Chao-1 for successful connections only\nsuccessful_chao1 AS (\n    SELECT\n        observation_date,\n        peer_id,\n        COUNT(DISTINCT crawl_id) AS times_observed\n    FROM peer_connection_analysis\n    WHERE connection_status = 'successful'\n    \n        AND observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nsuccessful_stats AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS s_obs_successful,\n        SUM(CASE WHEN times_observed = 1 THEN 1 ELSE 0 END) AS f1_successful,\n        SUM(CASE WHEN times_observed = 2 THEN 1 ELSE 0 END) AS f2_successful\n    FROM successful_chao1\n    GROUP BY observation_date\n),\n\n-- Chao-1 for ALL connection attempts (successful + failed)\nall_attempts_chao1 AS (\n    SELECT\n        observation_date,\n        peer_id,\n        COUNT(DISTINCT crawl_id) AS times_observed\n    FROM peer_connection_analysis\n    \n        WHERE observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nall_attempts_stats AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS s_obs_all,\n        SUM(CASE WHEN times_observed = 1 THEN 1 ELSE 0 END) AS f1_all,\n        SUM(CASE WHEN times_observed = 2 THEN 1 ELSE 0 END) AS f2_all\n    FROM all_attempts_chao1\n    GROUP BY observation_date\n),\n\n-- Additional peers known from failed connections\npeer_status_summary AS (\n    SELECT\n        observation_date,\n        peer_id,\n        MAX(CASE WHEN connection_status = 'successful' THEN 1 ELSE 0 END) AS had_success,\n        MAX(CASE WHEN connection_status = 'failed' THEN 1 ELSE 0 END) AS had_failure\n    FROM peer_connection_analysis\n    \n        WHERE observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nfailed_only_peers AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS peers_with_only_failures\n    FROM peer_status_summary\n    WHERE had_failure = 1 AND had_success = 0\n    GROUP BY observation_date\n),\n\n-- Connection success rates by failure type\nfailure_analysis AS (\n    SELECT\n        observation_date,\n        failure_type,\n        COUNT(DISTINCT peer_id) AS peer_count,\n        COUNT(*) AS attempt_count,\n        \n        -- Estimate reachability probability based on failure type\n        CASE failure_type\n            WHEN 'timeout' THEN 0.3      -- Sometimes reachable\n            WHEN 'refused' THEN 0.1      -- Rarely reachable (firewall/NAT)\n            WHEN 'unreachable' THEN 0.05 -- Very rarely reachable\n            WHEN 'protocol_mismatch' THEN 0.8  -- Likely reachable with right protocol\n            WHEN 'dial_error' THEN 0.2   -- Sometimes reachable\n            ELSE 0.1\n        END AS estimated_reachability_prob\n        \n    FROM peer_connection_analysis\n    WHERE connection_status = 'failed'\n    \n        AND observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, failure_type\n),\n\n-- Calculate enhanced estimates\nenhanced_calculations AS (\n    SELECT\n        COALESCE(s.observation_date, a.observation_date) AS observation_date,\n        \n        -- Successful connection metrics\n        COALESCE(s.s_obs_successful, 0) AS observed_successful_nodes,\n        CASE\n            WHEN COALESCE(s.f2_successful, 0) > 0 THEN \n                COALESCE(s.s_obs_successful, 0) + toFloat64(s.f1_successful * (s.f1_successful - 1)) / (2.0 * toFloat64(s.f2_successful + 1))\n            WHEN COALESCE(s.f1_successful, 0) > 0 THEN \n                COALESCE(s.s_obs_successful, 0) + toFloat64(s.f1_successful * (s.f1_successful - 1)) / 2.0\n            ELSE \n                toFloat64(COALESCE(s.s_obs_successful, 0))\n        END AS chao1_successful,\n        \n        -- All attempt metrics  \n        COALESCE(a.s_obs_all, 0) AS observed_total_peers,\n        CASE\n            WHEN COALESCE(a.f2_all, 0) > 0 THEN \n                COALESCE(a.s_obs_all, 0) + toFloat64(a.f1_all * (a.f1_all - 1)) / (2.0 * toFloat64(a.f2_all + 1))\n            WHEN COALESCE(a.f1_all, 0) > 0 THEN \n                COALESCE(a.s_obs_all, 0) + toFloat64(a.f1_all * (a.f1_all - 1)) / 2.0\n            ELSE \n                toFloat64(COALESCE(a.s_obs_all, 0))\n        END AS chao1_all_attempts,\n        \n        -- Failed connection insights\n        COALESCE(f.peers_with_only_failures, 0) AS failed_only_peers,\n        \n        COALESCE(s.f1_successful, 0) AS f1_successful,\n        COALESCE(s.f2_successful, 0) AS f2_successful,\n        COALESCE(a.f1_all, 0) AS f1_all,\n        COALESCE(a.f2_all, 0) AS f2_all\n        \n    FROM successful_stats s\n    FULL OUTER JOIN all_attempts_stats a ON s.observation_date = a.observation_date\n    LEFT JOIN failed_only_peers f ON COALESCE(s.observation_date, a.observation_date) = f.observation_date\n),\n\n-- Separate CTE for failure analysis aggregation\nfailure_reachability AS (\n    SELECT\n        observation_date,\n        SUM(toFloat64(peer_count) * estimated_reachability_prob) AS estimated_reachable_from_failures\n    FROM failure_analysis\n    GROUP BY observation_date\n),\n\n-- Combine all estimates\ncombined_estimates AS (\n    SELECT\n        e.*,\n        COALESCE(fr.estimated_reachable_from_failures, 0.0) AS estimated_reachable_from_failures\n    FROM enhanced_calculations e\n    LEFT JOIN failure_reachability fr ON e.observation_date = fr.observation_date\n),\n\nfinal_estimates AS (\n    SELECT\n        observation_date,\n        observed_successful_nodes,\n        observed_total_peers,\n        failed_only_peers,\n        \n        -- Different estimation approaches\n        toUInt64(round(chao1_successful, 0)) AS chao1_successful_only,\n        toUInt64(round(chao1_all_attempts, 0)) AS chao1_all_discovered,\n        toUInt64(round(estimated_reachable_from_failures, 0)) AS estimated_additional_reachable,\n        \n        -- Enhanced total estimate combining multiple signals\n        toUInt64(round(\n            chao1_successful +  -- Hidden successful nodes\n            estimated_reachable_from_failures  -- Additional reachable from failures\n        , 0)) AS enhanced_total_reachable,\n        \n        -- Network size estimate (includes unreachable nodes)\n        toUInt64(round(chao1_all_attempts, 0)) AS estimated_network_size,\n        \n        -- Success rates\n        CASE WHEN observed_total_peers > 0 THEN \n            round(100.0 * observed_successful_nodes / observed_total_peers, 2)\n        ELSE 0 END AS connection_success_rate_pct,\n        \n        -- Coverage estimates\n        CASE WHEN chao1_all_attempts > 0 THEN\n            round(100.0 * observed_total_peers / chao1_all_attempts, 2)\n        ELSE 100 END AS network_discovery_coverage_pct,\n        \n        CASE WHEN enhanced_total_reachable > 0 THEN\n            round(100.0 * observed_successful_nodes / enhanced_total_reachable, 2) \n        ELSE 100 END AS reachable_discovery_coverage_pct,\n        \n        -- Diagnostic info\n        f1_successful, f2_successful, f1_all, f2_all\n        \n    FROM combined_estimates\n)\n\nSELECT\n    observation_date,\n    \n    -- Core metrics\n    observed_successful_nodes,\n    observed_total_peers, \n    failed_only_peers,\n    \n    -- Population estimates\n    chao1_successful_only,\n    enhanced_total_reachable,\n    estimated_network_size,\n    estimated_additional_reachable,\n    \n    -- Success and coverage rates\n    connection_success_rate_pct,\n    network_discovery_coverage_pct,\n    reachable_discovery_coverage_pct,\n    \n    -- Hidden node estimates\n    chao1_successful_only - observed_successful_nodes AS hidden_successful_nodes,\n    enhanced_total_reachable - observed_successful_nodes AS hidden_reachable_nodes,\n    estimated_network_size - observed_total_peers AS hidden_total_nodes,\n    \n    -- Percentages\n    CASE WHEN chao1_successful_only > 0 THEN\n        round(100.0 * (chao1_successful_only - observed_successful_nodes) / chao1_successful_only, 2)\n    ELSE 0 END AS hidden_successful_pct,\n    \n    CASE WHEN estimated_network_size > 0 THEN\n        round(100.0 * (estimated_network_size - observed_total_peers) / estimated_network_size, 2) \n    ELSE 0 END AS hidden_total_pct,\n    \n    -- Diagnostic information\n    f1_successful AS successful_singletons,\n    f2_successful AS successful_doubletons,\n    f1_all AS all_singletons,\n    f2_all AS all_doubletons,\n    \n    now() AS calculated_at\n\nFROM final_estimates\nORDER BY observation_date DESC", "relation_name": "`dbt`.`int_esg_node_population_chao1`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.911946Z", "completed_at": "2025-09-04T07:25:40.006655Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.026577Z", "completed_at": "2025-09-04T07:25:40.026585Z"}], "thread_id": "Thread-4", "execution_time": 0.20192718505859375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_value_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,xdai_value \n    ,xdai_value_avg \n    ,xdai_value_median\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_value_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.926823Z", "completed_at": "2025-09-04T07:25:40.007909Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.027439Z", "completed_at": "2025-09-04T07:25:40.027450Z"}], "thread_id": "Thread-12", "execution_time": 0.20159387588500977, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_clients_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,argMax(IF(client='','Unknown',client),visit_ended_at) AS client\n        ,argMax(platform,visit_ended_at) AS platform\n        ,argMax(generic_provider,visit_ended_at) AS generic_provider\n        ,argMax(peer_country,visit_ended_at) AS peer_country\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_p2p_discv5_clients_daily`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT date , 'Clients' AS metric, client AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Platform' AS metric, platform AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Provider' AS metric, generic_provider AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Country' AS metric, peer_country AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv5_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.932357Z", "completed_at": "2025-09-04T07:25:40.008491Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.028284Z", "completed_at": "2025-09-04T07:25:40.028291Z"}], "thread_id": "Thread-37", "execution_time": 0.2018439769744873, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_forks_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,toString(any(cl_fork_name)) AS fork\n        ,toString(any(cl_next_fork_name)) AS next_fork\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_p2p_discv5_forks_daily`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,'Current Fork' AS label\n    ,fork AS fork\n    ,COUNT(*) AS cnt\nFROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL\n\nSELECT\n    date\n    ,'Next Fork' AS label\n    ,next_fork AS fork\n    ,COUNT(*) AS cnt\nFROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv5_forks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.944134Z", "completed_at": "2025-09-04T07:25:40.009250Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.029137Z", "completed_at": "2025-09-04T07:25:40.029147Z"}], "thread_id": "Thread-28", "execution_time": 0.20147061347961426, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\n-- 1) First CTE: basic peer info\ngnosis_peers AS (\n    SELECT \n        peer_id,\n        cl_fork_name,\n        cl_next_fork_name,\n        peer_properties.ip AS ip,\n        any(splitByChar('/', agent_version)[1]) AS client\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) = today() - INTERVAL 1 DAY\n        AND empty(dial_errors) = 1\n        AND crawl_error IS NULL\n    GROUP BY\n        peer_id,\n        cl_fork_name,\n        cl_next_fork_name,\n        ip\n),\n\n-- 2) Second CTE: attach discovery_id_prefix to each peer\ngnosis_prefixes AS (\n    SELECT \n        d.discovery_id_prefix,\n        d.peer_id,\n        p.ip,\n        p.cl_fork_name,\n        p.cl_next_fork_name,\n        IF(p.client='', 'Unknown', p.client) AS client\n    FROM `dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids` AS d\n    INNER JOIN gnosis_peers AS p\n      ON p.peer_id = d.peer_id\n)\n\nSELECT\n    t1.date,\n\n    -- Peer columns from the subquery t1\n    t1.peer_ip,\n    t1.peer_discovery_id_prefix,\n    t1.peer_cl_fork_name,\n    t1.peer_cl_next_fork_name,\n    t1.peer_client,\n\n    -- Geographical info for peer (from crawlers_data.ipinfo)\n    peer_info.hostname   AS peer_hostname,\n    peer_info.city       AS peer_city,\n    peer_info.country    AS peer_country,\n    peer_info.org        AS peer_org,\n    peer_info.loc        AS peer_loc,\n\n    -- Neighbor columns from subquery t1\n    t1.neighbor_ip,\n    t1.neighbor_discovery_id_prefix,\n    t1.neighbor_cl_fork_name,\n    t1.neighbor_cl_next_fork_name,\n    t1.neighbor_client,\n\n    -- Geographical info for neighbor (from crawlers_data.ipinfo)\n    neighbor_info.city    AS neighbor_city,\n    neighbor_info.country AS neighbor_country,\n    neighbor_info.org     AS neighbor_org,\n    neighbor_info.loc     AS neighbor_loc,\n\n    -- Finally, the count of edges\n    t1.cnt\nFROM (\n    SELECT\n        toStartOfDay(n.crawl_created_at) AS date,\n\n        -- \u201cPeer\u201d side of the edge\n        peer_p.ip                      AS peer_ip,\n        peer_p.discovery_id_prefix     AS peer_discovery_id_prefix,\n        peer_p.cl_fork_name            AS peer_cl_fork_name,\n        peer_p.cl_next_fork_name       AS peer_cl_next_fork_name,\n        peer_p.client                  AS peer_client,\n\n        -- \u201cNeighbor\u201d side of the edge\n        neighbor_p.ip                      AS neighbor_ip,\n        neighbor_p.discovery_id_prefix     AS neighbor_discovery_id_prefix,\n        neighbor_p.cl_fork_name            AS neighbor_cl_fork_name,\n        neighbor_p.cl_next_fork_name       AS neighbor_cl_next_fork_name,\n        neighbor_p.client                  AS neighbor_client,\n\n        COUNT(*) AS cnt\n    FROM `dbt`.`stg_nebula_discv5__neighbors` AS n\n\n    -- join to get the discovery_prefix + client/fork info for \u201cpeer\u201d\n    INNER JOIN gnosis_prefixes AS peer_p\n      ON peer_p.discovery_id_prefix = n.peer_discovery_id_prefix\n\n    -- join to get the discovery_prefix + client/fork info for \u201cneighbor\u201d\n    INNER JOIN gnosis_prefixes AS neighbor_p\n      ON neighbor_p.discovery_id_prefix = n.neighbor_discovery_id_prefix\n\n    WHERE\n        toStartOfDay(n.crawl_created_at) = today() - INTERVAL 1 DAY\n\n    GROUP BY\n        date,\n        peer_p.ip,\n        peer_p.discovery_id_prefix,\n        peer_p.cl_fork_name,\n        peer_p.cl_next_fork_name,\n        peer_p.client,\n        neighbor_p.ip,\n        neighbor_p.discovery_id_prefix,\n        neighbor_p.cl_fork_name,\n        neighbor_p.cl_next_fork_name,\n        neighbor_p.client\n) AS t1\n\n-- LEFT JOIN to ipinfo for \u201cpeer\u201d\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS peer_info\n  ON peer_info.ip = t1.peer_ip\n\n-- LEFT JOIN to ipinfo for \u201cneighbor\u201d\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS neighbor_info\n  ON neighbor_info.ip = t1.neighbor_ip", "relation_name": "`dbt`.`int_p2p_discv5_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.938017Z", "completed_at": "2025-09-04T07:25:40.009832Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.030001Z", "completed_at": "2025-09-04T07:25:40.030009Z"}], "thread_id": "Thread-5", "execution_time": 0.20295929908752441, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_geo_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers_ip AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,any(peer_properties.ip) AS ip\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_p2p_discv5_geo_daily`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT\n    t1.date\n    ,IF(t2.country='',NULL,splitByString(',',t2.loc)[1]) AS lat\n    ,IF(t2.country='',NULL,splitByString(',',t2.loc)[2]) AS long\n    ,IF(t2.country='','Unknown', t2.country) AS country\n    ,COUNT(*) AS cnt\nFROM peers_ip t1\nLEFT JOIN\n    `crawlers_data`.`ipinfo` t2\n    ON t1.ip = t2.ip\nGROUP BY 1, 2, 3, 4", "relation_name": "`dbt`.`int_p2p_discv5_geo_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.950866Z", "completed_at": "2025-09-04T07:25:40.010777Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.030848Z", "completed_at": "2025-09-04T07:25:40.030855Z"}], "thread_id": "Thread-39", "execution_time": 0.20260143280029297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_visits_latest", "compiled": true, "compiled_code": "\n\nWITH \n\ndiscv4_prev7D AS (\n    SELECT\n        date,\n        crawls\n    FROM `dbt`.`int_p2p_discv4_visits_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_visits_daily`), 7)\n),\n\ndiscv4 AS (\n    SELECT\n        date,\n        total_visits,\n        ROUND(COALESCE(successful_visits / NULLIF(total_visits, 0), 0) * 100, 1) AS pct_successful,\n        crawls\n    FROM `dbt`.`int_p2p_discv4_visits_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_visits_daily`)\n),\n\ndiscv5_prev7D AS (\n    SELECT\n        date,\n        crawls\n    FROM `dbt`.`int_p2p_discv5_visits_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_visits_daily`), 7)\n),\n\ndiscv5 AS (\n    SELECT\n        date,\n        total_visits,\n        ROUND(COALESCE(successful_visits / NULLIF(total_visits, 0), 0) * 100, 1) AS pct_successful,\n        crawls\n    FROM `dbt`.`int_p2p_discv5_visits_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_visits_daily`)\n)\n\nSELECT\n    t2.total_visits AS discv4_total_visits,\n    t2.pct_successful AS discv4_pct_successful,\n    t2.crawls AS discv4_crawls,\n    ROUND((COALESCE(t2.crawls / NULLIF(t1.crawls, 0), 0) - 1) * 100, 1) AS change_discv4_crawls_pct,\n    t4.total_visits AS discv5_total_visits,\n    t4.pct_successful AS discv5_pct_successful,\n    t4.crawls AS discv5_crawls,\n    ROUND((COALESCE(t4.crawls / NULLIF(t3.crawls, 0), 0) - 1) * 100, 1) AS change_discv5_crawls_pct\nFROM discv4_prev7D t1\nCROSS JOIN discv4 t2\nCROSS JOIN discv5_prev7D t3\nCROSS JOIN discv5 t4", "relation_name": "`dbt`.`api_p2p_visits_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.960325Z", "completed_at": "2025-09-04T07:25:40.011448Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.031705Z", "completed_at": "2025-09-04T07:25:40.031712Z"}], "thread_id": "Thread-33", "execution_time": 0.20221972465515137, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_apy_daily", "compiled": true, "compiled_code": "\n\nWITH\n\ndeposists AS (\n    SELECT \n        toStartOfDay(slot_timestamp) AS date\n        ,SUM(amount) AS amount\n    FROM `dbt`.`stg_consensus__deposits`\n    WHERE \n        slot_timestamp < toDate('2025-04-30')\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_apy_daily`\n    )\n  \n\n    GROUP BY 1\n\n    UNION ALL \n\n    SELECT \n        date\n        ,SUM(amount) AS amount\n    FROM `dbt`.`int_GBCDeposit_deposists_daily`\n    WHERE \n        date >= toDate('2025-04-30')\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_apy_daily`\n    )\n  \n\n    GROUP BY 1\n),\n\ndeposists_requests AS (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n        SUM(toUInt64(JSONExtractString(deposit, 'amount'))) AS amount\n    FROM `dbt`.`stg_consensus__execution_requests`\n    ARRAY JOIN JSONExtractArrayRaw(payload, 'deposits') AS deposit\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_apy_daily`\n    )\n  \n\n    GROUP BY 1\n),\n\n\nwithdrawals AS (\n    SELECT \n        toStartOfDay(slot_timestamp) AS date \n        ,SUM(amount) AS amount\n    FROM `dbt`.`stg_consensus__withdrawals`\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_apy_daily`\n    )\n  \n\n    GROUP BY 1\n),\n\nwithdrawals_requests AS (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n        SUM(toUInt64(JSONExtractString(withdrawals, 'amount'))) AS amount\n    FROM `dbt`.`stg_consensus__execution_requests`\n    ARRAY JOIN JSONExtractArrayRaw(payload, 'withdrawals') AS withdrawals\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_apy_daily`\n    )\n  \n\n    GROUP BY 1\n),\n\nvalidators AS (\n    SELECT\n        date,\n        balance,\n        lagInFrame(balance, 1, balance) OVER (\n            ORDER BY date\n            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n        ) AS prev_balance,\n        balance - prev_balance AS balance_diff\n    FROM (\n        SELECT\n            toStartOfDay(slot_timestamp) AS date,\n            SUM(balance) AS balance\n        FROM `dbt`.`stg_consensus__validators`\n        \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_apy_daily`\n    )\n  \n\n        GROUP BY 1\n    )\n)\n\nSELECT \n    t1.date AS date\n    ,t1.balance AS balance\n    ,t1.balance_diff AS balance_diff_original\n    ,COALESCE(t2.amount,0)  AS deposited_amount\n    ,COALESCE(t3.amount,0)  AS withdrawaled_amount\n    ,COALESCE(t4.amount,0)  AS deposited_amount_request\n    ,COALESCE(t5.amount,0)  AS withdrawaled_amount_request\n    ,t1.balance_diff - COALESCE(t2.amount,0) - COALESCE(t4.amount,0) + COALESCE(t3.amount,0) + COALESCE(t5.amount,0) AS eff_balance_diff\n    ,eff_balance_diff/t1.prev_balance AS rate\n    ,ROUND((POWER((1+rate),365) - 1) * 100,2) AS apy\nFROM validators t1\nLEFT JOIN \n    deposists t2\n    ON t2.date = t1.date\nLEFT JOIN \n    withdrawals t3\n    ON t3.date = t1.date\nLEFT JOIN \n    deposists_requests t4\n    ON t4.date = t1.date\nLEFT JOIN \n    withdrawals_requests t5\n    ON t5.date = t1.date", "relation_name": "`dbt`.`int_consensus_validators_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.956582Z", "completed_at": "2025-09-04T07:25:40.011985Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.032553Z", "completed_at": "2025-09-04T07:25:40.032560Z"}], "thread_id": "Thread-10", "execution_time": 0.20369768142700195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_graffiti_cloud", "compiled": true, "compiled_code": "\n\n\nSELECT\n    label\n    ,graffiti\n    ,value\nFROM `dbt`.`fct_consensus_graffiti_cloud`\nORDER BY label DESC, value DESC", "relation_name": "`dbt`.`api_consensus_graffiti_cloud`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.970569Z", "completed_at": "2025-09-04T07:25:40.013027Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.033390Z", "completed_at": "2025-09-04T07:25:40.033397Z"}], "thread_id": "Thread-17", "execution_time": 0.2033231258392334, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_rwa_backedfi_prices_daily", "compiled": true, "compiled_code": "\n\n\n\n   -- safely before any token was listed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bC3M'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bC3M'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bCOIN'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bCOIN'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bCSPX'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bCSPX'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bHIGH'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bHIGH'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bIB01'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bIB01'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bIBTA'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bIBTA'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bMSTR'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bMSTR'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bNVDA'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bNVDA'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'TSLAx'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'TSLAx'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nORDER BY bticker, date", "relation_name": "`dbt`.`fct_execution_rwa_backedfi_prices_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.980556Z", "completed_at": "2025-09-04T07:25:40.013727Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.034221Z", "completed_at": "2025-09-04T07:25:40.034227Z"}], "thread_id": "Thread-16", "execution_time": 0.20294880867004395, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_circles_avatars", "compiled": true, "compiled_code": "\n\nWITH dates AS (\n    -- get min/max date \n    SELECT\n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM `dbt`.`int_execution_circles_v2_avatars`\n),\ndate_series AS (\n    -- generate dense series of dates\n    SELECT\n        toDate(min_date) + number AS date\n    FROM dates\n    ARRAY JOIN range(dateDiff('day', min_date, max_date) + 1) AS number\n),\navatar_types AS (\n    SELECT DISTINCT avatar_type\n    FROM `dbt`.`int_execution_circles_v2_avatars`\n),\ndense_grid AS (\n    SELECT\n        d.date,\n        a.avatar_type\n    FROM date_series d\n    CROSS JOIN avatar_types a\n),\nfilled AS (\n    SELECT\n        g.date,\n        g.avatar_type,\n        coalesce(t.cnt, 0) AS cnt\n    FROM dense_grid g\n    LEFT JOIN `dbt`.`int_execution_circles_v2_avatars` t\n        ON g.date = t.date\n       AND g.avatar_type = t.avatar_type\n)\n\nSELECT\n    date,\n    avatar_type,\n    cnt,\n    SUM(cnt) OVER (PARTITION BY avatar_type ORDER BY date) AS total\nFROM filled", "relation_name": "`dbt`.`fct_execution_circles_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.985747Z", "completed_at": "2025-09-04T07:25:40.014399Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.035081Z", "completed_at": "2025-09-04T07:25:40.035088Z"}], "thread_id": "Thread-6", "execution_time": 0.203216552734375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_circles_backing", "compiled": true, "compiled_code": "\n\nWITH dates AS (\n    -- get min/max date \n    SELECT\n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM `dbt`.`int_execution_circles_backing`\n),\ndate_series AS (\n    -- generate dense series of dates\n    SELECT\n        toDate(min_date) + number AS date\n    FROM dates\n    ARRAY JOIN range(dateDiff('day', min_date, max_date) + 1) AS number\n),\n\nfilled AS (\n    SELECT\n        g.date,\n        coalesce(t.cnt, 0) AS cnt\n    FROM date_series g\n    LEFT JOIN `dbt`.`int_execution_circles_backing` t\n        ON g.date = t.date\n)\n\nSELECT\n    date,\n    cnt,\n    SUM(cnt) OVER (ORDER BY date) AS total\nFROM filled\nWHERE date < today()", "relation_name": "`dbt`.`fct_execution_circles_backing`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:39.990642Z", "completed_at": "2025-09-04T07:25:40.017254Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.036178Z", "completed_at": "2025-09-04T07:25:40.036188Z"}], "thread_id": "Thread-21", "execution_time": 0.19604182243347168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_yields_sdai_apy_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nsdai_apy_daily AS (\n    SELECT\n        date,\n        floor(POWER((1+rate),365) - 1,4) * 100 AS apy,\n        floor(\n            avg(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 6  PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_7DMA,\n        floor(\n            avg(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_30DMA,\n         floor(\n            median(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 6  PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_7DMM,\n        floor(\n            median(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_30DMM\n    FROM `dbt`.`int_yields_sdai_rate_daily`\n)\n\nSELECT date, apy, 'Daily' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_7DMA, '7DMA' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_30DMA, '30DMA' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_7DMM, '7DMM' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_30DMM, '30DMM' AS label FROM sdai_apy_daily", "relation_name": "`dbt`.`fct_yields_sdai_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.078635Z", "completed_at": "2025-09-04T07:25:40.167001Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.268266Z", "completed_at": "2025-09-04T07:25:40.268280Z"}], "thread_id": "Thread-2", "execution_time": 0.21738910675048828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_deposits_withdrawls_cnt_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,cnt AS value\nFROM \n    `dbt`.`fct_consensus_deposits_withdrawls_daily`\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_deposits_withdrawls_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.084779Z", "completed_at": "2025-09-04T07:25:40.254875Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.271393Z", "completed_at": "2025-09-04T07:25:40.271401Z"}], "thread_id": "Thread-23", "execution_time": 0.2180485725402832, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_deposits_withdrawls_volume_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,total_amount AS value\nFROM \n    `dbt`.`fct_consensus_deposits_withdrawls_daily`\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_deposits_withdrawls_volume_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.098987Z", "completed_at": "2025-09-04T07:25:40.256343Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.272480Z", "completed_at": "2025-09-04T07:25:40.272487Z"}], "thread_id": "Thread-8", "execution_time": 0.216094970703125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_state_full_size_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,bytes/POWER(10,9) AS value\nFROM `dbt`.`fct_execution_state_full_size_daily`", "relation_name": "`dbt`.`api_execution_state_full_size_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.093672Z", "completed_at": "2025-09-04T07:25:40.257251Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.274564Z", "completed_at": "2025-09-04T07:25:40.274572Z"}], "thread_id": "Thread-30", "execution_time": 0.2187976837158203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_clients_pct_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,client\n    ,pct AS value\nFROM `dbt`.`fct_execution_blocks_clients_daily`\nORDER BY date, client", "relation_name": "`dbt`.`api_execution_blocks_clients_pct_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.102911Z", "completed_at": "2025-09-04T07:25:40.257814Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.275426Z", "completed_at": "2025-09-04T07:25:40.275433Z"}], "thread_id": "Thread-19", "execution_time": 0.2184453010559082, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv4_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv4_clients_daily`\nWHERE date < today()\nORDER BY date, metric, label", "relation_name": "`dbt`.`api_p2p_discv4_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.089883Z", "completed_at": "2025-09-04T07:25:40.258388Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.276269Z", "completed_at": "2025-09-04T07:25:40.276276Z"}], "thread_id": "Thread-1", "execution_time": 0.22113418579101562, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_clients_cnt_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,client\n    ,cnt AS value\nFROM `dbt`.`fct_execution_blocks_clients_daily`\nORDER BY date, client", "relation_name": "`dbt`.`api_execution_blocks_clients_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.106895Z", "completed_at": "2025-09-04T07:25:40.259102Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.277133Z", "completed_at": "2025-09-04T07:25:40.277143Z"}], "thread_id": "Thread-25", "execution_time": 0.21953344345092773, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv4_clients_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv4_clients_daily`\nWHERE date = (SELECT MAX(date) FROM  `dbt`.`int_p2p_discv4_clients_daily` )\nORDER BY metric, label", "relation_name": "`dbt`.`api_p2p_discv4_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.125127Z", "completed_at": "2025-09-04T07:25:40.260137Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.278014Z", "completed_at": "2025-09-04T07:25:40.278021Z"}], "thread_id": "Thread-26", "execution_time": 0.2185654640197754, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv5_clients_daily`\nWHERE date < today()\nORDER BY date, metric, label", "relation_name": "`dbt`.`api_p2p_discv5_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.118924Z", "completed_at": "2025-09-04T07:25:40.260696Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.278884Z", "completed_at": "2025-09-04T07:25:40.278890Z"}], "thread_id": "Thread-37", "execution_time": 0.22005224227905273, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_clients_latest", "compiled": true, "compiled_code": "\n\nWITH \n\ndiscv4_prev7D AS (\n    SELECT\n        date,\n        SUM(value) AS discv4_count\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`), 7)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv4 AS (\n    SELECT\n        date,\n        SUM(value) AS discv4_count\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv5_prev7D AS (\n    SELECT\n        date,\n        SUM(value) AS discv5_count\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_clients_daily`), 7)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv5 AS (\n    SELECT\n        date,\n        SUM(value) AS discv5_count\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_clients_daily`)\n        AND metric = 'Clients'\n    GROUP BY date\n)\n\nSELECT\n    t2.discv4_count AS discv4_count,\n    ROUND((COALESCE(t2.discv4_count / NULLIF(t1.discv4_count, 0), 0) - 1) * 100, 1) AS change_discv4_pct,\n    t4.discv5_count AS discv5_count,\n    ROUND((COALESCE(t4.discv5_count / NULLIF(t3.discv5_count, 0), 0) - 1) * 100, 1) AS change_discv5_pct\nFROM discv4_prev7D t1\nCROSS JOIN discv4 t2\nCROSS JOIN discv5_prev7D t3\nCROSS JOIN discv5 t4", "relation_name": "`dbt`.`api_p2p_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.111150Z", "completed_at": "2025-09-04T07:25:40.261241Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.279734Z", "completed_at": "2025-09-04T07:25:40.279740Z"}], "thread_id": "Thread-29", "execution_time": 0.22153782844543457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_classification", "compiled": true, "compiled_code": "\n\n\nWITH latest_observations AS (\n    SELECT \n        toDate(visit_ended_at) as observation_date,\n        peer_id,\n        argMax(ip, visit_ended_at) AS ip_address,\n        argMax(client, visit_ended_at) AS client_type,\n        argMax(peer_country, visit_ended_at) AS country_code,\n        argMax(generic_provider, visit_ended_at) AS generic_provider,\n        argMax(peer_org, visit_ended_at) AS peer_org,\n        MAX(visit_ended_at) AS last_seen_that_day\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE \n        empty(dial_errors) = 1 \n        AND crawl_error IS NULL\n        AND toStartOfDay(visit_ended_at) < today()\n        \n            AND toDate(visit_ended_at) > (SELECT MAX(date) FROM `dbt`.`int_esg_node_classification`)\n        \n    GROUP BY observation_date, peer_id\n),\n\nnode_categories AS (\n    SELECT\n        observation_date,\n        peer_id,\n        ip_address,\n        client_type,\n        country_code,\n        generic_provider,\n        peer_org,\n        \n        -- Classify nodes into operational archetypes based on generic_provider\n        CASE\n            WHEN generic_provider IN ('AWS', 'Google', 'Azure', 'Oracle Cloud', 'Alibaba Cloud') \n                THEN 'cloud_hosted'\n            WHEN generic_provider IN ('DigitalOcean', 'OVHcloud', 'Hetzner', 'Scaleway', 'Linode', 'Vultr', \n                                    'Equinix Metal', 'Hosting/CDN (Other)') \n                THEN 'cloud_hosted'\n            WHEN generic_provider = 'Carrier/Transit' \n                THEN 'professional_operator'\n            WHEN lower(peer_org) LIKE '%datacenter%' \n                OR lower(peer_org) LIKE '%data center%'\n                OR lower(peer_org) LIKE '%hosting%'\n                OR lower(peer_org) LIKE '%server%'\n                THEN 'professional_operator'\n            WHEN generic_provider = 'Public ISP (Home/Office)' \n                THEN 'home_staker'\n            WHEN lower(peer_org) LIKE '%telecom%'\n                OR lower(peer_org) LIKE '%broadband%'\n                OR lower(peer_org) LIKE '%cable%'\n                OR lower(peer_org) LIKE '%fiber%'\n                OR lower(peer_org) LIKE '%residential%'\n                THEN 'home_staker'\n            ELSE 'unknown'\n        END AS node_category,\n        \n        CASE\n            WHEN generic_provider IN ('AWS', 'Google', 'Azure', 'Oracle Cloud', 'Alibaba Cloud') THEN 0.95\n            WHEN generic_provider IN ('DigitalOcean', 'OVHcloud', 'Hetzner', 'Scaleway', 'Linode', 'Vultr') THEN 0.90\n            WHEN generic_provider = 'Public ISP (Home/Office)' THEN 0.80\n            WHEN generic_provider = 'Hosting/CDN (Other)' THEN 0.75\n            WHEN generic_provider = 'Carrier/Transit' THEN 0.70\n            WHEN generic_provider = 'Unknown' THEN 0.30\n            ELSE 0.50\n        END AS classification_confidence\n        \n    FROM latest_observations\n),\n\ndaily_distribution AS (\n    SELECT\n        observation_date AS date,\n        node_category,\n        COUNT(DISTINCT peer_id) AS observed_nodes,\n        AVG(classification_confidence) AS avg_confidence\n    FROM node_categories\n    GROUP BY observation_date, node_category\n),\n\nchao1_data AS (\n    SELECT\n        p.observation_date,\n        p.observed_successful_nodes,\n        p.enhanced_total_reachable,\n        p.connection_success_rate_pct\n    FROM `dbt`.`int_esg_node_population_chao1` p\n    WHERE 1=1\n        \n            AND p.observation_date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_classification`)\n        \n),\n\nscaled_distribution AS (\n    SELECT\n        d.date,\n        d.node_category,\n        d.observed_nodes,\n        d.avg_confidence,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(greatest(toFloat64(d.observed_nodes), \n                    toFloat64(d.observed_nodes) * c.enhanced_total_reachable / c.observed_successful_nodes))\n            ELSE d.observed_nodes\n        END AS estimated_total_nodes,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(greatest(toFloat64(d.observed_nodes), \n                    toFloat64(d.observed_nodes) * c.enhanced_total_reachable * 0.85 / c.observed_successful_nodes))\n            ELSE toUInt64(d.observed_nodes * 0.85)\n        END AS nodes_lower_95,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(toFloat64(d.observed_nodes) * c.enhanced_total_reachable * 1.15 / c.observed_successful_nodes)\n            ELSE toUInt64(d.observed_nodes * 1.15)\n        END AS nodes_upper_95,\n        \n        COALESCE(c.connection_success_rate_pct / 100.0, 0.75) AS sample_coverage,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                round(toFloat64(c.enhanced_total_reachable) / c.observed_successful_nodes, 3)\n            ELSE 1.0\n        END AS scaling_factor\n        \n    FROM daily_distribution d\n    LEFT JOIN chao1_data c ON d.date = c.observation_date\n),\n\ngeographic_distribution AS (\n    SELECT\n        observation_date AS date,\n        node_category,\n        country_code,\n        COUNT(DISTINCT peer_id) AS country_observed_nodes\n    FROM node_categories\n    WHERE country_code IS NOT NULL AND country_code != '' AND country_code != 'Unknown'\n    GROUP BY observation_date, node_category, country_code\n),\n\ngeographic_scaled AS (\n    SELECT\n        g.date,\n        g.node_category,\n        g.country_code,\n        g.country_observed_nodes,\n        \n        CASE \n            WHEN s.scaling_factor > 0 THEN\n                toUInt64(toFloat64(g.country_observed_nodes) * s.scaling_factor)\n            ELSE g.country_observed_nodes\n        END AS country_estimated_nodes\n        \n    FROM geographic_distribution g\n    JOIN scaled_distribution s\n        ON g.date = s.date AND g.node_category = s.node_category\n)\n\nSELECT\n    s.date,\n    s.node_category,\n    s.observed_nodes,\n    s.estimated_total_nodes,\n    s.nodes_lower_95,\n    s.nodes_upper_95,\n    s.avg_confidence,\n    s.sample_coverage,\n    s.scaling_factor,\n    \n    round(100.0 * s.estimated_total_nodes / \n          SUM(s.estimated_total_nodes) OVER (PARTITION BY s.date), 2) AS category_percentage,\n    \n    s.estimated_total_nodes - s.observed_nodes AS hidden_nodes_estimated,\n    round(100.0 * (s.estimated_total_nodes - s.observed_nodes) / s.estimated_total_nodes, 2) AS hidden_nodes_percentage,\n    \n    CASE \n        WHEN COUNT(g.country_code) > 0 THEN\n            toJSONString(groupArray((g.country_code, g.country_estimated_nodes)))\n        ELSE '[]'\n    END AS geographic_distribution,\n    \n    CASE \n        WHEN COUNT(g.country_code) > 0 THEN\n            arrayStringConcat(\n                arraySlice(\n                    arrayMap(x -> tupleElement(x, 1),\n                        arraySort(x -> -tupleElement(x, 2),\n                            groupArray((g.country_code, g.country_estimated_nodes))\n                        )\n                    ), 1, 5\n                ), ', '\n            )\n        ELSE 'No geographic data'\n    END AS top_countries,\n    \n    now() AS calculated_at\n    \nFROM scaled_distribution s\nLEFT JOIN geographic_scaled g\n    ON s.date = g.date AND s.node_category = g.node_category\n\nGROUP BY \n    s.date, s.node_category, s.observed_nodes, s.estimated_total_nodes,\n    s.nodes_lower_95, s.nodes_upper_95, s.avg_confidence, s.sample_coverage, s.scaling_factor\n\nORDER BY s.date, s.estimated_total_nodes DESC", "relation_name": "`dbt`.`int_esg_node_classification`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.130162Z", "completed_at": "2025-09-04T07:25:40.262294Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.280599Z", "completed_at": "2025-09-04T07:25:40.280607Z"}], "thread_id": "Thread-28", "execution_time": 0.22058343887329102, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_clients_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv5_clients_daily`\nWHERE date = (SELECT MAX(date) FROM  `dbt`.`int_p2p_discv5_clients_daily` )\nORDER BY metric, label", "relation_name": "`dbt`.`api_p2p_discv5_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.138024Z", "completed_at": "2025-09-04T07:25:40.263160Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.281435Z", "completed_at": "2025-09-04T07:25:40.281442Z"}], "thread_id": "Thread-22", "execution_time": 0.22021174430847168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_next_fork_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`\nWHERE label = 'Next Fork' \nORDER BY date ASC, fork ASC", "relation_name": "`dbt`.`api_p2p_discv5_next_fork_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.134259Z", "completed_at": "2025-09-04T07:25:40.263728Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.282258Z", "completed_at": "2025-09-04T07:25:40.282266Z"}], "thread_id": "Thread-33", "execution_time": 0.22161126136779785, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_current_fork_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`\nWHERE label = 'Current Fork' \nORDER BY date ASC, fork ASC", "relation_name": "`dbt`.`api_p2p_discv5_current_fork_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.146200Z", "completed_at": "2025-09-04T07:25:40.264954Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.283108Z", "completed_at": "2025-09-04T07:25:40.283115Z"}], "thread_id": "Thread-10", "execution_time": 0.2206878662109375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_p2p_discv5_forks_daily", "compiled": true, "compiled_code": "SELECT\n    date\n    ,label\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`", "relation_name": "`dbt`.`fct_p2p_discv5_forks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.155479Z", "completed_at": "2025-09-04T07:25:40.265860Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.283966Z", "completed_at": "2025-09-04T07:25:40.283973Z"}], "thread_id": "Thread-16", "execution_time": 0.2203824520111084, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_rwa_backedfi_prices_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  bticker,\n  date,\n  price         \nFROM `dbt`.`fct_execution_rwa_backedfi_prices_daily`\nORDER BY\n  bticker,\n  date", "relation_name": "`dbt`.`api_execution_rwa_backedfi_prices_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.159297Z", "completed_at": "2025-09-04T07:25:40.266441Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.284824Z", "completed_at": "2025-09-04T07:25:40.284832Z"}], "thread_id": "Thread-34", "execution_time": 0.22065401077270508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_validators_apy_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,balance\n    ,rate\n    ,avg(rate) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rate_7dma\n    ,apy\n    ,ROUND((POWER((1+rate_7dma),365) - 1) * 100,2) AS apy_7dma\nFROM `dbt`.`int_consensus_validators_apy_daily`\nWHERE date > DATE '2021-12-08'", "relation_name": "`dbt`.`fct_consensus_validators_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.142052Z", "completed_at": "2025-09-04T07:25:40.267065Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.285677Z", "completed_at": "2025-09-04T07:25:40.285684Z"}], "thread_id": "Thread-32", "execution_time": 0.22385692596435547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_topology_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    peer_ip,\n    peer_discovery_id_prefix,\n    peer_cl_fork_name,\n    peer_cl_next_fork_name,\n    peer_client,\n    peer_hostname,\n    peer_city,\n    peer_country,\n    peer_org,\n    splitByChar(',', peer_loc)[1] AS peer_lat,\n    splitByChar(',', peer_loc)[2] AS peer_lon,\n    neighbor_ip,\n    neighbor_discovery_id_prefix,\n    neighbor_cl_fork_name,\n    neighbor_cl_next_fork_name,\n    neighbor_client,\n    neighbor_city,\n    neighbor_country,\n    neighbor_org,\n    splitByChar(',', neighbor_loc)[1] AS neighbor_lat,\n    splitByChar(',', neighbor_loc)[2] AS neighbor_lon,\n    cnt\nFROM  `dbt`.`int_p2p_discv5_topology_latest`", "relation_name": "`dbt`.`api_p2p_discv5_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.149685Z", "completed_at": "2025-09-04T07:25:40.267681Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.286525Z", "completed_at": "2025-09-04T07:25:40.286532Z"}], "thread_id": "Thread-36", "execution_time": 0.2235405445098877, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_p2p_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ndiscv4_topology AS (\n    SELECT\n        date,\n        peer_ip,\n        peer_discovery_id_prefix,\n        peer_client,\n        peer_hostname,\n        peer_city,\n        peer_country,\n        peer_org,\n        splitByChar(',', peer_loc)[1] AS peer_lat,\n        splitByChar(',', peer_loc)[2] AS peer_lon,\n        neighbor_ip,\n        neighbor_discovery_id_prefix,\n        neighbor_client,\n        neighbor_city,\n        neighbor_country,\n        neighbor_org,\n        splitByChar(',', neighbor_loc)[1] AS neighbor_lat,\n        splitByChar(',', neighbor_loc)[2] AS neighbor_lon,\n        cnt\n    FROM `dbt`.`int_p2p_discv4_topology_latest`\n),\n\ndiscv5_topology AS (\n    SELECT\n        date,\n        peer_ip,\n        peer_discovery_id_prefix,\n        peer_client,\n        peer_hostname,\n        peer_city,\n        peer_country,\n        peer_org,\n        splitByChar(',', peer_loc)[1] AS peer_lat,\n        splitByChar(',', peer_loc)[2] AS peer_lon,\n        neighbor_ip,\n        neighbor_discovery_id_prefix,\n        neighbor_client,\n        neighbor_city,\n        neighbor_country,\n        neighbor_org,\n        splitByChar(',', neighbor_loc)[1] AS neighbor_lat,\n        splitByChar(',', neighbor_loc)[2] AS neighbor_lon,\n        cnt\n    FROM `dbt`.`int_p2p_discv5_topology_latest`\n)\n\nSELECT 'DiscV4' AS protocol, * FROM discv4_topology\nUNION ALL\nSELECT 'DiscV5' AS protocol, * FROM discv5_topology", "relation_name": "`dbt`.`fct_p2p_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.163146Z", "completed_at": "2025-09-04T07:25:40.269183Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.287508Z", "completed_at": "2025-09-04T07:25:40.287517Z"}], "thread_id": "Thread-31", "execution_time": 0.22190260887145996, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_avatars", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,avatar_type\n    ,cnt\n    ,total\nFROM `dbt`.`fct_execution_circles_avatars`\nORDER BY date, avatar_type", "relation_name": "`dbt`.`api_execution_circles_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.172295Z", "completed_at": "2025-09-04T07:25:40.270189Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.288357Z", "completed_at": "2025-09-04T07:25:40.288367Z"}], "thread_id": "Thread-35", "execution_time": 0.22153854370117188, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_groups_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ngroups_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Group'\n),\n\ngroups_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Group'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM groups_latest t1\nCROSS JOIN groups_7d t2", "relation_name": "`dbt`.`api_execution_circles_groups_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.167725Z", "completed_at": "2025-09-04T07:25:40.270783Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.289216Z", "completed_at": "2025-09-04T07:25:40.289223Z"}], "thread_id": "Thread-11", "execution_time": 0.22299504280090332, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_backers_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nbackers_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_backing`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_backing`)\n),\n\nbackers_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_backing`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_backing`), 7)\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM backers_latest t1\nCROSS JOIN backers_7d t2", "relation_name": "`dbt`.`api_execution_circles_backers_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.178138Z", "completed_at": "2025-09-04T07:25:40.273397Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.290321Z", "completed_at": "2025-09-04T07:25:40.290330Z"}], "thread_id": "Thread-40", "execution_time": 0.22221636772155762, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_humans_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nhumans_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Human'\n),\n\nhumans_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Human'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM humans_latest t1\nCROSS JOIN humans_7d t2", "relation_name": "`dbt`.`api_execution_circles_humans_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.245668Z", "completed_at": "2025-09-04T07:25:40.273989Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.291248Z", "completed_at": "2025-09-04T07:25:40.291255Z"}], "thread_id": "Thread-13", "execution_time": 0.22248220443725586, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_orgs_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\norgs_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Org'\n),\n\norgs_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Org'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM orgs_latest t1\nCROSS JOIN orgs_7d t2", "relation_name": "`dbt`.`api_execution_circles_orgs_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.301753Z", "completed_at": "2025-09-04T07:25:40.329559Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.330962Z", "completed_at": "2025-09-04T07:25:40.330971Z"}], "thread_id": "Thread-7", "execution_time": 0.03413891792297363, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_client_distribution", "compiled": true, "compiled_code": "\n\nWITH node_classification AS (\n    -- Get total nodes per category from classification model\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        scaling_factor\n    FROM `dbt`.`int_esg_node_classification`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`)\n    \n),\n\n-- Combine client data from both DiscV4 (execution) and DiscV5 (consensus)\ncombined_client_data AS (\n    -- DiscV5 Consensus clients\n    SELECT\n        date,\n        'consensus_' || label AS client_type,\n        value AS observed_client_nodes\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE metric = 'Clients' \n        AND value > 0\n        AND label NOT IN ('Unknown', '')\n        \n            AND date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`) - INTERVAL 1 DAY\n        \n    \n    UNION ALL\n    \n    -- DiscV4 Execution clients  \n    SELECT\n        date,\n        'execution_' || label AS client_type,\n        value AS observed_client_nodes\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE metric = 'Clients'\n        AND value > 0  \n        AND label NOT IN ('Unknown', '')\n        \n            AND date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`) - INTERVAL 1 DAY\n        \n),\n\n-- Calculate client distribution percentages\nobserved_client_distribution AS (\n    SELECT\n        date,\n        client_type,\n        observed_client_nodes,\n        round(100.0 * observed_client_nodes / SUM(observed_client_nodes) OVER (PARTITION BY date), 3) AS observed_client_percentage\n    FROM combined_client_data\n),\n\n-- Apply client distribution to each node category\nclient_distribution_by_category AS (\n    SELECT\n        nc.date,\n        nc.node_category, \n        ocd.client_type,\n        ocd.observed_client_nodes,\n        ocd.observed_client_percentage,\n        \n        -- Calculate client nodes for this category\n        -- Each client gets same percentage of each category\n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.estimated_total_nodes\n        )) AS estimated_client_nodes,\n        \n        -- Proportional bounds\n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.nodes_lower_95\n        )) AS client_nodes_lower_95,\n        \n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.nodes_upper_95\n        )) AS client_nodes_upper_95,\n        \n        -- Client efficiency factors\n        CASE \n            -- Consensus client efficiency (relative to baseline)\n            WHEN ocd.client_type = 'consensus_Lighthouse' THEN 0.95\n            WHEN ocd.client_type = 'consensus_Nimbus' THEN 0.85  \n            WHEN ocd.client_type = 'consensus_Teku' THEN 1.15\n            WHEN ocd.client_type = 'consensus_Prysm' THEN 1.05\n            WHEN ocd.client_type = 'consensus_Lodestar' THEN 1.10\n            \n            -- Execution client efficiency (relative to baseline)\n            WHEN ocd.client_type = 'execution_Erigon' THEN 0.95\n            WHEN ocd.client_type = 'execution_Nethermind' THEN 1.00\n            WHEN ocd.client_type = 'execution_Besu' THEN 1.02\n            WHEN ocd.client_type = 'execution_Geth' THEN 0.98\n            \n            -- Default for other/unknown clients\n            ELSE 1.0\n        END AS client_efficiency_factor,\n        \n        nc.scaling_factor\n        \n    FROM node_classification nc\n    JOIN observed_client_distribution ocd ON nc.date = ocd.date\n    WHERE nc.estimated_total_nodes > 0\n),\n\n-- Calculate final metrics with rankings\nfinal_client_distribution AS (\n    SELECT\n        date,\n        node_category,\n        client_type,\n        estimated_client_nodes,\n        client_nodes_lower_95,\n        client_nodes_upper_95,\n        client_efficiency_factor,\n        \n        -- Percentage within this node category\n        round(100.0 * estimated_client_nodes / \n              NULLIF(SUM(estimated_client_nodes) OVER (PARTITION BY date, node_category), 0), 2\n        ) AS category_client_percentage,\n        \n        -- Global percentage across all categories  \n        round(100.0 * estimated_client_nodes /\n              NULLIF(SUM(estimated_client_nodes) OVER (PARTITION BY date), 0), 2\n        ) AS global_client_percentage,\n        \n        -- Ranking within category\n        ROW_NUMBER() OVER (\n            PARTITION BY date, node_category \n            ORDER BY estimated_client_nodes DESC, client_type\n        ) AS rank_in_category,\n        \n        -- Global ranking\n        ROW_NUMBER() OVER (\n            PARTITION BY date \n            ORDER BY estimated_client_nodes DESC, node_category, client_type\n        ) AS global_rank\n        \n    FROM client_distribution_by_category\n    WHERE estimated_client_nodes > 0\n)\n\nSELECT\n    date,\n    node_category,\n    client_type,\n    estimated_client_nodes,\n    client_nodes_lower_95,\n    client_nodes_upper_95,\n    client_efficiency_factor,\n    category_client_percentage,\n    global_client_percentage,\n    rank_in_category,\n    global_rank,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM final_client_distribution\nORDER BY date, node_category, estimated_client_nodes DESC", "relation_name": "`dbt`.`int_esg_node_client_distribution`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.311186Z", "completed_at": "2025-09-04T07:25:40.330215Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.332567Z", "completed_at": "2025-09-04T07:25:40.332574Z"}], "thread_id": "Thread-15", "execution_time": 0.03508806228637695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_geographic_distribution", "compiled": true, "compiled_code": "\n\nWITH node_classification AS (\n    -- Get node classification data\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        geographic_distribution\n    FROM `dbt`.`int_esg_node_classification`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_geographic_distribution`)\n    \n),\n\n-- Parse geographic distribution JSON\ngeographic_parsed AS (\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        \n        -- Parse JSON array of country distributions\n        JSONExtract(geographic_distribution, 'Array(Tuple(String, UInt32))') AS country_array\n    FROM node_classification\n),\n\ngeographic_expanded AS (\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95, \n        nodes_upper_95,\n        \n        -- Unpack country data\n        arrayJoin(country_array) AS country_tuple,\n        tupleElement(country_tuple, 1) AS country_code,\n        tupleElement(country_tuple, 2) AS estimated_nodes\n        \n    FROM geographic_parsed\n    WHERE length(country_array) > 0\n),\n\n-- Add country metadata from country_codes table\ncountry_enriched AS (\n    SELECT\n        g.date,\n        g.node_category,\n        g.country_code,\n        g.estimated_nodes,\n        \n        -- Calculate bounds proportionally\n        round(toFloat64(g.estimated_nodes) * g.nodes_lower_95 / g.estimated_total_nodes) AS nodes_lower_95,\n        round(toFloat64(g.estimated_nodes) * g.nodes_upper_95 / g.estimated_total_nodes) AS nodes_upper_95,\n        \n        -- Country percentage within this category\n        round(100.0 * g.estimated_nodes / g.estimated_total_nodes, 2) AS category_percentage,\n        \n        -- Get country metadata from reference table\n        COALESCE(cc.name, 'Unknown') AS country_name,\n        COALESCE(cc.region, 'Other') AS region,\n        cc.`sub-region` AS sub_region,\n        cc.`alpha-3` AS country_code_alpha3\n        \n    FROM geographic_expanded g\n    LEFT JOIN `dbt`.`stg_crawlers_data__country_codes` cc\n        ON g.country_code = cc.`alpha-2`\n    WHERE g.estimated_nodes > 0  -- Only include countries with nodes\n)\n\nSELECT\n    date,\n    node_category,\n    country_code,\n    country_name,\n    region,\n    sub_region,\n    country_code_alpha3,\n    estimated_nodes AS estimated_total_nodes,\n    nodes_lower_95,\n    nodes_upper_95,\n    category_percentage,\n    \n    -- Overall percentage across all categories\n    round(100.0 * estimated_nodes / SUM(estimated_nodes) OVER (PARTITION BY date), 2) AS global_percentage,\n    \n    -- Ranking within category\n    ROW_NUMBER() OVER (PARTITION BY date, node_category ORDER BY estimated_nodes DESC) AS rank_in_category,\n    \n    -- Ranking globally\n    ROW_NUMBER() OVER (PARTITION BY date ORDER BY estimated_nodes DESC) AS global_rank,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM country_enriched\nORDER BY date, node_category, estimated_nodes DESC", "relation_name": "`dbt`.`int_esg_node_geographic_distribution`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.321335Z", "completed_at": "2025-09-04T07:25:40.331923Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.334121Z", "completed_at": "2025-09-04T07:25:40.334128Z"}], "thread_id": "Thread-24", "execution_time": 0.03538632392883301, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_info_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ndeposits_withdrawls_latest AS (\n    SELECT\n        label\n        ,cnt\n        ,total_amount\n    FROM \n        `dbt`.`fct_consensus_deposits_withdrawls_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`fct_consensus_deposits_withdrawls_daily`)\n),\n\ndeposits_withdrawls_7d AS (\n    SELECT\n        label\n        ,cnt\n        ,total_amount\n    FROM \n        `dbt`.`fct_consensus_deposits_withdrawls_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`), 7)\n),\n\napy_latest AS (\n    SELECT\n        apy_7dma\n    FROM \n        `dbt`.`fct_consensus_validators_apy_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`fct_consensus_validators_apy_daily`)\n),\n\napy_7d AS (\n    SELECT\n       apy_7dma\n    FROM \n        `dbt`.`fct_consensus_validators_apy_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`fct_consensus_validators_apy_daily`), 7)\n),\n\nstatus_latest AS (\n    SELECT\n        status AS label\n        ,CAST(COALESCE(cnt,0) AS Float64) AS value\n    FROM \n        `dbt`.`int_consensus_validators_status_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_validators_status_daily`)\n),\n\nstatus_7d AS (\n    SELECT\n        status AS label\n        ,CAST(COALESCE(cnt,0) AS Float64) AS value\n    FROM \n        `dbt`.`int_consensus_validators_status_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_validators_status_daily`), 7)\n),\n\n\nstaked_latest AS (\n    SELECT\n        'Staked' AS label\n        ,effective_balance/32 AS value\n    FROM \n        `dbt`.`int_consensus_validators_balances_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_validators_balances_daily`)\n),\n\nstaked_7d AS (\n    SELECT\n        'Staked' AS label\n        ,effective_balance/32 AS value\n    FROM \n        `dbt`.`int_consensus_validators_balances_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_validators_balances_daily`), 7)\n),\n\n\ninfo_latest AS ( \n    SELECT\n        'deposits_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_latest WHERE label = 'deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_latest WHERE label = 'withdrawls'), 0) AS value\n    UNION ALL\n    SELECT\n        'deposits_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'withdrawls'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'withdrawls'), 0) AS value\n    UNION ALL\n    SELECT\n        'APY7D' AS label \n    ,COALESCE((SELECT ROUND(apy_7dma,2) FROM apy_latest),0) AS value\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM status_latest\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM staked_latest\n),\n\ninfo_7d AS ( \n    SELECT\n        'deposits_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_7d WHERE label = 'deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_7d WHERE label = 'withdrawls'), 0) AS value\n    UNION ALL\n    SELECT\n        'deposits_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_7d WHERE label = 'deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'APY7D' AS label \n    ,COALESCE((SELECT ROUND(apy_7dma,2) FROM apy_7d),0) AS value\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM status_7d\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM staked_7d\n)\n\nSELECT\n    t1.label\n    ,t1.value AS value\n    ,IF(t1.value=0 AND t2.value=0, 0, ROUND(( COALESCE(t1.value / NULLIF(t2.value, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM info_latest t1\nINNER JOIN info_7d t2\nON t2.label = t1.label", "relation_name": "`dbt`.`fct_consensus_info_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.317343Z", "completed_at": "2025-09-04T07:25:40.333413Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.335213Z", "completed_at": "2025-09-04T07:25:40.335220Z"}], "thread_id": "Thread-36", "execution_time": 0.0371091365814209, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_apy_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,label\n    ,apy\nFROM (\n    SELECT date, 'Daily' AS label, apy AS apy FROM `dbt`.`fct_consensus_validators_apy_daily`\n    UNION ALL \n    SELECT date, '7DMA' AS label, apy_7dma AS apy FROM `dbt`.`fct_consensus_validators_apy_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_validators_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.345683Z", "completed_at": "2025-09-04T07:25:40.364772Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.378619Z", "completed_at": "2025-09-04T07:25:40.378628Z"}], "thread_id": "Thread-18", "execution_time": 0.041025638580322266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_dynamic_power_consumption", "compiled": true, "compiled_code": "\n\nWITH node_distribution AS (\n    SELECT\n        date,\n        node_category,\n        country_code,\n        country_name,\n        region,\n        sub_region,\n        country_code_alpha3,\n        estimated_total_nodes,  \n        nodes_lower_95,           \n        nodes_upper_95          \n    FROM `dbt`.`int_esg_node_geographic_distribution` n\n    \n        WHERE n.date > (SELECT MAX(date) FROM `dbt`.`int_esg_dynamic_power_consumption`)\n    \n),\n\n-- Get client efficiency from upstream client distribution model\nclient_efficiency_by_category AS (\n    SELECT\n        date,\n        node_category,\n        \n        -- Weighted average client efficiency for this category\n        SUM(category_client_percentage / 100.0 * client_efficiency_factor) AS avg_client_efficiency,\n        \n        -- Client diversity count for resilience bonus\n        COUNT(DISTINCT client_type) AS client_diversity,\n        \n        -- Total estimated client nodes for validation\n        SUM(estimated_client_nodes) AS total_client_nodes,\n        \n        -- Client breakdown for diagnostics\n        groupArray((client_type, category_client_percentage, estimated_client_nodes)) AS client_breakdown\n        \n    FROM `dbt`.`int_esg_node_client_distribution` ncd\n    \n        WHERE ncd.date > (SELECT MAX(date) FROM `dbt`.`int_esg_dynamic_power_consumption`) - INTERVAL 1 DAY\n    \n    GROUP BY date, node_category\n),\n\n-- Base power calculations by hardware tier with CCRI empirical values\npower_per_category AS (\n    SELECT\n        nd.date,\n        nd.node_category,\n        nd.country_code,\n        nd.country_name,\n        nd.region,\n        nd.sub_region,\n        nd.country_code_alpha3,\n        nd.estimated_total_nodes,\n        nd.nodes_lower_95,\n        nd.nodes_upper_95,\n        \n        -- CCRI empirical power consumption (Watts per node)\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 22.0        -- CCRI Tier 4: mean of 16.56-25.97W\n            WHEN 'professional_operator' THEN 48.0  -- CCRI Tier 5: mean of 36.82-59.95W\n            WHEN 'cloud_hosted' THEN 155.0      -- CCRI Tier 6: mean of 139.90-186.76W\n            ELSE 50.0\n        END AS base_power_watts,\n        \n        -- Standard deviation based on CCRI measurement ranges\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 3.3        -- ~15% of 22W (conservative uncertainty)\n            WHEN 'professional_operator' THEN 7.2  -- ~15% of 48W\n            WHEN 'cloud_hosted' THEN 23.0       -- ~15% of 155W\n            ELSE 7.5\n        END AS power_std_watts,\n        \n        -- Data source for traceability\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 'CCRI_Tier4_Empirical'\n            WHEN 'professional_operator' THEN 'CCRI_Tier5_Empirical'\n            WHEN 'cloud_hosted' THEN 'CCRI_Tier6_Empirical'\n            ELSE 'CCRI_Default'\n        END AS power_source,\n        \n        -- Measurement confidence (CCRI empirical data is high quality)\n        0.85 AS measurement_confidence,\n        \n        -- PUE by category  \n        CASE nd.node_category\n            WHEN 'home_staker' THEN 1.0         -- No datacenter overhead\n            WHEN 'professional_operator' THEN 1.58  -- Traditional datacenter\n            WHEN 'cloud_hosted' THEN 1.15       -- Efficient cloud datacenter\n            ELSE 1.1\n        END AS pue_factor,\n        \n        -- Client efficiency from upstream model\n        COALESCE(ce.avg_client_efficiency, 1.0) AS client_efficiency_multiplier,\n        \n        -- Diversity bonus (more client types = better resilience)\n        CASE \n            WHEN ce.client_diversity > 0 THEN 0.95 + 0.05 * least(4, ce.client_diversity) / 4.0\n            ELSE 1.0\n        END AS diversity_bonus,\n        \n        ce.client_breakdown,\n        ce.total_client_nodes\n        \n    FROM node_distribution nd\n    LEFT JOIN client_efficiency_by_category ce ON nd.date = ce.date AND nd.node_category = ce.node_category\n),\n\n-- Apply all efficiency factors\nfinal_power_calculations AS (\n    SELECT\n        p.*,\n        \n        -- Final power per node with all efficiency factors\n        p.base_power_watts * p.client_efficiency_multiplier * p.diversity_bonus AS avg_power_watts_per_node,\n        p.power_std_watts * p.client_efficiency_multiplier * p.diversity_bonus AS power_std_dev_per_node,\n        \n        -- Daily energy consumption (kWh)\n        p.estimated_total_nodes * \n        p.base_power_watts * \n        p.client_efficiency_multiplier * \n        p.diversity_bonus * \n        24.0 / 1000.0 AS daily_energy_kwh_mean\n\n    FROM power_per_category p\n),\n\n-- Carbon intensity lookup with robust fallback\ncarbon_intensity_lookup AS (\n    SELECT DISTINCT\n        p.date,\n        p.country_code_alpha3,\n        \n        -- Robust fallback hierarchy\n        COALESCE(\n            ci_country.carbon_intensity_mean,\n            ci_world.carbon_intensity_mean,\n            450.0\n        ) AS carbon_intensity_gco2_kwh,\n        \n        COALESCE(\n            ci_country.carbon_intensity_std,\n            ci_world.carbon_intensity_std, \n            45.0\n        ) AS carbon_intensity_std_gco2_kwh,\n        \n        CASE \n            WHEN ci_country.carbon_intensity_mean IS NOT NULL THEN 'country_specific'\n            WHEN ci_world.carbon_intensity_mean IS NOT NULL THEN 'world_average'\n            ELSE 'conservative_default'\n        END AS carbon_intensity_source\n        \n    FROM final_power_calculations p\n    LEFT JOIN `dbt`.`int_esg_carbon_intensity_ensemble` ci_country\n        ON p.country_code_alpha3 = ci_country.country_code\n        AND ci_country.month_date = toStartOfMonth(p.date)\n        AND p.country_code_alpha3 IS NOT NULL\n        AND p.country_code_alpha3 != ''\n    LEFT JOIN `dbt`.`int_esg_carbon_intensity_ensemble` ci_world\n        ON ci_world.country_code = 'WORLD'\n        AND ci_world.month_date = toStartOfMonth(p.date)\n    WHERE ci_country.month_date != DATE '1970-01-01' OR ci_world.month_date != DATE '1970-01-01' -- nu;;s ghet repl;ace by date...\n),\n\n-- Final calculations with carbon emissions\nfinal_calculations AS (\n    SELECT\n        p.date AS date,\n        p.node_category AS node_category,\n        p.country_code AS country_code,\n        p.country_code_alpha3 AS country_code_alpha3,\n        p.country_name AS country_name,\n        p.region AS region,\n        p.sub_region AS sub_region,\n        p.estimated_total_nodes AS estimated_total_nodes,\n        p.nodes_lower_95 AS nodes_lower_95,\n        p.nodes_upper_95 AS nodes_upper_95,\n        p.avg_power_watts_per_node AS avg_power_watts_per_node,\n        p.power_std_dev_per_node AS power_std_dev_per_node,\n        p.daily_energy_kwh_mean AS daily_energy_kwh_mean,\n        p.pue_factor AS pue_factor,\n        p.client_efficiency_multiplier AS client_efficiency,\n        p.diversity_bonus,\n        \n        -- CCRI source tracking\n        p.power_source,\n        p.measurement_confidence,\n        p.base_power_watts AS ccri_base_power_watts,\n        \n        -- Carbon intensity from lookup\n        ci.carbon_intensity_gco2_kwh,\n        ci.carbon_intensity_std_gco2_kwh,\n        ci.carbon_intensity_source,\n        \n        -- CO2 calculations\n        p.daily_energy_kwh_mean * p.pue_factor * ci.carbon_intensity_gco2_kwh / 1000.0 AS daily_co2_kg_mean,\n        \n        -- CO2 standard deviation\n        sqrt(\n            pow(p.daily_energy_kwh_mean * p.pue_factor * ci.carbon_intensity_std_gco2_kwh / 1000.0, 2) +\n            pow(p.power_std_dev_per_node * 24 / 1000.0 * p.pue_factor * ci.carbon_intensity_gco2_kwh / 1000.0, 2)\n        ) AS daily_co2_kg_std,\n        \n        -- Diagnostics\n        p.client_breakdown,\n        p.total_client_nodes\n        \n    FROM final_power_calculations p\n    INNER JOIN carbon_intensity_lookup ci\n        ON p.date = ci.date\n        AND COALESCE(p.country_code_alpha3, '') = COALESCE(ci.country_code_alpha3, '')\n)\n\nSELECT\n    date,\n    node_category,\n    country_code,\n    country_name,\n    region,\n    estimated_total_nodes,\n    nodes_lower_95,\n    nodes_upper_95,\n    \n    -- Power consumption metrics\n    round(avg_power_watts_per_node, 2) AS avg_power_watts_per_node,\n    round(power_std_dev_per_node, 2) AS power_std_dev_per_node,\n    round(daily_energy_kwh_mean, 2) AS daily_energy_kwh_mean,\n    round(pue_factor, 3) AS pue_mean,\n    round(client_efficiency, 3) AS client_efficiency_factor,\n    round(diversity_bonus, 3) AS diversity_bonus,\n    \n    -- Carbon emissions\n    round(daily_co2_kg_mean, 4) AS daily_co2_kg_mean,\n    round(daily_co2_kg_std, 4) AS daily_co2_kg_std,\n    round(carbon_intensity_gco2_kwh, 2) AS carbon_intensity_gco2_kwh,\n    round(carbon_intensity_std_gco2_kwh, 2) AS carbon_intensity_std_gco2_kwh,\n    \n    -- Confidence intervals\n    round(greatest(0, daily_co2_kg_mean - 1.96 * daily_co2_kg_std), 4) AS daily_co2_kg_lower_95,\n    round(daily_co2_kg_mean + 1.96 * daily_co2_kg_std, 4) AS daily_co2_kg_upper_95,\n    \n    -- CCRI data quality and source tracking\n    carbon_intensity_source,\n    round(ccri_base_power_watts, 2) AS ccri_base_power_watts,\n    power_source,\n    round(measurement_confidence, 3) AS measurement_confidence,\n    \n    -- Performance comparison with previous estimates\n    round(\n        100.0 * (avg_power_watts_per_node - CASE node_category\n            WHEN 'home_staker' THEN 75.0\n            WHEN 'professional_operator' THEN 200.0  \n            WHEN 'cloud_hosted' THEN 110.0\n            ELSE 100.0\n        END) / CASE node_category\n            WHEN 'home_staker' THEN 75.0\n            WHEN 'professional_operator' THEN 200.0\n            WHEN 'cloud_hosted' THEN 110.0  \n            ELSE 100.0\n        END, 1\n    ) AS power_reduction_vs_previous_pct,\n    \n    -- Diagnostics\n    toJSONString(client_breakdown) AS client_breakdown_json,\n    total_client_nodes AS debug_total_clients,\n    \n    -- Metadata\n    now() AS calculated_at\n\nFROM final_calculations\nWHERE estimated_total_nodes > 0", "relation_name": "`dbt`.`int_esg_dynamic_power_consumption`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.355418Z", "completed_at": "2025-09-04T07:25:40.372983Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.379922Z", "completed_at": "2025-09-04T07:25:40.379931Z"}], "thread_id": "Thread-20", "execution_time": 0.04111838340759277, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_active_ongoing_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'active_ongoing'", "relation_name": "`dbt`.`api_consensus_info_active_ongoing_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.361104Z", "completed_at": "2025-09-04T07:25:40.380770Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.384237Z", "completed_at": "2025-09-04T07:25:40.384244Z"}], "thread_id": "Thread-12", "execution_time": 0.042536258697509766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_apy_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'APY7D'", "relation_name": "`dbt`.`api_consensus_info_apy_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.365487Z", "completed_at": "2025-09-04T07:25:40.381355Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.385111Z", "completed_at": "2025-09-04T07:25:40.385119Z"}], "thread_id": "Thread-27", "execution_time": 0.042236328125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_deposits_cnt_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'deposits_cnt'", "relation_name": "`dbt`.`api_consensus_info_deposits_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.373609Z", "completed_at": "2025-09-04T07:25:40.382272Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.385981Z", "completed_at": "2025-09-04T07:25:40.385988Z"}], "thread_id": "Thread-39", "execution_time": 0.03200960159301758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_withdrawls_cnt_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'withdrawls_cnt'", "relation_name": "`dbt`.`api_consensus_info_withdrawls_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.369247Z", "completed_at": "2025-09-04T07:25:40.382857Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.386877Z", "completed_at": "2025-09-04T07:25:40.386888Z"}], "thread_id": "Thread-5", "execution_time": 0.04204988479614258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_staked_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    toUInt32(value) AS value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'Staked'", "relation_name": "`dbt`.`api_consensus_info_staked_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.389362Z", "completed_at": "2025-09-04T07:25:40.398076Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.398666Z", "completed_at": "2025-09-04T07:25:40.398674Z"}], "thread_id": "Thread-20", "execution_time": 0.01101064682006836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_esg_carbon_footprint_uncertainty", "compiled": true, "compiled_code": "\n\nWITH node_country_distribution AS (\n    -- Get node distribution by country and category with their carbon intensities\n    SELECT\n        date,\n        node_category,\n        country_code,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        carbon_intensity_gco2_kwh,\n        daily_energy_kwh_mean,\n        avg_power_watts_per_node,\n        power_std_dev_per_node,\n        daily_co2_kg_mean,\n        daily_co2_kg_std\n    FROM `dbt`.`int_esg_dynamic_power_consumption`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`)\n    \n),\n\n-- Calculate network effective CIF from geographic distribution\nnetwork_effective_cif AS (\n    SELECT\n        date,\n        -- Network Effective CIF = \u03a3(nodes_in_country \u00d7 country_CIF) / total_nodes\n        SUM(estimated_total_nodes * carbon_intensity_gco2_kwh) / \n        NULLIF(SUM(estimated_total_nodes), 0) AS network_weighted_cif,\n        \n        -- Weighted standard deviation of network CIF\n        -- Using variance formula: Var = \u03a3(w_i * (x_i - mean)\u00b2) / \u03a3(w_i)\n        -- Then std = sqrt(var)\n        SQRT(\n            SUM(estimated_total_nodes * pow(carbon_intensity_gco2_kwh, 2)) / NULLIF(SUM(estimated_total_nodes), 0) -\n            pow(SUM(estimated_total_nodes * carbon_intensity_gco2_kwh) / NULLIF(SUM(estimated_total_nodes), 0), 2)\n        ) AS network_cif_std\n    FROM node_country_distribution\n    GROUP BY date\n),\n\ndaily_power_data AS (\n    -- Aggregate power consumption across all categories and countries\n    SELECT\n        date,\n        node_category,\n        \n        -- Node counts with uncertainty\n        SUM(estimated_total_nodes) AS category_nodes,\n        SUM(nodes_lower_95) AS category_nodes_lower_95,\n        SUM(nodes_upper_95) AS category_nodes_upper_95,\n        \n        -- Energy totals with uncertainty calculation\n        SUM(daily_energy_kwh_mean) AS category_energy_kwh_mean,\n        \n        -- Energy standard deviation (propagate uncertainty from power and node count)\n        SQRT(SUM(\n            pow(power_std_dev_per_node * estimated_total_nodes * 24 / 1000.0, 2) + \n            pow(avg_power_watts_per_node * (nodes_upper_95 - nodes_lower_95) / 3.92 * 24 / 1000.0, 2)\n        )) AS category_energy_kwh_std,\n        \n        -- Carbon totals\n        SUM(daily_co2_kg_mean) AS category_co2_kg,\n        SQRT(SUM(pow(daily_co2_kg_std, 2))) AS category_co2_kg_std,\n        \n        -- Weighted averages\n        SUM(daily_energy_kwh_mean * estimated_total_nodes) / NULLIF(SUM(estimated_total_nodes), 0) AS weighted_avg_energy_per_node,\n        SUM(daily_co2_kg_mean * estimated_total_nodes) / NULLIF(SUM(estimated_total_nodes), 0) AS weighted_avg_co2_per_node,\n        \n        -- Country count for this category\n        COUNT(DISTINCT country_code) AS countries_represented\n        \n    FROM node_country_distribution\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`)\n    \n    GROUP BY date, node_category\n),\n\nnetwork_totals AS (\n    -- Calculate network-wide totals with full uncertainty propagation\n    SELECT\n        date,\n        \n        -- Total network size with bounds\n        SUM(category_nodes) AS total_estimated_nodes,\n        SUM(category_nodes_lower_95) AS total_nodes_lower_95,\n        SUM(category_nodes_upper_95) AS total_nodes_upper_95,\n        \n        -- Total energy consumption with uncertainty\n        SUM(category_energy_kwh_mean) AS total_energy_kwh_mean,\n        SQRT(SUM(pow(category_energy_kwh_std, 2))) AS total_energy_kwh_std,\n        \n        -- Total emissions with error propagation\n        SUM(category_co2_kg) AS total_co2_kg_mean,\n        SQRT(SUM(pow(category_co2_kg_std, 2))) AS total_co2_kg_std,\n        \n        -- Category breakdown for energy\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_energy_kwh_mean ELSE 0 END) AS home_staker_energy_kwh,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_energy_kwh_mean ELSE 0 END) AS professional_energy_kwh,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_energy_kwh_mean ELSE 0 END) AS cloud_energy_kwh,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_energy_kwh_mean ELSE 0 END) AS unknown_energy_kwh,\n        \n        -- Category breakdown for carbon\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_co2_kg ELSE 0 END) AS home_staker_co2_kg,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_co2_kg ELSE 0 END) AS professional_co2_kg,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_co2_kg ELSE 0 END) AS cloud_co2_kg,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_co2_kg ELSE 0 END) AS unknown_co2_kg,\n        \n        -- Node breakdown\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_nodes ELSE 0 END) AS home_staker_nodes,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_nodes ELSE 0 END) AS professional_nodes,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_nodes ELSE 0 END) AS cloud_nodes,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_nodes ELSE 0 END) AS unknown_nodes,\n        \n        -- Quality metrics\n        COUNT(DISTINCT CASE WHEN category_nodes > 0 THEN node_category END) AS active_categories,\n        MAX(countries_represented) AS max_countries_in_category\n        \n    FROM daily_power_data\n    GROUP BY date\n),\n\n-- Add Chao-1 population estimates for comparison\nchao1_comparison AS (\n    SELECT\n        nt.date AS date,\n        nt.*,\n        necif.network_weighted_cif,\n        necif.network_cif_std,\n        \n        -- Link to Chao-1 estimates\n        c.observed_successful_nodes AS chao1_observed,\n        c.enhanced_total_reachable AS chao1_estimated,\n        c.connection_success_rate_pct AS chao1_success_rate,\n        c.reachable_discovery_coverage_pct AS chao1_coverage,\n        \n        -- Compare our estimates to Chao-1\n        round(100.0 * nt.total_estimated_nodes / NULLIF(c.enhanced_total_reachable, 0), 1) AS node_estimate_vs_chao1_pct,\n        \n        -- Calculate scaling factor applied\n        round(toFloat64(nt.total_estimated_nodes) / NULLIF(c.observed_successful_nodes, 0), 2) AS applied_scaling_factor\n        \n    FROM network_totals nt\n    JOIN network_effective_cif necif ON nt.date = necif.date\n    LEFT JOIN `dbt`.`int_esg_node_population_chao1` c\n        ON c.observation_date = nt.date\n),\n\nenhanced_statistics AS (\n    SELECT\n        date,\n        \n        -- Node population metrics with bounds\n        total_estimated_nodes,\n        total_nodes_lower_95,\n        total_nodes_upper_95,\n        chao1_observed,\n        chao1_estimated,\n        chao1_success_rate,\n        chao1_coverage,\n        node_estimate_vs_chao1_pct,\n        applied_scaling_factor,\n        \n        -- Network carbon intensity with uncertainty\n        round(network_weighted_cif, 2) AS network_carbon_intensity_gco2_kwh,\n        round(network_cif_std, 2) AS network_carbon_intensity_std,\n        \n        -- Daily energy metrics with full uncertainty bands\n        round(total_energy_kwh_mean, 2) AS daily_energy_kwh_mean,\n        round(total_energy_kwh_std, 2) AS daily_energy_kwh_std,\n        \n        -- Daily energy confidence intervals (95%)\n        round(greatest(0, total_energy_kwh_mean - 1.96 * total_energy_kwh_std), 2) AS daily_energy_kwh_lower_95,\n        round(total_energy_kwh_mean + 1.96 * total_energy_kwh_std, 2) AS daily_energy_kwh_upper_95,\n        \n        -- Daily energy confidence intervals (90%)\n        round(greatest(0, total_energy_kwh_mean - 1.645 * total_energy_kwh_std), 2) AS daily_energy_kwh_lower_90,\n        round(total_energy_kwh_mean + 1.645 * total_energy_kwh_std, 2) AS daily_energy_kwh_upper_90,\n        \n        -- Annual energy projections with uncertainty\n        round(total_energy_kwh_mean * 365 / 1000, 2) AS annual_energy_mwh_mean,\n        round(total_energy_kwh_std * sqrt(365) / 1000, 2) AS annual_energy_mwh_std,\n        \n        -- Annual energy confidence intervals (95%)\n        round(greatest(0, (total_energy_kwh_mean * 365 / 1000) - 1.96 * (total_energy_kwh_std * sqrt(365) / 1000)), 2) AS annual_energy_mwh_lower_95,\n        round((total_energy_kwh_mean * 365 / 1000) + 1.96 * (total_energy_kwh_std * sqrt(365) / 1000), 2) AS annual_energy_mwh_upper_95,\n        \n        -- Annual energy confidence intervals (90%)\n        round(greatest(0, (total_energy_kwh_mean * 365 / 1000) - 1.645 * (total_energy_kwh_std * sqrt(365) / 1000)), 2) AS annual_energy_mwh_lower_90,\n        round((total_energy_kwh_mean * 365 / 1000) + 1.645 * (total_energy_kwh_std * sqrt(365) / 1000), 2) AS annual_energy_mwh_upper_90,\n        \n        -- Carbon emissions (primary metrics)\n        round(total_co2_kg_mean, 2) AS daily_co2_kg_mean,\n        round(total_co2_kg_std, 2) AS daily_co2_kg_std,\n        \n        -- Daily CO2 confidence intervals (95%)\n        round(greatest(0, total_co2_kg_mean - 1.96 * total_co2_kg_std), 2) AS daily_co2_kg_lower_95,\n        round(total_co2_kg_mean + 1.96 * total_co2_kg_std, 2) AS daily_co2_kg_upper_95,\n        \n        -- Daily CO2 confidence intervals (90%)\n        round(greatest(0, total_co2_kg_mean - 1.645 * total_co2_kg_std), 2) AS daily_co2_kg_lower_90,\n        round(total_co2_kg_mean + 1.645 * total_co2_kg_std, 2) AS daily_co2_kg_upper_90,\n        \n        -- Annual CO2 projections\n        round(total_co2_kg_mean * 365 / 1000, 2) AS annual_co2_tonnes_mean,\n        round(total_co2_kg_std * sqrt(365) / 1000, 2) AS annual_co2_tonnes_std,\n        \n        -- Category breakdowns for energy\n        round(home_staker_energy_kwh, 2) AS home_staker_energy_kwh_daily,\n        round(professional_energy_kwh, 2) AS professional_energy_kwh_daily,\n        round(cloud_energy_kwh, 2) AS cloud_energy_kwh_daily,\n        round(unknown_energy_kwh, 2) AS unknown_energy_kwh_daily,\n        \n        -- Category breakdowns for carbon\n        round(home_staker_co2_kg, 2) AS home_staker_co2_kg_daily,\n        round(professional_co2_kg, 2) AS professional_co2_kg_daily,\n        round(cloud_co2_kg, 2) AS cloud_co2_kg_daily,\n        round(unknown_co2_kg, 2) AS unknown_co2_kg_daily,\n        \n        -- Category percentages\n        round(100.0 * home_staker_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS home_staker_pct,\n        round(100.0 * professional_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS professional_pct,\n        round(100.0 * cloud_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS cloud_pct,\n        \n        -- Node distribution\n        home_staker_nodes,\n        professional_nodes,\n        cloud_nodes,\n        unknown_nodes,\n        \n        -- Relative uncertainties\n        round(100.0 * total_energy_kwh_std / NULLIF(total_energy_kwh_mean, 0), 1) AS energy_relative_uncertainty_pct,\n        round(100.0 * total_co2_kg_std / NULLIF(total_co2_kg_mean, 0), 1) AS carbon_relative_uncertainty_pct,\n        \n        -- Quality metrics\n        active_categories,\n        max_countries_in_category AS countries_with_nodes\n        \n    FROM chao1_comparison\n)\n\nSELECT\n    date,\n    \n    -- PRIMARY CARBON FOOTPRINT METRICS WITH BANDS\n    daily_co2_kg_mean,\n    daily_co2_kg_std,\n    daily_co2_kg_lower_95,\n    daily_co2_kg_upper_95,\n    daily_co2_kg_lower_90,\n    daily_co2_kg_upper_90,\n    \n    -- Annual CO2 projections with uncertainty bands\n    annual_co2_tonnes_mean AS annual_co2_tonnes_projected,\n    annual_co2_tonnes_std,\n    round(greatest(0, annual_co2_tonnes_mean - 1.96 * annual_co2_tonnes_std), 2) AS annual_co2_tonnes_lower_95,\n    round(annual_co2_tonnes_mean + 1.96 * annual_co2_tonnes_std, 2) AS annual_co2_tonnes_upper_95,\n    round(greatest(0, annual_co2_tonnes_mean - 1.645 * annual_co2_tonnes_std), 2) AS annual_co2_tonnes_lower_90,\n    round(annual_co2_tonnes_mean + 1.645 * annual_co2_tonnes_std, 2) AS annual_co2_tonnes_upper_90,\n    \n    -- PRIMARY ENERGY METRICS WITH BANDS\n    daily_energy_kwh_mean AS daily_energy_kwh_total,\n    daily_energy_kwh_std,\n    daily_energy_kwh_lower_95,\n    daily_energy_kwh_upper_95,\n    daily_energy_kwh_lower_90,\n    daily_energy_kwh_upper_90,\n    \n    -- Annual energy projections with uncertainty bands\n    annual_energy_mwh_mean AS annual_energy_Mwh_projected,\n    annual_energy_mwh_std,\n    annual_energy_mwh_lower_95,\n    annual_energy_mwh_upper_95,\n    annual_energy_mwh_lower_90,\n    annual_energy_mwh_upper_90,\n    \n    -- NETWORK CARBON INTENSITY WITH UNCERTAINTY\n    network_carbon_intensity_gco2_kwh AS effective_carbon_intensity,\n    network_carbon_intensity_std AS effective_carbon_intensity_std,\n    round(greatest(0, network_carbon_intensity_gco2_kwh - 1.96 * network_carbon_intensity_std), 2) AS effective_carbon_intensity_lower_95,\n    round(network_carbon_intensity_gco2_kwh + 1.96 * network_carbon_intensity_std, 2) AS effective_carbon_intensity_upper_95,\n    \n    -- NODE POPULATION WITH BOUNDS\n    total_estimated_nodes AS estimated_nodes,\n    total_nodes_lower_95 AS nodes_lower_95,\n    total_nodes_upper_95 AS nodes_upper_95,\n    \n    -- Category breakdown for energy (daily)\n    home_staker_energy_kwh_daily,\n    professional_energy_kwh_daily,\n    cloud_energy_kwh_daily,\n    unknown_energy_kwh_daily,\n    \n    -- Category breakdown for emissions (daily)\n    home_staker_co2_kg_daily,\n    professional_co2_kg_daily,\n    cloud_co2_kg_daily,\n    unknown_co2_kg_daily,\n    \n    -- Category percentages\n    home_staker_pct,\n    professional_pct,\n    cloud_pct,\n    \n    -- Node distribution by category\n    home_staker_nodes,\n    professional_nodes,\n    cloud_nodes,\n    unknown_nodes,\n    \n    -- UNCERTAINTY METRICS\n    energy_relative_uncertainty_pct,\n    carbon_relative_uncertainty_pct,\n    \n    -- Quality metrics\n    active_categories AS node_categories_active,\n    countries_with_nodes,\n    \n    -- Comparison with Chao-1 estimates\n    chao1_observed AS baseline_observed_nodes,\n    chao1_estimated AS chao1_total_estimated,\n    node_estimate_vs_chao1_pct,\n    applied_scaling_factor,\n    round(chao1_success_rate, 1) AS network_reachability_pct,\n    round(chao1_coverage, 1) AS discovery_completeness_pct,\n    \n    -- PER-NODE METRICS WITH BOUNDS\n    round(daily_co2_kg_mean / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS grams_co2_per_node_daily,\n    round(daily_energy_kwh_mean / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS wh_per_node_daily,\n    \n    -- Per-node uncertainty bands\n    round(greatest(0, (daily_co2_kg_mean - 1.96 * daily_co2_kg_std) / NULLIF(total_estimated_nodes, 0) * 1000), 1) AS grams_co2_per_node_lower_95,\n    round((daily_co2_kg_mean + 1.96 * daily_co2_kg_std) / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS grams_co2_per_node_upper_95,\n    \n    round(greatest(0, (daily_energy_kwh_mean - 1.96 * daily_energy_kwh_std) / NULLIF(total_estimated_nodes, 0) * 1000), 1) AS wh_per_node_lower_95,\n    round((daily_energy_kwh_mean + 1.96 * daily_energy_kwh_std) / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS wh_per_node_upper_95\n    \nFROM enhanced_statistics\nORDER BY date DESC", "relation_name": "`dbt`.`fct_esg_carbon_footprint_uncertainty`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.409545Z", "completed_at": "2025-09-04T07:25:40.422880Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.446156Z", "completed_at": "2025-09-04T07:25:40.446165Z"}], "thread_id": "Thread-6", "execution_time": 0.04498600959777832, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_emissions_annualised_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    annual_co2_tonnes_projected\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date DESC \nLIMIT 1", "relation_name": "`dbt`.`api_esg_carbon_emissions_annualised_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.415817Z", "completed_at": "2025-09-04T07:25:40.428675Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.458523Z", "completed_at": "2025-09-04T07:25:40.458532Z"}], "thread_id": "Thread-21", "execution_time": 0.05614042282104492, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_emissions_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    AVG(daily_co2_kg_mean) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_value,\n    AVG(daily_co2_kg_lower_90) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_90,\n    AVG(daily_co2_kg_upper_90) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_90,\n    AVG(daily_co2_kg_lower_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_95,\n    AVG(daily_co2_kg_upper_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_95\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date", "relation_name": "`dbt`.`api_esg_carbon_emissions_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.423474Z", "completed_at": "2025-09-04T07:25:40.451156Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.462152Z", "completed_at": "2025-09-04T07:25:40.462162Z"}], "thread_id": "Thread-14", "execution_time": 0.056298255920410156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_timeseries_bands", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    daily_co2_kg_mean AS value,\n    daily_co2_kg_lower_95 AS lower_95,\n    daily_co2_kg_upper_95 AS upper_95,\n    daily_co2_kg_lower_90 AS lower_90,\n    daily_co2_kg_upper_90 AS upper_90,\n    \n    -- Moving averages for smoothing\n    AVG(daily_co2_kg_mean) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_value,\n    AVG(daily_co2_kg_lower_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_95,\n    AVG(daily_co2_kg_upper_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_95,\n    \n    -- Month-to-date statistics\n    AVG(daily_co2_kg_mean) OVER (PARTITION BY toStartOfMonth(date) ORDER BY date) AS mtd_avg,\n    SUM(daily_co2_kg_mean) OVER (PARTITION BY toStartOfMonth(date) ORDER BY date) AS mtd_total\n    \nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`", "relation_name": "`dbt`.`api_esg_carbon_timeseries_bands`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.433509Z", "completed_at": "2025-09-04T07:25:40.459784Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.464565Z", "completed_at": "2025-09-04T07:25:40.464575Z"}], "thread_id": "Thread-23", "execution_time": 0.055754899978637695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_energy_consumption_annualised_latest", "compiled": true, "compiled_code": "\n\n\nSELECT\n    annual_energy_Mwh_projected\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nORDER BY date DESC \nLIMIT 1", "relation_name": "`dbt`.`api_esg_energy_consumption_annualised_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.429265Z", "completed_at": "2025-09-04T07:25:40.460588Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.466029Z", "completed_at": "2025-09-04T07:25:40.466037Z"}], "thread_id": "Thread-2", "execution_time": 0.057848215103149414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_cif_network_vs_countries_daily", "compiled": true, "compiled_code": "\n\n\nWITH network_daily_cif AS (\n    -- Get network's daily effective carbon intensity\n    SELECT\n        date,\n        effective_carbon_intensity AS carbon_intensity,\n        'GNOSIS' AS entity_code\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE effective_carbon_intensity IS NOT NULL\n        AND effective_carbon_intensity > 0\n),\n\ncountry_monthly_cif AS (\n    -- Get all monthly country carbon intensities \n    SELECT\n        ci.country_code,\n        ci.carbon_intensity_mean AS carbon_intensity,\n        ci.month_date\n    FROM `dbt`.`int_esg_carbon_intensity_ensemble` ci\n    WHERE ci.country_code != 'WORLD'\n        AND ci.carbon_intensity_mean IS NOT NULL\n        AND ci.carbon_intensity_mean > 0\n        AND ci.country_code IN (\n            'USA',  -- United States\n            'DEU',  -- Germany  \n            'CHN',  -- China\n            'FRA',  -- France\n            'SWE',  -- Sweden \n            'AUS',  -- Australia\n            'BRA',  -- Brazil\n            'ISL'   -- Iceland\n        )\n),\n\ncountry_timeseries AS (\n    -- Join countries to dates using the correct month's CIF\n    SELECT\n        nd.date,\n        cm.carbon_intensity,\n        cm.country_code AS entity_code\n    FROM network_daily_cif nd\n    JOIN country_monthly_cif cm \n        ON cm.month_date = toStartOfMonth(nd.date)  -- Match date to its month\n),\n\n-- Combine network and country data\ncombined_data AS (\n    SELECT * FROM network_daily_cif\n    UNION ALL\n    SELECT * FROM country_timeseries\n),\n\n-- Add comparison metrics\nwith_comparisons AS (\n    SELECT\n        cd.*,\n        nd.carbon_intensity AS network_cif\n    FROM combined_data cd\n    LEFT JOIN network_daily_cif nd ON cd.date = nd.date\n)\n\nSELECT\n    date,\n    entity_code,\n    round(carbon_intensity, 1) AS carbon_intensity_gco2_kwh\nFROM with_comparisons\nORDER BY date, entity_code, carbon_intensity_gco2_kwh DESC", "relation_name": "`dbt`.`api_esg_cif_network_vs_countries_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.438485Z", "completed_at": "2025-09-04T07:25:40.461350Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.466918Z", "completed_at": "2025-09-04T07:25:40.466928Z"}], "thread_id": "Thread-8", "execution_time": 0.05377030372619629, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_energy_monthly", "compiled": true, "compiled_code": "\n\n\nSELECT toStartOfMonth(date) AS date, SUM(daily_energy_kwh_total) AS value\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nGROUP BY 1\nORDER BY date", "relation_name": "`dbt`.`api_esg_energy_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.442405Z", "completed_at": "2025-09-04T07:25:40.463006Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.467937Z", "completed_at": "2025-09-04T07:25:40.467945Z"}], "thread_id": "Thread-30", "execution_time": 0.05406308174133301, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_estimated_nodes_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT \n    date\n    ,baseline_observed_nodes\n    ,estimated_nodes\n    ,nodes_lower_95\n    ,nodes_upper_95\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date", "relation_name": "`dbt`.`api_esg_estimated_nodes_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.447142Z", "completed_at": "2025-09-04T07:25:40.463942Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.468805Z", "completed_at": "2025-09-04T07:25:40.468812Z"}], "thread_id": "Thread-19", "execution_time": 0.05371665954589844, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_info_annual_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,label\n    ,mean_val\n    ,lower_95\n    ,upper_95\n    ,lower_90\n    ,upper_90\nFROM (\n    SELECT \n        date\n        ,'Energy (MWh)' AS label\n        ,annual_energy_Mwh_projected AS mean_val\n        ,annual_energy_mwh_lower_95 AS lower_95\n        ,annual_energy_mwh_upper_95 AS upper_95\n        ,annual_energy_mwh_lower_90 AS lower_90\n        ,annual_energy_mwh_upper_90 AS upper_90\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT \n        date\n        ,'CO2e (tonnes)' AS label\n        ,annual_co2_tonnes_projected AS mean_val\n        ,annual_co2_tonnes_lower_95 AS lower_95\n        ,annual_co2_tonnes_upper_95 AS upper_95\n        ,annual_co2_tonnes_lower_90 AS lower_90\n        ,annual_co2_tonnes_upper_90 AS upper_90\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_esg_info_annual_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-09-04T07:25:40.451891Z", "completed_at": "2025-09-04T07:25:40.465484Z"}, {"name": "execute", "started_at": "2025-09-04T07:25:40.469776Z", "completed_at": "2025-09-04T07:25:40.469783Z"}], "thread_id": "Thread-1", "execution_time": 0.0502924919128418, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_info_category_daily", "compiled": true, "compiled_code": "\n\n\n\n\nSELECT \n    date\n    ,label\n    ,category\n    ,value\nFROM (\n    SELECT date, 'Home Staker' AS label, 'CO2e (kg)' AS category, home_staker_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'CO2e (kg)' AS category, professional_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'CO2e (kg)' AS category, cloud_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'CO2e (kg)' AS category, unknown_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n\n    UNION ALL \n\n    SELECT date, 'Home Staker' AS label, 'Energy (kWh)' AS category, home_staker_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'Energy (kWh)' AS category, professional_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'Energy (kWh)' AS category, cloud_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'Energy (kWh)' AS category, unknown_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n\n    UNION ALL \n\n    SELECT date, 'Home Staker' AS label, 'Nodes' AS category, CAST(home_staker_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'Nodes' AS category, CAST(professional_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'Nodes' AS category, CAST(cloud_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'Nodes' AS category, CAST(unknown_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n)\nORDER BY date, label, category", "relation_name": "`dbt`.`api_esg_info_category_daily`", "batch_results": null}], "elapsed_time": 5.818073034286499, "args": {"which": "generate", "macro_debugging": false, "compile": true, "require_nested_cumulative_type_params": false, "log_format": "default", "source_freshness_run_project_hooks": false, "log_level_file": "debug", "strict_mode": false, "partial_parse": true, "exclude": [], "show_resource_report": false, "write_json": true, "profiles_dir": "/home/runner/work/dbt-cerebro/dbt-cerebro", "quiet": false, "log_format_file": "debug", "require_batched_execution_for_custom_microbatch_strategy": false, "version_check": true, "cache_selected_only": false, "use_colors": true, "empty_catalog": false, "log_file_max_bytes": 10485760, "state_modified_compare_vars": false, "print": true, "populate_cache": true, "require_resource_names_without_spaces": false, "require_yaml_configuration_for_mf_time_spines": false, "static_parser": true, "send_anonymous_usage_stats": true, "static": false, "indirect_selection": "eager", "favor_state": false, "partial_parse_file_diff": true, "require_explicit_package_overrides_for_builtin_materializations": true, "skip_nodes_if_on_run_start_fails": false, "warn_error_options": {"include": [], "exclude": []}, "project_dir": "/home/runner/work/dbt-cerebro/dbt-cerebro", "state_modified_compare_more_unrendered_values": false, "select": [], "introspect": true, "use_colors_file": true, "invocation_command": "dbt docs generate", "defer": false, "log_level": "info", "log_path": "/home/runner/work/dbt-cerebro/dbt-cerebro/logs", "vars": {}, "printer_width": 80}}