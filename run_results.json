{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.4", "generated_at": "2025-12-13T16:37:56.435731Z", "invocation_id": "b64ab7a4-abee-4221-a68f-21e6c2ca3184", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.086364Z", "completed_at": "2025-12-13T16:37:52.096721Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.097335Z", "completed_at": "2025-12-13T16:37:52.097351Z"}], "thread_id": "Thread-1", "execution_time": 0.012291431427001953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_labels", "compiled": true, "compiled_code": "\n\nSELECT \n    validator_index\n    ,pubkey\n    ,withdrawal_credentials\nFROM stg_consensus__validators\nWHERE slot = (SELECT MAX(slot) FROM stg_consensus__validators)", "relation_name": "`dbt`.`int_consensus_validators_labels`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.100295Z", "completed_at": "2025-12-13T16:37:52.104424Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.105035Z", "completed_at": "2025-12-13T16:37:52.105042Z"}], "thread_id": "Thread-1", "execution_time": 0.0061070919036865234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__attestations", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    attestation_index,\n    aggregation_bits,\n    signature,\n    attestation_slot,\n    committee_index,\n    beacon_block_root,\n    source_epoch,\n    source_root,\n    target_epoch,\n    target_root,\n    slot_timestamp\nFROM \n    `consensus`.`attestations` FINAL", "relation_name": "`dbt`.`stg_consensus__attestations`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.108039Z", "completed_at": "2025-12-13T16:37:52.112514Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.113127Z", "completed_at": "2025-12-13T16:37:52.113134Z"}], "thread_id": "Thread-1", "execution_time": 0.0065038204193115234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__blob_commitments", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    commitment_index,\n    commitment,\n    slot_timestamp\nFROM \n    `consensus`.`blob_commitments` FINAL", "relation_name": "`dbt`.`stg_consensus__blob_commitments`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.116130Z", "completed_at": "2025-12-13T16:37:52.120257Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.120869Z", "completed_at": "2025-12-13T16:37:52.120876Z"}], "thread_id": "Thread-1", "execution_time": 0.006081581115722656, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__blocks", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    proposer_index,\n    parent_root,\n    state_root,\n    signature,\n    version,\n    randao_reveal,\n    graffiti,\n    eth1_deposit_root,\n    eth1_deposit_count,\n    eth1_block_hash,\n    sync_aggregate_participation,\n    withdrawals_count,\n    blob_kzg_commitments_count,\n    execution_requests_count,\n    slot_timestamp\nFROM \n    `consensus`.`blocks` FINAL", "relation_name": "`dbt`.`stg_consensus__blocks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.123815Z", "completed_at": "2025-12-13T16:37:52.127809Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.128423Z", "completed_at": "2025-12-13T16:37:52.128430Z"}], "thread_id": "Thread-1", "execution_time": 0.0059201717376708984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__deposits", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    deposit_index,\n    pubkey,\n    withdrawal_credentials,\n    amount,\n    signature,\n    proof,\n    slot_timestamp\nFROM \n    `consensus`.`deposits` FINAL", "relation_name": "`dbt`.`stg_consensus__deposits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.131371Z", "completed_at": "2025-12-13T16:37:52.135371Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.135972Z", "completed_at": "2025-12-13T16:37:52.135978Z"}], "thread_id": "Thread-1", "execution_time": 0.0060520172119140625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__execution_requests", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    payload,\n    deposits_count,\n    withdrawals_count,\n    consolidations_count,\n    slot_timestamp\nFROM \n    `consensus`.`execution_requests` FINAL", "relation_name": "`dbt`.`stg_consensus__execution_requests`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.138818Z", "completed_at": "2025-12-13T16:37:52.142902Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.143519Z", "completed_at": "2025-12-13T16:37:52.143526Z"}], "thread_id": "Thread-1", "execution_time": 0.0060236454010009766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__rewards", "compiled": true, "compiled_code": "\n\nSELECT\n    slot\n    proposer_index,\n    total,\n    attestations,\n    sync_aggregate,\n    proposer_slashings,\n    attester_slashings,\n    slot_timestamp\nFROM \n    `consensus`.`rewards` FINAL", "relation_name": "`dbt`.`stg_consensus__rewards`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.146394Z", "completed_at": "2025-12-13T16:37:52.151156Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.151742Z", "completed_at": "2025-12-13T16:37:52.151749Z"}], "thread_id": "Thread-1", "execution_time": 0.006609439849853516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__specs", "compiled": true, "compiled_code": "\n\nSELECT\n    parameter_name,\n    parameter_value,\nFROM \n    `consensus`.`specs` FINAL", "relation_name": "`dbt`.`stg_consensus__specs`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.154425Z", "completed_at": "2025-12-13T16:37:52.158247Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.158827Z", "completed_at": "2025-12-13T16:37:52.158834Z"}], "thread_id": "Thread-1", "execution_time": 0.005663633346557617, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__time_helpers", "compiled": true, "compiled_code": "\n\nSELECT\n    genesis_time_unix,\n    seconds_per_slot,\n    slots_per_epoch\nFROM \n    `consensus`.`time_helpers` FINAL", "relation_name": "`dbt`.`stg_consensus__time_helpers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.161692Z", "completed_at": "2025-12-13T16:37:52.165627Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.166257Z", "completed_at": "2025-12-13T16:37:52.166264Z"}], "thread_id": "Thread-1", "execution_time": 0.0058536529541015625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__validators", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    validator_index,\n    balance,\n    status,\n    pubkey,\n    withdrawal_credentials,\n    effective_balance,\n    slashed,\n    activation_eligibility_epoch,\n    activation_epoch,\n    exit_epoch,\n    withdrawable_epoch,\n    slot_timestamp\nFROM \n    `consensus`.`validators` FINAL\nWHERE balance > 0", "relation_name": "`dbt`.`stg_consensus__validators`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.169114Z", "completed_at": "2025-12-13T16:37:52.173250Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.173861Z", "completed_at": "2025-12-13T16:37:52.173868Z"}], "thread_id": "Thread-1", "execution_time": 0.006116390228271484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__withdrawals", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    block_number,\n    block_hash,\n    withdrawal_index,\n    validator_index,\n    address,\n    amount,\n    slot_timestamp\nFROM \n    `consensus`.`withdrawals` FINAL", "relation_name": "`dbt`.`stg_consensus__withdrawals`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.176741Z", "completed_at": "2025-12-13T16:37:52.180943Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.181591Z", "completed_at": "2025-12-13T16:37:52.181598Z"}], "thread_id": "Thread-1", "execution_time": 0.006208658218383789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__country_codes", "compiled": true, "compiled_code": "\n\n\nSELECT\n    \"name\",\n    \"alpha-2\",\n    \"alpha-3\",\n    \"country-code\",\n    \"iso_3166-2\",\n    \"region\",\n    \"sub-region\",\n    \"intermediate-region\",\n    \"region-code\",\n    \"sub-region-code\",\n    \"intermediate-region-code\"\nFROM\n    `crawlers_data`.`country_codes`", "relation_name": "`dbt`.`stg_crawlers_data__country_codes`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.184372Z", "completed_at": "2025-12-13T16:37:52.188444Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.189043Z", "completed_at": "2025-12-13T16:37:52.189050Z"}], "thread_id": "Thread-1", "execution_time": 0.006041288375854492, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_bridge_flows", "compiled": true, "compiled_code": "\n\nSELECT\n  timestamp,\n  bridge,\n  source_chain,\n  dest_chain,\n  token,\n  toFloat64(amount_token) AS amount_token,\n  toFloat64(amount_usd)   AS amount_usd,\n  toFloat64(net_usd)      AS net_usd,         \n  CASE\n    WHEN dest_chain   = 'gnosis' THEN 'in'\n    WHEN source_chain = 'gnosis' THEN 'out'\n    ELSE 'xchain'\n  END AS direction\nFROM `crawlers_data`.`dune_bridge_flows`", "relation_name": "`dbt`.`stg_crawlers_data__dune_bridge_flows`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.191885Z", "completed_at": "2025-12-13T16:37:52.196882Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.197515Z", "completed_at": "2025-12-13T16:37:52.197522Z"}], "thread_id": "Thread-1", "execution_time": 0.006981611251831055, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_gno_supply", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    label,\n    block_date,\n    supply\nFROM `crawlers_data`.`dune_gno_supply`", "relation_name": "`dbt`.`stg_crawlers_data__dune_gno_supply`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.200244Z", "completed_at": "2025-12-13T16:37:52.204077Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.204675Z", "completed_at": "2025-12-13T16:37:52.204682Z"}], "thread_id": "Thread-1", "execution_time": 0.005698204040527344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_prices", "compiled": true, "compiled_code": "\n\nSELECT\n  toDate(block_date)                    AS date,\n  upper(symbol)                         AS symbol,\n  anyLast(toFloat64(price))             AS price   \nFROM `crawlers_data`.`dune_prices`\nGROUP BY date, symbol\nORDER BY date, symbol", "relation_name": "`dbt`.`stg_crawlers_data__dune_prices`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.207541Z", "completed_at": "2025-12-13T16:37:52.211413Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.212038Z", "completed_at": "2025-12-13T16:37:52.212045Z"}], "thread_id": "Thread-1", "execution_time": 0.005838155746459961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__ember_electricity_data", "compiled": true, "compiled_code": "\n\n\nSELECT\n    \"Area\",\n    \"ISO 3 code\",\n    \"Date\",\n    \"Area type\",\n    \"Continent\",\n    \"Ember region\",\n    \"EU\" ,\n    \"OECD\",\n    \"G20\",\n    \"G7\",\n    \"ASEAN\",\n    \"Category\",\n    \"Subcategory\",\n    \"Variable\",\n    \"Unit\",\n    \"Value\",\n    \"YoY absolute change\",\n    \"YoY % change\" \nFROM\n    `crawlers_data`.`ember_electricity_data`", "relation_name": "`dbt`.`stg_crawlers_data__ember_electricity_data`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.214917Z", "completed_at": "2025-12-13T16:37:52.219529Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.220179Z", "completed_at": "2025-12-13T16:37:52.220187Z"}], "thread_id": "Thread-1", "execution_time": 0.006632328033447266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__ipinfo", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    ip,\n    hostname,\n    city,\n    region,\n    country,\n    loc,\n    org,\n    postal,\n    timezone,\n    asn,\n    company,\n    carrier,\n    is_bogon,\n    is_mobile,\n    multiIf(\n      lowerUTF8(org) ILIKE '%amazon web services%' OR lowerUTF8(org) ILIKE '%amazon data services%' OR lowerUTF8(org) ILIKE '%aws%' OR lowerUTF8(org) ILIKE '%amazon.com%', 'AWS',\n      (lowerUTF8(org) ILIKE '%google cloud%' OR lowerUTF8(org) ILIKE '%google llc%' OR lowerUTF8(org) ILIKE '%gcp%' OR lowerUTF8(org) ILIKE '%google%') AND lowerUTF8(org) NOT ILIKE '%fiber%', 'Google',\n      lowerUTF8(org) ILIKE '%microsoft azure%' OR lowerUTF8(org) ILIKE '%azure%' OR lowerUTF8(org) ILIKE '%microsoft corporation%' OR lowerUTF8(org) ILIKE '%msft%', 'Azure',\n      lowerUTF8(org) ILIKE '%oracle cloud%' OR lowerUTF8(org) ILIKE '%oracle america%' OR lowerUTF8(org) ILIKE '%oci%', 'Oracle Cloud',\n      lowerUTF8(org) ILIKE '%alibaba cloud%' OR lowerUTF8(org) ILIKE '%aliyun%' OR lowerUTF8(org) ILIKE '%alibaba%', 'Alibaba Cloud',\n\n      lowerUTF8(org) ILIKE '%cloudflare%', 'Cloudflare',\n      (lowerUTF8(org) ILIKE '%akamai%' AND lowerUTF8(org) NOT ILIKE '%linode%'), 'Akamai',\n      lowerUTF8(org) ILIKE '%fastly%', 'Fastly',\n\n      lowerUTF8(org) ILIKE '%digitalocean%' OR lowerUTF8(org) ILIKE '%digital ocean%', 'DigitalOcean',\n      lowerUTF8(org) ILIKE '%ovh%', 'OVHcloud',\n      lowerUTF8(org) ILIKE '%hetzner%', 'Hetzner',\n      lowerUTF8(org) ILIKE '%scaleway%' OR lowerUTF8(org) ILIKE '%online s.a.s%' OR lowerUTF8(org) ILIKE '%iliad%', 'Scaleway',\n      lowerUTF8(org) ILIKE '%linode%', 'Linode',\n      lowerUTF8(org) ILIKE '%vultr%' OR lowerUTF8(org) ILIKE '%choopa%', 'Vultr',\n      lowerUTF8(org) ILIKE '%equinix metal%' OR lowerUTF8(org) ILIKE '%packet host%' OR lowerUTF8(org) ILIKE '%packet, inc%', 'Equinix Metal',\n      lowerUTF8(org) ILIKE '%fly.io%' OR lowerUTF8(org) ILIKE '%fly io%', 'Fly.io',\n      lowerUTF8(org) ILIKE '%netlify%', 'Netlify',\n      lowerUTF8(org) ILIKE '%vercel%' OR lowerUTF8(org) ILIKE '%zeit%', 'Vercel',\n      lowerUTF8(org) ILIKE '%heroku%', 'Heroku',\n      lowerUTF8(org) ILIKE '%render.com%' OR lowerUTF8(org) ILIKE '% render %', 'Render',\n\n      -- Carrier / transit networks (keep as its own bucket; change to 'Public ISP (Home/Office)' if you prefer)\n      lowerUTF8(org) ILIKE '%cogent%' OR lowerUTF8(org) ILIKE '%lumen%' OR lowerUTF8(org) ILIKE '%level 3%' OR lowerUTF8(org) ILIKE '%centurylink%' OR\n      lowerUTF8(org) ILIKE '%telia carrier%' OR lowerUTF8(org) ILIKE '%arelion%' OR lowerUTF8(org) ILIKE '%gtt%' OR lowerUTF8(org) ILIKE '%hurricane electric%' OR\n      lowerUTF8(org) ILIKE '%he.net%' OR lowerUTF8(org) ILIKE '%ntt communications%' OR lowerUTF8(org) ILIKE '%tata communications%' OR lowerUTF8(org) ILIKE '%zayo%' OR\n      lowerUTF8(org) ILIKE '%kddi%' OR lowerUTF8(org) ILIKE '%sparkle%' OR lowerUTF8(org) ILIKE '%backbone%' OR lowerUTF8(org) ILIKE '%chinanet-backbone%', 'Carrier/Transit',\n\n      -- Education / government \u2192 treat like public access\n      lowerUTF8(org) ILIKE '%university%' OR lowerUTF8(org) ILIKE '%college%' OR lowerUTF8(org) ILIKE '%school%' OR lowerUTF8(org) ILIKE '%ministry%' OR lowerUTF8(org) ILIKE '%government%', 'Public ISP (Home/Office)',\n\n      -- Generic hosting/CDN hints\n      lowerUTF8(org) ILIKE '%datacenter%' OR lowerUTF8(org) ILIKE '%data center%' OR lowerUTF8(org) ILIKE '%colo%' OR lowerUTF8(org) ILIKE '%hosting%' OR lowerUTF8(org) ILIKE '%vps%' OR lowerUTF8(org) ILIKE '%server%' OR lowerUTF8(org) ILIKE '%incapsula%' OR lowerUTF8(org) ILIKE '%imperva%', 'Hosting/CDN (Other)',\n\n      -- Fallback for residential & office ISPs\n      lowerUTF8(org) ILIKE '%telecom%' OR lowerUTF8(org) ILIKE '%telekom%' OR lowerUTF8(org) ILIKE '%telecommunications%' OR lowerUTF8(org) ILIKE '%communications%' OR lowerUTF8(org) ILIKE '%wireless%' OR\n      lowerUTF8(org) ILIKE '%cable%' OR lowerUTF8(org) ILIKE '%broadband%' OR lowerUTF8(org) ILIKE '%internet%' OR lowerUTF8(org) ILIKE '%fibre%' OR lowerUTF8(org) ILIKE '%fiber%' OR lowerUTF8(org) ILIKE '%mobile%', 'Public ISP (Home/Office)',\n      lowerUTF8(org) = '', 'Unknown',\n      'Public ISP (Home/Office)'\n  ) AS generic_provider\n  FROM `crawlers_data`.`ipinfo` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_crawlers_data__ipinfo`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.222912Z", "completed_at": "2025-12-13T16:37:52.226862Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.227484Z", "completed_at": "2025-12-13T16:37:52.227491Z"}], "thread_id": "Thread-1", "execution_time": 0.005859375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_agent_semvers_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    agent_version_semver,\n    agent_version_semver_str,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_agent_semvers_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.230385Z", "completed_at": "2025-12-13T16:37:52.234363Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.234960Z", "completed_at": "2025-12-13T16:37:52.234971Z"}], "thread_id": "Thread-1", "execution_time": 0.005893707275390625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_cloud_provider_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    cloud_provider,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_cloud_provider_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.237808Z", "completed_at": "2025-12-13T16:37:52.242887Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.243535Z", "completed_at": "2025-12-13T16:37:52.243542Z"}], "thread_id": "Thread-1", "execution_time": 0.007070779800415039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_countries_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    country_name,\n    country,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_countries_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_countries_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.246433Z", "completed_at": "2025-12-13T16:37:52.250307Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.250906Z", "completed_at": "2025-12-13T16:37:52.250913Z"}], "thread_id": "Thread-1", "execution_time": 0.005803108215332031, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_quic_support_over_7d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    crawl_created_at,\n    quic_support,\n    __count,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_quic_support_over_7d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_quic_support_over_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.254003Z", "completed_at": "2025-12-13T16:37:52.258437Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.259061Z", "completed_at": "2025-12-13T16:37:52.259068Z"}], "thread_id": "Thread-1", "execution_time": 0.006646394729614258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__blocks", "compiled": true, "compiled_code": "\n\n\nWITH\n\nsource AS (\n    SELECT \n        block_number,\n        block_hash,\n        parent_hash,\n        uncles_hash,\n        author,\n        state_root,\n        transactions_root,\n        receipts_root,\n        gas_used,\n        gas_limit,\n        extra_data,\n        size,\n        mix_hash,\n        nonce,\n        base_fee_per_gas,\n        withdrawals_root,\n        block_timestamp\n    FROM \n        `execution`.`blocks`\n    WHERE \n        block_timestamp > '1970-01-01' -- remove genesis\n)\n\nSELECT\n    block_number,\n    block_hash,\n    parent_hash,\n    uncles_hash,\n    CONCAT('0x',author) AS author,\n    state_root,\n    transactions_root,\n    receipts_root,\n    gas_used,\n    gas_limit,\n    extra_data,\n    \narrayFilter(\n    x -> x != '',\n    /* split on every \u201cnon word-ish\u201d character (dash, @, space, etc.) */\n    splitByRegexp(\n        '[^A-Za-z0-9\\\\.]+',            -- \u21fd anything that isn\u2019t a\u2013z, 0\u20139 or \u201c.\u201d\n        arrayStringConcat(\n            arrayMap(\n                i -> if(\n                    reinterpretAsUInt8(substring(unhex(coalesce(extra_data, '')), i, 1)) BETWEEN 32 AND 126,\n                    reinterpretAsString(substring(unhex(coalesce(extra_data, '')), i, 1)),\n                    ' '\n                ),\n                range(1, length(unhex(coalesce(extra_data, ''))) + 1)\n            ),\n            ''\n        )\n    )\n)\n AS decoded_extra_data,\n    size,\n    mix_hash,\n    nonce,\n    base_fee_per_gas,\n    withdrawals_root,\n    block_timestamp\nFROM source", "relation_name": "`dbt`.`stg_execution__blocks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.262068Z", "completed_at": "2025-12-13T16:37:52.266029Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.266658Z", "completed_at": "2025-12-13T16:37:52.266666Z"}], "thread_id": "Thread-1", "execution_time": 0.006071329116821289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__logs", "compiled": true, "compiled_code": "\n\n\nWITH\n\nsource AS (\n    SELECT\n    block_number,\n    block_hash,\n    transaction_index,\n    log_index,\n    transaction_hash,\n    CONCAT('0x',address) AS address,\n    CONCAT('0x',topic0) AS topic0,\n    topic1,\n    topic2,\n    topic3,\n    data,\n    n_data_bytes,\n    block_timestamp\n    FROM `execution`.`logs`\n)\n\nSELECT\n   *\nFROM source", "relation_name": "`dbt`.`stg_execution__logs`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.269478Z", "completed_at": "2025-12-13T16:37:52.273732Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.274370Z", "completed_at": "2025-12-13T16:37:52.274377Z"}], "thread_id": "Thread-1", "execution_time": 0.006245613098144531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__storage_diffs", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n    SELECT \n        block_number,\n        transaction_index,\n        CONCAT('0x', transaction_hash) AS transaction_hash,\n        CONCAT('0x', address) AS address,\n        slot,\n        from_value,\n        to_value,\n        block_timestamp\n    FROM \n        `execution`.`storage_diffs`\n)\n\nSELECT\n    *\nFROM source", "relation_name": "`dbt`.`stg_execution__storage_diffs`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.277282Z", "completed_at": "2025-12-13T16:37:52.282366Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.282961Z", "completed_at": "2025-12-13T16:37:52.282968Z"}], "thread_id": "Thread-1", "execution_time": 0.007143974304199219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__transactions", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n    SELECT\n        block_number,\n        transaction_index,\n        transaction_hash,\n        nonce,\n        from_address,\n        to_address,\n        value_string,\n        input,\n        gas_limit,\n        gas_used,\n        gas_price,\n        transaction_type,\n        max_priority_fee_per_gas,\n        max_fee_per_gas,\n        success,\n        n_input_bytes,\n        n_input_zero_bytes,\n        n_input_nonzero_bytes,\n        n_rlp_bytes,\n        r,\n        s,\n        v,\n        block_hash,\n        block_timestamp\n    FROM `execution`.`transactions` FINAL\n)\n\nSELECT\n    block_number,\n    transaction_index,\n    transaction_hash,\n    nonce,\n    CONCAT('0x',from_address) AS from_address,\n    IF(to_address IS NULL, NULL, CONCAT('0x',to_address)) AS to_address,\n    CAST(value_string AS UInt256) AS value,\n    input,\n    gas_limit,\n    gas_used,\n    gas_price,\n    transaction_type,\n    max_priority_fee_per_gas,\n    max_fee_per_gas,\n    success,\n    n_input_bytes,\n    n_input_zero_bytes,\n    n_input_nonzero_bytes,\n    n_rlp_bytes,\n    r,\n    s,\n    v,\n    block_hash,\n    block_timestamp\nFROM source", "relation_name": "`dbt`.`stg_execution__transactions`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.285852Z", "completed_at": "2025-12-13T16:37:52.289822Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.290452Z", "completed_at": "2025-12-13T16:37:52.290459Z"}], "thread_id": "Thread-1", "execution_time": 0.005906343460083008, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__discovery_id_prefixes_x_peer_ids", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    discovery_id_prefix,\n    peer_id\n  FROM `nebula_discv4`.`discovery_id_prefixes_x_peer_ids` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.293265Z", "completed_at": "2025-12-13T16:37:52.297259Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.297859Z", "completed_at": "2025-12-13T16:37:52.297866Z"}], "thread_id": "Thread-1", "execution_time": 0.0059621334075927734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__neighbors", "compiled": true, "compiled_code": "\n\nWITH \n\nsource AS (\n  SELECT \n    crawl_id,\n    crawl_created_at,\n    peer_discovery_id_prefix,\n    neighbor_discovery_id_prefix,\n    error_bits\n  FROM `nebula_discv4`.`neighbors` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__neighbors`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.301183Z", "completed_at": "2025-12-13T16:37:52.305155Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.305757Z", "completed_at": "2025-12-13T16:37:52.305764Z"}], "thread_id": "Thread-1", "execution_time": 0.006067752838134766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__visits", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    crawl_id,\n    peer_id,\n    agent_version,\n    protocols,\n    dial_maddrs,\n    filtered_maddrs,\n    extra_maddrs,\n    dial_errors,\n    connect_maddr,\n    crawl_error,\n    visit_started_at,\n    visit_ended_at,\n    peer_properties\n  FROM `nebula_discv4`.`visits` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__visits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.308689Z", "completed_at": "2025-12-13T16:37:52.312655Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.313326Z", "completed_at": "2025-12-13T16:37:52.313333Z"}], "thread_id": "Thread-1", "execution_time": 0.0061609745025634766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__discovery_id_prefixes_x_peer_ids", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    discovery_id_prefix,\n    peer_id\n  FROM `nebula`.`discovery_id_prefixes_x_peer_ids` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.316197Z", "completed_at": "2025-12-13T16:37:52.320188Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.320770Z", "completed_at": "2025-12-13T16:37:52.320777Z"}], "thread_id": "Thread-1", "execution_time": 0.005873680114746094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__neighbors", "compiled": true, "compiled_code": "\n\nWITH \n\nsource AS (\n  SELECT \n    crawl_id,\n    crawl_created_at,\n    peer_discovery_id_prefix,\n    neighbor_discovery_id_prefix,\n    error_bits\n  FROM `nebula`.`neighbors` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__neighbors`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.323612Z", "completed_at": "2025-12-13T16:37:52.328741Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.329388Z", "completed_at": "2025-12-13T16:37:52.329395Z"}], "thread_id": "Thread-1", "execution_time": 0.007147312164306641, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__visits", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    crawl_id,\n    peer_id,\n    agent_version,\n    protocols,\n    dial_maddrs,\n    filtered_maddrs,\n    extra_maddrs,\n    dial_errors,\n    connect_maddr,\n    crawl_error,\n    visit_started_at,\n    visit_ended_at,\n    peer_properties\n  FROM `nebula`.`visits` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__visits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.332291Z", "completed_at": "2025-12-13T16:37:52.334249Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.334837Z", "completed_at": "2025-12-13T16:37:52.334844Z"}], "thread_id": "Thread-1", "execution_time": 0.0040130615234375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.contracts_abi", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.337419Z", "completed_at": "2025-12-13T16:37:52.339288Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.339840Z", "completed_at": "2025-12-13T16:37:52.339847Z"}], "thread_id": "Thread-1", "execution_time": 0.003643035888671875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.event_signatures", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.343038Z", "completed_at": "2025-12-13T16:37:52.344879Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.345487Z", "completed_at": "2025-12-13T16:37:52.345494Z"}], "thread_id": "Thread-1", "execution_time": 0.004205226898193359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.function_signatures", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.348200Z", "completed_at": "2025-12-13T16:37:52.350025Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.350630Z", "completed_at": "2025-12-13T16:37:52.350639Z"}], "thread_id": "Thread-1", "execution_time": 0.0037648677825927734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.tokens_whitelist", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.353629Z", "completed_at": "2025-12-13T16:37:52.367575Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.368155Z", "completed_at": "2025-12-13T16:37:52.368162Z"}], "thread_id": "Thread-1", "execution_time": 0.015861988067626953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_validators_labels_validator_index.ecfc429170", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect validator_index\nfrom `dbt`.`int_consensus_validators_labels`\nwhere validator_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.370694Z", "completed_at": "2025-12-13T16:37:52.377608Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.378190Z", "completed_at": "2025-12-13T16:37:52.378197Z"}], "thread_id": "Thread-1", "execution_time": 0.00872492790222168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_consensus_validators_labels_validator_index.b102725776", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    validator_index as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_consensus_validators_labels`\nwhere validator_index is not null\ngroup by validator_index\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.380871Z", "completed_at": "2025-12-13T16:37:52.388619Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.389229Z", "completed_at": "2025-12-13T16:37:52.389237Z"}], "thread_id": "Thread-1", "execution_time": 0.009634256362915039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_attestations_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,slot - attestation_slot AS inclusion_delay\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__attestations`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_attestations_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_attestations_daily` AS x2\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_attestations_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.391915Z", "completed_at": "2025-12-13T16:37:52.396738Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.397338Z", "completed_at": "2025-12-13T16:37:52.397345Z"}], "thread_id": "Thread-1", "execution_time": 0.006751298904418945, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__attestations_attestation_index.58b9a4912c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect attestation_index\nfrom `dbt`.`stg_consensus__attestations`\nwhere attestation_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.399928Z", "completed_at": "2025-12-13T16:37:52.404476Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.405041Z", "completed_at": "2025-12-13T16:37:52.405048Z"}], "thread_id": "Thread-1", "execution_time": 0.0063626766204833984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__attestations_committee_index.5a5ae311f8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect committee_index\nfrom `dbt`.`stg_consensus__attestations`\nwhere committee_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.407662Z", "completed_at": "2025-12-13T16:37:52.413127Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.413688Z", "completed_at": "2025-12-13T16:37:52.413695Z"}], "thread_id": "Thread-1", "execution_time": 0.007269859313964844, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__attestations_slot_timestamp.590b7f0b9d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__attestations`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.416390Z", "completed_at": "2025-12-13T16:37:52.421653Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.422257Z", "completed_at": "2025-12-13T16:37:52.422264Z"}], "thread_id": "Thread-1", "execution_time": 0.007142305374145508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_blob_commitments_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__blob_commitments`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_blob_commitments_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_blob_commitments_daily` AS x2\n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_consensus_blob_commitments_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.424829Z", "completed_at": "2025-12-13T16:37:52.429465Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.430048Z", "completed_at": "2025-12-13T16:37:52.430055Z"}], "thread_id": "Thread-1", "execution_time": 0.006488323211669922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__blob_commitments_commitment_index.ddcbbbd385", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect commitment_index\nfrom `dbt`.`stg_consensus__blob_commitments`\nwhere commitment_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.432696Z", "completed_at": "2025-12-13T16:37:52.437129Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.437690Z", "completed_at": "2025-12-13T16:37:52.437697Z"}], "thread_id": "Thread-1", "execution_time": 0.0062313079833984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__blob_commitments_slot_timestamp.969dc885e2", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__blob_commitments`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.440410Z", "completed_at": "2025-12-13T16:37:52.446110Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.446711Z", "completed_at": "2025-12-13T16:37:52.446718Z"}], "thread_id": "Thread-1", "execution_time": 0.007639408111572266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_graffiti_daily", "compiled": true, "compiled_code": "\n\nWITH\n    -- Canonical lists\n    ['nethermind','erigon','geth','besu','reth'] AS el_keys,\n    ['Nethermind','Erigon','Geth','Besu','Reth'] AS el_names,\n    ['lighthouse','teku','prysm','lodestar','nimbus'] AS cl_keys,\n    ['Lighthouse','Teku','Prysm','Lodestar','Nimbus'] AS cl_names,\n\n    -- Platform/hosting brands \n    ['dappnode','avado','allnodes','twinstake','stakewise','gateway','kleros',\n     'filoozom','kpk-validators','hopr','digitalconsultantsllc',\n     'synthex'] AS brand_keys,\n    ['DappNode','Avado','Allnodes','Twinstake','StakeWise','gateway.fm','kleros.io',\n     'filoozom.eth','kpk-validators','HOPR','DigitalConsultantsLLC.xyz',\n     'Synthex'] AS brand_names,\n\n\nfinal AS (\n    SELECT\n        date\n        ,graffiti\n        ,cnt\n        -- Lowercased text to search in\n        ,lowerUTF8(graffiti) AS g\n\n        -- Detect any brand first (highest precedence)\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, brand_keys) AS brands_found\n        ,if(length(brands_found) > 0,\n            arrayElement(brand_names, indexOf(brand_keys, brands_found[1])),\n            null) AS brand_label\n\n        -- Detect EL/CL clients (order-insensitive, separator-agnostic)\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, el_keys) AS el_found\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, cl_keys) AS cl_found\n\n        -- Pick the first match per side by priority order above\n        ,if(length(el_found) > 0,\n            arrayElement(el_names, indexOf(el_keys, el_found[1])),\n            null) AS el_label\n\n        ,if(length(cl_found) > 0,\n            arrayElement(cl_names, indexOf(cl_keys, cl_found[1])),\n            null) AS cl_label\n\n        -- Final label priority:\n        -- 1) Brand/platform if any\n        -- 2) EL+CL combo if both found\n        -- 3) Single client if only one side found\n        -- 4) Other\n        ,coalesce(\n            brand_label,\n            if(el_label IS NOT NULL AND cl_label IS NOT NULL, concat(el_label, '+', cl_label), null),\n            el_label,\n            cl_label,\n            if(graffiti = 'None', graffiti, null),\n            'Other'\n        ) AS label\n    FROM (\n        SELECT\n            toStartOfDay(slot_timestamp) AS date\n            ,IF(graffiti='0x0000000000000000000000000000000000000000000000000000000000000000', \n                'None', \n                unhex(right(graffiti,-2))\n            ) AS graffiti\n            ,COUNT(*) AS cnt\n        FROM `dbt`.`stg_consensus__blocks`\n        WHERE\n            slot_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_graffiti_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_graffiti_daily` AS x2\n    )\n  \n\n        GROUP BY 1, 2\n    )\n)\n\nSELECT\n    date\n    ,graffiti\n    ,label\n    ,cnt\nFROM final", "relation_name": "`dbt`.`int_consensus_graffiti_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.449456Z", "completed_at": "2025-12-13T16:37:52.454151Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.454731Z", "completed_at": "2025-12-13T16:37:52.454738Z"}], "thread_id": "Thread-1", "execution_time": 0.006649494171142578, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__blocks_eth1_block_hash.0ea22711e9", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect eth1_block_hash\nfrom `dbt`.`stg_consensus__blocks`\nwhere eth1_block_hash is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.457356Z", "completed_at": "2025-12-13T16:37:52.462839Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.463428Z", "completed_at": "2025-12-13T16:37:52.463435Z"}], "thread_id": "Thread-1", "execution_time": 0.007322549819946289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__blocks_proposer_index.67fbc80e41", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect proposer_index\nfrom `dbt`.`stg_consensus__blocks`\nwhere proposer_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.466028Z", "completed_at": "2025-12-13T16:37:52.470452Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.471004Z", "completed_at": "2025-12-13T16:37:52.471011Z"}], "thread_id": "Thread-1", "execution_time": 0.00628209114074707, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__blocks_slot_timestamp.fbaaf552e6", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__blocks`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.473626Z", "completed_at": "2025-12-13T16:37:52.477976Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.478564Z", "completed_at": "2025-12-13T16:37:52.478572Z"}], "thread_id": "Thread-1", "execution_time": 0.0062427520751953125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_consensus__blocks_eth1_block_hash.9c6bcdba18", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    eth1_block_hash as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_consensus__blocks`\nwhere eth1_block_hash is not null\ngroup by eth1_block_hash\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.481256Z", "completed_at": "2025-12-13T16:37:52.485641Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.486213Z", "completed_at": "2025-12-13T16:37:52.486220Z"}], "thread_id": "Thread-1", "execution_time": 0.006300210952758789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__deposits_deposit_index.e7a756cb32", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect deposit_index\nfrom `dbt`.`stg_consensus__deposits`\nwhere deposit_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.488801Z", "completed_at": "2025-12-13T16:37:52.493212Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.493765Z", "completed_at": "2025-12-13T16:37:52.493772Z"}], "thread_id": "Thread-1", "execution_time": 0.006264448165893555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__deposits_slot_timestamp.761249155f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__deposits`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.496390Z", "completed_at": "2025-12-13T16:37:52.501754Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.502329Z", "completed_at": "2025-12-13T16:37:52.502336Z"}], "thread_id": "Thread-1", "execution_time": 0.007223844528198242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__execution_requests_slot_timestamp.fa392e26f6", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__execution_requests`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.504901Z", "completed_at": "2025-12-13T16:37:52.509329Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.509880Z", "completed_at": "2025-12-13T16:37:52.509887Z"}], "thread_id": "Thread-1", "execution_time": 0.0062580108642578125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__rewards_proposer_index.ea1712fd1f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect proposer_index\nfrom `dbt`.`stg_consensus__rewards`\nwhere proposer_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.512498Z", "completed_at": "2025-12-13T16:37:52.516887Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.517463Z", "completed_at": "2025-12-13T16:37:52.517470Z"}], "thread_id": "Thread-1", "execution_time": 0.006257295608520508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__rewards_slot_timestamp.7144033664", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__rewards`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.520137Z", "completed_at": "2025-12-13T16:37:52.524645Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.525251Z", "completed_at": "2025-12-13T16:37:52.525259Z"}], "thread_id": "Thread-1", "execution_time": 0.006464719772338867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_forks", "compiled": true, "compiled_code": "\n\nWITH\n\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\nfork_version AS (\n    SELECT\n        IF(fork_name='GENESIS', 'PHASE0', fork_name) AS fork_name\n        ,parameter_value\n    FROM (\n        SELECT\n            arrayElement(splitByChar('_', ifNull(parameter_name, '')), 1) AS fork_name\n            ,parameter_value\n        FROM `dbt`.`stg_consensus__specs`\n        WHERE parameter_name LIKE '%_FORK_VERSION'\n    )\n),\n\nfork_epoch AS (\n    SELECT\n        arrayElement(splitByChar('_', ifNull(parameter_name, '')), 1) AS fork_name\n        ,parameter_value\n    FROM `dbt`.`stg_consensus__specs`\n    WHERE parameter_name LIKE '%_FORK_EPOCH'\n\n    UNION ALL \n\n    SELECT 'PHASE0' AS fork_name, '0' AS parameter_value \n)\n\nSELECT \n  t1.cl_fork_name AS fork_name\n  ,t2.parameter_value AS fork_version \n  ,t1.fork_digest AS fork_digest\n  ,t3.parameter_value AS fork_epoch \n  ,IF(CAST(t3.parameter_value AS Int) = -1, NULL,\n    addSeconds(\n          toDateTime(t4.genesis_time_unix, 'UTC'),\n          CAST(t3.parameter_value AS Int) * (t4.seconds_per_slot * t4.slots_per_epoch )\n      )\n   ) AS fork_time\nFROM \n  fork_digests t1\nINNER JOIN\n  fork_version t2\n  ON LOWER(t2.fork_name) = LOWER(t1.cl_fork_name)\nINNER JOIN\n  fork_epoch t3\n  ON LOWER(t3.fork_name) = LOWER(t1.cl_fork_name)\nCROSS JOIN `dbt`.`stg_consensus__time_helpers` t4", "relation_name": "`dbt`.`fct_consensus_forks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.528019Z", "completed_at": "2025-12-13T16:37:52.533828Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.534423Z", "completed_at": "2025-12-13T16:37:52.534430Z"}], "thread_id": "Thread-1", "execution_time": 0.007686614990234375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_blocks_daily", "compiled": true, "compiled_code": "\n\nWITH\n\ntime_helpers AS (\n    SELECT\n        genesis_time_unix,\n        seconds_per_slot\n    FROM \n        `dbt`.`stg_consensus__time_helpers`\n)\n\nSELECT\n    date\n    ,cnt AS blocks_produced\n    ,total_blob_commitments\n    ,blocks_with_zero_blob_commitments\n    ,CASE\n        WHEN toStartOfDay(toDateTime(genesis_time_unix)) = date \n            THEN CAST((86400 - toUnixTimestamp(toDateTime(genesis_time_unix)) % 86400) / seconds_per_slot - cnt AS UInt64)\n        ELSE CAST(86400 / seconds_per_slot - cnt AS UInt64)\n    END AS blocks_missed\nFROM (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date\n        ,COUNT(*) AS cnt\n        ,SUM(blob_kzg_commitments_count) AS total_blob_commitments\n        ,SUM(IF(blob_kzg_commitments_count = 0, 1, 0)) AS blocks_with_zero_blob_commitments\n    FROM `dbt`.`stg_consensus__blocks`\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_blocks_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_blocks_daily` AS x2\n    )\n  \n\n    GROUP BY 1\n) t1\nCROSS JOIN time_helpers t2", "relation_name": "`dbt`.`int_consensus_blocks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.537304Z", "completed_at": "2025-12-13T16:37:52.542811Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.543432Z", "completed_at": "2025-12-13T16:37:52.543439Z"}], "thread_id": "Thread-1", "execution_time": 0.007653236389160156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_credentials_daily", "compiled": true, "compiled_code": "\n\n\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,leftUTF8(withdrawal_credentials, 4) AS credentials_type\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__validators`\n\n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_credentials_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_credentials_daily` AS x2\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_credentials_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.546038Z", "completed_at": "2025-12-13T16:37:52.552940Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.553568Z", "completed_at": "2025-12-13T16:37:52.553577Z"}], "thread_id": "Thread-1", "execution_time": 0.008782625198364258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_entry_queue_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nqueue_activation AS (\n    SELECT\n        validator_index\n        ,date\n        ,epoch_eligibility\n        ,epoch_activation\n        ,(epoch_activation - epoch_eligibility) * 16 * 5 /(60 * 60 * 24) AS activation_days\n    FROM (\n        SELECT \n            validator_index\n            ,toStartOfDay(argMin(slot_timestamp,slot)) AS date\n            ,argMin(activation_eligibility_epoch,slot) AS epoch_eligibility\n            ,argMin(activation_epoch,slot) AS epoch_activation\n        FROM `dbt`.`stg_consensus__validators`\n        WHERE \n            activation_epoch < 18446744073709551615\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_entry_queue_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_entry_queue_daily` AS x2\n    )\n  \n\n        GROUP BY 1\n    )\n)\n\nSELECT\n    date\n    ,validator_count\n    ,q_activation[1] AS q05\n    ,q_activation[2] AS q10\n    ,q_activation[3] AS q25\n    ,q_activation[4] AS q50\n    ,q_activation[5] AS q75\n    ,q_activation[6] AS q90\n    ,q_activation[7] AS q95\n    ,mean\nFROM (\n    SELECT\n        date,\n        count() AS validator_count\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(activation_days) AS q_activation\n        ,avg(activation_days) AS  mean\n    FROM queue_activation\n    GROUP BY date\n)", "relation_name": "`dbt`.`int_consensus_entry_queue_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.556437Z", "completed_at": "2025-12-13T16:37:52.561713Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.562318Z", "completed_at": "2025-12-13T16:37:52.562325Z"}], "thread_id": "Thread-1", "execution_time": 0.007386445999145508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_balances_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,SUM(balance/POWER(10,9)) AS balance\n    ,SUM(effective_balance/POWER(10,9)) AS effective_balance\nFROM `dbt`.`stg_consensus__validators`\nWHERE \n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_validators_balances_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_balances_daily` AS x2\n    )\n  \n\nGROUP BY date", "relation_name": "`dbt`.`int_consensus_validators_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.565073Z", "completed_at": "2025-12-13T16:37:52.570592Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.571213Z", "completed_at": "2025-12-13T16:37:52.571220Z"}], "thread_id": "Thread-1", "execution_time": 0.007468223571777344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_status_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,status\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__validators`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_validators_status_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_status_daily` AS x2\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_validators_status_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.573965Z", "completed_at": "2025-12-13T16:37:52.579621Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.580244Z", "completed_at": "2025-12-13T16:37:52.580252Z"}], "thread_id": "Thread-1", "execution_time": 0.007615327835083008, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_withdrawal_credentials_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,withdrawal_credentials\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__validators`\nWHERE\n    slot_timestamp < today()\n    AND status LIKE 'active_%'\n\n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_withdrawal_credentials_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_withdrawal_credentials_daily` AS x2\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_withdrawal_credentials_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.583034Z", "completed_at": "2025-12-13T16:37:52.587506Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.588061Z", "completed_at": "2025-12-13T16:37:52.588068Z"}], "thread_id": "Thread-1", "execution_time": 0.0063321590423583984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__validators_slot_timestamp.e395d1a15a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__validators`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.590652Z", "completed_at": "2025-12-13T16:37:52.596070Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.596653Z", "completed_at": "2025-12-13T16:37:52.596660Z"}], "thread_id": "Thread-1", "execution_time": 0.007222175598144531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__validators_validator_index.3356b32a86", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect validator_index\nfrom `dbt`.`stg_consensus__validators`\nwhere validator_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.599277Z", "completed_at": "2025-12-13T16:37:52.603643Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.604218Z", "completed_at": "2025-12-13T16:37:52.604225Z"}], "thread_id": "Thread-1", "execution_time": 0.006271839141845703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_consensus__validators_validator_index.e1e5562382", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    validator_index as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_consensus__validators`\nwhere validator_index is not null\ngroup by validator_index\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.606837Z", "completed_at": "2025-12-13T16:37:52.614939Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.615549Z", "completed_at": "2025-12-13T16:37:52.615557Z"}], "thread_id": "Thread-1", "execution_time": 0.010001897811889648, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_deposits_withdrawals_daily", "compiled": true, "compiled_code": "\n\nWITH\n\ndeposists AS (\n    SELECT \n        toStartOfDay(slot_timestamp) AS date\n        ,SUM(amount) AS amount\n        ,COUNT(*) AS cnt\n    FROM `dbt`.`stg_consensus__deposits`\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_deposits_withdrawals_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_deposits_withdrawals_daily` AS x2\n    )\n  \n\n    GROUP BY 1\n),\n\ndeposists_requests AS (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date\n        ,SUM(toUInt64(JSONExtractString(deposit, 'amount'))) AS amount\n        ,COUNT() AS cnt\n    FROM `dbt`.`stg_consensus__execution_requests`\n    ARRAY JOIN JSONExtractArrayRaw(payload, 'deposits') AS deposit\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_deposits_withdrawals_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_deposits_withdrawals_daily` AS x2\n    )\n  \n\n    GROUP BY 1\n),\n\nwithdrawals AS (\n    SELECT \n        toStartOfDay(slot_timestamp) AS date \n        ,SUM(amount) AS amount\n        ,COUNT(*) AS cnt\n    FROM `dbt`.`stg_consensus__withdrawals`\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_deposits_withdrawals_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_deposits_withdrawals_daily` AS x2\n    )\n  \n\n    GROUP BY 1\n)\n\n\nSELECT\n    label\n    ,date\n    ,SUM(amount/POWER(10,9)) AS total_amount\n    ,SUM(cnt) AS cnt\nFROM (\n    SELECT 'Deposits' AS label, * FROM deposists\n    UNION ALL\n    SELECT 'Deposits' AS label, * FROM deposists_requests\n    UNION ALL\n    SELECT 'Withdrawals' AS label, * FROM withdrawals\n)\nGROUP BY label, date", "relation_name": "`dbt`.`int_consensus_deposits_withdrawals_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.618384Z", "completed_at": "2025-12-13T16:37:52.636242Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.636847Z", "completed_at": "2025-12-13T16:37:52.636854Z"}], "thread_id": "Thread-1", "execution_time": 0.01992487907409668, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_per_index_apy_daily", "compiled": true, "compiled_code": "\n\n\n\n\n\n\nWITH\n\nwithdrawals AS (\n    SELECT \n        toStartOfDay(slot_timestamp) AS date \n        ,validator_index\n        ,SUM(amount) AS amount\n    FROM `dbt`.`stg_consensus__withdrawals`\n    WHERE\n        1=1\n        \n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_validators_per_index_apy_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_per_index_apy_daily` AS x2\n    )\n  \n\n        \n    GROUP BY 1, 2\n),\n\n\n\ncurrent_partition AS (\n    SELECT \n        max(toStartOfMonth(date)) AS month\n        ,max(date)  AS max_date\n    FROM `dbt`.`int_consensus_validators_per_index_apy_daily`\n    \n),\nprev_balance AS (\n    SELECT \n        t1.validator_index\n        ,argMax(t1.balance, t1.date) AS balance\n        ,argMax(t1.withdrawaled_amount, t1.date) AS withdrawaled_amount\n    FROM `dbt`.`int_consensus_validators_per_index_apy_daily` t1\n    CROSS JOIN current_partition t2\n    WHERE \n        toStartOfMonth(t1.date) = t2.month\n        \n        AND \n        t1.date < t2.max_date\n        \n    GROUP BY t1.validator_index\n),\n\n\nvalidators AS (\n    SELECT\n        toStartOfDay(t1.slot_timestamp, 'UTC') AS date,\n        t1.validator_index,\n        t1.pubkey,\n        t1.balance,\n        COALESCE(\n            lagInFrame(toNullable(t1.balance), 1, NULL) OVER (\n                PARTITION BY t1.validator_index\n                ORDER BY date\n                ROWS BETWEEN 1 PRECEDING AND CURRENT ROW\n            ),\n            \n                t2.balance\n            \n        ) AS prev_balance,\n        COALESCE(t3.amount,0) AS withdrawaled_amount,\n        COALESCE(\n            lagInFrame(toNullable(t3.amount), 1, NULL) OVER (\n                PARTITION BY t3.validator_index\n                ORDER BY date\n                ROWS BETWEEN 1 PRECEDING AND CURRENT ROW\n            ),\n            \n                t2.withdrawaled_amount\n            \n        ) AS prev_withdrawaled_amount,\n        t1.balance - prev_balance AS balance_diff,\n        t1.status AS status\n    FROM `dbt`.`stg_consensus__validators` t1\n    \n    LEFT JOIN prev_balance t2\n    ON t2.validator_index = t1.validator_index\n    \n    LEFT JOIN withdrawals t3\n    ON t3.date = toStartOfDay(t1.slot_timestamp, 'UTC')\n    AND t3.validator_index = t1.validator_index\n    WHERE\n        (t1.status LIKE 'active_%' OR t1.status = 'pending_queued')\n        \n        \n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_validators_per_index_apy_daily` AS x1\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_per_index_apy_daily` AS x2\n    )\n  \n\n        \n)\n\nSELECT \n    t1.date AS date\n    ,t1.validator_index AS validator_index\n    ,t1.status AS status\n    ,t1.balance AS balance\n    ,t1.balance - t1.prev_balance AS balance_diff_original\n    ,t1.withdrawaled_amount AS withdrawaled_amount\n    ,greatest(\n            -- balance + withdrawaled_amount mod 32 mGNO ()\n            t1.balance + t1.withdrawaled_amount \n            - MOD(t1.balance + t1.withdrawaled_amount,32000000000) \n            + toUInt64(roundBankers(MOD(t1.balance + t1.withdrawaled_amount, 32000000000) / 32000000000) * 32000000000)\n\n        - (\n            -- balance + withdrawaled_amount mod 32 mGNO ()\n            t1.prev_balance + t1.prev_withdrawaled_amount \n            - MOD(t1.prev_balance + t1.prev_withdrawaled_amount,32000000000)\n            + toUInt64(roundBankers(MOD(t1.prev_balance + t1.prev_withdrawaled_amount, 32000000000) / 32000000000) * 32000000000)\n        )\n    ,0) AS deposited_amount\n    ,balance_diff_original - deposited_amount + withdrawaled_amount AS eff_balance_diff\n   -- ,eff_balance_diff/IF(t1.prev_balance=0, deposited_amount, toInt64(t1.prev_balance)) AS rate\n    ,eff_balance_diff/(toInt64(t1.prev_balance) + deposited_amount) AS rate\n    ,ROUND((POWER((1+rate),365) - 1) * 100,2) AS apy\nFROM validators t1", "relation_name": "`dbt`.`int_consensus_validators_per_index_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.639532Z", "completed_at": "2025-12-13T16:37:52.644134Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.644768Z", "completed_at": "2025-12-13T16:37:52.644775Z"}], "thread_id": "Thread-1", "execution_time": 0.006555080413818359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__withdrawals_block_hash.ca4d2a4653", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect block_hash\nfrom `dbt`.`stg_consensus__withdrawals`\nwhere block_hash is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.647437Z", "completed_at": "2025-12-13T16:37:52.652926Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.653522Z", "completed_at": "2025-12-13T16:37:52.653529Z"}], "thread_id": "Thread-1", "execution_time": 0.0074307918548583984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__withdrawals_slot_timestamp.572376d120", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__withdrawals`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.656193Z", "completed_at": "2025-12-13T16:37:52.660627Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.661193Z", "completed_at": "2025-12-13T16:37:52.661201Z"}], "thread_id": "Thread-1", "execution_time": 0.006331443786621094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__withdrawals_validator_index.a457d1ccde", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect validator_index\nfrom `dbt`.`stg_consensus__withdrawals`\nwhere validator_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.663809Z", "completed_at": "2025-12-13T16:37:52.668223Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.668771Z", "completed_at": "2025-12-13T16:37:52.668778Z"}], "thread_id": "Thread-1", "execution_time": 0.006196737289428711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__withdrawals_withdrawal_index.6ed4b7c2a7", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect withdrawal_index\nfrom `dbt`.`stg_consensus__withdrawals`\nwhere withdrawal_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.671439Z", "completed_at": "2025-12-13T16:37:52.675805Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.676377Z", "completed_at": "2025-12-13T16:37:52.676384Z"}], "thread_id": "Thread-1", "execution_time": 0.006178140640258789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_consensus__withdrawals_block_hash.376679d9e9", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    block_hash as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_consensus__withdrawals`\nwhere block_hash is not null\ngroup by block_hash\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.679006Z", "completed_at": "2025-12-13T16:37:52.683395Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.683944Z", "completed_at": "2025-12-13T16:37:52.683951Z"}], "thread_id": "Thread-1", "execution_time": 0.006235599517822266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_consensus__withdrawals_validator_index.464577ebff", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    validator_index as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_consensus__withdrawals`\nwhere validator_index is not null\ngroup by validator_index\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.686656Z", "completed_at": "2025-12-13T16:37:52.692490Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.693105Z", "completed_at": "2025-12-13T16:37:52.693112Z"}], "thread_id": "Thread-1", "execution_time": 0.0077588558197021484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_bridges_flows_daily", "compiled": true, "compiled_code": "\n\nWITH base AS (\n    SELECT\n        toDate(timestamp) AS date, \n        bridge,\n        source_chain,\n        dest_chain,\n        token,\n        direction,\n        sum(amount_token) AS volume_token,\n        sum(amount_usd) AS volume_usd,\n        sum(net_usd) AS net_usd,\n        count() AS txs \n    FROM `dbt`.`stg_crawlers_data__dune_bridge_flows`\n    WHERE timestamp < today()\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_bridges_flows_daily` AS x1\n    )\n    AND toStartOfDay(timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_bridges_flows_daily` AS x2\n    )\n  \n \n    GROUP BY date, bridge, source_chain, dest_chain, token,direction\n)\n\nSELECT * FROM base", "relation_name": "`dbt`.`int_bridges_flows_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.695891Z", "completed_at": "2025-12-13T16:37:52.702173Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.702740Z", "completed_at": "2025-12-13T16:37:52.702748Z"}], "thread_id": "Thread-1", "execution_time": 0.008239507675170898, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_bridge_flows_bridge.6a40a61451", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect bridge\nfrom `dbt`.`stg_crawlers_data__dune_bridge_flows`\nwhere bridge is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.705447Z", "completed_at": "2025-12-13T16:37:52.709855Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.710429Z", "completed_at": "2025-12-13T16:37:52.710437Z"}], "thread_id": "Thread-1", "execution_time": 0.0063190460205078125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_bridge_flows_dest_chain.7493c99994", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect dest_chain\nfrom `dbt`.`stg_crawlers_data__dune_bridge_flows`\nwhere dest_chain is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.713069Z", "completed_at": "2025-12-13T16:37:52.717507Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.718061Z", "completed_at": "2025-12-13T16:37:52.718069Z"}], "thread_id": "Thread-1", "execution_time": 0.006308555603027344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_bridge_flows_source_chain.46658efe1d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect source_chain\nfrom `dbt`.`stg_crawlers_data__dune_bridge_flows`\nwhere source_chain is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.720720Z", "completed_at": "2025-12-13T16:37:52.725312Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.725880Z", "completed_at": "2025-12-13T16:37:52.725887Z"}], "thread_id": "Thread-1", "execution_time": 0.006456136703491211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_bridge_flows_timestamp.0ab9971d11", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect timestamp\nfrom `dbt`.`stg_crawlers_data__dune_bridge_flows`\nwhere timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.728594Z", "completed_at": "2025-12-13T16:37:52.732996Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.733572Z", "completed_at": "2025-12-13T16:37:52.733579Z"}], "thread_id": "Thread-1", "execution_time": 0.006310939788818359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_bridge_flows_token.47697e500b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect token\nfrom `dbt`.`stg_crawlers_data__dune_bridge_flows`\nwhere token is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.736329Z", "completed_at": "2025-12-13T16:37:52.741366Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.741953Z", "completed_at": "2025-12-13T16:37:52.741961Z"}], "thread_id": "Thread-1", "execution_time": 0.006989240646362305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_crawlers_data_gno_supply_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  label,\n  block_date AS date,\n  supply    \nFROM `dbt`.`stg_crawlers_data__dune_gno_supply`\nORDER BY date, label", "relation_name": "`dbt`.`api_crawlers_data_gno_supply_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.744733Z", "completed_at": "2025-12-13T16:37:52.749240Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.749795Z", "completed_at": "2025-12-13T16:37:52.749802Z"}], "thread_id": "Thread-1", "execution_time": 0.0063877105712890625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_prices_date.a7e4d781b8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`stg_crawlers_data__dune_prices`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.752515Z", "completed_at": "2025-12-13T16:37:52.758536Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.759151Z", "completed_at": "2025-12-13T16:37:52.759159Z"}], "thread_id": "Thread-1", "execution_time": 0.007908821105957031, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_carbon_intensity_ensemble", "compiled": true, "compiled_code": "\n\nWITH ember_monthly AS (\n    -- Monthly carbon intensity from Ember with enhanced uncertainty\n    SELECT\n        toDate(\"Date\") AS month_date,\n        CASE \n            WHEN \"Area\" = 'World' THEN 'WORLD'  -- World average as special country code\n            ELSE \"ISO 3 code\"\n        END AS country_code,\n        \"Value\" AS carbon_intensity_gco2_kwh,\n        COALESCE(\"Continent\", 'World') AS continent,\n        'ember' AS source,\n        0.85 AS base_confidence\n    FROM `dbt`.`stg_crawlers_data__ember_electricity_data`\n    WHERE   \n        \"Unit\" = 'gCO2/kWh'\n        AND (\n            (\"ISO 3 code\" IS NOT NULL AND \"ISO 3 code\" != '') OR \n            (\"Area\" = 'World')  -- Include World data\n        )\n        AND \"Value\" IS NOT NULL\n        AND \"Value\" > 0\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(\"Date\")) >= (\n      SELECT max(toStartOfMonth(x1.month_date))\n      FROM `dbt`.`int_esg_carbon_intensity_ensemble` AS x1\n    )\n    AND toStartOfDay(\"Date\") >= (\n      SELECT max(toStartOfDay(x2.month_date, 'UTC'))\n      FROM `dbt`.`int_esg_carbon_intensity_ensemble` AS x2\n    )\n  \n\n),\n\n-- Enhanced uncertainty modeling for monthly data\nuncertainty_enhanced AS (\n    SELECT\n        month_date,\n        country_code,\n        continent,\n        carbon_intensity_gco2_kwh AS base_ci,\n        \n        -- Calculate temporal uncertainty based on grid characteristics\n        -- Higher uncertainty for countries with more variable generation\n        carbon_intensity_gco2_kwh * (\n            CASE \n                -- High renewable countries have more temporal variation\n                WHEN carbon_intensity_gco2_kwh < 100 THEN 0.25  -- Low carbon grids (solar/wind heavy)\n                WHEN carbon_intensity_gco2_kwh < 300 THEN 0.20  -- Medium carbon grids  \n                WHEN carbon_intensity_gco2_kwh < 600 THEN 0.15  -- High carbon grids (more stable)\n                ELSE 0.12  -- Very high carbon grids (coal/gas baseload)\n            END\n        ) AS temporal_uncertainty,\n        \n        -- Data quality uncertainty (monthly averages hide daily/hourly variation)\n        carbon_intensity_gco2_kwh * 0.10 AS measurement_uncertainty,\n        \n        -- Continent-based seasonal adjustment factors\n        CASE continent\n            -- Europe & Asia (mostly Northern Hemisphere, heating-dominant)\n            WHEN 'Europe' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.18  -- Winter heating peak\n                    WHEN month(month_date) IN (6, 7, 8) THEN 0.92   -- Summer low + solar\n                    WHEN month(month_date) IN (3, 4, 11) THEN 1.08  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- Asia (mix of climates, but mostly Northern Hemisphere)\n            WHEN 'Asia' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.12  -- Winter (heating + industrial)\n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.08   -- Summer (cooling demand)\n                    WHEN month(month_date) IN (4, 5, 9, 10) THEN 1.05  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- North America (heating-dominant north, cooling-dominant south)\n            WHEN 'North America' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.15  -- Winter heating\n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.12   -- Summer cooling\n                    WHEN month(month_date) IN (4, 5, 9, 10) THEN 1.03  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- Oceania (Southern Hemisphere - reversed seasons)\n            WHEN 'Oceania' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.15   -- Southern winter\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.95  -- Southern summer\n                    WHEN month(month_date) IN (3, 4, 9, 10) THEN 1.05  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- South America (Southern Hemisphere + tropical)\n            WHEN 'South America' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.10   -- Southern winter (milder)\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.98  -- Southern summer\n                    ELSE 1.0\n                END\n                \n            -- Africa (mix of Northern/Southern + tropical, minimal variation)\n            WHEN 'Africa' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.05   -- Slight dry season effect\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.98  -- Wet season\n                    ELSE 1.0\n                END\n                \n            -- World/Default (minimal adjustment)\n            ELSE 1.0\n        END AS seasonal_factor,\n        \n        source,\n        base_confidence\n        \n    FROM ember_monthly\n),\n\n-- Final aggregation with confidence intervals\nfinal_estimates AS (\n    SELECT\n        month_date,\n        country_code,\n        \n        -- Point estimates with seasonal adjustment\n        round(base_ci * seasonal_factor, 2) AS carbon_intensity_mean,\n        \n        -- Combined uncertainty (temporal + measurement)\n        round(sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS carbon_intensity_std,\n        \n        -- Confidence intervals for Monte Carlo sampling\n        round(greatest(0, base_ci * seasonal_factor - 1.96 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2))), 2) AS ci_lower_95,\n        round(base_ci * seasonal_factor + 1.96 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS ci_upper_95,\n        \n        round(greatest(0, base_ci * seasonal_factor - 1.645 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2))), 2) AS ci_lower_90,\n        round(base_ci * seasonal_factor + 1.645 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS ci_upper_90,\n        \n        -- Coefficient of variation for uncertainty assessment\n        round(sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor), 3) AS coefficient_of_variation,\n        \n        -- Raw values for diagnostics\n        round(base_ci, 2) AS base_carbon_intensity,\n        round(temporal_uncertainty, 2) AS temporal_std,\n        round(measurement_uncertainty, 2) AS measurement_std,\n        round(seasonal_factor, 3) AS seasonal_adjustment,\n        continent,\n        \n        -- Data quality indicators\n        arrayPushFront([], source) AS sources_used,\n        base_confidence AS confidence_score,\n        1 AS n_sources,\n        \n        -- Uncertainty category for diagnostics\n        CASE \n            WHEN sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor) < 0.15 THEN 'Low'\n            WHEN sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor) < 0.25 THEN 'Medium' \n            ELSE 'High'\n        END AS uncertainty_category\n        \n    FROM uncertainty_enhanced\n)\n\nSELECT\n    month_date,\n    country_code,\n    \n    -- Core metrics for carbon footprint calculation\n    carbon_intensity_mean,\n    carbon_intensity_std,\n    ci_lower_95,\n    ci_upper_95,\n    ci_lower_90,\n    ci_upper_90,\n    \n    -- Uncertainty analysis\n    coefficient_of_variation,\n    uncertainty_category,\n    \n    -- Component breakdown for diagnostics\n    base_carbon_intensity,\n    temporal_std,\n    measurement_std,\n    seasonal_adjustment,\n    \n    -- Data provenance and quality\n    sources_used,\n    confidence_score,\n    n_sources,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM final_estimates", "relation_name": "`dbt`.`int_esg_carbon_intensity_ensemble`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.761830Z", "completed_at": "2025-12-13T16:37:52.766404Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.766975Z", "completed_at": "2025-12-13T16:37:52.766982Z"}], "thread_id": "Thread-1", "execution_time": 0.006434202194213867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__ember_electricity_data_Date.d1114ec663", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect Date\nfrom `dbt`.`stg_crawlers_data__ember_electricity_data`\nwhere Date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.769706Z", "completed_at": "2025-12-13T16:37:52.773708Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.774339Z", "completed_at": "2025-12-13T16:37:52.774347Z"}], "thread_id": "Thread-1", "execution_time": 0.005959987640380859, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,any_value(toInt32(floor(__total))) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d` \nGROUP BY 1, 2\nORDER BY date ASC, client ASC", "relation_name": "`dbt`.`api_probelab_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.777118Z", "completed_at": "2025-12-13T16:37:52.781230Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.781825Z", "completed_at": "2025-12-13T16:37:52.781832Z"}], "thread_id": "Thread-1", "execution_time": 0.006063938140869141, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_version_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,agent_version_semver_str AS version\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d` \nORDER BY date ASC, client ASC, version ASC", "relation_name": "`dbt`.`api_probelab_clients_version_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.784612Z", "completed_at": "2025-12-13T16:37:52.790719Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.791319Z", "completed_at": "2025-12-13T16:37:52.791326Z"}], "thread_id": "Thread-1", "execution_time": 0.008085012435913086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_agent_semvers_avg_1d_max_crawl_created_at.8219363436", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect max_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d`\nwhere max_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.793936Z", "completed_at": "2025-12-13T16:37:52.798659Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.799263Z", "completed_at": "2025-12-13T16:37:52.799270Z"}], "thread_id": "Thread-1", "execution_time": 0.006614208221435547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_agent_semvers_avg_1d_min_crawl_created_at.c13768a358", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect min_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d`\nwhere min_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.802015Z", "completed_at": "2025-12-13T16:37:52.805865Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.806474Z", "completed_at": "2025-12-13T16:37:52.806481Z"}], "thread_id": "Thread-1", "execution_time": 0.005765438079833984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_cloud_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,cloud_provider AS cloud\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d` \nORDER BY date ASC, client ASC, cloud ASC", "relation_name": "`dbt`.`api_probelab_clients_cloud_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.809219Z", "completed_at": "2025-12-13T16:37:52.813939Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.814545Z", "completed_at": "2025-12-13T16:37:52.814553Z"}], "thread_id": "Thread-1", "execution_time": 0.006696462631225586, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_cloud_provider_avg_1d_max_crawl_created_at.d05a72e66c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect max_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d`\nwhere max_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.817228Z", "completed_at": "2025-12-13T16:37:52.821953Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.822543Z", "completed_at": "2025-12-13T16:37:52.822550Z"}], "thread_id": "Thread-1", "execution_time": 0.006649494171142578, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_cloud_provider_avg_1d_min_crawl_created_at.68ec277b94", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect min_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d`\nwhere min_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.825238Z", "completed_at": "2025-12-13T16:37:52.829187Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.829778Z", "completed_at": "2025-12-13T16:37:52.829785Z"}], "thread_id": "Thread-1", "execution_time": 0.005872964859008789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_country_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,country\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_countries_avg_1d` \nORDER BY date ASC, client ASC, country ASC", "relation_name": "`dbt`.`api_probelab_clients_country_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.832542Z", "completed_at": "2025-12-13T16:37:52.838591Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.839173Z", "completed_at": "2025-12-13T16:37:52.839181Z"}], "thread_id": "Thread-1", "execution_time": 0.007992744445800781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_countries_avg_1d_max_crawl_created_at.b401aa1bdb", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect max_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_countries_avg_1d`\nwhere max_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.841824Z", "completed_at": "2025-12-13T16:37:52.846532Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.847108Z", "completed_at": "2025-12-13T16:37:52.847117Z"}], "thread_id": "Thread-1", "execution_time": 0.006546974182128906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_countries_avg_1d_min_crawl_created_at.69cddc52ad", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect min_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_countries_avg_1d`\nwhere min_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.849820Z", "completed_at": "2025-12-13T16:37:52.853680Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.854288Z", "completed_at": "2025-12-13T16:37:52.854295Z"}], "thread_id": "Thread-1", "execution_time": 0.005738019943237305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_quic_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,quic_support AS quic\n    ,__count AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_quic_support_over_7d` \nORDER BY date ASC, client ASC, quic ASC", "relation_name": "`dbt`.`api_probelab_clients_quic_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.856967Z", "completed_at": "2025-12-13T16:37:52.861771Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.862386Z", "completed_at": "2025-12-13T16:37:52.862393Z"}], "thread_id": "Thread-1", "execution_time": 0.0067179203033447266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_quic_support_over_7d_crawl_created_at.18c921e476", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_quic_support_over_7d`\nwhere crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.865037Z", "completed_at": "2025-12-13T16:37:52.869769Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.870372Z", "completed_at": "2025-12-13T16:37:52.870379Z"}], "thread_id": "Thread-1", "execution_time": 0.006623983383178711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_quic_support_over_7d_max_crawl_created_at.5d67ad70ef", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect max_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_quic_support_over_7d`\nwhere max_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.873030Z", "completed_at": "2025-12-13T16:37:52.878850Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.879427Z", "completed_at": "2025-12-13T16:37:52.879434Z"}], "thread_id": "Thread-1", "execution_time": 0.007709980010986328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_quic_support_over_7d_min_crawl_created_at.4d6a3c258b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect min_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_quic_support_over_7d`\nwhere min_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.882149Z", "completed_at": "2025-12-13T16:37:52.887638Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.888265Z", "completed_at": "2025-12-13T16:37:52.888272Z"}], "thread_id": "Thread-1", "execution_time": 0.007453441619873047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_blocks_clients_version_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nclients_version AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date\n        ,multiIf(\n             lower(decoded_extra_data[1]) = 'choose' \n            OR lower(decoded_extra_data[1]) = 'mysticryuujin'  \n            OR lower(decoded_extra_data[1]) = 'sanae.io'\n            OR decoded_extra_data[1] = ''  , \n            'Unknown',\n            decoded_extra_data[1]\n        )   AS client\n        ,IF(length(decoded_extra_data)>1, \n            IF(decoded_extra_data[2]='Ethereum',decoded_extra_data[3],decoded_extra_data[2]), \n            ''\n        ) AS version\n        ,COUNT(*) AS cnt\n    FROM `dbt`.`stg_execution__blocks`\n    \n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_blocks_clients_version_daily` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_blocks_clients_version_daily` AS x2\n    )\n  \n\n    GROUP BY 1, 2, 3\n)\n\nSELECT\n    *\nFROM clients_version", "relation_name": "`dbt`.`int_execution_blocks_clients_version_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.890994Z", "completed_at": "2025-12-13T16:37:52.896714Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.897340Z", "completed_at": "2025-12-13T16:37:52.897347Z"}], "thread_id": "Thread-1", "execution_time": 0.007670164108276367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_blocks_gas_usage_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  toDate(block_timestamp)         AS date,\n  SUM(gas_used)                   AS gas_used_sum,\n  SUM(gas_limit)                  AS gas_limit_sum,\n  gas_used_sum / NULLIF(gas_limit_sum, 0) AS gas_used_fraq\nFROM `dbt`.`stg_execution__blocks`\n\n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_blocks_gas_usage_daily` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_blocks_gas_usage_daily` AS x2\n    )\n  \n\nGROUP BY date", "relation_name": "`dbt`.`int_execution_blocks_gas_usage_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.899978Z", "completed_at": "2025-12-13T16:37:52.904646Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.905258Z", "completed_at": "2025-12-13T16:37:52.905266Z"}], "thread_id": "Thread-1", "execution_time": 0.006555080413818359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__blocks_block_hash.3968ee550e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect block_hash\nfrom `dbt`.`stg_execution__blocks`\nwhere block_hash is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.907877Z", "completed_at": "2025-12-13T16:37:52.912478Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.913040Z", "completed_at": "2025-12-13T16:37:52.913048Z"}], "thread_id": "Thread-1", "execution_time": 0.0064697265625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__blocks_block_timestamp.d1b2bdbc42", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect block_timestamp\nfrom `dbt`.`stg_execution__blocks`\nwhere block_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.915670Z", "completed_at": "2025-12-13T16:37:52.920229Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.920793Z", "completed_at": "2025-12-13T16:37:52.920800Z"}], "thread_id": "Thread-1", "execution_time": 0.006383657455444336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_execution__blocks_block_hash.dfc272288f", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    block_hash as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_execution__blocks`\nwhere block_hash is not null\ngroup by block_hash\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.923479Z", "completed_at": "2025-12-13T16:37:52.929125Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.929687Z", "completed_at": "2025-12-13T16:37:52.929694Z"}], "thread_id": "Thread-1", "execution_time": 0.007528543472290039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__logs_block_hash.a4b8ab1ff5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect block_hash\nfrom `dbt`.`stg_execution__logs`\nwhere block_hash is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.932429Z", "completed_at": "2025-12-13T16:37:52.936974Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.937559Z", "completed_at": "2025-12-13T16:37:52.937567Z"}], "thread_id": "Thread-1", "execution_time": 0.006516933441162109, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__logs_block_timestamp.881b6edd16", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect block_timestamp\nfrom `dbt`.`stg_execution__logs`\nwhere block_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.940182Z", "completed_at": "2025-12-13T16:37:52.944688Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.945286Z", "completed_at": "2025-12-13T16:37:52.945293Z"}], "thread_id": "Thread-1", "execution_time": 0.006393909454345703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__logs_log_index.e8be0c3c17", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect log_index\nfrom `dbt`.`stg_execution__logs`\nwhere log_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.947933Z", "completed_at": "2025-12-13T16:37:52.952449Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.953005Z", "completed_at": "2025-12-13T16:37:52.953012Z"}], "thread_id": "Thread-1", "execution_time": 0.006399869918823242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__logs_transaction_hash.2d593d529d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect transaction_hash\nfrom `dbt`.`stg_execution__logs`\nwhere transaction_hash is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.955642Z", "completed_at": "2025-12-13T16:37:52.960119Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.960679Z", "completed_at": "2025-12-13T16:37:52.960687Z"}], "thread_id": "Thread-1", "execution_time": 0.006274223327636719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__logs_transaction_index.b98dbd3698", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect transaction_index\nfrom `dbt`.`stg_execution__logs`\nwhere transaction_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.963301Z", "completed_at": "2025-12-13T16:37:52.968763Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.969375Z", "completed_at": "2025-12-13T16:37:52.969382Z"}], "thread_id": "Thread-1", "execution_time": 0.0073451995849609375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_execution__logs_block_hash.39d25d05c6", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    block_hash as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_execution__logs`\nwhere block_hash is not null\ngroup by block_hash\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.972015Z", "completed_at": "2025-12-13T16:37:52.976457Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.977018Z", "completed_at": "2025-12-13T16:37:52.977025Z"}], "thread_id": "Thread-1", "execution_time": 0.0063169002532958984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_execution__logs_transaction_hash.f1d4264177", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    transaction_hash as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_execution__logs`\nwhere transaction_hash is not null\ngroup by transaction_hash\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.979785Z", "completed_at": "2025-12-13T16:37:52.985311Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.985903Z", "completed_at": "2025-12-13T16:37:52.985911Z"}], "thread_id": "Thread-1", "execution_time": 0.007487773895263672, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_state_size_full_diff_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\n\nstate_size_diff AS (\n    SELECT \n        toStartOfDay(block_timestamp) AS date \n        ,SUM(IF(to_value!='0000000000000000000000000000000000000000000000000000000000000000',32,-32)) AS bytes_diff\n    FROM \n        `dbt`.`stg_execution__storage_diffs`\n    \n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_state_size_full_diff_daily` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_state_size_full_diff_daily` AS x2\n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT\n    *\nFROM state_size_diff", "relation_name": "`dbt`.`int_execution_state_size_full_diff_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.988618Z", "completed_at": "2025-12-13T16:37:52.993229Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:52.993808Z", "completed_at": "2025-12-13T16:37:52.993816Z"}], "thread_id": "Thread-1", "execution_time": 0.006562232971191406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__storage_diffs_transaction_hash.355bce9dc8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect transaction_hash\nfrom `dbt`.`stg_execution__storage_diffs`\nwhere transaction_hash is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:52.996424Z", "completed_at": "2025-12-13T16:37:53.000873Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.001447Z", "completed_at": "2025-12-13T16:37:53.001454Z"}], "thread_id": "Thread-1", "execution_time": 0.006249904632568359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__storage_diffs_transaction_index.c3d3eabba2", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect transaction_index\nfrom `dbt`.`stg_execution__storage_diffs`\nwhere transaction_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.003970Z", "completed_at": "2025-12-13T16:37:53.008552Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.009154Z", "completed_at": "2025-12-13T16:37:53.009162Z"}], "thread_id": "Thread-1", "execution_time": 0.006417036056518555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_execution__storage_diffs_transaction_hash.ead3d5cd43", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    transaction_hash as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_execution__storage_diffs`\nwhere transaction_hash is not null\ngroup by transaction_hash\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.011825Z", "completed_at": "2025-12-13T16:37:53.020152Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.020751Z", "completed_at": "2025-12-13T16:37:53.020758Z"}], "thread_id": "Thread-1", "execution_time": 0.010195732116699219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_info_daily", "compiled": true, "compiled_code": "\n\nWITH tx AS (\n  SELECT\n    block_timestamp,\n    toDate(block_timestamp)             AS date,\n    toString(transaction_type)          AS transaction_type,\n    coalesce(success, 0)                AS success,\n    toFloat64(value) / 1e18             AS value_native,             \n    toFloat64(coalesce(gas_used, 0))    AS gas_used,                 \n    toFloat64(coalesce(gas_price, 0))   AS gas_price                 \n  FROM `dbt`.`stg_execution__transactions`\n  WHERE block_timestamp < today()\n  \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_transactions_info_daily` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_transactions_info_daily` AS x2\n    )\n  \n\n),\n\nagg_base AS (\n  SELECT\n    date,\n    transaction_type,\n    success,\n    COUNT()                     AS n_txs,\n    SUM(value_native)           AS xdai_value_sum_raw,\n    AVG(value_native)           AS xdai_value_avg_raw,\n    median(value_native)        AS xdai_value_median_raw,\n    SUM(gas_used)               AS gas_used_sum_raw,          -- \u201cgas units\u201d\n    AVG(gas_price)              AS gas_price_avg_raw_wei,     -- in wei\n    median(gas_price)           AS gas_price_med_raw_wei,     -- in wei\n    SUM(gas_used * gas_price)   AS fee_sum_raw_wei            -- in wei\n  FROM tx\n  GROUP BY date, transaction_type, success\n),\n\nagg AS (\n  SELECT\n    date,\n    transaction_type,\n    success,\n    n_txs,\n    xdai_value_sum_raw                       AS xdai_value,\n    xdai_value_avg_raw                       AS xdai_value_avg,\n    xdai_value_median_raw                    AS xdai_value_median,\n    gas_used_sum_raw                         AS gas_used,\n    CAST(gas_price_avg_raw_wei / 1e9 AS Int32)   AS gas_price_avg,       -- Gwei\n    CAST(gas_price_med_raw_wei / 1e9 AS Int32)   AS gas_price_median,    -- Gwei\n    fee_sum_raw_wei / 1e18                   AS fee_native_sum          -- xDai\n  FROM agg_base\n),\n\npx AS (\n  SELECT\n    date,\n    price\n  FROM `dbt`.`stg_crawlers_data__dune_prices`\n  WHERE symbol = 'XDAI'\n  \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_transactions_info_daily` AS x1\n    )\n    AND toStartOfDay(date) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_transactions_info_daily` AS x2\n    )\n  \n\n)\n\nSELECT\n  a.date,\n  a.transaction_type,\n  a.success,\n  a.n_txs,\n  a.xdai_value,\n  a.xdai_value_avg,\n  a.xdai_value_median,\n  a.gas_used,\n  a.gas_price_avg,\n  a.gas_price_median,\n  a.fee_native_sum,\n  a.fee_native_sum * coalesce(px.price, 1.0) AS fee_usd_sum\nFROM agg a\nLEFT JOIN px\n  ON px.date = a.date", "relation_name": "`dbt`.`int_execution_transactions_info_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.023750Z", "completed_at": "2025-12-13T16:37:53.028270Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.028837Z", "completed_at": "2025-12-13T16:37:53.028844Z"}], "thread_id": "Thread-1", "execution_time": 0.006707191467285156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__transactions_transaction_hash.92b0650777", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect transaction_hash\nfrom `dbt`.`stg_execution__transactions`\nwhere transaction_hash is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.031476Z", "completed_at": "2025-12-13T16:37:53.035881Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.036459Z", "completed_at": "2025-12-13T16:37:53.036467Z"}], "thread_id": "Thread-1", "execution_time": 0.006292104721069336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__transactions_transaction_index.f0d9adb918", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect transaction_index\nfrom `dbt`.`stg_execution__transactions`\nwhere transaction_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.038990Z", "completed_at": "2025-12-13T16:37:53.043399Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.043964Z", "completed_at": "2025-12-13T16:37:53.043971Z"}], "thread_id": "Thread-1", "execution_time": 0.006192684173583984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_execution__transactions_transaction_hash.173e989c74", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    transaction_hash as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_execution__transactions`\nwhere transaction_hash is not null\ngroup by transaction_hash\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.046552Z", "completed_at": "2025-12-13T16:37:53.051280Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.051841Z", "completed_at": "2025-12-13T16:37:53.051848Z"}], "thread_id": "Thread-1", "execution_time": 0.006511688232421875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__discovery_id_prefixes_x_peer_ids_peer_id.fa91b6f34a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.054486Z", "completed_at": "2025-12-13T16:37:53.060079Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.060660Z", "completed_at": "2025-12-13T16:37:53.060667Z"}], "thread_id": "Thread-1", "execution_time": 0.007431745529174805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv4__discovery_id_prefixes_x_peer_ids_peer_id.ee76ad9364", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.063254Z", "completed_at": "2025-12-13T16:37:53.140710Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.141289Z", "completed_at": "2025-12-13T16:37:53.141299Z"}], "thread_id": "Thread-1", "execution_time": 0.079345703125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__neighbors_crawl_created_at.08104da64e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_created_at\nfrom `dbt`.`stg_nebula_discv4__neighbors`\nwhere crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.143949Z", "completed_at": "2025-12-13T16:37:53.148582Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.149154Z", "completed_at": "2025-12-13T16:37:53.149162Z"}], "thread_id": "Thread-1", "execution_time": 0.0065267086029052734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__neighbors_crawl_id.8726626b01", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_id\nfrom `dbt`.`stg_nebula_discv4__neighbors`\nwhere crawl_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.151744Z", "completed_at": "2025-12-13T16:37:53.156131Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.156690Z", "completed_at": "2025-12-13T16:37:53.156697Z"}], "thread_id": "Thread-1", "execution_time": 0.006232500076293945, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv4__neighbors_crawl_id.8f71244658", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    crawl_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv4__neighbors`\nwhere crawl_id is not null\ngroup by crawl_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.159398Z", "completed_at": "2025-12-13T16:37:53.167277Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.167865Z", "completed_at": "2025-12-13T16:37:53.167872Z"}], "thread_id": "Thread-1", "execution_time": 0.009809017181396484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_peers", "compiled": true, "compiled_code": "\n\n\n\n\nWITH\n\n  peers AS (\n    SELECT \n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors\n  FROM `dbt`.`stg_nebula_discv4__visits` A\n  WHERE\n      toString(peer_properties.network_id) = '100'\n      \n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(x1.visit_ended_at))\n      FROM `dbt`.`int_p2p_discv4_peers` AS x1\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(x2.visit_ended_at, 'UTC'))\n      FROM `dbt`.`int_p2p_discv4_peers` AS x2\n    )\n  \n\n      \n  ),\n\n  parsed AS (\n    SELECT\n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors,\n      -- break into slash-delimited parts\n      splitByChar('/', agent_version)                        AS slash_parts,\n      length(slash_parts)                                    AS sp_len,\n\n      -- if 4+ parts, take last two as platform+runtime; otherwise only platform\n      IF(\n        length(slash_parts) > 3,\n        arrayElement(slash_parts, sp_len-1),\n        arrayElement(slash_parts, sp_len)\n      )                                                       AS platform,\n\n      IF(\n        length(slash_parts) > 3,\n        arrayElement(slash_parts, sp_len),\n        ''\n      )                                                       AS runtime,\n\n      -- head_parts = everything before the last 1 or 2 elements\n      arraySlice(\n        slash_parts,\n        1,\n        sp_len - IF(sp_len > 3, 2, 1)\n      )                                                       AS head_parts\n\n    FROM peers\n  ),\n\n  exploded AS (\n    SELECT\n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors,\n      head_parts[1]                                          AS client,\n\n      -- if head_parts has 3 elements, the middle is variant\n      IF(\n        length(head_parts) = 3,\n        head_parts[2],\n        ''\n      )                                                       AS variant,\n\n      -- the last element of head_parts is our raw \u201cver_blob\u201d\n      arrayElement(head_parts, length(head_parts))            AS ver_blob,\n\n      platform,\n      runtime,\n\n      -- split out \u201c+\u201d-style metadata\n      IF(ver_blob LIKE '%+%', arrayElement(splitByChar('+', ver_blob), 1), ver_blob) AS pre_blob,\n      IF(ver_blob LIKE '%+%', arrayElement(splitByChar('+', ver_blob), 2), '')        AS plus_build\n\n    FROM parsed\n  ),\n\nbasic_info AS (\n  SELECT\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    --replaceRegexpAll(connect_maddr, '^/ip4/([0-9.]+)/tcp/[0-9]+$', '\\\\1') AS ip,\n    arrayElement(splitByChar('/', ifNull(connect_maddr, '')), 3) AS ip,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    IF(\n      plus_build != '',\n      arrayElement(splitByChar('-', pre_blob), 1),\n      splitByChar('-', ver_blob)[1]\n    )                                                       AS version,\n    IF(\n      plus_build != '',\n      IF(\n        length(splitByChar('-', pre_blob)) >= 2,\n        arrayElement(splitByChar('-', pre_blob), 2),\n        ''\n      ),\n      IF(\n        length(splitByChar('-', ver_blob)) = 3,\n        arrayElement(splitByChar('-', ver_blob), 2),\n        ''\n      )\n    )                                                       AS channel,\n    IF(\n      plus_build != '',\n      plus_build,\n      IF(\n        length(splitByChar('-', ver_blob)) > 1,\n        arrayElement(splitByChar('-', ver_blob), -1),\n        ''\n      )\n    )                                                       AS build,\n    platform,\n    runtime\n  FROM exploded\n)\n\nSELECT\n  t1.visit_ended_at,\n  t1.peer_id,\n  t1.agent_version,\n  t1.ip,\n  t1.peer_properties,\n  t1.crawl_error,\n  t1.dial_errors,\n  t1.client,\n  t1.variant,\n  t1.version,\n  t1.channel,\n  t1.build,\n  t1.platform,\n  t1.runtime,\n  t2.hostname   AS peer_hostname,\n  t2.city       AS peer_city,\n  t2.country    AS peer_country,\n  t2.org        AS peer_org,\n  t2.loc        AS peer_loc,\n  t2.generic_provider AS generic_provider\nFROM\n  basic_info t1\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS t2\n  ON t2.ip = t1.ip", "relation_name": "`dbt`.`int_p2p_discv4_peers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.170564Z", "completed_at": "2025-12-13T16:37:53.176256Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.176870Z", "completed_at": "2025-12-13T16:37:53.176877Z"}], "thread_id": "Thread-1", "execution_time": 0.007626056671142578, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_visits_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nvisits_info AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,COUNT(visit_ended_at) AS total_visits\n        ,SUM(IF( empty(dial_errors) = 1 OR crawl_error IS NULL, 1, 0)) AS successful_visits\n        ,COUNT(DISTINCT crawl_id) AS crawls\n    FROM `dbt`.`stg_nebula_discv4__visits`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        toString(peer_properties.network_id) = '100'\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_p2p_discv4_visits_daily` AS x1\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_p2p_discv4_visits_daily` AS x2\n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT * FROM visits_info", "relation_name": "`dbt`.`int_p2p_discv4_visits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.179589Z", "completed_at": "2025-12-13T16:37:53.184963Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.185538Z", "completed_at": "2025-12-13T16:37:53.185546Z"}], "thread_id": "Thread-1", "execution_time": 0.007286787033081055, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__visits_crawl_id.1047c05835", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_id\nfrom `dbt`.`stg_nebula_discv4__visits`\nwhere crawl_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.188133Z", "completed_at": "2025-12-13T16:37:53.192533Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.193084Z", "completed_at": "2025-12-13T16:37:53.193106Z"}], "thread_id": "Thread-1", "execution_time": 0.006272554397583008, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__visits_peer_id.4d2f8a686c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`stg_nebula_discv4__visits`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.195688Z", "completed_at": "2025-12-13T16:37:53.200119Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.200677Z", "completed_at": "2025-12-13T16:37:53.200684Z"}], "thread_id": "Thread-1", "execution_time": 0.006276369094848633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__visits_visit_ended_at.a94c7d50d3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect visit_ended_at\nfrom `dbt`.`stg_nebula_discv4__visits`\nwhere visit_ended_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.203374Z", "completed_at": "2025-12-13T16:37:53.207760Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.208331Z", "completed_at": "2025-12-13T16:37:53.208339Z"}], "thread_id": "Thread-1", "execution_time": 0.0063555240631103516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__visits_visit_started_at.de065da8ac", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect visit_started_at\nfrom `dbt`.`stg_nebula_discv4__visits`\nwhere visit_started_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.210899Z", "completed_at": "2025-12-13T16:37:53.215320Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.215880Z", "completed_at": "2025-12-13T16:37:53.215887Z"}], "thread_id": "Thread-1", "execution_time": 0.006256580352783203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv4__visits_crawl_id.41e26560eb", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    crawl_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv4__visits`\nwhere crawl_id is not null\ngroup by crawl_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.218449Z", "completed_at": "2025-12-13T16:37:53.223788Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.224363Z", "completed_at": "2025-12-13T16:37:53.224370Z"}], "thread_id": "Thread-1", "execution_time": 0.007170915603637695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv4__visits_peer_id.3b9792bf3e", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv4__visits`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.226984Z", "completed_at": "2025-12-13T16:37:53.231669Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.232251Z", "completed_at": "2025-12-13T16:37:53.232258Z"}], "thread_id": "Thread-1", "execution_time": 0.006571769714355469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__discovery_id_prefixes_x_peer_ids_peer_id.db4024f2cc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.234841Z", "completed_at": "2025-12-13T16:37:53.239470Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.240027Z", "completed_at": "2025-12-13T16:37:53.240034Z"}], "thread_id": "Thread-1", "execution_time": 0.006485462188720703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv5__discovery_id_prefixes_x_peer_ids_peer_id.f54e03ba37", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.242614Z", "completed_at": "2025-12-13T16:37:53.247180Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.247740Z", "completed_at": "2025-12-13T16:37:53.247748Z"}], "thread_id": "Thread-1", "execution_time": 0.006397247314453125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__neighbors_crawl_created_at.76b1283e34", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_created_at\nfrom `dbt`.`stg_nebula_discv5__neighbors`\nwhere crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.250384Z", "completed_at": "2025-12-13T16:37:53.254961Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.255538Z", "completed_at": "2025-12-13T16:37:53.255545Z"}], "thread_id": "Thread-1", "execution_time": 0.006386995315551758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__neighbors_crawl_id.a789b348b9", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_id\nfrom `dbt`.`stg_nebula_discv5__neighbors`\nwhere crawl_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.258173Z", "completed_at": "2025-12-13T16:37:53.262689Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.263287Z", "completed_at": "2025-12-13T16:37:53.263295Z"}], "thread_id": "Thread-1", "execution_time": 0.0064165592193603516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv5__neighbors_crawl_id.27d1de0819", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    crawl_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv5__neighbors`\nwhere crawl_id is not null\ngroup by crawl_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.265949Z", "completed_at": "2025-12-13T16:37:53.275421Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.275994Z", "completed_at": "2025-12-13T16:37:53.276001Z"}], "thread_id": "Thread-1", "execution_time": 0.011311054229736328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_peers", "compiled": true, "compiled_code": "\n\n\n\n\nWITH\n\n-- Known fork digests \u2192 names\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\n-- Known fork versions \u2192 names\nfork_version AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_version,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0x00000064','Phase0'),\n      ('0x01000064','Altair'),\n      ('0x02000064','Bellatrix'),\n      ('0x03000064','Capella'),\n      ('0x04000064','Deneb'),\n      ('0x05000064','Electra'),\n      ('0x06000064','Fulu')\n    ]) AS tup\n  )\n),\n\n/* Pull only relevant rows from source and normalize Dynamic\u2192String once */\npeers AS (\n  SELECT \n    t1.crawl_id,\n    t1.visit_ended_at,\n    t1.peer_id,\n    t1.connect_maddr,\n    -- Dynamic JSON leaves \u2192 String for safe joins/filters\n    toString(t1.peer_properties.fork_digest)         AS fork_digest,\n    toString(t1.peer_properties.next_fork_version)   AS next_fork_version,\n\n    -- Map to fork names\n    t2.cl_fork_name                                  AS cl_fork_name,\n    coalesce(t3.cl_fork_name, toString(t1.peer_properties.next_fork_version))\n                                                    AS cl_next_fork_name,\n\n    t1.agent_version,\n    --t1.peer_properties,\n    t1.crawl_error,\n    t1.dial_errors\n  FROM `dbt`.`stg_nebula_discv5__visits` AS t1\n  LEFT JOIN fork_digests t2\n    ON toString(t1.peer_properties.fork_digest) = t2.fork_digest\n  LEFT JOIN fork_version t3\n    ON toString(t1.peer_properties.next_fork_version) = t3.fork_version\n  WHERE\n    (\n      toString(t1.peer_properties.fork_digest) IN (SELECT fork_digest FROM fork_digests)\n      OR toString(t1.peer_properties.next_fork_version) LIKE '%064'\n    )\n    \n      \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(x1.visit_ended_at))\n      FROM `dbt`.`int_p2p_discv5_peers` AS x1\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(x2.visit_ended_at, 'UTC'))\n      FROM `dbt`.`int_p2p_discv5_peers` AS x2\n    )\n  \n\n    \n),\n\n/* Split and locate version token via regex */\nparsed AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n    --peer_properties,\n    crawl_error,\n    dial_errors,\n    agent_version,\n\n    splitByChar('/', agent_version)                                         AS parts,\n    length(splitByChar('/', agent_version))                                 AS parts_len,\n    arraySlice(splitByChar('/', agent_version), 2)                         AS tail,\n    length(arraySlice(splitByChar('/', agent_version), 2))                 AS tail_len,\n\n    splitByChar('/', agent_version)[1]                                     AS client,\n\n    -- first tail index that looks like a version (v?digits(.digits){0,3}\u2026)\n    arrayFirstIndex(x ->\n        (substring(x, 1, 1) = 'v' OR match(x, '^[0-9]')) AND\n        match(x, '^v?[0-9]+(\\\\.[0-9]+){0,3}([\\\\-\\\\w\\\\.\\\\+]+)?$')\n      , arraySlice(splitByChar('/', agent_version), 2))                    AS ver_idx_tail\n  FROM peers\n),\n\n/* Derive variant, version blob, platform, runtime */\nwith_parts AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n   -- peer_properties,\n    crawl_error,\n    dial_errors,\n    agent_version,\n    parts,\n    parts_len,\n    tail,\n    tail_len,\n    client,\n    ver_idx_tail,\n\n    /* variant: exactly one token between client and version */\n    IF(ver_idx_tail > 1, tail[1], '')                                       AS variant,\n\n    /* raw version token (may include '-' channel and/or '+' build) */\n    IF(ver_idx_tail > 0, tail[ver_idx_tail], '')                            AS ver_blob,\n\n    /* tokens after version for platform/runtime */\n    IF(ver_idx_tail > 0 AND tail_len >= ver_idx_tail + 1, tail[ver_idx_tail + 1], '')\n      AS platform,\n    IF(ver_idx_tail > 0 AND tail_len >= ver_idx_tail + 2, tail[ver_idx_tail + 2], '')\n      AS runtime\n  FROM parsed\n),\n\n/* Split version blob and prep hyphen parts; also clean runtime */\nexploded AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n   -- peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    ver_blob,\n\n    -- strip leading '-' in runtime\n    replaceRegexpOne(runtime, '^-+', '')                                    AS runtime,\n    platform,\n\n    /* version blob split around '+' */\n    IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[1], ver_blob) AS pre_blob,\n    IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[2], '')       AS plus_build,\n\n    /* hyphen parts for channel/build logic (work off pre_blob) */\n    splitByChar('-', IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[1], ver_blob))\n                                                                            AS hy_parts\n  FROM with_parts\n),\n\nbasic_info AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    replaceRegexpAll(connect_maddr, '^/ip4/([0-9.]+)/tcp/[0-9]+$', '\\\\1') AS ip,\n    fork_digest,\n    cl_fork_name,\n    cl_next_fork_name,\n    next_fork_version,\n   -- peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    IF(length(hy_parts) >= 1, hy_parts[1], '')                                AS version,\n    IF(length(hy_parts) >= 3, hy_parts[2], '')                                 AS channel,\n    IF(\n      plus_build != '',\n      plus_build,\n      IF(length(hy_parts) >= 2, hy_parts[length(hy_parts)], '')\n    )                                                                          AS build,\n    platform,\n    runtime\n  FROM exploded\n)\n\nSELECT\n  t1.crawl_id,\n  t1.visit_ended_at,\n  t1.peer_id,\n  t1.agent_version,\n  t1.ip,\n  t1.fork_digest,\n  t1.cl_fork_name,\n  t1.cl_next_fork_name,\n  t1.next_fork_version,\n  t1.crawl_error,\n  t1.dial_errors,\n  t1.client,\n  t1.variant,\n  t1.version,\n  t1.channel,\n  t1.build,\n  CASE\n      WHEN t1.platform = '' THEN 'Unknown'\n      WHEN t1.platform = 'aarch64-linux' THEN 'linux-aarch_64'\n      WHEN t1.platform = 'x86_64-linux' THEN 'linux-x86_64'\n      WHEN t1.platform = 'x86_64-windows' THEN 'windows-x86_64'\n      ELSE t1.platform\n  END AS platform,\n  t1.runtime,\n  t2.hostname   AS peer_hostname,\n  t2.city       AS peer_city,\n  t2.country    AS peer_country,\n  t2.org        AS peer_org,\n  t2.loc        AS peer_loc,\n  t2.generic_provider AS generic_provider\nFROM\n  basic_info t1\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS t2\n  ON t2.ip = t1.ip", "relation_name": "`dbt`.`int_p2p_discv5_peers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.278940Z", "completed_at": "2025-12-13T16:37:53.284469Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.285050Z", "completed_at": "2025-12-13T16:37:53.285057Z"}], "thread_id": "Thread-1", "execution_time": 0.0076787471771240234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_visits_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\nvisits_info AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,COUNT(visit_ended_at) AS total_visits\n        ,SUM(IF( empty(dial_errors) = 1 OR crawl_error IS NULL, 1, 0)) AS successful_visits\n        ,COUNT(DISTINCT crawl_id) AS crawls\n    FROM `dbt`.`stg_nebula_discv5__visits`\n    WHERE\n      toStartOfDay(visit_ended_at) < today()\n      AND\n      (\n        toString(peer_properties.fork_digest) IN (SELECT fork_digest FROM fork_digests)\n        OR toString(peer_properties.next_fork_version) LIKE '%064'\n      )\n      \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_p2p_discv5_visits_daily` AS x1\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_p2p_discv5_visits_daily` AS x2\n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT * FROM visits_info", "relation_name": "`dbt`.`int_p2p_discv5_visits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.287733Z", "completed_at": "2025-12-13T16:37:53.292442Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.293021Z", "completed_at": "2025-12-13T16:37:53.293028Z"}], "thread_id": "Thread-1", "execution_time": 0.00658726692199707, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__visits_crawl_id.9cb9b578fa", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_id\nfrom `dbt`.`stg_nebula_discv5__visits`\nwhere crawl_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.295725Z", "completed_at": "2025-12-13T16:37:53.300227Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.300804Z", "completed_at": "2025-12-13T16:37:53.300812Z"}], "thread_id": "Thread-1", "execution_time": 0.006373167037963867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__visits_peer_id.216f34e1f7", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`stg_nebula_discv5__visits`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.303455Z", "completed_at": "2025-12-13T16:37:53.307845Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.308421Z", "completed_at": "2025-12-13T16:37:53.308428Z"}], "thread_id": "Thread-1", "execution_time": 0.006196022033691406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__visits_visit_ended_at.2fa2ff079f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect visit_ended_at\nfrom `dbt`.`stg_nebula_discv5__visits`\nwhere visit_ended_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.311019Z", "completed_at": "2025-12-13T16:37:53.316640Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.317222Z", "completed_at": "2025-12-13T16:37:53.317229Z"}], "thread_id": "Thread-1", "execution_time": 0.007425546646118164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__visits_visit_started_at.7bc42b8695", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect visit_started_at\nfrom `dbt`.`stg_nebula_discv5__visits`\nwhere visit_started_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.319836Z", "completed_at": "2025-12-13T16:37:53.324295Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.324855Z", "completed_at": "2025-12-13T16:37:53.324862Z"}], "thread_id": "Thread-1", "execution_time": 0.006298065185546875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv5__visits_crawl_id.73f88f1c7e", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    crawl_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv5__visits`\nwhere crawl_id is not null\ngroup by crawl_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.327532Z", "completed_at": "2025-12-13T16:37:53.331867Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.332462Z", "completed_at": "2025-12-13T16:37:53.332470Z"}], "thread_id": "Thread-1", "execution_time": 0.006253242492675781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv5__visits_peer_id.dcf6d33c4b", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv5__visits`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.335148Z", "completed_at": "2025-12-13T16:37:53.340558Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.341176Z", "completed_at": "2025-12-13T16:37:53.341184Z"}], "thread_id": "Thread-1", "execution_time": 0.007359027862548828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_AgentResultMapping_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '99c43743a2dbd406160cc43cf08113b17178789c'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2025-06-10'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_AgentResultMapping_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_AgentResultMapping_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.344133Z", "completed_at": "2025-12-13T16:37:53.349610Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.350211Z", "completed_at": "2025-12-13T16:37:53.350219Z"}], "thread_id": "Thread-1", "execution_time": 0.007434368133544922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_ConditionalTokens_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-01'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_ConditionalTokens_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_ConditionalTokens_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.352883Z", "completed_at": "2025-12-13T16:37:53.358287Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.358863Z", "completed_at": "2025-12-13T16:37:53.358870Z"}], "thread_id": "Thread-1", "execution_time": 0.007226228713989258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_FPMMDeterministicFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-04'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_FPMMDeterministicFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_FPMMDeterministicFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.361608Z", "completed_at": "2025-12-13T16:37:53.368165Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.368754Z", "completed_at": "2025-12-13T16:37:53.368761Z"}], "thread_id": "Thread-1", "execution_time": 0.008485794067382812, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_GBCDeposit_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '0b98057ea310f4d31f2a452b414647007d1645d9'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_GBCDeposit_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_GBCDeposit_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.371570Z", "completed_at": "2025-12-13T16:37:53.376826Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.377424Z", "completed_at": "2025-12-13T16:37:53.377432Z"}], "thread_id": "Thread-1", "execution_time": 0.007204294204711914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_OmenAgentResultMapping_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-09-30'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_OmenAgentResultMapping_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_OmenAgentResultMapping_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.380177Z", "completed_at": "2025-12-13T16:37:53.385437Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.386009Z", "completed_at": "2025-12-13T16:37:53.386016Z"}], "thread_id": "Thread-1", "execution_time": 0.007222890853881836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Realitio_v2_1_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2021-01-13'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Realitio_v2_1_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Realitio_v2_1_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.388700Z", "completed_at": "2025-12-13T16:37:53.393957Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.394554Z", "completed_at": "2025-12-13T16:37:53.394561Z"}], "thread_id": "Thread-1", "execution_time": 0.007102251052856445, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_MarketFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-10-08'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Seer_MarketFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_MarketFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.397355Z", "completed_at": "2025-12-13T16:37:53.402728Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.403347Z", "completed_at": "2025-12-13T16:37:53.403354Z"}], "thread_id": "Thread-1", "execution_time": 0.00732731819152832, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_Wrapped1155Factory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-02-07'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Seer_Wrapped1155Factory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_Wrapped1155Factory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.406063Z", "completed_at": "2025-12-13T16:37:53.412708Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.413321Z", "completed_at": "2025-12-13T16:37:53.413328Z"}], "thread_id": "Thread-1", "execution_time": 0.008591413497924805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-09-22'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.416032Z", "completed_at": "2025-12-13T16:37:53.421297Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.421876Z", "completed_at": "2025-12-13T16:37:53.421883Z"}], "thread_id": "Thread-1", "execution_time": 0.007172107696533203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraPool_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-11-30'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraPool_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.424608Z", "completed_at": "2025-12-13T16:37:53.429913Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.430506Z", "completed_at": "2025-12-13T16:37:53.430513Z"}], "thread_id": "Thread-1", "execution_time": 0.007234811782836914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_aaveV3_PoolConfigurator_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '7304979ec9e4eaa0273b6a037a31c4e9e5a75d16'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-10-04'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_aaveV3_PoolConfigurator_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '7304979ec9e4eaa0273b6a037a31c4e9e5a75d16'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_aaveV3_PoolConfigurator_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.433225Z", "completed_at": "2025-12-13T16:37:53.438480Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.439061Z", "completed_at": "2025-12-13T16:37:53.439068Z"}], "thread_id": "Thread-1", "execution_time": 0.007202863693237305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_aaveV3_PoolInstance_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'b50201558b00496a145fe76f7424749556e326d8'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-10-04'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_aaveV3_PoolInstance_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'b50201558b00496a145fe76f7424749556e326d8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_aaveV3_PoolInstance_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.441777Z", "completed_at": "2025-12-13T16:37:53.447087Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.447700Z", "completed_at": "2025-12-13T16:37:53.447708Z"}], "thread_id": "Thread-1", "execution_time": 0.007237911224365234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_TSLAx_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '19972d1750f959dd14cf436da6360185bd54cea0'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_TSLAx_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '19972d1750f959dd14cf436da6360185bd54cea0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_TSLAx_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.450395Z", "completed_at": "2025-12-13T16:37:53.455641Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.456235Z", "completed_at": "2025-12-13T16:37:53.456243Z"}], "thread_id": "Thread-1", "execution_time": 0.0070879459381103516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bC3M_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '83ec02059f686e747392a22ddfed7833ba0d7ce3'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bC3M_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83ec02059f686e747392a22ddfed7833ba0d7ce3'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bC3M_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.458928Z", "completed_at": "2025-12-13T16:37:53.465332Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.465905Z", "completed_at": "2025-12-13T16:37:53.465912Z"}], "thread_id": "Thread-1", "execution_time": 0.008238554000854492, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bCOIN_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '69b2d456e8830847f488afdde2a636bfb26218c6'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bCOIN_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '69b2d456e8830847f488afdde2a636bfb26218c6'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bCOIN_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.468600Z", "completed_at": "2025-12-13T16:37:53.473763Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.474359Z", "completed_at": "2025-12-13T16:37:53.474366Z"}], "thread_id": "Thread-1", "execution_time": 0.007006168365478516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bCSPX_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '1332d2b4dc83238b621b7f7d0f72fec58bb81a9b'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bCSPX_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '1332d2b4dc83238b621b7f7d0f72fec58bb81a9b'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bCSPX_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.477052Z", "completed_at": "2025-12-13T16:37:53.482383Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.482970Z", "completed_at": "2025-12-13T16:37:53.482977Z"}], "thread_id": "Thread-1", "execution_time": 0.00723576545715332, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bHIGH_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '9e8e794ad6ecdb6d5c7eabe059d30e907f58859b'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bHIGH_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9e8e794ad6ecdb6d5c7eabe059d30e907f58859b'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bHIGH_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.485730Z", "completed_at": "2025-12-13T16:37:53.490959Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.491558Z", "completed_at": "2025-12-13T16:37:53.491565Z"}], "thread_id": "Thread-1", "execution_time": 0.007175922393798828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bIB01_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '788d911ae7c95121a89a0f0306db65d87422e1de'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bIB01_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '788d911ae7c95121a89a0f0306db65d87422e1de'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bIB01_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.494289Z", "completed_at": "2025-12-13T16:37:53.499469Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.500046Z", "completed_at": "2025-12-13T16:37:53.500053Z"}], "thread_id": "Thread-1", "execution_time": 0.007130622863769531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bIBTA_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '9f9953d8a2c5366f098754d48f2d69b144ce03da'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bIBTA_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9f9953d8a2c5366f098754d48f2d69b144ce03da'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bIBTA_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.502791Z", "completed_at": "2025-12-13T16:37:53.507977Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.508579Z", "completed_at": "2025-12-13T16:37:53.508586Z"}], "thread_id": "Thread-1", "execution_time": 0.007137298583984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bMSTR_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'c8429803dcda7df86822ab173ea285c10bf1eb66'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bMSTR_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'c8429803dcda7df86822ab173ea285c10bf1eb66'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bMSTR_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.511316Z", "completed_at": "2025-12-13T16:37:53.517737Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.518334Z", "completed_at": "2025-12-13T16:37:53.518341Z"}], "thread_id": "Thread-1", "execution_time": 0.00838327407836914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bNVDA_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '1d3be4d05eba2aa6c4eede85a74f491c31766e64'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bNVDA_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '1d3be4d05eba2aa6c4eede85a74f491c31766e64'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bNVDA_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.521044Z", "completed_at": "2025-12-13T16:37:53.526358Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.526955Z", "completed_at": "2025-12-13T16:37:53.526962Z"}], "thread_id": "Thread-1", "execution_time": 0.0072519779205322266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v1_Hub_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '29b9a7fbb8995b2423a71cc17cf9810798f6c543'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v1_Hub_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '29b9a7fbb8995b2423a71cc17cf9810798f6c543'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v1_Hub_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.529667Z", "completed_at": "2025-12-13T16:37:53.534883Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.535492Z", "completed_at": "2025-12-13T16:37:53.535499Z"}], "thread_id": "Thread-1", "execution_time": 0.007082462310791016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_CirclesBackingFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'eced91232c609a42f6016860e8223b8aecaa7bd0'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2025-04-25'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_CirclesBackingFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'eced91232c609a42f6016860e8223b8aecaa7bd0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_CirclesBackingFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.538248Z", "completed_at": "2025-12-13T16:37:53.543572Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.544201Z", "completed_at": "2025-12-13T16:37:53.544208Z"}], "thread_id": "Thread-1", "execution_time": 0.0073316097259521484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_Hub_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'c12c1e50abb450d6205ea2c3fa861b3b834d13e8'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_Hub_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'c12c1e50abb450d6205ea2c3fa861b3b834d13e8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_Hub_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.547113Z", "completed_at": "2025-12-13T16:37:53.552265Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.552841Z", "completed_at": "2025-12-13T16:37:53.552848Z"}], "thread_id": "Thread-1", "execution_time": 0.007077217102050781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_NameRegistry_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'a27566fd89162cc3d40cb59c87aaaa49b85f3474'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_NameRegistry_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a27566fd89162cc3d40cb59c87aaaa49b85f3474'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_NameRegistry_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.555531Z", "completed_at": "2025-12-13T16:37:53.561822Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.562416Z", "completed_at": "2025-12-13T16:37:53.562423Z"}], "thread_id": "Thread-1", "execution_time": 0.00813436508178711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_sdai_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'af204776c7245bf4147c2612bf6e5972ee483701'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_sdai_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'af204776c7245bf4147c2612bf6e5972ee483701'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_sdai_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.565062Z", "completed_at": "2025-12-13T16:37:53.570362Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.570961Z", "completed_at": "2025-12-13T16:37:53.570968Z"}], "thread_id": "Thread-1", "execution_time": 0.007181644439697266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_wxdai_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_wxdai_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_wxdai_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.573718Z", "completed_at": "2025-12-13T16:37:53.579043Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.579655Z", "completed_at": "2025-12-13T16:37:53.579662Z"}], "thread_id": "Thread-1", "execution_time": 0.007222414016723633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_AgentResultMapping_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2025-06-30'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_AgentResultMapping_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_AgentResultMapping_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.582415Z", "completed_at": "2025-12-13T16:37:53.587628Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.588224Z", "completed_at": "2025-12-13T16:37:53.588231Z"}], "thread_id": "Thread-1", "execution_time": 0.0071756839752197266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_ConditionalTokens_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-01'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_ConditionalTokens_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_ConditionalTokens_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.590912Z", "completed_at": "2025-12-13T16:37:53.596151Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.596730Z", "completed_at": "2025-12-13T16:37:53.596737Z"}], "thread_id": "Thread-1", "execution_time": 0.007144451141357422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_FPMMDeterministicFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-04'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_FPMMDeterministicFactory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_FPMMDeterministicFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.599532Z", "completed_at": "2025-12-13T16:37:53.604788Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.605381Z", "completed_at": "2025-12-13T16:37:53.605388Z"}], "thread_id": "Thread-1", "execution_time": 0.007195949554443359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_GBCDeposit_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_GBCDeposit_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_GBCDeposit_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.608060Z", "completed_at": "2025-12-13T16:37:53.614659Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.615255Z", "completed_at": "2025-12-13T16:37:53.615262Z"}], "thread_id": "Thread-1", "execution_time": 0.008503198623657227, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_OmenAgentResultMapping_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-09-30'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_OmenAgentResultMapping_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_OmenAgentResultMapping_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.617945Z", "completed_at": "2025-12-13T16:37:53.623175Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.623753Z", "completed_at": "2025-12-13T16:37:53.623761Z"}], "thread_id": "Thread-1", "execution_time": 0.00707244873046875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Realitio_v2_1_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2021-01-13'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Realitio_v2_1_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Realitio_v2_1_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.626484Z", "completed_at": "2025-12-13T16:37:53.631755Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.632377Z", "completed_at": "2025-12-13T16:37:53.632384Z"}], "thread_id": "Thread-1", "execution_time": 0.0072116851806640625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_MarketFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-10-08'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Seer_MarketFactory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_MarketFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.635086Z", "completed_at": "2025-12-13T16:37:53.640392Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.640980Z", "completed_at": "2025-12-13T16:37:53.640987Z"}], "thread_id": "Thread-1", "execution_time": 0.007212638854980469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_Wrapped1155Factory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-02-07'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Seer_Wrapped1155Factory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_Wrapped1155Factory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.643735Z", "completed_at": "2025-12-13T16:37:53.649056Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.649653Z", "completed_at": "2025-12-13T16:37:53.649660Z"}], "thread_id": "Thread-1", "execution_time": 0.007264137268066406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-09-22'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.652403Z", "completed_at": "2025-12-13T16:37:53.657717Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.658309Z", "completed_at": "2025-12-13T16:37:53.658316Z"}], "thread_id": "Thread-1", "execution_time": 0.00726008415222168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraPool_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-11-30'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraPool_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.661002Z", "completed_at": "2025-12-13T16:37:53.667507Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.668075Z", "completed_at": "2025-12-13T16:37:53.668082Z"}], "thread_id": "Thread-1", "execution_time": 0.008418560028076172, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_wxdai_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_wxdai_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_wxdai_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.670767Z", "completed_at": "2025-12-13T16:37:53.675960Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.676567Z", "completed_at": "2025-12-13T16:37:53.676575Z"}], "thread_id": "Thread-1", "execution_time": 0.007104396820068359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_labels", "compiled": true, "compiled_code": "\n\n\nWITH latest AS (\n  SELECT\n    lower(address) AS address,\n    (label, introduced_at) AS agg\n  FROM `crawlers_data`.`dune_labels`\n),\n\nclean AS (\n  SELECT\n    address,\n    tupleElement(agg, 1) AS label_raw,\n    tupleElement(agg, 2) AS introduced_at,\n\n    trim(replaceRegexpAll(tupleElement(agg, 1), '\\\\s*([:/|>])\\\\s*', '\\\\1'))                           AS s1,\n\n    replaceRegexpAll(\n      replaceRegexpAll(s1, '_0x[0-9a-fA-F]{40}$', ''),\n      '_0x[0-9a-fA-F]{1,}\u2026[0-9a-fA-F]{1,}$',\n      ''\n    )                                                                                                AS s2,\n\n    trim(extract(s2, '^([^:/|>]+)'))                                                                 AS s3,\n\n    trim(replaceRegexpAll(s3, '(?:\\\\s*[-_ ]?[Vv]\\\\d+(?:[._-]\\\\d+)*)\\\\b', ''))                        AS s4,\n\n    lowerUTF8(s4)                                                                                    AS s4_l,\n\n    (\n      match(s1, '_0x[0-9a-fA-F]{40}$')\n      OR match(s1, '_0x[0-9a-fA-F]{1,}\u2026[0-9a-fA-F]{1,}$')\n    )                                                                                                AS looks_like_token_tail\n  FROM latest\n),\n\nwl AS (\n  SELECT\n    lower(address) AS address,\n    symbol\n  FROM `dbt`.`tokens_whitelist`\n),\n\nbucketed AS (\n \n  SELECT\n    c.address,\n    c.label_raw,\n    c.introduced_at,\n    c.s4,\n    c.s4_l,\n    c.looks_like_token_tail,\n    w.symbol AS wl_symbol,\n\n    coalesce(\n      if(c.looks_like_token_tail,\n         if(w.symbol IS NOT NULL, w.symbol, 'ERC20'),\n         NULL\n      ),\n\n      multiIf(\n        match(c.s4_l, '^(realtoken|realtokens)\\\\b'),              'REALTOKEN',\n        match(lowerUTF8(c.label_raw), '(^|[^a-z0-9])gnosis[\\\\s_-]*safe(?:l2)?([^a-z0-9]|$)') OR match(c.s4_l, '^(safe(?:l2)?)\\\\b'), 'Safe',\n\n        match(c.s4_l, '(^|[^a-z])balancer([^a-z]|$)'),            'Balancer',\n        match(c.s4_l, '(^|[-_])gaug(e)?(\\\\b|_)'),                 'Balancer',\n        match(c.s4_l, '\\\\b\\\\d{1,3}%[a-z0-9._-]+'),                'Balancer',\n        match(c.s4_l, '\\\\b(w?moo)[a-z0-9]*balancer'),             'Balancer',\n\n        match(c.s4_l, '(^|[^a-z])curve([^a-z]|$)'),               'Curve',\n        match(c.s4_l, '^(yv\\\\s*curve|yvcurve|y\\\\s*curve|ycurve)'), 'Curve',\n        match(c.s4_l, '^curvefi\\\\b'),                             'Curve',\n\n        match(c.s4_l, '\\\\buniswap\\\\b'),                           'Uniswap',\n        match(c.s4_l, '\\\\buni[- _]?v?3\\\\b'),                      'Uniswap',\n        match(c.s4_l, '\\\\buni[- _]?v?2\\\\b'),                      'Uniswap',\n        match(c.s4_l, '\\\\bnonfungiblepositionmanager\\\\b'),        'Uniswap',\n        match(c.s4_l, '\\\\bpositions?\\\\s*nft\\\\b'),                 'Uniswap',\n        match(c.s4_l, '\\\\b(rcow|cow|moo\\\\w*)\\\\s*uniswap'),        'Uniswap',\n\n        match(c.s4_l, 'sushi'),                                   'Sushi',\n\n        match(c.s4_l, '\\\\bswapr\\\\b'),                             'Swapr',\n        match(c.s4_l, '^swaprv?3\\\\b'),                            'Swapr',\n        match(c.s4_l, '\\\\bswpr\\\\b'),                              'Swapr',\n\n        match(c.s4_l, '\\\\bcow\\\\s*swap\\\\b|\\\\bcow[_\\\\s-]?protocol\\\\b|^b_cow_amm\\\\b'), 'CowSwap',\n        match(c.s4_l, '^aave\\\\b'),                                'Aave',\n        match(c.s4_l, '\\\\baave\\\\s*v?2\\\\b|\\\\baave\\\\s*v?3\\\\b'),     'Aave',\n        match(c.s4_l, '^aavepool\\\\b'),                            'Aave',\n\n        c.s4\n      )\n    ) AS s5\n  FROM clean c\n  LEFT JOIN wl w\n    ON c.address = w.address\n),\n\ntidy AS (\n  SELECT\n    address,\n    label_raw,\n    introduced_at,\n    trim(\n      replaceRegexpAll(\n        replaceRegexpAll(\n          replaceRegexpAll(\n            left(s5, length(\n              replaceRegexpAll(\n                lowerUTF8(s5),\n                '\\\\b(factory|router|vault|pool|implementation|proxy|token|bridge|aggregator|registry|controller|manager|oracle|staking|treasury|multisig|gnosis\\\\s*safe|deployer|fee\\\\s*collector|minter|burner|timelock|governor|council|rewards?|distributor|airdrop)s?\\\\s*$',\n                ''\n              )\n            )),\n            '\\\\s*\\\\([^)]*\\\\)\\\\s*$', ''\n          ),\n          '\\\\?+$', ''\n        ),\n        '[_\\\\s-]+', ' '\n      )\n    ) AS s7\n  FROM bucketed\n),\n\ncanon AS (\n  SELECT\n    address,\n    label_raw,\n    introduced_at,\n    s7,\n    multiIf(\n      match(lowerUTF8(s7), '^unlock(\\\\s*protocol)?$'),                        'Unlock Protocol',\n      match(lowerUTF8(s7), '^(eth\\\\s*swarm|ethereum\\\\s*swarm|swarm)$'),       'Swarm',\n      match(lowerUTF8(s7), '^symmetric(\\\\s*finance)?$'),                      'Symmetric',\n      match(lowerUTF8(s7), '^elk(\\\\s*finance)?$'),                            'Elk Finance',\n      match(lowerUTF8(s7), '^monerium(\\\\s*(usde|iske|blacklist))?$'),         'Monerium',\n      match(lowerUTF8(s7), '^gnosis\\\\s*pay(\\\\s*(vip|spender|eiffel))?$|^gnosispay$'), 'Gnosis Pay',\n      match(lowerUTF8(s7), '^hopr(\\\\s*(protocol|network|token|boost\\\\s*nft))?$'),    'HOPR',\n      match(lowerUTF8(s7), '^kleros(\\\\s*curate)?$'),                          'Kleros',\n      match(lowerUTF8(s7), '^sismo(\\\\s*(badges|roots))?$'),                   'Sismo',\n      match(lowerUTF8(s7), '^request(\\\\s*network)?$'),                        'Request Network',\n      match(lowerUTF8(s7), '^event\\\\s*sbt(\\\\s*\\\\(esbt\\\\)\\\\s*test)?$'),        'EventSBT',\n      match(lowerUTF8(s7), '^polkamarkets(\\\\s*aa)?$'),                        'Polkamarkets',\n      match(lowerUTF8(s7), '^everclear.*$'),                                  'Everclear',\n      match(lowerUTF8(s7), '^merkly(\\\\s*farmer)?$'),                          'Merkly',\n      match(lowerUTF8(s7), '^zerion(\\\\s*premium\\\\s*purchaser\\\\s*l2)?$'),      'Zerion',\n      match(lowerUTF8(s7), '^aura(\\\\s*finance)?$'),                           'Aura Finance',\n      match(lowerUTF8(s7), '^open\\\\s*ocean(exchange)?$|^openoceanexchange$'), 'OpenOcean',\n      match(lowerUTF8(s7), '^(amb|.*\\\\sxdai\\\\s*amb)$'),                       'AMB',\n      match(lowerUTF8(s7), '^cow\\\\s*swap$'),                                  'CowSwap',\n      match(lowerUTF8(s7), '^(rmm|real\\\\s*rmm|rmm\\\\s*ecosystem\\\\s*reserve)$'), 'RMM',\n      match(lowerUTF8(s7), '^erc\\\\s*-?\\\\s*4337(\\\\s*entry\\\\s*point)?$'), 'ERC-4337 Entry Point',\n      match(lowerUTF8(s7), '^(aa\\\\s*entrypoint|erc-?4337\\\\s*entry\\\\s*point|entrypointsimulations|pimlicoentrypointsimulations)$'), 'ERC-4337 Entry Point',\n      match(lowerUTF8(s7), '^(uni|uni\\\\s*v?3\\\\s*swaprouter02)$'),                                      'Uniswap',\n      match(lowerUTF8(s7), '^(oneinch)$'),                                                             '1inch',\n      match(lowerUTF8(s7), '^layerzero$'),                                                             'LayerZero',\n      match(lowerUTF8(s7), '^(cowswap|b_cow_amm)$'),                                                   'CowSwap',\n      match(lowerUTF8(s7), '^angle(\\\\s+ageur)?$'),                                                     'Angle',\n      match(lowerUTF8(s7), '^sablier(\\\\s+.*)?$|^sablier\\\\s*flow\\\\b|^sablier\\\\s*lockup\\\\b'),            'Sablier',\n      match(lowerUTF8(s7), '^hats[_\\\\s-]?protocol'),                                                   'Hats Protocol',\n      match(lowerUTF8(s7), '^seaport\\\\??$'),                                                           'Seaport',\n      match(lowerUTF8(s7), '^poap(\\\\s+top)?$'),                                                        'POAP',\n      match(lowerUTF8(s7), '^merkly(\\\\s+onft)?$'),                                                     'Merkly',\n      match(lowerUTF8(s7), '^circles(\\\\s*ubi)?$'),                                                     'Circles',\n      match(lowerUTF8(s7), '^(hop|hop\\\\s*protocol)$'),                                                 'Hop Protocol',\n      match(lowerUTF8(s7), '^opensea$'),                                                               'OpenSea',\n      match(lowerUTF8(s7), '^paraswap$'),                                                              'ParaSwap',\n      match(lowerUTF8(s7), '^realt(oken)?(\\\\s*money\\\\s*market)?$|^realtoken\\\\s*dao$|^realtyam$|^real_rmm$'), 'REALTOKEN',\n      match(lowerUTF8(s7), '^nulladdress$|^burn\\\\s*address$'),                                         'Null/Burn',\n      match(lowerUTF8(s7), '^eoa$'),                                                                   'EOA',\n      match(lowerUTF8(s7), '^proxyadmin$|^transparentupgradeableproxy$|^upgradeablecommunitytoken$|^contractaddressfeehelper$|^controllermodule$'), 'Infrastructure',\n      match(lowerUTF8(s7), '^unnamed$|^oracle\\\\?$|^dex\\\\s*aggregator\\\\?$|^\\\\?$'),                      'Unknown',\n      s7\n    ) AS project_canon\n  FROM tidy\n)\n\nSELECT\n  address,\n  if(\n    lengthUTF8(project_canon) = 0\n    OR positionCaseInsensitive(project_canon, '0x') > 0\n    OR match(label_raw, '_0x[0-9a-fA-F]{40}$')\n    OR match(label_raw, '_0x[0-9a-fA-F]{1,}\u2026[0-9a-fA-F]{1,}$'),\n    'ERC20',\n    project_canon\n  ) AS project,\n  label_raw AS project_raw,\n  introduced_at\nFROM canon", "relation_name": "`dbt`.`stg_crawlers_data__dune_labels`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.679342Z", "completed_at": "2025-12-13T16:37:53.683283Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.683869Z", "completed_at": "2025-12-13T16:37:53.683876Z"}], "thread_id": "Thread-1", "execution_time": 0.005914449691772461, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_attestations_daily", "compiled": true, "compiled_code": "\nSELECT\n    date\n    ,inclusion_delay\n    ,cnt\nFROM `dbt`.`int_consensus_attestations_daily`\nORDER BY date, inclusion_delay", "relation_name": "`dbt`.`api_consensus_attestations_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.686534Z", "completed_at": "2025-12-13T16:37:53.691217Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.691790Z", "completed_at": "2025-12-13T16:37:53.691797Z"}], "thread_id": "Thread-1", "execution_time": 0.006530284881591797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_attestations_daily_date.3762d44128", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_attestations_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.694420Z", "completed_at": "2025-12-13T16:37:53.698835Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.699404Z", "completed_at": "2025-12-13T16:37:53.699411Z"}], "thread_id": "Thread-1", "execution_time": 0.006213665008544922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_blob_commitments_daily_date.3327c6b9f7", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_blob_commitments_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.702367Z", "completed_at": "2025-12-13T16:37:53.707310Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.707891Z", "completed_at": "2025-12-13T16:37:53.707898Z"}], "thread_id": "Thread-1", "execution_time": 0.0071260929107666016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_graffiti_label_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,SUM(cnt) AS value\nFROM `dbt`.`int_consensus_graffiti_daily`\nGROUP BY date, label\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_graffiti_label_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.710704Z", "completed_at": "2025-12-13T16:37:53.714521Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.715116Z", "completed_at": "2025-12-13T16:37:53.715123Z"}], "thread_id": "Thread-1", "execution_time": 0.005772829055786133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_graffiti_cloud", "compiled": true, "compiled_code": "\n\n\nWITH base AS (\n  SELECT\n      graffiti,\n      sumIf(cnt, date >= today() - 7)  AS v_7d,\n      sumIf(cnt, date >= today() - 30) AS v_30d,\n      sumIf(cnt, date >= today() - 90) AS v_90d,\n      sum(cnt)                         AS v_all\n  FROM `dbt`.`int_consensus_graffiti_daily`\n  WHERE graffiti != 'None'\n  GROUP BY graffiti\n)\nSELECT\n  label,\n  graffiti,\n  value\nFROM base\nARRAY JOIN\n  ['7D','30D','90D','All'] AS label,\n  [v_7d, v_30d, v_90d, v_all] AS value\nORDER BY label, value DESC\nLIMIT 50 BY label", "relation_name": "`dbt`.`fct_consensus_graffiti_cloud`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.717846Z", "completed_at": "2025-12-13T16:37:53.722251Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.722802Z", "completed_at": "2025-12-13T16:37:53.722809Z"}], "thread_id": "Thread-1", "execution_time": 0.00626683235168457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_graffiti_daily_date.428851ad09", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_graffiti_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.725554Z", "completed_at": "2025-12-13T16:37:53.729362Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.729940Z", "completed_at": "2025-12-13T16:37:53.729947Z"}], "thread_id": "Thread-1", "execution_time": 0.0057489871978759766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_forks", "compiled": true, "compiled_code": "\n\nSELECT\n  fork_name\n  ,fork_version \n  ,fork_digest\n  ,fork_epoch \nFROM `dbt`.`fct_consensus_forks`\nORDER BY fork_version ASC", "relation_name": "`dbt`.`api_consensus_forks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.732596Z", "completed_at": "2025-12-13T16:37:53.736445Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.737011Z", "completed_at": "2025-12-13T16:37:53.737018Z"}], "thread_id": "Thread-1", "execution_time": 0.005684614181518555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_blob_commitments_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,total_blob_commitments AS value\nFROM `dbt`.`int_consensus_blocks_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_blob_commitments_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.739739Z", "completed_at": "2025-12-13T16:37:53.743894Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.744486Z", "completed_at": "2025-12-13T16:37:53.744493Z"}], "thread_id": "Thread-1", "execution_time": 0.0060498714447021484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_blocks_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,label\n    ,value\nFROM (\n    SELECT date, 'produced' AS label, blocks_produced AS value FROM `dbt`.`int_consensus_blocks_daily`\n    UNION ALL \n    SELECT date, 'missed' AS label, blocks_missed AS value FROM `dbt`.`int_consensus_blocks_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_blocks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.747324Z", "completed_at": "2025-12-13T16:37:53.752726Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.753323Z", "completed_at": "2025-12-13T16:37:53.753330Z"}], "thread_id": "Thread-1", "execution_time": 0.007371664047241211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_zero_blob_commitments_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,label\n    ,value\nFROM (\n    SELECT date, 'with Blobs' AS label, toInt64(blocks_produced) - toInt64(blocks_with_zero_blob_commitments) AS value FROM `dbt`.`int_consensus_blocks_daily`\n    UNION ALL \n    SELECT date, 'without Blobs' AS label, toInt64(blocks_with_zero_blob_commitments) AS value FROM `dbt`.`int_consensus_blocks_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_zero_blob_commitments_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.756071Z", "completed_at": "2025-12-13T16:37:53.759903Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.760500Z", "completed_at": "2025-12-13T16:37:53.760508Z"}], "thread_id": "Thread-1", "execution_time": 0.00568699836730957, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_credentials_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,credentials_type\n    ,cnt\n    ,ROUND(cnt/(SUM(cnt) OVER (PARTITION BY date)) * 100,2) AS pct \nFROM `dbt`.`int_consensus_credentials_daily`\nORDER BY date, credentials_type", "relation_name": "`dbt`.`api_consensus_credentials_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.763283Z", "completed_at": "2025-12-13T16:37:53.767369Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.767948Z", "completed_at": "2025-12-13T16:37:53.767955Z"}], "thread_id": "Thread-1", "execution_time": 0.0060291290283203125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_credentials_latest", "compiled": true, "compiled_code": "\n\nSELECT \n    credentials_type\n    ,cnt\nFROM `dbt`.`int_consensus_credentials_daily`\nWHERE date = (SELECT MAX(date) FROM `dbt`.`int_consensus_credentials_daily`)", "relation_name": "`dbt`.`api_consensus_credentials_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.770570Z", "completed_at": "2025-12-13T16:37:53.774985Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.775560Z", "completed_at": "2025-12-13T16:37:53.775568Z"}], "thread_id": "Thread-1", "execution_time": 0.00622248649597168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_credentials_daily_date.4d0b4560ad", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_credentials_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.778245Z", "completed_at": "2025-12-13T16:37:53.782191Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.782794Z", "completed_at": "2025-12-13T16:37:53.782801Z"}], "thread_id": "Thread-1", "execution_time": 0.005853414535522461, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_entry_queue_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,validator_count\n    ,q05\n    ,q10\n    ,q25\n    ,q50\n    ,q75\n    ,q90\n    ,q95\n    ,mean\nFROM `dbt`.`int_consensus_entry_queue_daily`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_entry_queue_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.785534Z", "completed_at": "2025-12-13T16:37:53.791195Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.791749Z", "completed_at": "2025-12-13T16:37:53.791756Z"}], "thread_id": "Thread-1", "execution_time": 0.007544040679931641, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_entry_queue_daily_date.15e3afea2e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_entry_queue_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.794330Z", "completed_at": "2025-12-13T16:37:53.798731Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.799305Z", "completed_at": "2025-12-13T16:37:53.799313Z"}], "thread_id": "Thread-1", "execution_time": 0.006202220916748047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_entry_queue_daily_validator_index.319160416e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect validator_index\nfrom `dbt`.`int_consensus_entry_queue_daily`\nwhere validator_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.801868Z", "completed_at": "2025-12-13T16:37:53.806238Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.806794Z", "completed_at": "2025-12-13T16:37:53.806801Z"}], "thread_id": "Thread-1", "execution_time": 0.006149768829345703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_consensus_entry_queue_daily_validator_index.fc738c2e6c", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    validator_index as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_consensus_entry_queue_daily`\nwhere validator_index is not null\ngroup by validator_index\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.809452Z", "completed_at": "2025-12-13T16:37:53.813292Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.813862Z", "completed_at": "2025-12-13T16:37:53.813869Z"}], "thread_id": "Thread-1", "execution_time": 0.005651950836181641, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_staked_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,effective_balance/32 AS value\nFROM `dbt`.`int_consensus_validators_balances_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_staked_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.816639Z", "completed_at": "2025-12-13T16:37:53.820754Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.821346Z", "completed_at": "2025-12-13T16:37:53.821353Z"}], "thread_id": "Thread-1", "execution_time": 0.0061113834381103516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_balances_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,value\nFROM (\n    SELECT\n        date\n        ,'balance' AS label\n        ,balance AS value\n    FROM `dbt`.`int_consensus_validators_balances_daily`\n\n    UNION ALL \n\n    SELECT\n        date\n        ,'eff. balance' AS label\n        ,effective_balance AS value\n    FROM `dbt`.`int_consensus_validators_balances_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_validators_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.824019Z", "completed_at": "2025-12-13T16:37:53.828500Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.829047Z", "completed_at": "2025-12-13T16:37:53.829054Z"}], "thread_id": "Thread-1", "execution_time": 0.0064013004302978516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_validators_balances_daily_date.13eaf1e79b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_validators_balances_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.831620Z", "completed_at": "2025-12-13T16:37:53.836783Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.837401Z", "completed_at": "2025-12-13T16:37:53.837408Z"}], "thread_id": "Thread-1", "execution_time": 0.007024288177490234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_active_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,cnt\nFROM `dbt`.`int_consensus_validators_status_daily`\nWHERE status = 'active_ongoing'\nORDER BY date", "relation_name": "`dbt`.`api_consensus_validators_active_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.840167Z", "completed_at": "2025-12-13T16:37:53.844013Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.844618Z", "completed_at": "2025-12-13T16:37:53.844625Z"}], "thread_id": "Thread-1", "execution_time": 0.005721330642700195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_status_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,status\n    ,cnt\nFROM `dbt`.`int_consensus_validators_status_daily`\nWHERE status NOT IN ('active_ongoing', 'withdrawal_done')\nORDER BY date, status", "relation_name": "`dbt`.`api_consensus_validators_status_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.847356Z", "completed_at": "2025-12-13T16:37:53.851867Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.852444Z", "completed_at": "2025-12-13T16:37:53.852451Z"}], "thread_id": "Thread-1", "execution_time": 0.00649261474609375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_validators_status_daily_date.8a3bdc4a88", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_validators_status_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.855117Z", "completed_at": "2025-12-13T16:37:53.858937Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.859540Z", "completed_at": "2025-12-13T16:37:53.859547Z"}], "thread_id": "Thread-1", "execution_time": 0.005760908126831055, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_withdrawal_credentials_freq_daily", "compiled": true, "compiled_code": "\nSELECT \n    date\n    ,CASE \n        WHEN cnt < 10 THEN '[1-10['\n        WHEN cnt >= 10 AND cnt < 50 THEN '[10-50['\n        WHEN cnt >= 50 AND cnt < 100 THEN '[50-100['\n        WHEN cnt >= 100 AND cnt < 500 THEN '[100-500['\n        WHEN cnt >= 500 AND cnt < 1000 THEN '[500-1000['\n        WHEN cnt >= 1000 AND cnt < 2000 THEN '[1000-2000['\n        ELSE '2000+'\n    END AS bin_number_validators\n    ,count() AS withdrawal_credentials_freq_cnt\nFROM `dbt`.`int_consensus_withdrawal_credentials_daily`\nGROUP BY 1, 2", "relation_name": "`dbt`.`fct_consensus_withdrawal_credentials_freq_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.862351Z", "completed_at": "2025-12-13T16:37:53.866771Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.867337Z", "completed_at": "2025-12-13T16:37:53.867345Z"}], "thread_id": "Thread-1", "execution_time": 0.006299734115600586, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_withdrawal_credentials_daily_date.3c49b681c3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_withdrawal_credentials_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.869946Z", "completed_at": "2025-12-13T16:37:53.873803Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.874404Z", "completed_at": "2025-12-13T16:37:53.874411Z"}], "thread_id": "Thread-1", "execution_time": 0.005710124969482422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_deposits_withdrawls_cnt_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,cnt AS value\nFROM \n    `dbt`.`int_consensus_deposits_withdrawals_daily`\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_deposits_withdrawls_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.877152Z", "completed_at": "2025-12-13T16:37:53.882249Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.882830Z", "completed_at": "2025-12-13T16:37:53.882837Z"}], "thread_id": "Thread-1", "execution_time": 0.006953716278076172, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_deposits_withdrawls_volume_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,total_amount AS value\nFROM \n    `dbt`.`int_consensus_deposits_withdrawals_daily`\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_deposits_withdrawls_volume_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.885537Z", "completed_at": "2025-12-13T16:37:53.889914Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.890493Z", "completed_at": "2025-12-13T16:37:53.890501Z"}], "thread_id": "Thread-1", "execution_time": 0.0061931610107421875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_deposits_withdrawals_daily_date.033d8e04f1", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_deposits_withdrawals_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.893189Z", "completed_at": "2025-12-13T16:37:53.897691Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.898321Z", "completed_at": "2025-12-13T16:37:53.898328Z"}], "thread_id": "Thread-1", "execution_time": 0.006436586380004883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_validators_dists_last_30_days", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q_balance[1] AS q05_balance,\n    q_balance[2] AS q10_balance,\n    q_balance[3] AS q25_balance,\n    q_balance[4] AS q50_balance,\n    q_balance[5] AS q75_balance,\n    q_balance[6] AS q90_balance,\n    q_balance[7] AS q95_balance,\n    q_apy[1] AS q05_apy,\n    q_apy[2] AS q10_apy,\n    q_apy[3] AS q25_apy,\n    q_apy[4] AS q50_apy,\n    q_apy[5] AS q75_apy,\n    q_apy[6] AS q90_apy,\n    q_apy[7] AS q95_apy\nFROM (\n    SELECT\n        (SELECT max(date) FROM  `dbt`.`int_consensus_validators_per_index_apy_daily` ) AS date\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(balance/POWER(10,9)) AS q_balance\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(apy) AS q_apy\n    FROM `dbt`.`int_consensus_validators_per_index_apy_daily` \n    WHERE date >= addDays((SELECT max(date) FROM  `dbt`.`int_consensus_validators_per_index_apy_daily` ), -30)\n)", "relation_name": "`dbt`.`fct_consensus_validators_dists_last_30_days`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.901291Z", "completed_at": "2025-12-13T16:37:53.907129Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.907744Z", "completed_at": "2025-12-13T16:37:53.907751Z"}], "thread_id": "Thread-1", "execution_time": 0.007831573486328125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_dists_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q_balance[1] AS q05_balance,\n    q_balance[2] AS q10_balance,\n    q_balance[3] AS q25_balance,\n    q_balance[4] AS q50_balance,\n    q_balance[5] AS q75_balance,\n    q_balance[6] AS q90_balance,\n    q_balance[7] AS q95_balance,\n    avg_balance,\n    q_apy[1] AS q05_apy,\n    q_apy[2] AS q10_apy,\n    q_apy[3] AS q25_apy,\n    q_apy[4] AS q50_apy,\n    q_apy[5] AS q75_apy,\n    q_apy[6] AS q90_apy,\n    q_apy[7] AS q95_apy,\n    avg_apy\nFROM (\n    SELECT\n        date\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(balance/POWER(10,9)) AS q_balance\n        ,avg(balance/POWER(10,9)) AS avg_balance\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(apy) AS q_apy\n        ,avg(apy) AS avg_apy\n    FROM `dbt`.`int_consensus_validators_per_index_apy_daily`\n    WHERE status != 'pending_queued' AND apy < 200 --outlier filter\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_consensus_validators_dists_daily` AS x1\n    )\n    AND toStartOfDay(date) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_dists_daily` AS x2\n    )\n  \n\n    GROUP BY date\n)", "relation_name": "`dbt`.`int_consensus_validators_dists_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.910672Z", "completed_at": "2025-12-13T16:37:53.915183Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.915745Z", "completed_at": "2025-12-13T16:37:53.915752Z"}], "thread_id": "Thread-1", "execution_time": 0.0064427852630615234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_validators_per_index_apy_daily_date.d8e4f0bed2", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_validators_per_index_apy_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.918338Z", "completed_at": "2025-12-13T16:37:53.924055Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.924637Z", "completed_at": "2025-12-13T16:37:53.924644Z"}], "thread_id": "Thread-1", "execution_time": 0.007582426071166992, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_validators_per_index_apy_daily_validator_index.bf0825b655", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect validator_index\nfrom `dbt`.`int_consensus_validators_per_index_apy_daily`\nwhere validator_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.927237Z", "completed_at": "2025-12-13T16:37:53.931811Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.932382Z", "completed_at": "2025-12-13T16:37:53.932390Z"}], "thread_id": "Thread-1", "execution_time": 0.0063974857330322266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_consensus_validators_per_index_apy_daily_validator_index.d0da5cde77", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    validator_index as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_consensus_validators_per_index_apy_daily`\nwhere validator_index is not null\ngroup by validator_index\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.934993Z", "completed_at": "2025-12-13T16:37:53.941052Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.941651Z", "completed_at": "2025-12-13T16:37:53.941658Z"}], "thread_id": "Thread-1", "execution_time": 0.00791025161743164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_bridges_kpis_snapshot", "compiled": true, "compiled_code": "\n\nWITH mx AS (\n  SELECT max(date) AS d\n  FROM `dbt`.`int_bridges_flows_daily`\n),\ncum AS (\n  SELECT\n    sum(volume_usd) AS cum_vol_usd,\n    sum(net_usd)    AS cum_net_usd,\n    sum(txs)        AS cum_txs\n  FROM `dbt`.`int_bridges_flows_daily`, mx\n  WHERE date <= mx.d\n),\ncur7 AS (\n  SELECT\n    sum(volume_usd) AS vol_7d,\n    sum(net_usd)    AS net_7d,\n    sum(txs)        AS txs_7d\n  FROM `dbt`.`int_bridges_flows_daily`, mx\n  WHERE date BETWEEN subtractDays(mx.d, 6) AND mx.d\n),\nprev7 AS (\n  SELECT\n    sum(volume_usd) AS vol_prev_7d,\n    sum(net_usd)    AS net_prev_7d,\n    sum(txs)        AS txs_prev_7d\n  FROM `dbt`.`int_bridges_flows_daily`, mx\n  WHERE date BETWEEN subtractDays(mx.d, 13) AND subtractDays(mx.d, 7)\n),\nbridges AS (\n  SELECT uniqExact(trim(lower(bridge))) AS distinct_bridges\n  FROM `dbt`.`int_bridges_flows_daily`, mx\n  WHERE date <= mx.d\n),\nchains_u AS (\n  SELECT trim(lower(source_chain)) AS chain\n  FROM `dbt`.`int_bridges_flows_daily`, mx\n  WHERE date <= mx.d AND lower(source_chain) != 'gnosis'\n  UNION ALL\n  SELECT trim(lower(dest_chain)) AS chain\n  FROM `dbt`.`int_bridges_flows_daily`, mx\n  WHERE date <= mx.d AND lower(dest_chain) != 'gnosis'\n),\nchains AS (\n  SELECT uniqExact(chain) AS distinct_chains\n  FROM chains_u\n)\nSELECT\n  mx.d AS as_of_date,\n  cum.cum_vol_usd,\n  cum.cum_net_usd,\n  cum.cum_txs,\n  cur7.vol_7d,\n  cur7.net_7d,\n  cur7.txs_7d,\n  coalesce(prev7.vol_prev_7d, 0) AS vol_prev_7d,\n  coalesce(prev7.net_prev_7d, 0) AS net_prev_7d,\n  coalesce(prev7.txs_prev_7d, 0) AS txs_prev_7d,\n  if(cur7.vol_7d = 0, NULL, cur7.net_7d / cur7.vol_7d) AS rate_7d,\n  if(coalesce(prev7.vol_prev_7d,0) = 0, NULL, coalesce(prev7.net_prev_7d,0) / prev7.vol_prev_7d) AS rate_prev_7d,\n  if(coalesce(prev7.vol_prev_7d,0) = 0, NULL, (cur7.vol_7d - coalesce(prev7.vol_prev_7d,0)) / prev7.vol_prev_7d) AS chg_vol_7d,\n  if(coalesce(prev7.net_prev_7d,0) = 0, NULL, (cur7.net_7d - coalesce(prev7.net_prev_7d,0)) / prev7.net_prev_7d) AS chg_net_7d,\n  if(\n    coalesce(prev7.vol_prev_7d,0) = 0 OR coalesce(prev7.net_prev_7d,0) = 0 OR cur7.vol_7d = 0 OR cur7.net_7d = 0,\n    NULL,\n    ( (cur7.net_7d / cur7.vol_7d) - (prev7.net_prev_7d / prev7.vol_prev_7d) ) / (prev7.net_prev_7d / prev7.vol_prev_7d)\n  ) AS chg_rate_7d,\n  bridges.distinct_bridges,\n  chains.distinct_chains\nFROM mx, cum, cur7, prev7, bridges, chains", "relation_name": "`dbt`.`fct_bridges_kpis_snapshot`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.944575Z", "completed_at": "2025-12-13T16:37:53.948703Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.949330Z", "completed_at": "2025-12-13T16:37:53.949338Z"}], "thread_id": "Thread-1", "execution_time": 0.006220579147338867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_bridges_netflow_weekly_by_bridge", "compiled": true, "compiled_code": "\n\nWITH w AS (\n  SELECT\n    toStartOfWeek(date, 1) AS week,\n    bridge,\n    sum(net_usd)           AS netflow_usd_week\n  FROM `dbt`.`int_bridges_flows_daily`\n  WHERE date < toStartOfWeek(today(), 1)\n  GROUP BY week, bridge\n),\nbounds AS (\n  SELECT min(week) AS minw, max(week) AS maxw FROM w\n),\ncalendar AS (\n  SELECT toDate(addWeeks(minw, number)) AS week\n  FROM bounds\n  ARRAY JOIN range(dateDiff('week', minw, maxw) + 1) AS number\n),\nbridges AS (\n  SELECT DISTINCT bridge FROM w\n),\ngrid AS (\n  SELECT b.bridge, c.week\n  FROM bridges b\n  CROSS JOIN calendar c\n),\nfilled AS (\n  SELECT\n    g.week,\n    g.bridge,\n    coalesce(w.netflow_usd_week, 0) AS netflow_usd_week\n  FROM grid g\n  LEFT JOIN w\n    ON w.week = g.week\n   AND w.bridge = g.bridge\n)\nSELECT\n  week,\n  bridge,\n  netflow_usd_week,\n  sum(netflow_usd_week) OVER (\n    PARTITION BY bridge\n    ORDER BY week\n    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n  ) AS cum_netflow_usd\nFROM filled\nORDER BY week, bridge", "relation_name": "`dbt`.`fct_bridges_netflow_weekly_by_bridge`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.952142Z", "completed_at": "2025-12-13T16:37:53.956610Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.957215Z", "completed_at": "2025-12-13T16:37:53.957222Z"}], "thread_id": "Thread-1", "execution_time": 0.006459474563598633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_bridges_sankey_edges_token_daily", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT\n    date,\n    source_chain              AS source_chain,\n    dest_chain                AS dest_chain,\n    bridge                    AS bridge,\n    token                     AS token,\n    toFloat64(volume_usd)     AS volume_usd\n  FROM `dbt`.`int_bridges_flows_daily`\n  WHERE date < today()  \n),\n\nout_left AS (\n  SELECT\n    b.date,\n    'out'         AS direction,\n    'left'        AS side,\n    'gnosis'      AS source,\n    b.bridge      AS target,\n    b.token,\n    sum(b.volume_usd) AS value\n  FROM base b\n  WHERE b.source_chain = 'gnosis'\n  GROUP BY b.date, direction, side, source, target, b.token\n),\nout_right AS (\n  SELECT\n    b.date,\n    'out'         AS direction,\n    'right'       AS side,\n    b.bridge      AS source,\n    b.dest_chain  AS target,   \n    b.token,\n    sum(b.volume_usd) AS value\n  FROM base b\n  WHERE b.source_chain = 'gnosis'\n    AND b.dest_chain  != 'gnosis'\n  GROUP BY b.date, direction, side, source, target, b.token\n),\n\nin_left AS (\n  SELECT\n    b.date,\n    'in'          AS direction,\n    'left'        AS side,\n    b.source_chain AS source,  \n    b.bridge       AS target,\n    b.token,\n    sum(b.volume_usd) AS value\n  FROM base b\n  WHERE b.dest_chain = 'gnosis'\n    AND b.source_chain != 'gnosis'\n  GROUP BY b.date, direction, side, source, target, b.token\n),\nin_right AS (\n  SELECT\n    b.date,\n    'in'          AS direction,\n    'right'       AS side,\n    b.bridge      AS source,\n    'gnosis'      AS target,\n    b.token,\n    sum(b.volume_usd) AS value\n  FROM base b\n  WHERE b.dest_chain = 'gnosis'\n  GROUP BY b.date, direction, side, source, target, b.token\n)\n\nSELECT * FROM out_left\nUNION ALL SELECT * FROM out_right\nUNION ALL SELECT * FROM in_left\nUNION ALL SELECT * FROM in_right", "relation_name": "`dbt`.`fct_bridges_sankey_edges_token_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.960111Z", "completed_at": "2025-12-13T16:37:53.964379Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.964956Z", "completed_at": "2025-12-13T16:37:53.964962Z"}], "thread_id": "Thread-1", "execution_time": 0.006177186965942383, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_bridges_token_netflow_daily_by_bridge", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  bridge                 AS bridge,\n  token                  AS token,\n  sum(net_usd)           AS value\nFROM `dbt`.`int_bridges_flows_daily`\nWHERE date < today()               \nGROUP BY date, bridge, token\nORDER BY date, bridge, token", "relation_name": "`dbt`.`fct_bridges_token_netflow_daily_by_bridge`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.967728Z", "completed_at": "2025-12-13T16:37:53.973523Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.974079Z", "completed_at": "2025-12-13T16:37:53.974086Z"}], "thread_id": "Thread-1", "execution_time": 0.007731199264526367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_bridge.22fa82ecb1", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect bridge\nfrom `dbt`.`int_bridges_flows_daily`\nwhere bridge is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.976670Z", "completed_at": "2025-12-13T16:37:53.981146Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.981708Z", "completed_at": "2025-12-13T16:37:53.981715Z"}], "thread_id": "Thread-1", "execution_time": 0.00626683235168457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_date.d92f7bda3a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_bridges_flows_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.984288Z", "completed_at": "2025-12-13T16:37:53.988724Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.989301Z", "completed_at": "2025-12-13T16:37:53.989309Z"}], "thread_id": "Thread-1", "execution_time": 0.006244659423828125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_dest_chain.7a88b5c775", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect dest_chain\nfrom `dbt`.`int_bridges_flows_daily`\nwhere dest_chain is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.991868Z", "completed_at": "2025-12-13T16:37:53.996348Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:53.996899Z", "completed_at": "2025-12-13T16:37:53.996906Z"}], "thread_id": "Thread-1", "execution_time": 0.0062601566314697266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_direction.d762c3bc15", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect direction\nfrom `dbt`.`int_bridges_flows_daily`\nwhere direction is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:53.999572Z", "completed_at": "2025-12-13T16:37:54.004020Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.004597Z", "completed_at": "2025-12-13T16:37:54.004604Z"}], "thread_id": "Thread-1", "execution_time": 0.006366252899169922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_net_usd.54a757230e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect net_usd\nfrom `dbt`.`int_bridges_flows_daily`\nwhere net_usd is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.007202Z", "completed_at": "2025-12-13T16:37:54.012704Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.013281Z", "completed_at": "2025-12-13T16:37:54.013289Z"}], "thread_id": "Thread-1", "execution_time": 0.0073926448822021484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_source_chain.70f106b0e7", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect source_chain\nfrom `dbt`.`int_bridges_flows_daily`\nwhere source_chain is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.015807Z", "completed_at": "2025-12-13T16:37:54.020343Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.020912Z", "completed_at": "2025-12-13T16:37:54.020920Z"}], "thread_id": "Thread-1", "execution_time": 0.006336688995361328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_token.f1ed52e8b3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect token\nfrom `dbt`.`int_bridges_flows_daily`\nwhere token is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.023554Z", "completed_at": "2025-12-13T16:37:54.027927Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.028499Z", "completed_at": "2025-12-13T16:37:54.028507Z"}], "thread_id": "Thread-1", "execution_time": 0.006193637847900391, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_txs.dc0f757424", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect txs\nfrom `dbt`.`int_bridges_flows_daily`\nwhere txs is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.031123Z", "completed_at": "2025-12-13T16:37:54.035561Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.036133Z", "completed_at": "2025-12-13T16:37:54.036140Z"}], "thread_id": "Thread-1", "execution_time": 0.006274223327636719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_volume_token.8f5dfe2767", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect volume_token\nfrom `dbt`.`int_bridges_flows_daily`\nwhere volume_token is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.038737Z", "completed_at": "2025-12-13T16:37:54.043281Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.043835Z", "completed_at": "2025-12-13T16:37:54.043843Z"}], "thread_id": "Thread-1", "execution_time": 0.0063419342041015625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_volume_usd.4cd92ff813", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect volume_usd\nfrom `dbt`.`int_bridges_flows_daily`\nwhere volume_usd is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.046479Z", "completed_at": "2025-12-13T16:37:54.050979Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.051562Z", "completed_at": "2025-12-13T16:37:54.051569Z"}], "thread_id": "Thread-1", "execution_time": 0.006408214569091797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_crawlers_data_gno_supply_daily_date.c4ad37ea75", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_crawlers_data_gno_supply_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.054068Z", "completed_at": "2025-12-13T16:37:54.059878Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.060466Z", "completed_at": "2025-12-13T16:37:54.060473Z"}], "thread_id": "Thread-1", "execution_time": 0.00760960578918457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_probelab_clients_daily_date.1689fe7ae8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_probelab_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.063052Z", "completed_at": "2025-12-13T16:37:54.067501Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.068054Z", "completed_at": "2025-12-13T16:37:54.068062Z"}], "thread_id": "Thread-1", "execution_time": 0.006323575973510742, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_probelab_clients_version_daily_date.3153592556", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_probelab_clients_version_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.070724Z", "completed_at": "2025-12-13T16:37:54.075192Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.075748Z", "completed_at": "2025-12-13T16:37:54.075755Z"}], "thread_id": "Thread-1", "execution_time": 0.0063326358795166016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_probelab_clients_cloud_daily_date.85645cfc12", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_probelab_clients_cloud_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.078367Z", "completed_at": "2025-12-13T16:37:54.082897Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.083478Z", "completed_at": "2025-12-13T16:37:54.083486Z"}], "thread_id": "Thread-1", "execution_time": 0.006417512893676758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_probelab_clients_country_daily_date.17a4b4d6fd", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_probelab_clients_country_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.086087Z", "completed_at": "2025-12-13T16:37:54.090570Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.091148Z", "completed_at": "2025-12-13T16:37:54.091155Z"}], "thread_id": "Thread-1", "execution_time": 0.006361722946166992, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_probelab_clients_quic_daily_date.469721c547", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_probelab_clients_quic_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.093794Z", "completed_at": "2025-12-13T16:37:54.098794Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.099398Z", "completed_at": "2025-12-13T16:37:54.099405Z"}], "thread_id": "Thread-1", "execution_time": 0.006920337677001953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_blocks_clients_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\nclients_blocks AS (\n    SELECT\n        date\n        ,client\n        ,SUM(cnt) AS cnt\n    FROM `dbt`.`int_execution_blocks_clients_version_daily`\n    WHERE date < today()\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,client\n    ,cnt\n    ,cnt/(SUM(cnt) OVER (PARTITION BY date)) AS fraq\nFROM \n    clients_blocks", "relation_name": "`dbt`.`fct_execution_blocks_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.101956Z", "completed_at": "2025-12-13T16:37:54.106642Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.107248Z", "completed_at": "2025-12-13T16:37:54.107256Z"}], "thread_id": "Thread-1", "execution_time": 0.006512641906738281, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_blocks_clients_version_daily_date.dd5f7f1301", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_blocks_clients_version_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.109895Z", "completed_at": "2025-12-13T16:37:54.113816Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.114416Z", "completed_at": "2025-12-13T16:37:54.114423Z"}], "thread_id": "Thread-1", "execution_time": 0.00578761100769043, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_gas_usage_pct_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  ROUND(gas_used_fraq * 100, 2) AS value\nFROM `dbt`.`int_execution_blocks_gas_usage_daily`\nWHERE date < today()   \nORDER BY date", "relation_name": "`dbt`.`api_execution_blocks_gas_usage_pct_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.117021Z", "completed_at": "2025-12-13T16:37:54.121002Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.121639Z", "completed_at": "2025-12-13T16:37:54.121646Z"}], "thread_id": "Thread-1", "execution_time": 0.00586700439453125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_blocks_gas_usage_monthly", "compiled": true, "compiled_code": "\n\nWITH monthly AS (\n  SELECT\n    date_trunc('month', date) AS month,\n    SUM(gas_used_sum)         AS gas_used_sum_monthly,\n    SUM(gas_limit_sum)        AS gas_limit_sum_monthly\n  FROM `dbt`.`int_execution_blocks_gas_usage_daily`\n  GROUP BY month\n)\nSELECT\n  month,\n  gas_used_sum_monthly,\n  gas_limit_sum_monthly,\n  gas_used_sum_monthly / NULLIF(gas_limit_sum_monthly, 0) AS used\nFROM monthly", "relation_name": "`dbt`.`fct_execution_blocks_gas_usage_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.124441Z", "completed_at": "2025-12-13T16:37:54.128909Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.129479Z", "completed_at": "2025-12-13T16:37:54.129486Z"}], "thread_id": "Thread-1", "execution_time": 0.006415367126464844, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_blocks_gas_usage_daily_date.1b2b9e203e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_blocks_gas_usage_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.132119Z", "completed_at": "2025-12-13T16:37:54.136000Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.136602Z", "completed_at": "2025-12-13T16:37:54.136609Z"}], "thread_id": "Thread-1", "execution_time": 0.00574183464050293, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_state_full_size_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,SUM(bytes_diff) OVER (ORDER BY date ASC) AS bytes\nFROM `dbt`.`int_execution_state_size_full_diff_daily`\nWHERE date < today()", "relation_name": "`dbt`.`fct_execution_state_full_size_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.139412Z", "completed_at": "2025-12-13T16:37:54.145205Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.145767Z", "completed_at": "2025-12-13T16:37:54.145775Z"}], "thread_id": "Thread-1", "execution_time": 0.0076732635498046875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_state_size_full_diff_daily_date.d17c9483d0", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_state_size_full_diff_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.148515Z", "completed_at": "2025-12-13T16:37:54.152449Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.153027Z", "completed_at": "2025-12-13T16:37:54.153034Z"}], "thread_id": "Thread-1", "execution_time": 0.005794525146484375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_cnt_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,n_txs AS value\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.155784Z", "completed_at": "2025-12-13T16:37:54.159630Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.160237Z", "completed_at": "2025-12-13T16:37:54.160244Z"}], "thread_id": "Thread-1", "execution_time": 0.005713701248168945, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_cnt_total", "compiled": true, "compiled_code": "\n\nSELECT\n    transaction_type\n    ,SUM(n_txs) AS value\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nGROUP BY transaction_type\nORDER BY transaction_type", "relation_name": "`dbt`.`api_execution_transactions_cnt_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.162918Z", "completed_at": "2025-12-13T16:37:54.166793Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.167394Z", "completed_at": "2025-12-13T16:37:54.167401Z"}], "thread_id": "Thread-1", "execution_time": 0.0057485103607177734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_gas_used_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,gas_used\n    ,gas_price_avg\n    ,gas_price_median\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_gas_used_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.170195Z", "completed_at": "2025-12-13T16:37:54.174087Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.174689Z", "completed_at": "2025-12-13T16:37:54.174696Z"}], "thread_id": "Thread-1", "execution_time": 0.0058782100677490234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_gas_used_weekly", "compiled": true, "compiled_code": "\n\nSELECT\n  toStartOfWeek(date)        AS date,          \n  transaction_type           AS label,\n  sum(gas_used)              AS value\n  -- avg(gas_price_avg)         AS gas_price_avg,     \n  -- median(gas_price_median)   AS gas_price_median   \nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\n  AND date < toStartOfWeek(today())               \nGROUP BY date, label\nORDER BY date, label", "relation_name": "`dbt`.`api_execution_transactions_gas_used_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.177504Z", "completed_at": "2025-12-13T16:37:54.181481Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.182061Z", "completed_at": "2025-12-13T16:37:54.182068Z"}], "thread_id": "Thread-1", "execution_time": 0.005922794342041016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_value_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,xdai_value \n    ,xdai_value_avg \n    ,xdai_value_median\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_value_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.184756Z", "completed_at": "2025-12-13T16:37:54.190519Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.191077Z", "completed_at": "2025-12-13T16:37:54.191085Z"}], "thread_id": "Thread-1", "execution_time": 0.007568836212158203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_info_daily_block_timestamp.1921bb7d1e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect block_timestamp\nfrom `dbt`.`int_execution_transactions_info_daily`\nwhere block_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.193677Z", "completed_at": "2025-12-13T16:37:54.198118Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.198682Z", "completed_at": "2025-12-13T16:37:54.198689Z"}], "thread_id": "Thread-1", "execution_time": 0.006235837936401367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_info_daily_date.5c42bfc6c2", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_transactions_info_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.201373Z", "completed_at": "2025-12-13T16:37:54.207301Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.207898Z", "completed_at": "2025-12-13T16:37:54.207906Z"}], "thread_id": "Thread-1", "execution_time": 0.007803678512573242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_clients_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,argMax(IF(client='','Unknown',client),visit_ended_at) AS client\n        ,argMax(platform,visit_ended_at) AS platform\n        ,argMax(generic_provider,visit_ended_at) AS generic_provider\n        ,argMax(peer_country,visit_ended_at) AS peer_country\n    FROM `dbt`.`int_p2p_discv4_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_p2p_discv4_clients_daily` AS x1\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_p2p_discv4_clients_daily` AS x2\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT date , 'Clients' AS metric, client AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Platform' AS metric, platform AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Provider' AS metric, generic_provider AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Country' AS metric, peer_country AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv4_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.211019Z", "completed_at": "2025-12-13T16:37:54.216439Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.217027Z", "completed_at": "2025-12-13T16:37:54.217034Z"}], "thread_id": "Thread-1", "execution_time": 0.007524251937866211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\n-- 1) First CTE: basic peer info\ngnosis_peers AS (\n    SELECT \n        peer_id,\n        ip,\n        any(client) AS client\n    FROM `dbt`.`int_p2p_discv4_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) = today() - INTERVAL 1 DAY\n        AND empty(dial_errors) = 1\n        AND crawl_error IS NULL\n    GROUP BY\n        peer_id,\n        ip\n),\n\n-- 2) Second CTE: attach discovery_id_prefix to each peer\ngnosis_prefixes AS (\n    SELECT \n        d.discovery_id_prefix,\n        d.peer_id,\n        p.ip,\n        IF(p.client='', 'Unknown', p.client) AS client\n    FROM `dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids` AS d\n    INNER JOIN gnosis_peers AS p\n      ON p.peer_id = d.peer_id\n)\n\nSELECT\n    t1.date,\n\n    -- Peer columns from the subquery t1\n    t1.peer_ip,\n    t1.peer_discovery_id_prefix,\n    t1.peer_client,\n\n    -- Geographical info for peer (from crawlers_data.ipinfo)\n    peer_info.hostname   AS peer_hostname,\n    peer_info.city       AS peer_city,\n    peer_info.country    AS peer_country,\n    peer_info.org        AS peer_org,\n    peer_info.loc        AS peer_loc,\n\n    -- Neighbor columns from subquery t1\n    t1.neighbor_ip,\n    t1.neighbor_discovery_id_prefix,\n    t1.neighbor_client,\n\n    -- Geographical info for neighbor (from crawlers_data.ipinfo)\n    neighbor_info.city    AS neighbor_city,\n    neighbor_info.country AS neighbor_country,\n    neighbor_info.org     AS neighbor_org,\n    neighbor_info.loc     AS neighbor_loc,\n\n    -- Finally, the count of edges\n    t1.cnt\nFROM (\n    SELECT\n        toStartOfDay(n.crawl_created_at) AS date,\n\n        -- \u201cPeer\u201d side of the edge\n        peer_p.ip                      AS peer_ip,\n        peer_p.discovery_id_prefix     AS peer_discovery_id_prefix,\n        peer_p.client                  AS peer_client,\n\n        -- \u201cNeighbor\u201d side of the edge\n        neighbor_p.ip                      AS neighbor_ip,\n        neighbor_p.discovery_id_prefix     AS neighbor_discovery_id_prefix,\n        neighbor_p.client                  AS neighbor_client,\n\n        COUNT(*) AS cnt\n    FROM `dbt`.`stg_nebula_discv4__neighbors` AS n\n\n    -- join to get the discovery_prefix + client/fork info for \u201cpeer\u201d\n    INNER JOIN gnosis_prefixes AS peer_p\n      ON peer_p.discovery_id_prefix = n.peer_discovery_id_prefix\n\n    -- join to get the discovery_prefix + client/fork info for \u201cneighbor\u201d\n    INNER JOIN gnosis_prefixes AS neighbor_p\n      ON neighbor_p.discovery_id_prefix = n.neighbor_discovery_id_prefix\n\n    WHERE\n        toStartOfDay(n.crawl_created_at) = today() - INTERVAL 1 DAY\n\n    GROUP BY\n        date,\n        peer_p.ip,\n        peer_p.discovery_id_prefix,\n        peer_p.client,\n        neighbor_p.ip,\n        neighbor_p.discovery_id_prefix,\n        neighbor_p.client\n) AS t1\n\n-- LEFT JOIN to ipinfo for \u201cpeer\u201d\nLEFT JOIN  `dbt`.`stg_crawlers_data__ipinfo` AS peer_info\n  ON peer_info.ip = t1.peer_ip\n\n-- LEFT JOIN to ipinfo for \u201cneighbor\u201d\nLEFT JOIN  `dbt`.`stg_crawlers_data__ipinfo` AS neighbor_info\n  ON neighbor_info.ip = t1.neighbor_ip", "relation_name": "`dbt`.`int_p2p_discv4_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.219836Z", "completed_at": "2025-12-13T16:37:54.224387Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.224945Z", "completed_at": "2025-12-13T16:37:54.224952Z"}], "thread_id": "Thread-1", "execution_time": 0.006472110748291016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv4_peers_peer_id.85213b218b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_p2p_discv4_peers`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.227516Z", "completed_at": "2025-12-13T16:37:54.233071Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.233645Z", "completed_at": "2025-12-13T16:37:54.233652Z"}], "thread_id": "Thread-1", "execution_time": 0.0074040889739990234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv4_peers_visit_ended_at.892f1eee6a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect visit_ended_at\nfrom `dbt`.`int_p2p_discv4_peers`\nwhere visit_ended_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.236210Z", "completed_at": "2025-12-13T16:37:54.240590Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.241164Z", "completed_at": "2025-12-13T16:37:54.241171Z"}], "thread_id": "Thread-1", "execution_time": 0.006191253662109375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_p2p_discv4_peers_peer_id.6c2e84dcf5", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_p2p_discv4_peers`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.243734Z", "completed_at": "2025-12-13T16:37:54.248223Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.248776Z", "completed_at": "2025-12-13T16:37:54.248783Z"}], "thread_id": "Thread-1", "execution_time": 0.006275653839111328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv4_visits_daily_date.7c3cc85976", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_p2p_discv4_visits_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.251442Z", "completed_at": "2025-12-13T16:37:54.262416Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.263001Z", "completed_at": "2025-12-13T16:37:54.263008Z"}], "thread_id": "Thread-1", "execution_time": 0.012833356857299805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_population_chao1", "compiled": true, "compiled_code": "\n\nWITH peer_connection_analysis AS (\n    SELECT\n        toDate(visit_ended_at) AS observation_date,\n        peer_id,\n        crawl_id,\n        \n        -- Categorize connection attempts\n        CASE \n            WHEN empty(dial_errors) = 1 AND crawl_error IS NULL THEN 'successful'\n            WHEN empty(dial_errors) = 0 OR crawl_error IS NOT NULL THEN 'failed'\n            ELSE 'unknown'\n        END AS connection_status,\n        \n        -- More granular failure analysis\n        CASE \n            WHEN empty(dial_errors) = 1 AND crawl_error IS NULL THEN 'successful'\n            WHEN crawl_error LIKE '%timeout%' THEN 'timeout'\n            WHEN crawl_error LIKE '%refused%' OR crawl_error LIKE '%connection refused%' THEN 'refused' \n            WHEN crawl_error LIKE '%unreachable%' THEN 'unreachable'\n            WHEN crawl_error LIKE '%protocol%' THEN 'protocol_mismatch'\n            WHEN NOT empty(dial_errors) THEN 'dial_error'\n            ELSE 'other_failure'\n        END AS failure_type\n        \n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(x1.observation_date))\n      FROM `dbt`.`int_esg_node_population_chao1` AS x1\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(x2.observation_date, 'UTC'))\n      FROM `dbt`.`int_esg_node_population_chao1` AS x2\n    )\n  \n\n),\n\n-- Chao-1 for successful connections only\nsuccessful_chao1 AS (\n    SELECT\n        observation_date,\n        peer_id,\n        COUNT(DISTINCT crawl_id) AS times_observed\n    FROM peer_connection_analysis\n    WHERE connection_status = 'successful'\n    \n        AND observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nsuccessful_stats AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS s_obs_successful,\n        SUM(CASE WHEN times_observed = 1 THEN 1 ELSE 0 END) AS f1_successful,\n        SUM(CASE WHEN times_observed = 2 THEN 1 ELSE 0 END) AS f2_successful\n    FROM successful_chao1\n    GROUP BY observation_date\n),\n\n-- Chao-1 for ALL connection attempts (successful + failed)\nall_attempts_chao1 AS (\n    SELECT\n        observation_date,\n        peer_id,\n        COUNT(DISTINCT crawl_id) AS times_observed\n    FROM peer_connection_analysis\n    \n        WHERE observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nall_attempts_stats AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS s_obs_all,\n        SUM(CASE WHEN times_observed = 1 THEN 1 ELSE 0 END) AS f1_all,\n        SUM(CASE WHEN times_observed = 2 THEN 1 ELSE 0 END) AS f2_all\n    FROM all_attempts_chao1\n    GROUP BY observation_date\n),\n\n-- Additional peers known from failed connections\npeer_status_summary AS (\n    SELECT\n        observation_date,\n        peer_id,\n        MAX(CASE WHEN connection_status = 'successful' THEN 1 ELSE 0 END) AS had_success,\n        MAX(CASE WHEN connection_status = 'failed' THEN 1 ELSE 0 END) AS had_failure\n    FROM peer_connection_analysis\n    \n        WHERE observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nfailed_only_peers AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS peers_with_only_failures\n    FROM peer_status_summary\n    WHERE had_failure = 1 AND had_success = 0\n    GROUP BY observation_date\n),\n\n-- Connection success rates by failure type\nfailure_analysis AS (\n    SELECT\n        observation_date,\n        failure_type,\n        COUNT(DISTINCT peer_id) AS peer_count,\n        COUNT(*) AS attempt_count,\n        \n        -- Estimate reachability probability based on failure type\n        CASE failure_type\n            WHEN 'timeout' THEN 0.3      -- Sometimes reachable\n            WHEN 'refused' THEN 0.1      -- Rarely reachable (firewall/NAT)\n            WHEN 'unreachable' THEN 0.05 -- Very rarely reachable\n            WHEN 'protocol_mismatch' THEN 0.8  -- Likely reachable with right protocol\n            WHEN 'dial_error' THEN 0.2   -- Sometimes reachable\n            ELSE 0.1\n        END AS estimated_reachability_prob\n        \n    FROM peer_connection_analysis\n    WHERE connection_status = 'failed'\n    \n        AND observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, failure_type\n),\n\n-- Calculate enhanced estimates\nenhanced_calculations AS (\n    SELECT\n        COALESCE(s.observation_date, a.observation_date) AS observation_date,\n        \n        -- Successful connection metrics\n        COALESCE(s.s_obs_successful, 0) AS observed_successful_nodes,\n        CASE\n            WHEN COALESCE(s.f2_successful, 0) > 0 THEN \n                COALESCE(s.s_obs_successful, 0) + toFloat64(s.f1_successful * (s.f1_successful - 1)) / (2.0 * toFloat64(s.f2_successful + 1))\n            WHEN COALESCE(s.f1_successful, 0) > 0 THEN \n                COALESCE(s.s_obs_successful, 0) + toFloat64(s.f1_successful * (s.f1_successful - 1)) / 2.0\n            ELSE \n                toFloat64(COALESCE(s.s_obs_successful, 0))\n        END AS chao1_successful,\n        \n        -- All attempt metrics  \n        COALESCE(a.s_obs_all, 0) AS observed_total_peers,\n        CASE\n            WHEN COALESCE(a.f2_all, 0) > 0 THEN \n                COALESCE(a.s_obs_all, 0) + toFloat64(a.f1_all * (a.f1_all - 1)) / (2.0 * toFloat64(a.f2_all + 1))\n            WHEN COALESCE(a.f1_all, 0) > 0 THEN \n                COALESCE(a.s_obs_all, 0) + toFloat64(a.f1_all * (a.f1_all - 1)) / 2.0\n            ELSE \n                toFloat64(COALESCE(a.s_obs_all, 0))\n        END AS chao1_all_attempts,\n        \n        -- Failed connection insights\n        COALESCE(f.peers_with_only_failures, 0) AS failed_only_peers,\n        \n        COALESCE(s.f1_successful, 0) AS f1_successful,\n        COALESCE(s.f2_successful, 0) AS f2_successful,\n        COALESCE(a.f1_all, 0) AS f1_all,\n        COALESCE(a.f2_all, 0) AS f2_all\n        \n    FROM successful_stats s\n    FULL OUTER JOIN all_attempts_stats a ON s.observation_date = a.observation_date\n    LEFT JOIN failed_only_peers f ON COALESCE(s.observation_date, a.observation_date) = f.observation_date\n),\n\n-- Separate CTE for failure analysis aggregation\nfailure_reachability AS (\n    SELECT\n        observation_date,\n        SUM(toFloat64(peer_count) * estimated_reachability_prob) AS estimated_reachable_from_failures\n    FROM failure_analysis\n    GROUP BY observation_date\n),\n\n-- Combine all estimates\ncombined_estimates AS (\n    SELECT\n        e.*,\n        COALESCE(fr.estimated_reachable_from_failures, 0.0) AS estimated_reachable_from_failures\n    FROM enhanced_calculations e\n    LEFT JOIN failure_reachability fr ON e.observation_date = fr.observation_date\n),\n\nfinal_estimates AS (\n    SELECT\n        observation_date,\n        observed_successful_nodes,\n        observed_total_peers,\n        failed_only_peers,\n        \n        -- Different estimation approaches\n        toUInt64(round(chao1_successful, 0)) AS chao1_successful_only,\n        toUInt64(round(chao1_all_attempts, 0)) AS chao1_all_discovered,\n        toUInt64(round(estimated_reachable_from_failures, 0)) AS estimated_additional_reachable,\n        \n        -- Enhanced total estimate combining multiple signals\n        toUInt64(round(\n            chao1_successful +  -- Hidden successful nodes\n            estimated_reachable_from_failures  -- Additional reachable from failures\n        , 0)) AS enhanced_total_reachable,\n        \n        -- Network size estimate (includes unreachable nodes)\n        toUInt64(round(chao1_all_attempts, 0)) AS estimated_network_size,\n        \n        -- Success rates\n        CASE WHEN observed_total_peers > 0 THEN \n            round(100.0 * observed_successful_nodes / observed_total_peers, 2)\n        ELSE 0 END AS connection_success_rate_pct,\n        \n        -- Coverage estimates\n        CASE WHEN chao1_all_attempts > 0 THEN\n            round(100.0 * observed_total_peers / chao1_all_attempts, 2)\n        ELSE 100 END AS network_discovery_coverage_pct,\n        \n        CASE WHEN enhanced_total_reachable > 0 THEN\n            round(100.0 * observed_successful_nodes / enhanced_total_reachable, 2) \n        ELSE 100 END AS reachable_discovery_coverage_pct,\n        \n        -- Diagnostic info\n        f1_successful, f2_successful, f1_all, f2_all\n        \n    FROM combined_estimates\n)\n\nSELECT\n    observation_date,\n    \n    -- Core metrics\n    observed_successful_nodes,\n    observed_total_peers, \n    failed_only_peers,\n    \n    -- Population estimates\n    chao1_successful_only,\n    enhanced_total_reachable,\n    estimated_network_size,\n    estimated_additional_reachable,\n    \n    -- Success and coverage rates\n    connection_success_rate_pct,\n    network_discovery_coverage_pct,\n    reachable_discovery_coverage_pct,\n    \n    -- Hidden node estimates\n    chao1_successful_only - observed_successful_nodes AS hidden_successful_nodes,\n    enhanced_total_reachable - observed_successful_nodes AS hidden_reachable_nodes,\n    estimated_network_size - observed_total_peers AS hidden_total_nodes,\n    \n    -- Percentages\n    CASE WHEN chao1_successful_only > 0 THEN\n        round(100.0 * (chao1_successful_only - observed_successful_nodes) / chao1_successful_only, 2)\n    ELSE 0 END AS hidden_successful_pct,\n    \n    CASE WHEN estimated_network_size > 0 THEN\n        round(100.0 * (estimated_network_size - observed_total_peers) / estimated_network_size, 2) \n    ELSE 0 END AS hidden_total_pct,\n    \n    -- Diagnostic information\n    f1_successful AS successful_singletons,\n    f2_successful AS successful_doubletons,\n    f1_all AS all_singletons,\n    f2_all AS all_doubletons,\n    \n    now() AS calculated_at\n\nFROM final_estimates\nORDER BY observation_date DESC", "relation_name": "`dbt`.`int_esg_node_population_chao1`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.265735Z", "completed_at": "2025-12-13T16:37:54.271518Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.272157Z", "completed_at": "2025-12-13T16:37:54.272165Z"}], "thread_id": "Thread-1", "execution_time": 0.007773399353027344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_clients_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,argMax(IF(client='','Unknown',client),visit_ended_at) AS client\n        ,argMax(platform,visit_ended_at) AS platform\n        ,argMax(generic_provider,visit_ended_at) AS generic_provider\n        ,argMax(peer_country,visit_ended_at) AS peer_country\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_p2p_discv5_clients_daily` AS x1\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_p2p_discv5_clients_daily` AS x2\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT date , 'Clients' AS metric, client AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Platform' AS metric, platform AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Provider' AS metric, generic_provider AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Country' AS metric, peer_country AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv5_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.275045Z", "completed_at": "2025-12-13T16:37:54.280691Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.281303Z", "completed_at": "2025-12-13T16:37:54.281310Z"}], "thread_id": "Thread-1", "execution_time": 0.007688283920288086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_forks_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,toString(any(cl_fork_name)) AS fork\n        ,toString(any(cl_next_fork_name)) AS next_fork\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_p2p_discv5_forks_daily` AS x1\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_p2p_discv5_forks_daily` AS x2\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,'Current Fork' AS label\n    ,fork AS fork\n    ,COUNT(*) AS cnt\nFROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL\n\nSELECT\n    date\n    ,'Next Fork' AS label\n    ,next_fork AS fork\n    ,COUNT(*) AS cnt\nFROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv5_forks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.285518Z", "completed_at": "2025-12-13T16:37:54.291000Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.291614Z", "completed_at": "2025-12-13T16:37:54.291621Z"}], "thread_id": "Thread-1", "execution_time": 0.008963346481323242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\n-- 1) First CTE: basic peer info\ngnosis_peers AS (\n    SELECT \n        peer_id,\n        cl_fork_name,\n        cl_next_fork_name,\n        ip,\n        any(splitByChar('/', agent_version)[1]) AS client\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) = today() - INTERVAL 1 DAY\n        AND empty(dial_errors) = 1\n        AND crawl_error IS NULL\n    GROUP BY\n        peer_id,\n        cl_fork_name,\n        cl_next_fork_name,\n        ip\n),\n\n-- 2) Second CTE: attach discovery_id_prefix to each peer\ngnosis_prefixes AS (\n    SELECT \n        d.discovery_id_prefix,\n        d.peer_id,\n        p.ip,\n        p.cl_fork_name,\n        p.cl_next_fork_name,\n        IF(p.client='', 'Unknown', p.client) AS client\n    FROM `dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids` AS d\n    INNER JOIN gnosis_peers AS p\n      ON p.peer_id = d.peer_id\n)\n\nSELECT\n    t1.date,\n\n    -- Peer columns from the subquery t1\n    t1.peer_ip,\n    t1.peer_discovery_id_prefix,\n    t1.peer_cl_fork_name,\n    t1.peer_cl_next_fork_name,\n    t1.peer_client,\n\n    -- Geographical info for peer (from crawlers_data.ipinfo)\n    peer_info.hostname   AS peer_hostname,\n    peer_info.city       AS peer_city,\n    peer_info.country    AS peer_country,\n    peer_info.org        AS peer_org,\n    peer_info.loc        AS peer_loc,\n\n    -- Neighbor columns from subquery t1\n    t1.neighbor_ip,\n    t1.neighbor_discovery_id_prefix,\n    t1.neighbor_cl_fork_name,\n    t1.neighbor_cl_next_fork_name,\n    t1.neighbor_client,\n\n    -- Geographical info for neighbor (from crawlers_data.ipinfo)\n    neighbor_info.city    AS neighbor_city,\n    neighbor_info.country AS neighbor_country,\n    neighbor_info.org     AS neighbor_org,\n    neighbor_info.loc     AS neighbor_loc,\n\n    -- Finally, the count of edges\n    t1.cnt\nFROM (\n    SELECT\n        toStartOfDay(n.crawl_created_at) AS date,\n\n        -- \u201cPeer\u201d side of the edge\n        peer_p.ip                      AS peer_ip,\n        peer_p.discovery_id_prefix     AS peer_discovery_id_prefix,\n        peer_p.cl_fork_name            AS peer_cl_fork_name,\n        peer_p.cl_next_fork_name       AS peer_cl_next_fork_name,\n        peer_p.client                  AS peer_client,\n\n        -- \u201cNeighbor\u201d side of the edge\n        neighbor_p.ip                      AS neighbor_ip,\n        neighbor_p.discovery_id_prefix     AS neighbor_discovery_id_prefix,\n        neighbor_p.cl_fork_name            AS neighbor_cl_fork_name,\n        neighbor_p.cl_next_fork_name       AS neighbor_cl_next_fork_name,\n        neighbor_p.client                  AS neighbor_client,\n\n        COUNT(*) AS cnt\n    FROM `dbt`.`stg_nebula_discv5__neighbors` AS n\n\n    -- join to get the discovery_prefix + client/fork info for \u201cpeer\u201d\n    INNER JOIN gnosis_prefixes AS peer_p\n      ON peer_p.discovery_id_prefix = n.peer_discovery_id_prefix\n\n    -- join to get the discovery_prefix + client/fork info for \u201cneighbor\u201d\n    INNER JOIN gnosis_prefixes AS neighbor_p\n      ON neighbor_p.discovery_id_prefix = n.neighbor_discovery_id_prefix\n\n    WHERE\n        toStartOfDay(n.crawl_created_at) = today() - INTERVAL 1 DAY\n\n    GROUP BY\n        date,\n        peer_p.ip,\n        peer_p.discovery_id_prefix,\n        peer_p.cl_fork_name,\n        peer_p.cl_next_fork_name,\n        peer_p.client,\n        neighbor_p.ip,\n        neighbor_p.discovery_id_prefix,\n        neighbor_p.cl_fork_name,\n        neighbor_p.cl_next_fork_name,\n        neighbor_p.client\n) AS t1\n\n-- LEFT JOIN to ipinfo for \u201cpeer\u201d\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS peer_info\n  ON peer_info.ip = t1.peer_ip\n\n-- LEFT JOIN to ipinfo for \u201cneighbor\u201d\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS neighbor_info\n  ON neighbor_info.ip = t1.neighbor_ip", "relation_name": "`dbt`.`int_p2p_discv5_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.294477Z", "completed_at": "2025-12-13T16:37:54.300241Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.300822Z", "completed_at": "2025-12-13T16:37:54.300829Z"}], "thread_id": "Thread-1", "execution_time": 0.007688760757446289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_visits_latest", "compiled": true, "compiled_code": "\n\nWITH \n\ndiscv4_prev7D AS (\n    SELECT\n        date,\n        crawls\n    FROM `dbt`.`int_p2p_discv4_visits_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_visits_daily`), 7)\n),\n\ndiscv4 AS (\n    SELECT\n        date,\n        total_visits,\n        ROUND(COALESCE(successful_visits / NULLIF(total_visits, 0), 0) * 100, 1) AS pct_successful,\n        crawls\n    FROM `dbt`.`int_p2p_discv4_visits_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_visits_daily`)\n),\n\ndiscv5_prev7D AS (\n    SELECT\n        date,\n        crawls\n    FROM `dbt`.`int_p2p_discv5_visits_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_visits_daily`), 7)\n),\n\ndiscv5 AS (\n    SELECT\n        date,\n        total_visits,\n        ROUND(COALESCE(successful_visits / NULLIF(total_visits, 0), 0) * 100, 1) AS pct_successful,\n        crawls\n    FROM `dbt`.`int_p2p_discv5_visits_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_visits_daily`)\n)\n\nSELECT\n    t2.total_visits AS discv4_total_visits,\n    t2.pct_successful AS discv4_pct_successful,\n    t2.crawls AS discv4_crawls,\n    ROUND((COALESCE(t2.crawls / NULLIF(t1.crawls, 0), 0) - 1) * 100, 1) AS change_discv4_crawls_pct,\n    t4.total_visits AS discv5_total_visits,\n    t4.pct_successful AS discv5_pct_successful,\n    t4.crawls AS discv5_crawls,\n    ROUND((COALESCE(t4.crawls / NULLIF(t3.crawls, 0), 0) - 1) * 100, 1) AS change_discv5_crawls_pct\nFROM discv4_prev7D t1\nCROSS JOIN discv4 t2\nCROSS JOIN discv5_prev7D t3\nCROSS JOIN discv5 t4", "relation_name": "`dbt`.`api_p2p_visits_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.303608Z", "completed_at": "2025-12-13T16:37:54.308648Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.309253Z", "completed_at": "2025-12-13T16:37:54.309260Z"}], "thread_id": "Thread-1", "execution_time": 0.006918907165527344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_GBCDeposit_deposists_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(block_timestamp) AS date\n    ,decoded_params['withdrawal_credentials'] AS withdrawal_credentials\n    ,SUM(reinterpretAsUInt64(unhex(substring(decoded_params['amount'], 3)))) AS amount\nFROM `dbt`.`contracts_GBCDeposit_events`\nWHERE\n    event_name = 'DepositEvent'\n    \n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_GBCDeposit_deposists_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.311968Z", "completed_at": "2025-12-13T16:37:54.327329Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.327915Z", "completed_at": "2025-12-13T16:37:54.327922Z"}], "thread_id": "Thread-1", "execution_time": 0.01719832420349121, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_rwa_backedfi_prices", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n\n\n        SELECT\n            'bC3M' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bC3M_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bCOIN' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bCOIN_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bCSPX' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bCSPX_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bHIGH' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bHIGH_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bIB01' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bIB01_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bIBTA' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bIBTA_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bMSTR' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bMSTR_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bNVDA' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bNVDA_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'TSLAx' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_TSLAx_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n    )\n  \n\n        GROUP BY 1, 2\n    ", "relation_name": "`dbt`.`int_execution_rwa_backedfi_prices`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.330628Z", "completed_at": "2025-12-13T16:37:54.336557Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.337175Z", "completed_at": "2025-12-13T16:37:54.337183Z"}], "thread_id": "Thread-1", "execution_time": 0.00788736343383789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_backing", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(block_timestamp) AS date\n    ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_CirclesBackingFactory_events`\nWHERE \n    event_name = 'CirclesBackingCompleted'\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_circles_backing` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_circles_backing` AS x2\n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_execution_circles_backing`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.340019Z", "completed_at": "2025-12-13T16:37:54.347022Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.347665Z", "completed_at": "2025-12-13T16:37:54.347672Z"}], "thread_id": "Thread-1", "execution_time": 0.008974552154541016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_transitive_transfers", "compiled": true, "compiled_code": "\n\n\nSELECT\n  toStartOfDay(block_timestamp) AS date\n  ,decoded_params['from'] AS from_avatar\n  ,decoded_params['to']   AS  to_avatar\n  ,SUM(\n    toUInt256OrZero(\n      arrayJoin(\n        JSONExtract(\n          ifNull(decoded_params['amounts'], '[]'),   -- remove Nullable\n          'Array(String)'                            -- get Array(String)\n        )\n      )\n    )\n  ) AS total_amount\n  ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE\n  event_name = 'StreamCompleted'\n  \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_circles_transitive_transfers` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_circles_transitive_transfers` AS x2\n    )\n  \n\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_execution_circles_transitive_transfers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.350455Z", "completed_at": "2025-12-13T16:37:54.356084Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.356684Z", "completed_at": "2025-12-13T16:37:54.356691Z"}], "thread_id": "Thread-1", "execution_time": 0.007646322250366211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_v1_avatars", "compiled": true, "compiled_code": "\n\n\nSELECT\n    block_timestamp\n    ,decoded_params['avatar'] AS user_address\n    ,decoded_params['inviter'] AS inviter_address\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE \n    event_name = 'RegisterHuman'\n    \n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_circles_v1_avatars` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_circles_v1_avatars` AS x2\n    )\n  \n", "relation_name": "`dbt`.`int_execution_circles_v1_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.359507Z", "completed_at": "2025-12-13T16:37:54.365269Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.365849Z", "completed_at": "2025-12-13T16:37:54.365856Z"}], "thread_id": "Thread-1", "execution_time": 0.00771021842956543, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_v2_avatars", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(block_timestamp) AS date\n    ,CASE  \n        WHEN event_name = 'RegisterHuman' THEN 'Human' \n        WHEN event_name = 'RegisterGroup' THEN 'Group' \n        WHEN event_name = 'RegisterOrganization' THEN 'Org'\n        ELSE 'Unknown' \n    END AS avatar_type\n    ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE \n    event_name IN ('RegisterHuman','RegisterGroup','RegisterOrganization')\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_circles_v2_avatars` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_circles_v2_avatars` AS x2\n    )\n  \n\nGROUP BY 1,2", "relation_name": "`dbt`.`int_execution_circles_v2_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.368722Z", "completed_at": "2025-12-13T16:37:54.376605Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.377209Z", "completed_at": "2025-12-13T16:37:54.377216Z"}], "thread_id": "Thread-1", "execution_time": 0.009840011596679688, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_yields_sdai_rate_daily", "compiled": true, "compiled_code": "\n\n\nWITH \n\nsdai_rate_sparse_daily AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date\n        ,argMin(\n          toUInt256OrNull(decoded_params['assets']) / toUInt256OrNull(decoded_params['shares']),\n          block_timestamp\n        ) AS sdai_conversion\n    FROM \n        `dbt`.`contracts_sdai_events`\n    WHERE \n        event_name = 'Deposit'\n        AND toUInt256OrNull(decoded_params['shares']) != 0\n        AND block_timestamp < today()\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_yields_sdai_rate_daily` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_yields_sdai_rate_daily` AS x2\n    )\n  \n\n    GROUP BY 1\n),\n\ncalendar AS (\n    SELECT\n        arrayJoin(\n            arrayMap(\n                x -> toStartOfDay(start_date + x),\n                range(toUInt32(end_date - start_date) + 1)\n            )\n        ) AS date\n    FROM (\n        SELECT \n          min(toDate(date)) AS start_date\n          ,max(toDate(date)) AS end_date\n        FROM sdai_rate_sparse_daily\n    )\n),\n\n\nlast_partition_value AS (\n    SELECT \n        sdai_conversion\n    FROM \n        `dbt`.`int_yields_sdai_rate_daily`\n    WHERE\n        toStartOfMonth(date) = (\n            SELECT addMonths(max(toStartOfMonth(date)), -1)\n            FROM `dbt`.`int_yields_sdai_rate_daily`\n        )\n    ORDER BY date DESC\n    LIMIT 1\n),\n\n\nsdai_daily_rate AS (\n  SELECT\n      date\n      ,sdai_conversion\n      ,floor(\n          sdai_conversion \n          - (\n            \n            COALESCE(\n                lagInFrame(sdai_conversion) OVER (\n                    ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n                ),\n                (SELECT sdai_conversion FROM last_partition_value)\n            )\n            \n            )\n      ,12) AS rate\n  FROM (\n    SELECT \n      t1.date\n      ,last_value(t2.sdai_conversion) ignore nulls OVER (ORDER BY t1.date) AS sdai_conversion\n    FROM calendar t1\n    LEFT JOIN\n      sdai_rate_sparse_daily t2\n      ON t2.date = t1.date\n  )\n)\n\n\nSELECT \n  date\n  ,sdai_conversion\n  ,rate\nFROM sdai_daily_rate\nWHERE rate IS NOT NULL", "relation_name": "`dbt`.`int_yields_sdai_rate_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.380044Z", "completed_at": "2025-12-13T16:37:54.389566Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.390199Z", "completed_at": "2025-12-13T16:37:54.390206Z"}], "thread_id": "Thread-1", "execution_time": 0.011504173278808594, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transfers_whitelisted_daily", "compiled": true, "compiled_code": "\n\n\n\n\nWITH tokens AS (\n    SELECT\n        lower(address)                       AS token_address,\n        decimals,\n        symbol,\n        date_start,\n        date_end\n    FROM `dbt`.`tokens_whitelist`\n    WHERE symbol != 'WxDAI'\n),\n\nraw_whitelisted_transfers AS (\n    SELECT\n        toDate(l.block_timestamp) AS date,\n        t.token_address,\n        t.symbol,\n        lower(concat('0x', substring(l.topic1, 25, 40))) AS \"from\",\n        lower(concat('0x', substring(l.topic2, 25, 40))) AS \"to\",\n        reinterpretAsInt256(\n                reverse(unhex(l.data))\n            ) AS value_raw\n    FROM `dbt`.`stg_execution__logs` AS l\n    INNER JOIN tokens t\n        ON lower(l.address) = t.token_address\n    WHERE\n        l.topic0 = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n        AND l.block_timestamp < today()\n        \n          \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_transfers_whitelisted_daily` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_transfers_whitelisted_daily` AS x2\n    )\n  \n\n        \n),\n\ntransfers_whitelisted_daily AS (\n    SELECT\n        date,\n        token_address,\n        any(symbol)       AS symbol,\n        \"from\",\n        \"to\",\n        sum(value_raw) AS amount_raw,\n        count() AS transfer_count\n    FROM raw_whitelisted_transfers\n    GROUP BY\n        date, token_address, \"from\", \"to\"\n),\n\n\nwxdai_logs AS (\n    SELECT\n        toDate(block_timestamp) AS date\n        ,'0xe91d153e0b41518a2ce8dd3d7944fa863463a97d' AS token_address\n        ,'WxDAI' AS symbol\n        ,decoded_params\n        ,event_name\n    FROM `dbt`.`contracts_wxdai_events` \n    WHERE (event_name = 'Withdrawal' OR event_name = 'Transfer' OR event_name = 'Deposit')\n        AND block_timestamp < today()\n        \n          \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_transfers_whitelisted_daily` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_transfers_whitelisted_daily` AS x2\n    )\n  \n\n        \n),\n\ndeposits_wxdai AS (\n    SELECT\n        date\n        ,token_address\n        ,symbol\n        ,'0x0000000000000000000000000000000000000000' AS \"from\"\n        ,decoded_params['dst'] AS \"to\"\n        ,toInt256(decoded_params['wad']) AS value_raw\n    FROM wxdai_logs\n    WHERE event_name = 'Deposit'\n),\n\nwithdrawals_wxdai AS (\n    SELECT\n        date\n        ,token_address\n        ,symbol\n        ,decoded_params['src'] AS \"from\"\n        ,'0x0000000000000000000000000000000000000000' AS \"to\"\n        ,toInt256(decoded_params['wad'])AS value_raw\n    FROM wxdai_logs\n    WHERE event_name = 'Withdrawal'\n),\n\ntransfers_wxdai AS (\n    SELECT\n        date\n        ,token_address\n        ,symbol\n        ,decoded_params['src'] AS \"from\"\n        ,decoded_params['dst']  AS \"to\"\n        ,toInt256(decoded_params['wad'])AS value_raw\n    FROM wxdai_logs\n    WHERE event_name = 'Transfer'\n),\n\ntransfers_wxdai_daily AS (\n    SELECT\n        date\n        ,token_address\n        ,symbol\n        ,\"from\"\n        ,\"to\"\n        ,SUM(value_raw) AS value_raw\n        ,count() AS transfer_count\n    FROM (\n        SELECT * FROM deposits_wxdai\n        UNION ALL \n        SELECT * FROM withdrawals_wxdai\n        UNION ALL \n        SELECT * FROM transfers_wxdai\n    )\n    GROUP BY 1, 2, 3, 4, 5\n),\n\ntransfers_daily AS (\n    SELECT * FROM transfers_whitelisted_daily\n    UNION ALL\n    SELECT * FROM transfers_wxdai_daily\n)\n\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    \"from\",\n    \"to\",\n    amount_raw,\n    transfer_count\nFROM transfers_daily", "relation_name": "`dbt`.`int_execution_transfers_whitelisted_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.392979Z", "completed_at": "2025-12-13T16:37:54.401412Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.402006Z", "completed_at": "2025-12-13T16:37:54.402013Z"}], "thread_id": "Thread-1", "execution_time": 0.01047062873840332, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_crawlers_data_labels", "compiled": true, "compiled_code": "\n\n\n\n\nWITH src AS (\n  SELECT\n    lower(address) AS address,\n    project,\n    introduced_at\n  FROM `dbt`.`stg_crawlers_data__dune_labels`\n  \n    \n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(introduced_at)) >= (\n      SELECT max(toStartOfMonth(x1.introduced_at))\n      FROM `dbt`.`int_crawlers_data_labels` AS x1\n    )\n    AND toStartOfDay(introduced_at) >= (\n      SELECT max(toStartOfDay(x2.introduced_at, 'UTC'))\n      FROM `dbt`.`int_crawlers_data_labels` AS x2\n    )\n  \n\n  \n),\n\nlabeled AS (\n  SELECT\n    address,\n    project,\n    introduced_at,\n\n    multiIf(\n\n      match(project, '(?i)^Unknown$'),           'Unknown',\n      match(project, '(?i)^EOA$'),               'EOAs',\n      match(project, '(?i)^ERC20$'),             'ERC20 Tokens',\n\n      match(project, '(?i)(uniswap|sushi|swapr|balancer|curve|honeyswap|levinswap|openocean|openoceanexchange|1inch|paraswap|cow\\\\s*swap|cowswap|gnosis\\\\s*protocol|xswap|symmetric(\\\\s*finance)?|elk\\\\s*finance|\\\\bdex\\\\b|aggregator|dex\\\\s*aggregator|zerion|kinetex\\\\s*xswap|baoswap)'),\n      'DEX',\n\n      match(project, '(?i)(\\\\baave\\\\b|spark(\\\\s*protocol)?|agave|compound|compoundadapter|\\\\bidle\\\\b|beefy|jarvis(\\\\s*network)?|gyroscope|qidao|powerpool|lending(manager)?|stakewise|aura\\\\s*finance|merkl)'),\n      'Lending & Yield',\n\n      match(project, '(?i)(\\\\bbridge\\\\b|omnibridge|hop(\\\\s*protocol)?|\\\\bbungee\\\\b|\\\\bacross\\\\b|connext|celer|stargate|lifi|li\\\\.?fi|\\\\bamb\\\\b|eth\\\\s*xdai\\\\s*amb|bsc\\\\s*xdai\\\\s*amb|\\\\brelay\\\\b|spokebridge|spokegateway|socket(\\\\b|\\\\s)|rango\\\\s*exchange|rubic(\\\\s*(onchain|crosschain))?|swaps?\\\\s*io|eywa|symbiosis|squid(\\\\s*spoke)?)'),\n      'Bridges',\n\n      match(project, '(?i)(layer\\\\s*zero|hyperlane|zk\\\\s*bridge|zkbridge|polyhedra|zk(light|client)|telepathy|messag(?:ing|e)|everclear|interop)'),\n      'Messaging / Interop',\n\n      match(project, '(?i)(safe(?:\\\\s*l2)?|gnosis\\\\s*safe|ambirewallet|biconomy|erc[- ]?4337|erc\\\\s*4337\\\\s*entry\\\\s*point|entry\\\\s*point|wethgateway|tokenbound|delegatecash|rhinestone|apex\\\\s*smart\\\\s*wallet|zeroexsettlerdeployersafemodule)'),\n      'Wallets & AA',\n\n      match(project, '(?i)(\\\\busdc\\\\b|\\\\busdt\\\\b|\\\\bsdai\\\\b|\\\\bdai\\\\b|\\\\bxdai\\\\b|ageur|angle|monerium(\\\\s*(iske|usde|blacklist))?|transmuter)'),\n      'Stablecoins & Fiat Ramps',\n\n      match(project, '(?i)(gnosis\\\\s*pay(\\\\s*(vip|spender|eiffel))?|\\\\bgpay\\\\b|request(\\\\s*network)?|payments?|invoice|smart\\\\s*invoice|superfluid|sablier|swing\\\\s*xdai\\\\s*single\\\\s*chain)'),\n      'Payments',\n\n      match(project, '(?i)(chainlink|tellor|pyth|\\\\boracle\\\\b|origin\\\\s*trail|origintrail|marketview|analytics|\\\\bdata\\\\b|\\\\bindex\\\\b|mu\\\\s*exchange\\\\s*pythoracle)'),\n      'Oracles & Data',\n\n      match(project, '(?i)(opensea|seaport|poap|nifty(ink|fair)?|\\\\bnft\\\\b|erc721|erc1155|foundation|eporio|marketplace|creator|mint|mech\\\\s*marketplace|ghost\\\\s*nft\\\\s*faucet|nfts2me|crypto\\\\s*stamp|nondescriptive\\\\s*1155|unlock(\\\\s*protocol)?)'),\n      'NFTs & Marketplaces',\n\n      match(project, '(?i)(dark\\\\s*forest|conquest\\\\.eth|mithraeum|\\\\bgame\\\\b|gaming)'),\n      'Gaming',\n\n      match(project, '(?i)(dao\\\\s*haus|daoh?a?us|daostack|\\\\bdao\\\\b|daosquare|plazadao|zodiac|snapshot|kleros(\\\\s*curate)?|reality\\\\s*eth|vocdoni|proof\\\\s*of\\\\s*humanity|sismo(\\\\s*(badges|roots|attestations\\\\s*registry))?|attestation|identity|omen|ran\\\\s*dao|circles|polkamarkets)'),\n      'DAOs & Governance',\n\n      match(project, '(?i)(tornado(?:\\\\.?\\\\s*cash)?|tornado\\\\s*cash\\\\s*nova|umbra|privacy|\\\\bmix\\\\b)'),\n      'Privacy',\n\n      match(project, '(?i)(autonolas|gnosis\\\\s*ai|autonomous|agent)'),\n      'AI & Agents',\n\n      match(project, '(?i)(real\\\\s*token|realtoken|real\\\\s*rmm|\\\\brmm\\\\b|emblem|backed)'),\n      'RWA & Tokenization',\n\n      match(project, '(?i)(^infrastructure$|gelato|opengsn|obol|ankr|shutter|infra(structure)?|registry|deployer|factory|controller|manager|router|pool|proxy|multisig|gnosis\\\\s*protocol|gnosis\\\\s*chain|xdai\\\\s*posdao|swarm|ethswarm|address\\\\s*tag\\\\s*registry|judicialassetfactory|hopr(\\\\s*(token|network|protocol))?)'),\n      'Infrastructure & DevTools',\n\n      'Others'\n    ) AS sector\n  FROM src\n)\n\nSELECT\n  address,\n  project,\n  sector,\n  introduced_at\nFROM labeled", "relation_name": "`dbt`.`int_crawlers_data_labels`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.404849Z", "completed_at": "2025-12-13T16:37:54.409485Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.410050Z", "completed_at": "2025-12-13T16:37:54.410058Z"}], "thread_id": "Thread-1", "execution_time": 0.00673985481262207, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_attestations_daily_date.3207eebc80", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_attestations_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.412721Z", "completed_at": "2025-12-13T16:37:54.417144Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.417717Z", "completed_at": "2025-12-13T16:37:54.417724Z"}], "thread_id": "Thread-1", "execution_time": 0.006235599517822266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_graffiti_label_daily_date.c8d1441f38", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_graffiti_label_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.420373Z", "completed_at": "2025-12-13T16:37:54.424251Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.424831Z", "completed_at": "2025-12-13T16:37:54.424839Z"}], "thread_id": "Thread-1", "execution_time": 0.005727291107177734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_graffiti_cloud", "compiled": true, "compiled_code": "\n\n\nSELECT\n    label\n    ,graffiti\n    ,value\nFROM `dbt`.`fct_consensus_graffiti_cloud`\nORDER BY label DESC, value DESC", "relation_name": "`dbt`.`api_consensus_graffiti_cloud`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.427493Z", "completed_at": "2025-12-13T16:37:54.431959Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.432530Z", "completed_at": "2025-12-13T16:37:54.432538Z"}], "thread_id": "Thread-1", "execution_time": 0.0063173770904541016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_blob_commitments_daily_date.ac917c94fc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_blob_commitments_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.435085Z", "completed_at": "2025-12-13T16:37:54.439557Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.440133Z", "completed_at": "2025-12-13T16:37:54.440140Z"}], "thread_id": "Thread-1", "execution_time": 0.006272792816162109, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_blocks_daily_date.e9ec9189ec", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_blocks_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.442702Z", "completed_at": "2025-12-13T16:37:54.448353Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.448909Z", "completed_at": "2025-12-13T16:37:54.448917Z"}], "thread_id": "Thread-1", "execution_time": 0.007430553436279297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_zero_blob_commitments_daily_date.e6d21e8e11", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_zero_blob_commitments_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.451496Z", "completed_at": "2025-12-13T16:37:54.455996Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.456612Z", "completed_at": "2025-12-13T16:37:54.456619Z"}], "thread_id": "Thread-1", "execution_time": 0.006346225738525391, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_credentials_daily_date.ca88cf1daa", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_credentials_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.459211Z", "completed_at": "2025-12-13T16:37:54.463622Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.464197Z", "completed_at": "2025-12-13T16:37:54.464205Z"}], "thread_id": "Thread-1", "execution_time": 0.00622248649597168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_entry_queue_daily_date.2e8aa4a490", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_entry_queue_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.466748Z", "completed_at": "2025-12-13T16:37:54.471142Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.471702Z", "completed_at": "2025-12-13T16:37:54.471710Z"}], "thread_id": "Thread-1", "execution_time": 0.006178140640258789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_staked_daily_date.cc2cf09386", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_staked_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.474301Z", "completed_at": "2025-12-13T16:37:54.478693Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.479259Z", "completed_at": "2025-12-13T16:37:54.479266Z"}], "thread_id": "Thread-1", "execution_time": 0.006180524826049805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_balances_daily_date.c8289bba92", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_balances_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.481812Z", "completed_at": "2025-12-13T16:37:54.487322Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.487877Z", "completed_at": "2025-12-13T16:37:54.487884Z"}], "thread_id": "Thread-1", "execution_time": 0.007294416427612305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_active_daily_date.0f0139a9c5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_active_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.490496Z", "completed_at": "2025-12-13T16:37:54.494999Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.495576Z", "completed_at": "2025-12-13T16:37:54.495583Z"}], "thread_id": "Thread-1", "execution_time": 0.0063135623931884766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_status_daily_date.91f2382e0e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_status_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.498274Z", "completed_at": "2025-12-13T16:37:54.502172Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.502760Z", "completed_at": "2025-12-13T16:37:54.502767Z"}], "thread_id": "Thread-1", "execution_time": 0.005844593048095703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_withdrawal_credentials_freq_daily", "compiled": true, "compiled_code": "\nSELECT \n    date\n    ,bin_number_validators AS label\n    ,withdrawal_credentials_freq_cnt AS value\nFROM `dbt`.`fct_consensus_withdrawal_credentials_freq_daily`\nORDER BY 1, 2", "relation_name": "`dbt`.`api_consensus_withdrawal_credentials_freq_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.505558Z", "completed_at": "2025-12-13T16:37:54.509955Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.510530Z", "completed_at": "2025-12-13T16:37:54.510537Z"}], "thread_id": "Thread-1", "execution_time": 0.006377696990966797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_consensus_withdrawal_credentials_freq_daily_date.f213289ea4", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_consensus_withdrawal_credentials_freq_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.513186Z", "completed_at": "2025-12-13T16:37:54.517664Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.518244Z", "completed_at": "2025-12-13T16:37:54.518251Z"}], "thread_id": "Thread-1", "execution_time": 0.006406307220458984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_deposits_withdrawls_cnt_daily_date.d17bc34ba0", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_deposits_withdrawls_cnt_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.520802Z", "completed_at": "2025-12-13T16:37:54.525383Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.525954Z", "completed_at": "2025-12-13T16:37:54.525962Z"}], "thread_id": "Thread-1", "execution_time": 0.006399393081665039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_deposits_withdrawls_volume_daily_date.8c82141e3f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_deposits_withdrawls_volume_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.528669Z", "completed_at": "2025-12-13T16:37:54.533765Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.534392Z", "completed_at": "2025-12-13T16:37:54.534399Z"}], "thread_id": "Thread-1", "execution_time": 0.0070078372955322266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_apy_dist_last_30_days", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q05_apy AS q05,\n    q10_apy AS q10,\n    q25_apy AS q25,\n    q50_apy AS q50,\n    q75_apy AS q75,\n    q90_apy AS q90,\n    q95_apy AS q95\nFROM `dbt`.`fct_consensus_validators_dists_last_30_days`", "relation_name": "`dbt`.`api_consensus_validators_apy_dist_last_30_days`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.537270Z", "completed_at": "2025-12-13T16:37:54.541156Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.541759Z", "completed_at": "2025-12-13T16:37:54.541767Z"}], "thread_id": "Thread-1", "execution_time": 0.0059528350830078125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_balance_dist_last_30_days", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q05_balance AS q05,\n    q10_balance AS q10,\n    q25_balance AS q25,\n    q50_balance AS q50,\n    q75_balance AS q75,\n    q90_balance AS q90,\n    q95_balance AS q95\nFROM `dbt`.`fct_consensus_validators_dists_last_30_days`", "relation_name": "`dbt`.`api_consensus_validators_balance_dist_last_30_days`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.544524Z", "completed_at": "2025-12-13T16:37:54.549039Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.549625Z", "completed_at": "2025-12-13T16:37:54.549633Z"}], "thread_id": "Thread-1", "execution_time": 0.006471395492553711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_consensus_validators_dists_last_30_days_date.220d93c4f9", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_consensus_validators_dists_last_30_days`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.552386Z", "completed_at": "2025-12-13T16:37:54.556302Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.556896Z", "completed_at": "2025-12-13T16:37:54.556904Z"}], "thread_id": "Thread-1", "execution_time": 0.005865573883056641, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_apy_dist_daily", "compiled": true, "compiled_code": "\n\n-- in GNO\nSELECT\n    date,\n    q05_apy AS q05,\n    q10_apy AS q10,\n    q25_apy AS q25,\n    q50_apy AS q50,\n    q75_apy AS q75,\n    q90_apy AS q90,\n    q95_apy AS q95,\n    avg_apy AS average\nFROM `dbt`.`int_consensus_validators_dists_daily`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_validators_apy_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.559749Z", "completed_at": "2025-12-13T16:37:54.563651Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.564261Z", "completed_at": "2025-12-13T16:37:54.564269Z"}], "thread_id": "Thread-1", "execution_time": 0.00595402717590332, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_balances_dist_daily", "compiled": true, "compiled_code": "\n\n-- in GNO\nSELECT\n    date,\n    q05_balance/32 AS q05,\n    q10_balance/32 AS q10,\n    q25_balance/32 AS q25,\n    q50_balance/32 AS q50,\n    q75_balance/32 AS q75,\n    q90_balance/32 AS q90,\n    q95_balance/32 AS q95\nFROM `dbt`.`int_consensus_validators_dists_daily`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_validators_balances_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.567071Z", "completed_at": "2025-12-13T16:37:54.576018Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.576627Z", "completed_at": "2025-12-13T16:37:54.576634Z"}], "thread_id": "Thread-1", "execution_time": 0.010924816131591797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_info_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ndeposits_withdrawls_latest AS (\n    SELECT\n        label\n        ,cnt\n        ,total_amount\n    FROM \n        `dbt`.`int_consensus_deposits_withdrawals_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_deposits_withdrawals_daily`)\n),\n\ndeposits_withdrawls_7d AS (\n    SELECT\n        label\n        ,cnt\n        ,total_amount\n    FROM \n        `dbt`.`int_consensus_deposits_withdrawals_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_deposits_withdrawals_daily`), 7)\n),\n\napy_latest AS (\n    SELECT\n        avg_apy AS apy\n    FROM \n        `dbt`.`int_consensus_validators_dists_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_validators_dists_daily`)\n),\n\napy_7d AS (\n    SELECT\n       avg_apy AS apy\n    FROM \n        `dbt`.`int_consensus_validators_dists_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_validators_dists_daily`), 7)\n),\n\nstatus_latest AS (\n    SELECT\n        status AS label\n        ,CAST(COALESCE(cnt,0) AS Float64) AS value\n    FROM \n        `dbt`.`int_consensus_validators_status_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_validators_status_daily`)\n),\n\nstatus_7d AS (\n    SELECT\n        status AS label\n        ,CAST(COALESCE(cnt,0) AS Float64) AS value\n    FROM \n        `dbt`.`int_consensus_validators_status_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_validators_status_daily`), 7)\n),\n\n\nstaked_latest AS (\n    SELECT\n        'Staked' AS label\n        ,effective_balance/32 AS value\n    FROM \n        `dbt`.`int_consensus_validators_balances_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_validators_balances_daily`)\n),\n\nstaked_7d AS (\n    SELECT\n        'Staked' AS label\n        ,effective_balance/32 AS value\n    FROM \n        `dbt`.`int_consensus_validators_balances_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_validators_balances_daily`), 7)\n),\n\n\ninfo_latest AS ( \n    SELECT\n        'deposits_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_latest WHERE label = 'Deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_latest WHERE label = 'Withdrawals'), 0) AS value\n    UNION ALL\n    SELECT\n        'deposits_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'Deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'Withdrawals'), 0) AS value\n    UNION ALL\n    SELECT\n        'APY' AS label \n    ,COALESCE((SELECT ROUND(apy,2) FROM apy_latest),0) AS value\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM status_latest\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM staked_latest\n),\n\ninfo_7d AS ( \n    SELECT\n        'deposits_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_7d WHERE label = 'Deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_7d WHERE label = 'Withdrawals'), 0) AS value\n    UNION ALL\n    SELECT\n        'deposits_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_7d WHERE label = 'Deposits'), 0) AS value\n    UNION ALL\n     SELECT\n        'withdrawls_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_7d WHERE label = 'Withdrawals'), 0) AS value\n    UNION ALL\n    SELECT\n        'APY' AS label \n    ,COALESCE((SELECT ROUND(apy,2) FROM apy_7d),0) AS value\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM status_7d\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM staked_7d\n)\n\nSELECT\n    t1.label\n    ,t1.value AS value\n    ,IF(t1.value=0 AND t2.value=0, 0, ROUND(( COALESCE(t1.value / NULLIF(t2.value, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM info_latest t1\nINNER JOIN info_7d t2\nON t2.label = t1.label", "relation_name": "`dbt`.`fct_consensus_info_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.579351Z", "completed_at": "2025-12-13T16:37:54.583952Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.584561Z", "completed_at": "2025-12-13T16:37:54.584568Z"}], "thread_id": "Thread-1", "execution_time": 0.006587982177734375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_validators_dists_daily_date.09c3cbe00c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_validators_dists_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.587220Z", "completed_at": "2025-12-13T16:37:54.591049Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.591647Z", "completed_at": "2025-12-13T16:37:54.591654Z"}], "thread_id": "Thread-1", "execution_time": 0.0057010650634765625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_kpi_distinct_bridges_all_time", "compiled": true, "compiled_code": "\n\nSELECT \n    distinct_bridges AS value\nFROM `dbt`.`fct_bridges_kpis_snapshot`\nORDER BY as_of_date DESC\nLIMIT 1", "relation_name": "`dbt`.`api_bridges_kpi_distinct_bridges_all_time`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.594347Z", "completed_at": "2025-12-13T16:37:54.598191Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.598762Z", "completed_at": "2025-12-13T16:37:54.598770Z"}], "thread_id": "Thread-1", "execution_time": 0.0057430267333984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_kpi_distinct_chains_all_time", "compiled": true, "compiled_code": "\n\nSELECT distinct_chains AS value\nFROM `dbt`.`fct_bridges_kpis_snapshot`\nORDER BY as_of_date DESC\nLIMIT 1", "relation_name": "`dbt`.`api_bridges_kpi_distinct_chains_all_time`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.601438Z", "completed_at": "2025-12-13T16:37:54.605339Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.605915Z", "completed_at": "2025-12-13T16:37:54.605922Z"}], "thread_id": "Thread-1", "execution_time": 0.00574040412902832, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_kpi_netflow_7d", "compiled": true, "compiled_code": "\n\nSELECT\n  round(net_7d, 2)        AS value,\n  round(net_prev_7d, 2)   AS prev_value,\n  chg_net_7d              AS change_pct\nFROM `dbt`.`fct_bridges_kpis_snapshot`\nORDER BY as_of_date DESC\nLIMIT 1", "relation_name": "`dbt`.`api_bridges_kpi_netflow_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.608571Z", "completed_at": "2025-12-13T16:37:54.612502Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.613078Z", "completed_at": "2025-12-13T16:37:54.613085Z"}], "thread_id": "Thread-1", "execution_time": 0.005774736404418945, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_kpi_total_netflow_all_time", "compiled": true, "compiled_code": "\n\nSELECT \n    round(cum_net_usd, 2) AS value\nFROM `dbt`.`fct_bridges_kpis_snapshot`\nORDER BY as_of_date DESC\nLIMIT 1", "relation_name": "`dbt`.`api_bridges_kpi_total_netflow_all_time`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.615767Z", "completed_at": "2025-12-13T16:37:54.620822Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.621418Z", "completed_at": "2025-12-13T16:37:54.621425Z"}], "thread_id": "Thread-1", "execution_time": 0.006943464279174805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_kpi_total_volume_all_time", "compiled": true, "compiled_code": "\n\nSELECT \n    round(cum_vol_usd, 2) AS value\nFROM `dbt`.`fct_bridges_kpis_snapshot`\nORDER BY as_of_date DESC\nLIMIT 1", "relation_name": "`dbt`.`api_bridges_kpi_total_volume_all_time`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.624083Z", "completed_at": "2025-12-13T16:37:54.627971Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.628572Z", "completed_at": "2025-12-13T16:37:54.628579Z"}], "thread_id": "Thread-1", "execution_time": 0.0058116912841796875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_kpi_volume_7d", "compiled": true, "compiled_code": "\n\nSELECT\n  round(vol_7d, 2)        AS value,\n  round(vol_prev_7d, 2)   AS prev_value,\n  chg_vol_7d              AS change_pct\nFROM `dbt`.`fct_bridges_kpis_snapshot`\nORDER BY as_of_date DESC\nLIMIT 1", "relation_name": "`dbt`.`api_bridges_kpi_volume_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.631287Z", "completed_at": "2025-12-13T16:37:54.635171Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.635757Z", "completed_at": "2025-12-13T16:37:54.635764Z"}], "thread_id": "Thread-1", "execution_time": 0.005818367004394531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_cum_netflow_weekly_by_bridge", "compiled": true, "compiled_code": "\n\nSELECT\n  week  AS date,\n  bridge AS series,\n  cum_netflow_usd AS value\nFROM `dbt`.`fct_bridges_netflow_weekly_by_bridge`\nORDER BY date, series", "relation_name": "`dbt`.`api_bridges_cum_netflow_weekly_by_bridge`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.638553Z", "completed_at": "2025-12-13T16:37:54.642711Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.643310Z", "completed_at": "2025-12-13T16:37:54.643317Z"}], "thread_id": "Thread-1", "execution_time": 0.006171703338623047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_sankey_gnosis_in_by_token_7d", "compiled": true, "compiled_code": "\n\nWITH mx AS (SELECT max(date) AS d FROM `dbt`.`fct_bridges_sankey_edges_token_daily`)\n\nSELECT token, source, target, sum(value) AS value\nFROM `dbt`.`fct_bridges_sankey_edges_token_daily`, mx\nWHERE direction = 'in'\n  AND date BETWEEN subtractDays(mx.d, 6) AND mx.d\nGROUP BY token, source, target\nHAVING value > 0\nORDER BY token, value DESC, source ASC, target ASC", "relation_name": "`dbt`.`api_bridges_sankey_gnosis_in_by_token_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.646077Z", "completed_at": "2025-12-13T16:37:54.650618Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.651228Z", "completed_at": "2025-12-13T16:37:54.651235Z"}], "thread_id": "Thread-1", "execution_time": 0.006562471389770508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_sankey_gnosis_in_ranges", "compiled": true, "compiled_code": "\n\nWITH mx AS (SELECT max(date) AS d FROM `dbt`.`fct_bridges_sankey_edges_token_daily`),\nmn AS (SELECT min(date) AS m FROM `dbt`.`fct_bridges_sankey_edges_token_daily`),\nranges AS (\n  SELECT '1D'  AS range, mx.d                       AS start_d, mx.d AS end_d, 1 AS range_order FROM mx\n  UNION ALL SELECT '7D',  subtractDays(mx.d,  6), mx.d, 2 FROM mx\n  UNION ALL SELECT '30D', subtractDays(mx.d, 29), mx.d, 3 FROM mx\n  UNION ALL SELECT '90D', subtractDays(mx.d, 89), mx.d, 4 FROM mx\n  UNION ALL SELECT 'All', mn.m, mx.d, 5 FROM mn, mx\n)\n\nSELECT\n  r.range,\n  e.source,\n  e.target,\n  sum(e.value) AS value\nFROM `dbt`.`fct_bridges_sankey_edges_token_daily` e\nJOIN ranges r ON e.date BETWEEN r.start_d AND r.end_d\nWHERE e.direction = 'in'\nGROUP BY r.range, e.source, e.target, r.range_order\nHAVING value > 0\nORDER BY r.range_order, value DESC, e.source ASC, e.target ASC", "relation_name": "`dbt`.`api_bridges_sankey_gnosis_in_ranges`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.653892Z", "completed_at": "2025-12-13T16:37:54.658120Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.658691Z", "completed_at": "2025-12-13T16:37:54.658698Z"}], "thread_id": "Thread-1", "execution_time": 0.006052255630493164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_sankey_gnosis_out_by_token_7d", "compiled": true, "compiled_code": "\n\nWITH mx AS (SELECT max(date) AS d FROM `dbt`.`fct_bridges_sankey_edges_token_daily`)\n\nSELECT token, source, target, sum(value) AS value\nFROM `dbt`.`fct_bridges_sankey_edges_token_daily`, mx\nWHERE direction = 'out'\n  AND date BETWEEN subtractDays(mx.d, 6) AND mx.d\nGROUP BY token, source, target\nHAVING value > 0\nORDER BY token, value DESC, source ASC, target ASC", "relation_name": "`dbt`.`api_bridges_sankey_gnosis_out_by_token_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.661419Z", "completed_at": "2025-12-13T16:37:54.667071Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.667675Z", "completed_at": "2025-12-13T16:37:54.667683Z"}], "thread_id": "Thread-1", "execution_time": 0.007596492767333984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_sankey_gnosis_out_ranges", "compiled": true, "compiled_code": "\n\nWITH mx AS (SELECT max(date) AS d FROM `dbt`.`fct_bridges_sankey_edges_token_daily`),\nmn AS (SELECT min(date) AS m FROM `dbt`.`fct_bridges_sankey_edges_token_daily`),\nranges AS (\n  SELECT '1D'  AS range, mx.d                       AS start_d, mx.d AS end_d, 1 AS range_order FROM mx\n  UNION ALL SELECT '7D',  subtractDays(mx.d,  6), mx.d, 2 FROM mx\n  UNION ALL SELECT '30D', subtractDays(mx.d, 29), mx.d, 3 FROM mx\n  UNION ALL SELECT '90D', subtractDays(mx.d, 89), mx.d, 4 FROM mx\n  UNION ALL SELECT 'All', mn.m, mx.d, 5 FROM mn, mx\n)\n\nSELECT\n  r.range,\n  e.source,\n  e.target,\n  sum(e.value) AS value\nFROM `dbt`.`fct_bridges_sankey_edges_token_daily` e\nJOIN ranges r ON e.date BETWEEN r.start_d AND r.end_d\nWHERE e.direction = 'out'\nGROUP BY r.range, e.source, e.target, r.range_order\nHAVING value > 0\nORDER BY r.range_order, value DESC, e.source ASC, e.target ASC", "relation_name": "`dbt`.`api_bridges_sankey_gnosis_out_ranges`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.670365Z", "completed_at": "2025-12-13T16:37:54.674884Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.675504Z", "completed_at": "2025-12-13T16:37:54.675512Z"}], "thread_id": "Thread-1", "execution_time": 0.006396293640136719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_bridges_sankey_edges_token_daily_date.f4408c8d4c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_bridges_sankey_edges_token_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.678203Z", "completed_at": "2025-12-13T16:37:54.682146Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.682735Z", "completed_at": "2025-12-13T16:37:54.682742Z"}], "thread_id": "Thread-1", "execution_time": 0.005869865417480469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_token_netflow_daily_by_bridge", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT date, bridge, token, value\n  FROM `dbt`.`fct_bridges_token_netflow_daily_by_bridge`\n),\nall_rows AS (\n  SELECT\n    date,\n    'All'   AS bridge,\n    token,\n    sum(value) AS value\n  FROM base\n  GROUP BY date, token\n),\nunioned AS (\n  SELECT date, bridge, token, value FROM base\n  UNION ALL\n  SELECT date, bridge, token, value FROM all_rows\n)\nSELECT\n  date,\n  bridge,\n  token,\n  value,\n  multiIf(bridge = 'All', 0, 1) AS bridge_order\nFROM unioned\nORDER BY date, bridge_order, bridge, token", "relation_name": "`dbt`.`api_bridges_token_netflow_daily_by_bridge`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.685487Z", "completed_at": "2025-12-13T16:37:54.689916Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.690487Z", "completed_at": "2025-12-13T16:37:54.690495Z"}], "thread_id": "Thread-1", "execution_time": 0.006371974945068359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_bridges_token_netflow_daily_by_bridge_date.b9e44b725f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_bridges_token_netflow_daily_by_bridge`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.693173Z", "completed_at": "2025-12-13T16:37:54.697017Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.697617Z", "completed_at": "2025-12-13T16:37:54.697624Z"}], "thread_id": "Thread-1", "execution_time": 0.005767822265625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_clients_cnt_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,client\n    ,cnt AS value\nFROM `dbt`.`fct_execution_blocks_clients_daily`\nORDER BY date, client", "relation_name": "`dbt`.`api_execution_blocks_clients_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.700348Z", "completed_at": "2025-12-13T16:37:54.704519Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.705114Z", "completed_at": "2025-12-13T16:37:54.705121Z"}], "thread_id": "Thread-1", "execution_time": 0.006020784378051758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_clients_pct_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,client\n    ,ROUND(fraq * 100, 2) AS value\nFROM `dbt`.`fct_execution_blocks_clients_daily`\nORDER BY date, client", "relation_name": "`dbt`.`api_execution_blocks_clients_pct_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.707823Z", "completed_at": "2025-12-13T16:37:54.713568Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.714148Z", "completed_at": "2025-12-13T16:37:54.714156Z"}], "thread_id": "Thread-1", "execution_time": 0.007630348205566406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_blocks_clients_daily_date.ba453188e6", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_execution_blocks_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.716750Z", "completed_at": "2025-12-13T16:37:54.721168Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.721747Z", "completed_at": "2025-12-13T16:37:54.721755Z"}], "thread_id": "Thread-1", "execution_time": 0.006247520446777344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_blocks_gas_usage_pct_daily_date.a4e57a886a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_blocks_gas_usage_pct_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.724460Z", "completed_at": "2025-12-13T16:37:54.728333Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.728915Z", "completed_at": "2025-12-13T16:37:54.728922Z"}], "thread_id": "Thread-1", "execution_time": 0.005716800689697266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_gas_usage_pct_monthly", "compiled": true, "compiled_code": "\n\nSELECT\n  month AS date,\n  ROUND(used * 100, 2) AS value\nFROM `dbt`.`fct_execution_blocks_gas_usage_monthly`\nORDER BY date", "relation_name": "`dbt`.`api_execution_blocks_gas_usage_pct_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.731636Z", "completed_at": "2025-12-13T16:37:54.735559Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.736175Z", "completed_at": "2025-12-13T16:37:54.736182Z"}], "thread_id": "Thread-1", "execution_time": 0.005900144577026367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_state_full_size_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,bytes/POWER(10,9) AS value\nFROM `dbt`.`fct_execution_state_full_size_daily`", "relation_name": "`dbt`.`api_execution_state_full_size_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.738869Z", "completed_at": "2025-12-13T16:37:54.743407Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.743962Z", "completed_at": "2025-12-13T16:37:54.743969Z"}], "thread_id": "Thread-1", "execution_time": 0.006327629089355469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_state_full_size_daily_date.d76bb8ce85", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_execution_state_full_size_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.746607Z", "completed_at": "2025-12-13T16:37:54.752261Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.752818Z", "completed_at": "2025-12-13T16:37:54.752825Z"}], "thread_id": "Thread-1", "execution_time": 0.00751495361328125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_cnt_daily_date.f29b9945e6", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_cnt_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.755465Z", "completed_at": "2025-12-13T16:37:54.838490Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.839059Z", "completed_at": "2025-12-13T16:37:54.839071Z"}], "thread_id": "Thread-1", "execution_time": 0.08488988876342773, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_gas_used_daily_date.1f6b125a22", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_gas_used_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.841761Z", "completed_at": "2025-12-13T16:37:54.846244Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.846804Z", "completed_at": "2025-12-13T16:37:54.846811Z"}], "thread_id": "Thread-1", "execution_time": 0.0063741207122802734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_gas_used_weekly_date.4d15d1e638", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_gas_used_weekly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.849435Z", "completed_at": "2025-12-13T16:37:54.853883Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.854464Z", "completed_at": "2025-12-13T16:37:54.854471Z"}], "thread_id": "Thread-1", "execution_time": 0.006296873092651367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_value_daily_date.9495d891e5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_value_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.857153Z", "completed_at": "2025-12-13T16:37:54.861042Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.861648Z", "completed_at": "2025-12-13T16:37:54.861656Z"}], "thread_id": "Thread-1", "execution_time": 0.00583958625793457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv4_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv4_clients_daily`\nWHERE date < today()\nORDER BY date, metric, label", "relation_name": "`dbt`.`api_p2p_discv4_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.864451Z", "completed_at": "2025-12-13T16:37:54.868554Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.869142Z", "completed_at": "2025-12-13T16:37:54.869149Z"}], "thread_id": "Thread-1", "execution_time": 0.0061321258544921875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv4_clients_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv4_clients_daily`\nWHERE date = (SELECT MAX(date) FROM  `dbt`.`int_p2p_discv4_clients_daily` )\nORDER BY metric, label", "relation_name": "`dbt`.`api_p2p_discv4_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.871733Z", "completed_at": "2025-12-13T16:37:54.877216Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.877773Z", "completed_at": "2025-12-13T16:37:54.877780Z"}], "thread_id": "Thread-1", "execution_time": 0.007307529449462891, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv4_clients_daily_date.db7cce1925", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_p2p_discv4_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.880427Z", "completed_at": "2025-12-13T16:37:54.884814Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.885383Z", "completed_at": "2025-12-13T16:37:54.885391Z"}], "thread_id": "Thread-1", "execution_time": 0.006223440170288086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv4_clients_daily_peer_id.373111a0c3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_p2p_discv4_clients_daily`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.887953Z", "completed_at": "2025-12-13T16:37:54.892324Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.892878Z", "completed_at": "2025-12-13T16:37:54.892885Z"}], "thread_id": "Thread-1", "execution_time": 0.0061931610107421875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_p2p_discv4_clients_daily_peer_id.cadec56725", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_p2p_discv4_clients_daily`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.895477Z", "completed_at": "2025-12-13T16:37:54.899985Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.900559Z", "completed_at": "2025-12-13T16:37:54.900566Z"}], "thread_id": "Thread-1", "execution_time": 0.006371736526489258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv4_topology_latest_peer_id.78ef9f3a69", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_p2p_discv4_topology_latest`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.903149Z", "completed_at": "2025-12-13T16:37:54.907552Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.908116Z", "completed_at": "2025-12-13T16:37:54.908124Z"}], "thread_id": "Thread-1", "execution_time": 0.006275653839111328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_p2p_discv4_topology_latest_peer_id.ecfe315c77", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_p2p_discv4_topology_latest`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.910803Z", "completed_at": "2025-12-13T16:37:54.919607Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.920228Z", "completed_at": "2025-12-13T16:37:54.920236Z"}], "thread_id": "Thread-1", "execution_time": 0.010769844055175781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_classification", "compiled": true, "compiled_code": "\n\n\nWITH latest_observations AS (\n    SELECT \n        toDate(visit_ended_at) as observation_date,\n        peer_id,\n        argMax(ip, visit_ended_at) AS ip_address,\n        argMax(client, visit_ended_at) AS client_type,\n        argMax(peer_country, visit_ended_at) AS country_code,\n        argMax(generic_provider, visit_ended_at) AS generic_provider,\n        argMax(peer_org, visit_ended_at) AS peer_org,\n        MAX(visit_ended_at) AS last_seen_that_day\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE \n        empty(dial_errors) = 1 \n        AND crawl_error IS NULL\n        AND toStartOfDay(visit_ended_at) < today()\n        \n            AND toDate(visit_ended_at) > (SELECT MAX(date) FROM `dbt`.`int_esg_node_classification`)\n        \n    GROUP BY observation_date, peer_id\n),\n\nnode_categories AS (\n    SELECT\n        observation_date,\n        peer_id,\n        ip_address,\n        client_type,\n        country_code,\n        generic_provider,\n        peer_org,\n        \n        -- Classify nodes into operational archetypes based on generic_provider\n        CASE\n            WHEN generic_provider IN ('AWS', 'Google', 'Azure', 'Oracle Cloud', 'Alibaba Cloud') \n                THEN 'cloud_hosted'\n            WHEN generic_provider IN ('DigitalOcean', 'OVHcloud', 'Hetzner', 'Scaleway', 'Linode', 'Vultr', \n                                    'Equinix Metal', 'Hosting/CDN (Other)') \n                THEN 'cloud_hosted'\n            WHEN generic_provider = 'Carrier/Transit' \n                THEN 'professional_operator'\n            WHEN lower(peer_org) LIKE '%datacenter%' \n                OR lower(peer_org) LIKE '%data center%'\n                OR lower(peer_org) LIKE '%hosting%'\n                OR lower(peer_org) LIKE '%server%'\n                THEN 'professional_operator'\n            WHEN generic_provider = 'Public ISP (Home/Office)' \n                THEN 'home_staker'\n            WHEN lower(peer_org) LIKE '%telecom%'\n                OR lower(peer_org) LIKE '%broadband%'\n                OR lower(peer_org) LIKE '%cable%'\n                OR lower(peer_org) LIKE '%fiber%'\n                OR lower(peer_org) LIKE '%residential%'\n                THEN 'home_staker'\n            ELSE 'unknown'\n        END AS node_category,\n        \n        CASE\n            WHEN generic_provider IN ('AWS', 'Google', 'Azure', 'Oracle Cloud', 'Alibaba Cloud') THEN 0.95\n            WHEN generic_provider IN ('DigitalOcean', 'OVHcloud', 'Hetzner', 'Scaleway', 'Linode', 'Vultr') THEN 0.90\n            WHEN generic_provider = 'Public ISP (Home/Office)' THEN 0.80\n            WHEN generic_provider = 'Hosting/CDN (Other)' THEN 0.75\n            WHEN generic_provider = 'Carrier/Transit' THEN 0.70\n            WHEN generic_provider = 'Unknown' THEN 0.30\n            ELSE 0.50\n        END AS classification_confidence\n        \n    FROM latest_observations\n),\n\ndaily_distribution AS (\n    SELECT\n        observation_date AS date,\n        node_category,\n        COUNT(DISTINCT peer_id) AS observed_nodes,\n        AVG(classification_confidence) AS avg_confidence\n    FROM node_categories\n    GROUP BY observation_date, node_category\n),\n\nchao1_data AS (\n    SELECT\n        p.observation_date,\n        p.observed_successful_nodes,\n        p.enhanced_total_reachable,\n        p.connection_success_rate_pct\n    FROM `dbt`.`int_esg_node_population_chao1` p\n    WHERE 1=1\n        \n            AND p.observation_date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_classification`)\n        \n),\n\nscaled_distribution AS (\n    SELECT\n        d.date,\n        d.node_category,\n        d.observed_nodes,\n        d.avg_confidence,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(greatest(toFloat64(d.observed_nodes), \n                    toFloat64(d.observed_nodes) * c.enhanced_total_reachable / c.observed_successful_nodes))\n            ELSE d.observed_nodes\n        END AS estimated_total_nodes,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(greatest(toFloat64(d.observed_nodes), \n                    toFloat64(d.observed_nodes) * c.enhanced_total_reachable * 0.85 / c.observed_successful_nodes))\n            ELSE toUInt64(d.observed_nodes * 0.85)\n        END AS nodes_lower_95,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(toFloat64(d.observed_nodes) * c.enhanced_total_reachable * 1.15 / c.observed_successful_nodes)\n            ELSE toUInt64(d.observed_nodes * 1.15)\n        END AS nodes_upper_95,\n        \n        COALESCE(c.connection_success_rate_pct / 100.0, 0.75) AS sample_coverage,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                round(toFloat64(c.enhanced_total_reachable) / c.observed_successful_nodes, 3)\n            ELSE 1.0\n        END AS scaling_factor\n        \n    FROM daily_distribution d\n    LEFT JOIN chao1_data c ON d.date = c.observation_date\n),\n\ngeographic_distribution AS (\n    SELECT\n        observation_date AS date,\n        node_category,\n        country_code,\n        COUNT(DISTINCT peer_id) AS country_observed_nodes\n    FROM node_categories\n    WHERE country_code IS NOT NULL AND country_code != '' AND country_code != 'Unknown'\n    GROUP BY observation_date, node_category, country_code\n),\n\ngeographic_scaled AS (\n    SELECT\n        g.date,\n        g.node_category,\n        g.country_code,\n        g.country_observed_nodes,\n        \n        CASE \n            WHEN s.scaling_factor > 0 THEN\n                toUInt64(toFloat64(g.country_observed_nodes) * s.scaling_factor)\n            ELSE g.country_observed_nodes\n        END AS country_estimated_nodes\n        \n    FROM geographic_distribution g\n    JOIN scaled_distribution s\n        ON g.date = s.date AND g.node_category = s.node_category\n)\n\nSELECT\n    s.date,\n    s.node_category,\n    s.observed_nodes,\n    s.estimated_total_nodes,\n    s.nodes_lower_95,\n    s.nodes_upper_95,\n    s.avg_confidence,\n    s.sample_coverage,\n    s.scaling_factor,\n    \n    round(100.0 * s.estimated_total_nodes / \n          SUM(s.estimated_total_nodes) OVER (PARTITION BY s.date), 2) AS category_percentage,\n    \n    s.estimated_total_nodes - s.observed_nodes AS hidden_nodes_estimated,\n    round(100.0 * (s.estimated_total_nodes - s.observed_nodes) / s.estimated_total_nodes, 2) AS hidden_nodes_percentage,\n    \n    CASE \n        WHEN COUNT(g.country_code) > 0 THEN\n            toJSONString(groupArray((g.country_code, g.country_estimated_nodes)))\n        ELSE '[]'\n    END AS geographic_distribution,\n    \n    CASE \n        WHEN COUNT(g.country_code) > 0 THEN\n            arrayStringConcat(\n                arraySlice(\n                    arrayMap(x -> tupleElement(x, 1),\n                        arraySort(x -> -tupleElement(x, 2),\n                            groupArray((g.country_code, g.country_estimated_nodes))\n                        )\n                    ), 1, 5\n                ), ', '\n            )\n        ELSE 'No geographic data'\n    END AS top_countries,\n    \n    now() AS calculated_at\n    \nFROM scaled_distribution s\nLEFT JOIN geographic_scaled g\n    ON s.date = g.date AND s.node_category = g.node_category\n\nGROUP BY \n    s.date, s.node_category, s.observed_nodes, s.estimated_total_nodes,\n    s.nodes_lower_95, s.nodes_upper_95, s.avg_confidence, s.sample_coverage, s.scaling_factor\n\nORDER BY s.date, s.estimated_total_nodes DESC", "relation_name": "`dbt`.`int_esg_node_classification`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.923017Z", "completed_at": "2025-12-13T16:37:54.927592Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.928178Z", "completed_at": "2025-12-13T16:37:54.928186Z"}], "thread_id": "Thread-1", "execution_time": 0.006603240966796875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_esg_node_population_chao1_crawl_id.8287fd921b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_id\nfrom `dbt`.`int_esg_node_population_chao1`\nwhere crawl_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.930701Z", "completed_at": "2025-12-13T16:37:54.935196Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.935773Z", "completed_at": "2025-12-13T16:37:54.935781Z"}], "thread_id": "Thread-1", "execution_time": 0.006288766860961914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_esg_node_population_chao1_peer_id.3bd40dc3d4", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_esg_node_population_chao1`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.938436Z", "completed_at": "2025-12-13T16:37:54.942837Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.943414Z", "completed_at": "2025-12-13T16:37:54.943422Z"}], "thread_id": "Thread-1", "execution_time": 0.006203413009643555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_esg_node_population_chao1_crawl_id.bfb9073510", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    crawl_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_esg_node_population_chao1`\nwhere crawl_id is not null\ngroup by crawl_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.945971Z", "completed_at": "2025-12-13T16:37:54.950325Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.950869Z", "completed_at": "2025-12-13T16:37:54.950876Z"}], "thread_id": "Thread-1", "execution_time": 0.006134033203125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_esg_node_population_chao1_peer_id.8374b515b0", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_esg_node_population_chao1`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.953540Z", "completed_at": "2025-12-13T16:37:54.959233Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.959806Z", "completed_at": "2025-12-13T16:37:54.959813Z"}], "thread_id": "Thread-1", "execution_time": 0.007581233978271484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_clients_latest", "compiled": true, "compiled_code": "\n\nWITH \n\ndiscv4_prev7D AS (\n    SELECT\n        date,\n        SUM(value) AS discv4_count\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`), 7)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv4 AS (\n    SELECT\n        date,\n        SUM(value) AS discv4_count\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv5_prev7D AS (\n    SELECT\n        date,\n        SUM(value) AS discv5_count\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_clients_daily`), 7)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv5 AS (\n    SELECT\n        date,\n        SUM(value) AS discv5_count\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_clients_daily`)\n        AND metric = 'Clients'\n    GROUP BY date\n)\n\nSELECT\n    t2.discv4_count AS discv4_count,\n    ROUND((COALESCE(t2.discv4_count / NULLIF(t1.discv4_count, 0), 0) - 1) * 100, 1) AS change_discv4_pct,\n    t4.discv5_count AS discv5_count,\n    ROUND((COALESCE(t4.discv5_count / NULLIF(t3.discv5_count, 0), 0) - 1) * 100, 1) AS change_discv5_pct\nFROM discv4_prev7D t1\nCROSS JOIN discv4 t2\nCROSS JOIN discv5_prev7D t3\nCROSS JOIN discv5 t4", "relation_name": "`dbt`.`api_p2p_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.962592Z", "completed_at": "2025-12-13T16:37:54.967640Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.968252Z", "completed_at": "2025-12-13T16:37:54.968260Z"}], "thread_id": "Thread-1", "execution_time": 0.007004261016845703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv5_clients_daily`\nWHERE date < today()\nORDER BY date, metric, label", "relation_name": "`dbt`.`api_p2p_discv5_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.970981Z", "completed_at": "2025-12-13T16:37:54.975110Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.975692Z", "completed_at": "2025-12-13T16:37:54.975699Z"}], "thread_id": "Thread-1", "execution_time": 0.005966901779174805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_clients_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv5_clients_daily`\nWHERE date = (SELECT MAX(date) FROM  `dbt`.`int_p2p_discv5_clients_daily` )\nORDER BY metric, label", "relation_name": "`dbt`.`api_p2p_discv5_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.978318Z", "completed_at": "2025-12-13T16:37:54.982853Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.983428Z", "completed_at": "2025-12-13T16:37:54.983435Z"}], "thread_id": "Thread-1", "execution_time": 0.006342649459838867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv5_clients_daily_date.5fbdde7245", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_p2p_discv5_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.985995Z", "completed_at": "2025-12-13T16:37:54.990411Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.990960Z", "completed_at": "2025-12-13T16:37:54.990967Z"}], "thread_id": "Thread-1", "execution_time": 0.006192207336425781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv5_clients_daily_peer_id.dbdc25d7e1", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_p2p_discv5_clients_daily`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:54.993536Z", "completed_at": "2025-12-13T16:37:54.997877Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:54.998457Z", "completed_at": "2025-12-13T16:37:54.998464Z"}], "thread_id": "Thread-1", "execution_time": 0.00616145133972168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_p2p_discv5_clients_daily_peer_id.2414407777", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_p2p_discv5_clients_daily`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.001076Z", "completed_at": "2025-12-13T16:37:55.004968Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.005577Z", "completed_at": "2025-12-13T16:37:55.005584Z"}], "thread_id": "Thread-1", "execution_time": 0.00574946403503418, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_current_fork_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`\nWHERE label = 'Current Fork' \nORDER BY date ASC, fork ASC", "relation_name": "`dbt`.`api_p2p_discv5_current_fork_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.008401Z", "completed_at": "2025-12-13T16:37:55.013459Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.014036Z", "completed_at": "2025-12-13T16:37:55.014043Z"}], "thread_id": "Thread-1", "execution_time": 0.0070040225982666016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_next_fork_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`\nWHERE label = 'Next Fork' \nORDER BY date ASC, fork ASC", "relation_name": "`dbt`.`api_p2p_discv5_next_fork_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.016784Z", "completed_at": "2025-12-13T16:37:55.020052Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.020641Z", "completed_at": "2025-12-13T16:37:55.020648Z"}], "thread_id": "Thread-1", "execution_time": 0.005173683166503906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_p2p_discv5_forks_daily", "compiled": true, "compiled_code": "SELECT\n    date\n    ,label\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`", "relation_name": "`dbt`.`fct_p2p_discv5_forks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.023318Z", "completed_at": "2025-12-13T16:37:55.027723Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.028296Z", "completed_at": "2025-12-13T16:37:55.028304Z"}], "thread_id": "Thread-1", "execution_time": 0.006273508071899414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv5_forks_daily_date.8e990ae415", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_p2p_discv5_forks_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.030862Z", "completed_at": "2025-12-13T16:37:55.035359Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.035914Z", "completed_at": "2025-12-13T16:37:55.035921Z"}], "thread_id": "Thread-1", "execution_time": 0.006284952163696289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv5_forks_daily_peer_id.7e2ec92420", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_p2p_discv5_forks_daily`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.038488Z", "completed_at": "2025-12-13T16:37:55.042854Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.043430Z", "completed_at": "2025-12-13T16:37:55.043437Z"}], "thread_id": "Thread-1", "execution_time": 0.0061647891998291016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_p2p_discv5_forks_daily_peer_id.31fc691e37", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_p2p_discv5_forks_daily`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.046159Z", "completed_at": "2025-12-13T16:37:55.051610Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.052243Z", "completed_at": "2025-12-13T16:37:55.052250Z"}], "thread_id": "Thread-1", "execution_time": 0.007447004318237305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_p2p_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ndiscv4_topology AS (\n    SELECT\n        date,\n        peer_ip,\n        peer_discovery_id_prefix,\n        peer_client,\n        peer_hostname,\n        peer_city,\n        peer_country,\n        peer_org,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(peer_loc, '')), 1)) AS peer_lat,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(peer_loc, '')), 2)) AS peer_lon,\n        neighbor_ip,\n        neighbor_discovery_id_prefix,\n        neighbor_client,\n        neighbor_city,\n        neighbor_country,\n        neighbor_org,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(neighbor_loc, '')), 1)) AS neighbor_lat,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(neighbor_loc, '')), 2)) AS neighbor_lon,\n        cnt\n    FROM `dbt`.`int_p2p_discv4_topology_latest`\n),\n\ndiscv5_topology AS (\n    SELECT\n        date,\n        peer_ip,\n        peer_discovery_id_prefix,\n        peer_client,\n        peer_hostname,\n        peer_city,\n        peer_country,\n        peer_org,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(peer_loc, '')), 1)) AS peer_lat,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(peer_loc, '')), 2)) AS peer_lon,\n        neighbor_ip,\n        neighbor_discovery_id_prefix,\n        neighbor_client,\n        neighbor_city,\n        neighbor_country,\n        neighbor_org,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(neighbor_loc, '')), 1)) AS neighbor_lat,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(neighbor_loc, '')), 2)) AS neighbor_lon,\n        cnt\n    FROM `dbt`.`int_p2p_discv5_topology_latest`\n)\n\nSELECT 'DiscV4' AS protocol, * FROM discv4_topology\nUNION ALL\nSELECT 'DiscV5' AS protocol, * FROM discv5_topology", "relation_name": "`dbt`.`fct_p2p_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.055074Z", "completed_at": "2025-12-13T16:37:55.059545Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.060125Z", "completed_at": "2025-12-13T16:37:55.060133Z"}], "thread_id": "Thread-1", "execution_time": 0.006356716156005859, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv5_topology_latest_peer_id.a2433c6a9f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_p2p_discv5_topology_latest`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.062665Z", "completed_at": "2025-12-13T16:37:55.067005Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.067630Z", "completed_at": "2025-12-13T16:37:55.067638Z"}], "thread_id": "Thread-1", "execution_time": 0.006182193756103516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_p2p_discv5_topology_latest_peer_id.72fec1dadd", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_p2p_discv5_topology_latest`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.070232Z", "completed_at": "2025-12-13T16:37:55.074734Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.075314Z", "completed_at": "2025-12-13T16:37:55.075321Z"}], "thread_id": "Thread-1", "execution_time": 0.006388425827026367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_visits_latest_date.05d6acdde5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_visits_latest`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.077887Z", "completed_at": "2025-12-13T16:37:55.082460Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.083018Z", "completed_at": "2025-12-13T16:37:55.083025Z"}], "thread_id": "Thread-1", "execution_time": 0.0063707828521728516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_GBCDeposit_deposists_daily_date.38d3333b70", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_GBCDeposit_deposists_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.085667Z", "completed_at": "2025-12-13T16:37:55.092769Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.093378Z", "completed_at": "2025-12-13T16:37:55.093385Z"}], "thread_id": "Thread-1", "execution_time": 0.008957624435424805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_rwa_backedfi_prices_daily", "compiled": true, "compiled_code": "\n\n\n\n   -- safely before any token was listed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bC3M'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bC3M'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bCOIN'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bCOIN'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bCSPX'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bCSPX'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bHIGH'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bHIGH'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bIB01'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bIB01'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bIBTA'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bIBTA'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bMSTR'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bMSTR'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bNVDA'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bNVDA'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'TSLAx'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'TSLAx'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nORDER BY bticker, date", "relation_name": "`dbt`.`fct_execution_rwa_backedfi_prices_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.096057Z", "completed_at": "2025-12-13T16:37:55.102034Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.102636Z", "completed_at": "2025-12-13T16:37:55.102644Z"}], "thread_id": "Thread-1", "execution_time": 0.007908105850219727, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_rwa_backedfi_prices_date.10510ec5d3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_rwa_backedfi_prices`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.105271Z", "completed_at": "2025-12-13T16:37:55.109460Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.110042Z", "completed_at": "2025-12-13T16:37:55.110050Z"}], "thread_id": "Thread-1", "execution_time": 0.006037473678588867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_circles_backing", "compiled": true, "compiled_code": "\n\nWITH dates AS (\n    -- get min/max date \n    SELECT\n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM `dbt`.`int_execution_circles_backing`\n),\ndate_series AS (\n    -- generate dense series of dates\n    SELECT\n        toDate(min_date) + number AS date\n    FROM dates\n    ARRAY JOIN range(dateDiff('day', min_date, max_date) + 1) AS number\n),\n\nfilled AS (\n    SELECT\n        g.date,\n        coalesce(t.cnt, 0) AS cnt\n    FROM date_series g\n    LEFT JOIN `dbt`.`int_execution_circles_backing` t\n        ON g.date = t.date\n)\n\nSELECT\n    date,\n    cnt,\n    SUM(cnt) OVER (ORDER BY date) AS total\nFROM filled\nWHERE date < today()", "relation_name": "`dbt`.`fct_execution_circles_backing`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.112777Z", "completed_at": "2025-12-13T16:37:55.117263Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.117822Z", "completed_at": "2025-12-13T16:37:55.117829Z"}], "thread_id": "Thread-1", "execution_time": 0.00636744499206543, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_circles_backing_date.f1014374da", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_circles_backing`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.120420Z", "completed_at": "2025-12-13T16:37:55.124894Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.125485Z", "completed_at": "2025-12-13T16:37:55.125492Z"}], "thread_id": "Thread-1", "execution_time": 0.0062961578369140625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_circles_transitive_transfers_date.3c0b3c4d11", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_circles_transitive_transfers`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.128171Z", "completed_at": "2025-12-13T16:37:55.132661Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.133238Z", "completed_at": "2025-12-13T16:37:55.133245Z"}], "thread_id": "Thread-1", "execution_time": 0.006303548812866211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_circles_v1_avatars_block_timestamp.59705b6705", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect block_timestamp\nfrom `dbt`.`int_execution_circles_v1_avatars`\nwhere block_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.135881Z", "completed_at": "2025-12-13T16:37:55.141387Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.141970Z", "completed_at": "2025-12-13T16:37:55.141977Z"}], "thread_id": "Thread-1", "execution_time": 0.007349252700805664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_circles_avatars", "compiled": true, "compiled_code": "\n\nWITH dates AS (\n    -- get min/max date \n    SELECT\n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM `dbt`.`int_execution_circles_v2_avatars`\n),\ndate_series AS (\n    -- generate dense series of dates\n    SELECT\n        toDate(min_date) + number AS date\n    FROM dates\n    ARRAY JOIN range(dateDiff('day', min_date, max_date) + 1) AS number\n),\navatar_types AS (\n    SELECT DISTINCT avatar_type\n    FROM `dbt`.`int_execution_circles_v2_avatars`\n),\ndense_grid AS (\n    SELECT\n        d.date,\n        a.avatar_type\n    FROM date_series d\n    CROSS JOIN avatar_types a\n),\nfilled AS (\n    SELECT\n        g.date,\n        g.avatar_type,\n        coalesce(t.cnt, 0) AS cnt\n    FROM dense_grid g\n    LEFT JOIN `dbt`.`int_execution_circles_v2_avatars` t\n        ON g.date = t.date\n       AND g.avatar_type = t.avatar_type\n)\n\nSELECT\n    date,\n    avatar_type,\n    cnt,\n    SUM(cnt) OVER (PARTITION BY avatar_type ORDER BY date) AS total\nFROM filled", "relation_name": "`dbt`.`fct_execution_circles_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.144831Z", "completed_at": "2025-12-13T16:37:55.149414Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.149973Z", "completed_at": "2025-12-13T16:37:55.149980Z"}], "thread_id": "Thread-1", "execution_time": 0.006459236145019531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_circles_v2_avatars_date.d60ea61f19", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_circles_v2_avatars`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.152644Z", "completed_at": "2025-12-13T16:37:55.156614Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.157231Z", "completed_at": "2025-12-13T16:37:55.157238Z"}], "thread_id": "Thread-1", "execution_time": 0.0058557987213134766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_yields_sdai_apy_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nsdai_apy_daily AS (\n    SELECT\n        date,\n        floor(POWER((1+rate),365) - 1,4) * 100 AS apy,\n        floor(\n            avg(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 6  PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_7DMA,\n        floor(\n            avg(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_30DMA,\n         floor(\n            median(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 6  PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_7DMM,\n        floor(\n            median(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_30DMM\n    FROM `dbt`.`int_yields_sdai_rate_daily`\n)\n\nSELECT date, apy, 'Daily' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_7DMA, '7DMA' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_30DMA, '30DMA' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_7DMM, '7DMM' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_30DMM, '30DMM' AS label FROM sdai_apy_daily", "relation_name": "`dbt`.`fct_yields_sdai_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.159899Z", "completed_at": "2025-12-13T16:37:55.164328Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.164883Z", "completed_at": "2025-12-13T16:37:55.164890Z"}], "thread_id": "Thread-1", "execution_time": 0.006211757659912109, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_yields_sdai_rate_daily_date.df9fcc0c06", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_yields_sdai_rate_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.167573Z", "completed_at": "2025-12-13T16:37:55.175247Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.175841Z", "completed_at": "2025-12-13T16:37:55.175848Z"}], "thread_id": "Thread-1", "execution_time": 0.009542465209960938, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_tokens_address_diffs_daily", "compiled": true, "compiled_code": "\n\n\n\n\nWITH base AS (\n    SELECT\n        date,\n        lower(token_address) AS token_address,\n        symbol,\n        lower(\"from\")        AS from_address,\n        lower(\"to\")          AS to_address,\n        amount_raw               AS amount_raw\n    FROM `dbt`.`int_execution_transfers_whitelisted_daily`\n    WHERE date < today()\n      \n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_tokens_address_diffs_daily` AS x1\n    )\n    AND toStartOfDay(date) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_tokens_address_diffs_daily` AS x2\n    )\n  \n\n      \n),\n\nwith_class AS (\n    SELECT\n        b.date,\n        b.token_address,\n        b.symbol,\n        coalesce(w.token_class, 'OTHER') AS token_class,\n        b.from_address,\n        b.to_address,\n        b.amount_raw\n    FROM base b\n    LEFT JOIN `dbt`.`tokens_whitelist` w\n      ON lower(w.address) = b.token_address\n),\n\ndeltas AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        from_address AS address,\n        -amount_raw      AS delta_raw\n    FROM with_class\n\n    UNION ALL\n\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        to_address   AS address,\n        amount_raw       AS delta_raw\n    FROM with_class\n),\n\nagg AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        lower(address) AS address,\n        sum(delta_raw)     AS net_delta_raw\n    FROM deltas\n    GROUP BY date, token_address, symbol, token_class, address\n)\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n    address,\n    net_delta_raw\nFROM agg\nWHERE net_delta_raw != 0", "relation_name": "`dbt`.`int_execution_tokens_address_diffs_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.178618Z", "completed_at": "2025-12-13T16:37:55.185851Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.186461Z", "completed_at": "2025-12-13T16:37:55.186468Z"}], "thread_id": "Thread-1", "execution_time": 0.009106159210205078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_tokens_transfers_daily", "compiled": true, "compiled_code": "\n\n\n\n\nWITH base AS (\n    SELECT\n        date,\n        lower(token_address) AS token_address,\n        symbol,\n        lower(\"from\")        AS from_address,\n        lower(\"to\")          AS to_address,\n        amount               AS amount,\n        amount_usd           AS amount_usd,\n        transfer_count       AS transfer_count\n    FROM `dbt`.`int_execution_transfers_whitelisted_daily`\n    WHERE date < today()\n      \n        \n  \n\n      \n),\n\nwith_class AS (\n    SELECT\n        b.date,\n        b.token_address,\n        b.symbol,\n        coalesce(w.token_class, 'OTHER') AS token_class,\n        b.amount,\n        b.amount_usd,\n        b.from_address,\n        b.to_address,\n        b.transfer_count\n    FROM base b\n    LEFT JOIN `dbt`.`tokens_whitelist` w\n      ON lower(w.address) = b.token_address\n),\n\nagg AS (\n    SELECT\n        date,\n        token_address,\n        any(symbol)      AS symbol,\n        any(token_class) AS token_class,\n        sum(amount)      AS volume_token,\n        sum(amount_usd)  AS volume_usd,\n        sum(transfer_count) AS transfer_count,\n        groupBitmapState(cityHash64(from_address)) AS ua_bitmap_state,\n        uniqExact(from_address)                    AS active_senders,\n        uniqExact(to_address)                      AS unique_receivers\n    FROM with_class\n    GROUP BY date, token_address\n)\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n    volume_token,\n    volume_usd,\n    transfer_count,\n    ua_bitmap_state,\n    active_senders,\n    unique_receivers\nFROM agg\nORDER BY date, token_address", "relation_name": "`dbt`.`int_execution_tokens_transfers_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.189236Z", "completed_at": "2025-12-13T16:37:55.194481Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.195055Z", "completed_at": "2025-12-13T16:37:55.195062Z"}], "thread_id": "Thread-1", "execution_time": 0.0070953369140625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_crawlers_data_distinct_projects_sectors", "compiled": true, "compiled_code": "\n\nSELECT DISTINCT\n  project,\n  sector\nFROM `dbt`.`int_crawlers_data_labels`\nWHERE project IS NOT NULL\n  AND sector  IS NOT NULL", "relation_name": "`dbt`.`fct_crawlers_data_distinct_projects_sectors`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.197905Z", "completed_at": "2025-12-13T16:37:55.206279Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.206866Z", "completed_at": "2025-12-13T16:37:55.206873Z"}], "thread_id": "Thread-1", "execution_time": 0.01028299331665039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_by_project_daily", "compiled": true, "compiled_code": "\n\n\n\n\n\nWITH lbl AS (\n  SELECT address, project, sector\n  FROM `dbt`.`int_crawlers_data_labels`\n),\n\ntx_labeled AS (\n  SELECT\n    toDate(t.block_timestamp)                        AS date,\n    coalesce(nullIf(trim(l.project), ''), 'Unknown') AS project,\n    lower(t.from_address)                            AS from_address,\n    toFloat64(coalesce(t.gas_used, 0))               AS gas_used,\n    toFloat64(coalesce(t.gas_price, 0))              AS gas_price\n  FROM `dbt`.`stg_execution__transactions` t\n  ANY LEFT JOIN lbl l ON lower(t.to_address) = l.address\n  WHERE t.block_timestamp < today()\n    AND t.from_address IS NOT NULL\n    AND t.success = 1\n    \n      \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_transactions_by_project_daily` AS x1\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_transactions_by_project_daily` AS x2\n    )\n  \n\n    \n),\n\nagg AS (\n  SELECT\n    date,\n    project,\n    count()                                    AS tx_count,\n    groupBitmapState(cityHash64(from_address)) AS ua_bitmap_state,\n    sum(gas_used)                              AS gas_used_sum,\n    sum(gas_used * gas_price) / 1e18           AS fee_native_sum\n  FROM tx_labeled\n  GROUP BY date, project\n),\n\nproj_sector AS (\n  SELECT\n    project,\n    coalesce(nullIf(trim(sector), ''), 'Unknown') AS sector\n  FROM (\n    SELECT project, anyHeavy(sector) AS sector\n    FROM `dbt`.`int_crawlers_data_labels`\n    GROUP BY project\n  )\n)\n\nSELECT\n  a.date                AS date,\n  a.project             AS project,\n  ps.sector             AS sector,\n  a.tx_count            AS tx_count,\n  a.ua_bitmap_state     AS ua_bitmap_state,\n  a.gas_used_sum        AS gas_used_sum,\n  a.fee_native_sum      AS fee_native_sum\nFROM agg a\nLEFT JOIN proj_sector ps ON ps.project = a.project", "relation_name": "`dbt`.`int_execution_transactions_by_project_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.210138Z", "completed_at": "2025-12-13T16:37:55.215135Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.215731Z", "completed_at": "2025-12-13T16:37:55.215738Z"}], "thread_id": "Thread-1", "execution_time": 0.007062673568725586, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_by_project_hourly_recent", "compiled": true, "compiled_code": "\n\nWITH lbl AS (\n  SELECT address, project, sector\n  FROM `dbt`.`int_crawlers_data_labels`\n),\n\n\nwm AS (\n  SELECT toStartOfDay(max(block_timestamp), 'UTC') AS max_day\n  FROM `dbt`.`stg_execution__transactions`\n  WHERE toStartOfMonth(block_timestamp) >= toStartOfMonth(today() - INTERVAL 1 MONTH)\n),\n\ntx AS (\n  SELECT\n    toStartOfHour(t.block_timestamp, 'UTC') AS hour,\n    lower(t.from_address)                 AS from_address,\n    lower(t.to_address)                   AS to_address,\n    toFloat64(coalesce(t.gas_used, 0))    AS gas_used,\n    toFloat64(coalesce(t.gas_price, 0))   AS gas_price\n  FROM `dbt`.`stg_execution__transactions` t\n  CROSS JOIN wm\n  WHERE \n    toStartOfMonth(block_timestamp) >= toStartOfMonth(today() - INTERVAL 1 MONTH)\n    AND toStartOfDay(t.block_timestamp, 'UTC') >= subtractDays(max_day, 2)\n    AND toStartOfDay(t.block_timestamp, 'UTC') < max_day\n    AND t.from_address IS NOT NULL\n    AND t.success = 1\n),\n\nclassified AS (\n  SELECT\n    tx.hour,\n    coalesce(nullIf(trim(l.project), ''), 'Unknown') AS project,\n    count()                                          AS tx_count,\n    countDistinct(tx.from_address)                   AS active_accounts,\n    groupBitmapState(cityHash64(tx.from_address))    AS ua_bitmap_state,\n    sum(tx.gas_used * tx.gas_price) / 1e18           AS fee_native_sum\n  FROM tx\n  ANY LEFT JOIN lbl l ON tx.to_address = l.address\n  GROUP BY tx.hour, project\n),\n\nproj_sector AS (\n  SELECT\n    project,\n    coalesce(nullIf(trim(sector), ''), 'Unknown') AS sector\n  FROM (\n    SELECT project, anyHeavy(sector) AS sector\n    FROM `dbt`.`int_crawlers_data_labels`\n    GROUP BY project\n  )\n)\n\nSELECT\n  c.hour,\n  c.project,\n  ps.sector,\n  c.tx_count,\n  c.active_accounts,\n  c.ua_bitmap_state,\n  c.fee_native_sum\nFROM classified c\nLEFT JOIN proj_sector ps ON ps.project = c.project", "relation_name": "`dbt`.`int_execution_transactions_by_project_hourly_recent`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.218580Z", "completed_at": "2025-12-13T16:37:55.223124Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.223684Z", "completed_at": "2025-12-13T16:37:55.223691Z"}], "thread_id": "Thread-1", "execution_time": 0.006512880325317383, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_crawlers_data_labels_introduced_at.caa2cba0cf", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect introduced_at\nfrom `dbt`.`int_crawlers_data_labels`\nwhere introduced_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.226267Z", "completed_at": "2025-12-13T16:37:55.230803Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.231378Z", "completed_at": "2025-12-13T16:37:55.231385Z"}], "thread_id": "Thread-1", "execution_time": 0.006342887878417969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_withdrawal_credentials_freq_daily_date.b55d46aedc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_withdrawal_credentials_freq_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.233973Z", "completed_at": "2025-12-13T16:37:55.239605Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.240175Z", "completed_at": "2025-12-13T16:37:55.240182Z"}], "thread_id": "Thread-1", "execution_time": 0.007467508316040039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_apy_dist_last_30_days_date.640e008a97", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_apy_dist_last_30_days`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.242740Z", "completed_at": "2025-12-13T16:37:55.247519Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.248076Z", "completed_at": "2025-12-13T16:37:55.248083Z"}], "thread_id": "Thread-1", "execution_time": 0.006623506546020508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_balance_dist_last_30_days_date.da42d3977a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_balance_dist_last_30_days`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.250701Z", "completed_at": "2025-12-13T16:37:55.255174Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.255745Z", "completed_at": "2025-12-13T16:37:55.255752Z"}], "thread_id": "Thread-1", "execution_time": 0.00627446174621582, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_apy_dist_daily_date.a70bc6aaff", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_apy_dist_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.258375Z", "completed_at": "2025-12-13T16:37:55.262782Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.263363Z", "completed_at": "2025-12-13T16:37:55.263370Z"}], "thread_id": "Thread-1", "execution_time": 0.006226062774658203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_balances_dist_daily_date.41eb9fe9cd", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_balances_dist_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.265999Z", "completed_at": "2025-12-13T16:37:55.269880Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.270480Z", "completed_at": "2025-12-13T16:37:55.270487Z"}], "thread_id": "Thread-1", "execution_time": 0.005730390548706055, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_active_ongoing_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'active_ongoing'", "relation_name": "`dbt`.`api_consensus_info_active_ongoing_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.273123Z", "completed_at": "2025-12-13T16:37:55.277009Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.277614Z", "completed_at": "2025-12-13T16:37:55.277621Z"}], "thread_id": "Thread-1", "execution_time": 0.005756855010986328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_apy_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'APY'", "relation_name": "`dbt`.`api_consensus_info_apy_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.280240Z", "completed_at": "2025-12-13T16:37:55.285367Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.285952Z", "completed_at": "2025-12-13T16:37:55.285959Z"}], "thread_id": "Thread-1", "execution_time": 0.006967067718505859, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_deposits_cnt_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'deposits_cnt'", "relation_name": "`dbt`.`api_consensus_info_deposits_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.288663Z", "completed_at": "2025-12-13T16:37:55.292519Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.293111Z", "completed_at": "2025-12-13T16:37:55.293119Z"}], "thread_id": "Thread-1", "execution_time": 0.005784273147583008, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_staked_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    toUInt32(value) AS value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'Staked'", "relation_name": "`dbt`.`api_consensus_info_staked_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.295838Z", "completed_at": "2025-12-13T16:37:55.299667Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.300263Z", "completed_at": "2025-12-13T16:37:55.300270Z"}], "thread_id": "Thread-1", "execution_time": 0.005694389343261719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_withdrawls_cnt_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'withdrawls_cnt'", "relation_name": "`dbt`.`api_consensus_info_withdrawls_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.302905Z", "completed_at": "2025-12-13T16:37:55.307405Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.307970Z", "completed_at": "2025-12-13T16:37:55.307978Z"}], "thread_id": "Thread-1", "execution_time": 0.00635528564453125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_bridges_cum_netflow_weekly_by_bridge_date.73f6426d30", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_bridges_cum_netflow_weekly_by_bridge`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.310581Z", "completed_at": "2025-12-13T16:37:55.315056Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.315636Z", "completed_at": "2025-12-13T16:37:55.315643Z"}], "thread_id": "Thread-1", "execution_time": 0.006346940994262695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_bridges_token_netflow_daily_by_bridge_date.5058311fee", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_bridges_token_netflow_daily_by_bridge`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.318314Z", "completed_at": "2025-12-13T16:37:55.322863Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.323428Z", "completed_at": "2025-12-13T16:37:55.323435Z"}], "thread_id": "Thread-1", "execution_time": 0.006438732147216797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_blocks_clients_cnt_daily_date.9319e2b653", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_blocks_clients_cnt_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.325993Z", "completed_at": "2025-12-13T16:37:55.331745Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.332348Z", "completed_at": "2025-12-13T16:37:55.332355Z"}], "thread_id": "Thread-1", "execution_time": 0.007631778717041016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_blocks_clients_pct_daily_date.49d7e9d160", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_blocks_clients_pct_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.334921Z", "completed_at": "2025-12-13T16:37:55.339361Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.339916Z", "completed_at": "2025-12-13T16:37:55.339923Z"}], "thread_id": "Thread-1", "execution_time": 0.0062601566314697266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_blocks_gas_usage_pct_monthly_date.b145145f73", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_blocks_gas_usage_pct_monthly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.342504Z", "completed_at": "2025-12-13T16:37:55.347003Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.347591Z", "completed_at": "2025-12-13T16:37:55.347604Z"}], "thread_id": "Thread-1", "execution_time": 0.006363391876220703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_state_full_size_daily_date.453c8c3223", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_state_full_size_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.350214Z", "completed_at": "2025-12-13T16:37:55.354637Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.355214Z", "completed_at": "2025-12-13T16:37:55.355222Z"}], "thread_id": "Thread-1", "execution_time": 0.0063130855560302734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_discv4_clients_daily_date.48ee0389eb", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_discv4_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.357887Z", "completed_at": "2025-12-13T16:37:55.366738Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.367346Z", "completed_at": "2025-12-13T16:37:55.367353Z"}], "thread_id": "Thread-1", "execution_time": 0.010788917541503906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_client_distribution", "compiled": true, "compiled_code": "\n\nWITH node_classification AS (\n    -- Get total nodes per category from classification model\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        scaling_factor\n    FROM `dbt`.`int_esg_node_classification`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`)\n    \n),\n\n-- Combine client data from both DiscV4 (execution) and DiscV5 (consensus)\ncombined_client_data AS (\n    -- DiscV5 Consensus clients\n    SELECT\n        date,\n        'consensus_' || label AS client_type,\n        value AS observed_client_nodes\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE metric = 'Clients' \n        AND value > 0\n        AND label NOT IN ('Unknown', '')\n        \n            AND date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`) - INTERVAL 1 DAY\n        \n    \n    UNION ALL\n    \n    -- DiscV4 Execution clients  \n    SELECT\n        date,\n        'execution_' || label AS client_type,\n        value AS observed_client_nodes\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE metric = 'Clients'\n        AND value > 0  \n        AND label NOT IN ('Unknown', '')\n        \n            AND date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`) - INTERVAL 1 DAY\n        \n),\n\n-- Calculate client distribution percentages\nobserved_client_distribution AS (\n    SELECT\n        date,\n        client_type,\n        observed_client_nodes,\n        round(100.0 * observed_client_nodes / SUM(observed_client_nodes) OVER (PARTITION BY date), 3) AS observed_client_percentage\n    FROM combined_client_data\n),\n\n-- Apply client distribution to each node category\nclient_distribution_by_category AS (\n    SELECT\n        nc.date,\n        nc.node_category, \n        ocd.client_type,\n        ocd.observed_client_nodes,\n        ocd.observed_client_percentage,\n        \n        -- Calculate client nodes for this category\n        -- Each client gets same percentage of each category\n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.estimated_total_nodes\n        )) AS estimated_client_nodes,\n        \n        -- Proportional bounds\n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.nodes_lower_95\n        )) AS client_nodes_lower_95,\n        \n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.nodes_upper_95\n        )) AS client_nodes_upper_95,\n        \n        -- Client efficiency factors\n        CASE \n            -- Consensus client efficiency (relative to baseline)\n            WHEN ocd.client_type = 'consensus_Lighthouse' THEN 0.95\n            WHEN ocd.client_type = 'consensus_Nimbus' THEN 0.85  \n            WHEN ocd.client_type = 'consensus_Teku' THEN 1.15\n            WHEN ocd.client_type = 'consensus_Prysm' THEN 1.05\n            WHEN ocd.client_type = 'consensus_Lodestar' THEN 1.10\n            \n            -- Execution client efficiency (relative to baseline)\n            WHEN ocd.client_type = 'execution_Erigon' THEN 0.95\n            WHEN ocd.client_type = 'execution_Nethermind' THEN 1.00\n            WHEN ocd.client_type = 'execution_Besu' THEN 1.02\n            WHEN ocd.client_type = 'execution_Geth' THEN 0.98\n            \n            -- Default for other/unknown clients\n            ELSE 1.0\n        END AS client_efficiency_factor,\n        \n        nc.scaling_factor\n        \n    FROM node_classification nc\n    JOIN observed_client_distribution ocd ON nc.date = ocd.date\n    WHERE nc.estimated_total_nodes > 0\n),\n\n-- Calculate final metrics with rankings\nfinal_client_distribution AS (\n    SELECT\n        date,\n        node_category,\n        client_type,\n        estimated_client_nodes,\n        client_nodes_lower_95,\n        client_nodes_upper_95,\n        client_efficiency_factor,\n        \n        -- Percentage within this node category\n        round(100.0 * estimated_client_nodes / \n              NULLIF(SUM(estimated_client_nodes) OVER (PARTITION BY date, node_category), 0), 2\n        ) AS category_client_percentage,\n        \n        -- Global percentage across all categories  \n        round(100.0 * estimated_client_nodes /\n              NULLIF(SUM(estimated_client_nodes) OVER (PARTITION BY date), 0), 2\n        ) AS global_client_percentage,\n        \n        -- Ranking within category\n        ROW_NUMBER() OVER (\n            PARTITION BY date, node_category \n            ORDER BY estimated_client_nodes DESC, client_type\n        ) AS rank_in_category,\n        \n        -- Global ranking\n        ROW_NUMBER() OVER (\n            PARTITION BY date \n            ORDER BY estimated_client_nodes DESC, node_category, client_type\n        ) AS global_rank\n        \n    FROM client_distribution_by_category\n    WHERE estimated_client_nodes > 0\n)\n\nSELECT\n    date,\n    node_category,\n    client_type,\n    estimated_client_nodes,\n    client_nodes_lower_95,\n    client_nodes_upper_95,\n    client_efficiency_factor,\n    category_client_percentage,\n    global_client_percentage,\n    rank_in_category,\n    global_rank,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM final_client_distribution\nORDER BY date, node_category, estimated_client_nodes DESC", "relation_name": "`dbt`.`int_esg_node_client_distribution`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.370152Z", "completed_at": "2025-12-13T16:37:55.377130Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.377726Z", "completed_at": "2025-12-13T16:37:55.377734Z"}], "thread_id": "Thread-1", "execution_time": 0.009002208709716797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_geographic_distribution", "compiled": true, "compiled_code": "\n\nWITH node_classification AS (\n    -- Get node classification data\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        geographic_distribution\n    FROM `dbt`.`int_esg_node_classification`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_geographic_distribution`)\n    \n),\n\n-- Parse geographic distribution JSON\ngeographic_parsed AS (\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        \n        -- Parse JSON array of country distributions\n        JSONExtract(geographic_distribution, 'Array(Tuple(String, UInt32))') AS country_array\n    FROM node_classification\n),\n\ngeographic_expanded AS (\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95, \n        nodes_upper_95,\n        \n        -- Unpack country data\n        arrayJoin(country_array) AS country_tuple,\n        tupleElement(country_tuple, 1) AS country_code,\n        tupleElement(country_tuple, 2) AS estimated_nodes\n        \n    FROM geographic_parsed\n    WHERE length(country_array) > 0\n),\n\n-- Add country metadata from country_codes table\ncountry_enriched AS (\n    SELECT\n        g.date,\n        g.node_category,\n        g.country_code,\n        g.estimated_nodes,\n        \n        -- Calculate bounds proportionally\n        round(toFloat64(g.estimated_nodes) * g.nodes_lower_95 / g.estimated_total_nodes) AS nodes_lower_95,\n        round(toFloat64(g.estimated_nodes) * g.nodes_upper_95 / g.estimated_total_nodes) AS nodes_upper_95,\n        \n        -- Country percentage within this category\n        round(100.0 * g.estimated_nodes / g.estimated_total_nodes, 2) AS category_percentage,\n        \n        -- Get country metadata from reference table\n        COALESCE(cc.name, 'Unknown') AS country_name,\n        COALESCE(cc.region, 'Other') AS region,\n        cc.`sub-region` AS sub_region,\n        cc.`alpha-3` AS country_code_alpha3\n        \n    FROM geographic_expanded g\n    LEFT JOIN `dbt`.`stg_crawlers_data__country_codes` cc\n        ON g.country_code = cc.`alpha-2`\n    WHERE g.estimated_nodes > 0  -- Only include countries with nodes\n)\n\nSELECT\n    date,\n    node_category,\n    country_code,\n    country_name,\n    region,\n    sub_region,\n    country_code_alpha3,\n    estimated_nodes AS estimated_total_nodes,\n    nodes_lower_95,\n    nodes_upper_95,\n    category_percentage,\n    \n    -- Overall percentage across all categories\n    round(100.0 * estimated_nodes / SUM(estimated_nodes) OVER (PARTITION BY date), 2) AS global_percentage,\n    \n    -- Ranking within category\n    ROW_NUMBER() OVER (PARTITION BY date, node_category ORDER BY estimated_nodes DESC) AS rank_in_category,\n    \n    -- Ranking globally\n    ROW_NUMBER() OVER (PARTITION BY date ORDER BY estimated_nodes DESC) AS global_rank,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM country_enriched\nORDER BY date, node_category, estimated_nodes DESC", "relation_name": "`dbt`.`int_esg_node_geographic_distribution`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.380557Z", "completed_at": "2025-12-13T16:37:55.385028Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.385608Z", "completed_at": "2025-12-13T16:37:55.385615Z"}], "thread_id": "Thread-1", "execution_time": 0.0064356327056884766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_esg_node_classification_peer_id.08efd9bad7", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_esg_node_classification`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.388237Z", "completed_at": "2025-12-13T16:37:55.392677Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.393252Z", "completed_at": "2025-12-13T16:37:55.393260Z"}], "thread_id": "Thread-1", "execution_time": 0.006331682205200195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_esg_node_classification_peer_id.d2c6a70b0b", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_esg_node_classification`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.395835Z", "completed_at": "2025-12-13T16:37:55.400341Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.400886Z", "completed_at": "2025-12-13T16:37:55.400893Z"}], "thread_id": "Thread-1", "execution_time": 0.006337881088256836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_clients_latest_date.79522e2cdc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_clients_latest`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.403509Z", "completed_at": "2025-12-13T16:37:55.407938Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.408517Z", "completed_at": "2025-12-13T16:37:55.408524Z"}], "thread_id": "Thread-1", "execution_time": 0.006325960159301758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_discv5_clients_daily_date.1187b1bb2f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_discv5_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.411151Z", "completed_at": "2025-12-13T16:37:55.415600Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.416164Z", "completed_at": "2025-12-13T16:37:55.416171Z"}], "thread_id": "Thread-1", "execution_time": 0.0063533782958984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_discv5_current_fork_daily_date.81d71f6217", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_discv5_current_fork_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.418762Z", "completed_at": "2025-12-13T16:37:55.424478Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.425032Z", "completed_at": "2025-12-13T16:37:55.425039Z"}], "thread_id": "Thread-1", "execution_time": 0.0075626373291015625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_discv5_next_fork_daily_date.617d796abf", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_discv5_next_fork_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.427643Z", "completed_at": "2025-12-13T16:37:55.432162Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.432722Z", "completed_at": "2025-12-13T16:37:55.432729Z"}], "thread_id": "Thread-1", "execution_time": 0.006308317184448242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_p2p_discv5_forks_daily_date.71a6724bfb", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_p2p_discv5_forks_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.435451Z", "completed_at": "2025-12-13T16:37:55.439425Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.440033Z", "completed_at": "2025-12-13T16:37:55.440040Z"}], "thread_id": "Thread-1", "execution_time": 0.005892753601074219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_topology_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    protocol,\n    date,\n    peer_discovery_id_prefix,\n    peer_client,\n    peer_city,\n    peer_country,\n    peer_org,\n    peer_lat,\n    peer_lon,\n    neighbor_discovery_id_prefix,\n    neighbor_client,\n    neighbor_city,\n    neighbor_country,\n    neighbor_org,\n    neighbor_lat,\n    neighbor_lon,\n    cnt\nFROM `dbt`.`fct_p2p_topology_latest`\nWHERE peer_lat IS NOT NULL AND neighbor_lat IS NOT NULL\nORDER BY protocol DESC", "relation_name": "`dbt`.`api_p2p_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.442765Z", "completed_at": "2025-12-13T16:37:55.447159Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.447708Z", "completed_at": "2025-12-13T16:37:55.447715Z"}], "thread_id": "Thread-1", "execution_time": 0.006283998489379883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_p2p_topology_latest_date.561982df18", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_p2p_topology_latest`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.450361Z", "completed_at": "2025-12-13T16:37:55.454218Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.454803Z", "completed_at": "2025-12-13T16:37:55.454810Z"}], "thread_id": "Thread-1", "execution_time": 0.0057523250579833984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_rwa_backedfi_prices_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  bticker,\n  date,\n  price         \nFROM `dbt`.`fct_execution_rwa_backedfi_prices_daily`\nORDER BY\n  bticker,\n  date", "relation_name": "`dbt`.`api_execution_rwa_backedfi_prices_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.457674Z", "completed_at": "2025-12-13T16:37:55.463146Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.463736Z", "completed_at": "2025-12-13T16:37:55.463743Z"}], "thread_id": "Thread-1", "execution_time": 0.007486820220947266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_token_prices_daily", "compiled": true, "compiled_code": "\n\nWITH dune AS (\n    SELECT\n        toDate(date)        AS date,\n        upper(symbol)       AS symbol,\n        toFloat64(price)    AS price\n    FROM `dbt`.`stg_crawlers_data__dune_prices`\n    WHERE date < today()\n),\n\nbackedfi AS (\n    SELECT\n        toDate(date)        AS date,\n        upper(bticker)      AS symbol,\n        toFloat64(price)    AS price\n    FROM `dbt`.`fct_execution_rwa_backedfi_prices_daily`\n    WHERE date < today()\n),\n\nwxdai_from_xdai AS (\n    SELECT\n        date,\n        'WXDAI',\n        price\n    FROM dune\n    WHERE symbol = 'XDAI'\n),\n\nagnosdai_from_sdai AS (\n    SELECT\n        date,\n        'AGNOSDAI',\n        price\n    FROM dune\n    WHERE symbol = 'SDAI'\n),\n\nusd_pegs AS (\n    SELECT\n        date,\n        symbol,\n        1.0 AS price\n    FROM (\n        SELECT DISTINCT date FROM dune\n    )\n    ARRAY JOIN ['USDC','USDC.E','USDT'] AS symbol\n)\n\nSELECT date, symbol, price FROM dune\nUNION ALL\nSELECT date, symbol, price FROM backedfi\nUNION ALL\nSELECT * FROM wxdai_from_xdai\nUNION ALL\nSELECT * FROM agnosdai_from_sdai\nUNION ALL\nSELECT date, symbol, price FROM usd_pegs\nORDER BY date, symbol", "relation_name": "`dbt`.`int_execution_token_prices_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.466541Z", "completed_at": "2025-12-13T16:37:55.471067Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.471655Z", "completed_at": "2025-12-13T16:37:55.471662Z"}], "thread_id": "Thread-1", "execution_time": 0.0065343379974365234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_rwa_backedfi_prices_daily_date.99116a3e90", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_execution_rwa_backedfi_prices_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.474350Z", "completed_at": "2025-12-13T16:37:55.479040Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.479643Z", "completed_at": "2025-12-13T16:37:55.479650Z"}], "thread_id": "Thread-1", "execution_time": 0.006551265716552734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_backers_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nbackers_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_backing`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_backing`)\n),\n\nbackers_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_backing`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_backing`), 7)\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM backers_latest t1\nCROSS JOIN backers_7d t2", "relation_name": "`dbt`.`api_execution_circles_backers_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.482296Z", "completed_at": "2025-12-13T16:37:55.486178Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.486765Z", "completed_at": "2025-12-13T16:37:55.486772Z"}], "thread_id": "Thread-1", "execution_time": 0.005729198455810547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_avatars", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,avatar_type\n    ,cnt\n    ,total\nFROM `dbt`.`fct_execution_circles_avatars`\nORDER BY date, avatar_type", "relation_name": "`dbt`.`api_execution_circles_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.489535Z", "completed_at": "2025-12-13T16:37:55.494301Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.494871Z", "completed_at": "2025-12-13T16:37:55.494878Z"}], "thread_id": "Thread-1", "execution_time": 0.0066258907318115234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_groups_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ngroups_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Group'\n),\n\ngroups_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Group'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM groups_latest t1\nCROSS JOIN groups_7d t2", "relation_name": "`dbt`.`api_execution_circles_groups_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.497537Z", "completed_at": "2025-12-13T16:37:55.502286Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.502857Z", "completed_at": "2025-12-13T16:37:55.502864Z"}], "thread_id": "Thread-1", "execution_time": 0.006578922271728516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_humans_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nhumans_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Human'\n),\n\nhumans_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Human'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM humans_latest t1\nCROSS JOIN humans_7d t2", "relation_name": "`dbt`.`api_execution_circles_humans_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.505530Z", "completed_at": "2025-12-13T16:37:55.511568Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.512161Z", "completed_at": "2025-12-13T16:37:55.512168Z"}], "thread_id": "Thread-1", "execution_time": 0.007895469665527344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_orgs_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\norgs_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Org'\n),\n\norgs_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Org'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM orgs_latest t1\nCROSS JOIN orgs_7d t2", "relation_name": "`dbt`.`api_execution_circles_orgs_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.514753Z", "completed_at": "2025-12-13T16:37:55.519194Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.519756Z", "completed_at": "2025-12-13T16:37:55.519763Z"}], "thread_id": "Thread-1", "execution_time": 0.00623774528503418, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_yields_sdai_apy_daily_date.b2bdc5f65c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_yields_sdai_apy_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.522344Z", "completed_at": "2025-12-13T16:37:55.526758Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.527338Z", "completed_at": "2025-12-13T16:37:55.527346Z"}], "thread_id": "Thread-1", "execution_time": 0.0062160491943359375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_tokens_address_diffs_daily_date.42826529da", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_tokens_address_diffs_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.529903Z", "completed_at": "2025-12-13T16:37:55.534332Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.534886Z", "completed_at": "2025-12-13T16:37:55.534893Z"}], "thread_id": "Thread-1", "execution_time": 0.0062520503997802734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_tokens_transfers_daily_date.f914da64d3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_tokens_transfers_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.537617Z", "completed_at": "2025-12-13T16:37:55.541467Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.542044Z", "completed_at": "2025-12-13T16:37:55.542051Z"}], "thread_id": "Thread-1", "execution_time": 0.005764961242675781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_crawlers_data_distinct_projects_sectors_totals", "compiled": true, "compiled_code": "\n\nSELECT\n  toFloat64(countDistinct(project)) AS value1,  \n  toFloat64(countDistinct(sector))  AS value2    \nFROM `dbt`.`fct_crawlers_data_distinct_projects_sectors`", "relation_name": "`dbt`.`api_crawlers_data_distinct_projects_sectors_totals`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.544844Z", "completed_at": "2025-12-13T16:37:55.550596Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.551198Z", "completed_at": "2025-12-13T16:37:55.551205Z"}], "thread_id": "Thread-1", "execution_time": 0.007732391357421875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_crawlers_data_distinct_projects_sectors_project.4a7e81c7b3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect project\nfrom `dbt`.`fct_crawlers_data_distinct_projects_sectors`\nwhere project is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.553799Z", "completed_at": "2025-12-13T16:37:55.558218Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.558772Z", "completed_at": "2025-12-13T16:37:55.558779Z"}], "thread_id": "Thread-1", "execution_time": 0.006209850311279297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_crawlers_data_distinct_projects_sectors_sector.d1a0f36858", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect sector\nfrom `dbt`.`fct_crawlers_data_distinct_projects_sectors`\nwhere sector is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.561448Z", "completed_at": "2025-12-13T16:37:55.565631Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.566230Z", "completed_at": "2025-12-13T16:37:55.566237Z"}], "thread_id": "Thread-1", "execution_time": 0.006050825119018555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_gas_share_by_project_daily", "compiled": true, "compiled_code": "\n\nWITH tot AS (\n  SELECT\n    date,\n    SUM(gas_used_sum) AS day_gas_used\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  WHERE date < today()     \n  GROUP BY date\n)\nSELECT\n  p.date,\n  p.project AS label,\n  ROUND(p.gas_used_sum / NULLIF(t.day_gas_used, 0) * 100, 2) AS value\nFROM `dbt`.`int_execution_transactions_by_project_daily` p\nJOIN tot t USING (date)\nWHERE p.date < today()\nORDER BY p.date DESC, label", "relation_name": "`dbt`.`api_execution_transactions_gas_share_by_project_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.568895Z", "completed_at": "2025-12-13T16:37:55.573304Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.573904Z", "completed_at": "2025-12-13T16:37:55.573911Z"}], "thread_id": "Thread-1", "execution_time": 0.006273746490478516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_project_monthly_top5", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT\n    toStartOfMonth(date)                    AS month,\n    project,\n    sum(tx_count)                           AS txs,\n    sum(fee_native_sum)                     AS fee_native,\n    sum(gas_used_sum)                       AS gas_used,\n    groupBitmapMergeState(ua_bitmap_state)  AS active_state\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  WHERE date < toStartOfMonth(today())          \n  GROUP BY month, project\n),\nranked AS (\n  SELECT\n    month, project, txs, fee_native, gas_used, active_state,\n    row_number() OVER (PARTITION BY month ORDER BY txs DESC, fee_native DESC, project ASC) AS rk\n  FROM base\n),\nbucketed AS (\n  SELECT\n    month,\n    if(rk <= 5, project, 'Others') AS project_label,\n    txs, fee_native, gas_used, active_state\n  FROM ranked\n),\nmonthly AS (\n  SELECT\n    month,\n    project_label AS project,\n    sum(txs)                            AS txs,\n    sum(fee_native)                     AS fee_native,\n    sum(gas_used)                       AS gas_used,\n    groupBitmapMergeState(active_state) AS active_state\n  FROM bucketed\n  GROUP BY month, project_label\n)\n\nSELECT * FROM (\n  SELECT month AS date, project AS label, 'Transactions'  AS metric, toFloat64(txs)                  AS value FROM monthly\n  UNION ALL\n  SELECT month AS date, project AS label, 'FeesNative'    AS metric, round(toFloat64(fee_native), 6) AS value FROM monthly\n  UNION ALL\n  SELECT month AS date, project AS label, 'GasUsed'       AS metric, toFloat64(gas_used)             AS value FROM monthly\n  UNION ALL\n  SELECT\n    month AS date,\n    project AS label,\n    'ActiveAccounts' AS metric,\n    toFloat64(finalizeAggregation(active_state)) AS value\n  FROM monthly\n)\nORDER BY date ASC, label ASC, metric ASC", "relation_name": "`dbt`.`fct_execution_transactions_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.576801Z", "completed_at": "2025-12-13T16:37:55.580796Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.581435Z", "completed_at": "2025-12-13T16:37:55.581442Z"}], "thread_id": "Thread-1", "execution_time": 0.006045818328857422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_sector_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    sector,\n    groupBitmapMerge(ua_bitmap_state)                 AS active_accounts,\n    sum(tx_count)                                     AS txs,\n    sum(gas_used_sum)                                 AS gas_used_sum,\n    round(toFloat64(sum(fee_native_sum)), 6)          AS fee_native_sum\nFROM `dbt`.`int_execution_transactions_by_project_daily`\nGROUP BY\n  date, sector", "relation_name": "`dbt`.`fct_execution_transactions_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.584428Z", "completed_at": "2025-12-13T16:37:55.588471Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.589049Z", "completed_at": "2025-12-13T16:37:55.589056Z"}], "thread_id": "Thread-1", "execution_time": 0.006080150604248047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_sector_weekly", "compiled": true, "compiled_code": "\n\nSELECT\n  toStartOfWeek(date)                          AS week,\n  sector,\n  toUInt64(groupBitmapMerge(ua_bitmap_state))  AS active_accounts,  \n  sum(tx_count)                                AS txs,\n  sum(gas_used_sum)                            AS gas_used_sum,\n  round(toFloat64(sum(fee_native_sum)), 2)     AS fee_native_sum\nFROM `dbt`.`int_execution_transactions_by_project_daily`\nWHERE date < toStartOfWeek(today())            \nGROUP BY week, sector", "relation_name": "`dbt`.`fct_execution_transactions_by_sector_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.591909Z", "completed_at": "2025-12-13T16:37:55.599926Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.600530Z", "completed_at": "2025-12-13T16:37:55.600537Z"}], "thread_id": "Thread-1", "execution_time": 0.010020017623901367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_by_project_alltime_state", "compiled": true, "compiled_code": "\n\n\n\n\nWITH src AS (\n  SELECT\n    toStartOfMonth(date)                   AS month,\n    project,\n    sumState(tx_count)                     AS txs_state,\n    sumState(fee_native_sum)               AS fee_state,\n    groupBitmapMergeState(ua_bitmap_state) AS aa_state\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  WHERE 1=1\n    \n      \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT max(toStartOfMonth(x1.month))\n      FROM `dbt`.`int_execution_transactions_by_project_alltime_state` AS x1\n    )\n    AND toStartOfDay(date) >= (\n      SELECT max(toStartOfDay(x2.month, 'UTC'))\n      FROM `dbt`.`int_execution_transactions_by_project_alltime_state` AS x2\n    )\n  \n\n    \n  GROUP BY month, project\n)\n\nSELECT project, month, txs_state, fee_state, aa_state\nFROM src", "relation_name": "`dbt`.`int_execution_transactions_by_project_alltime_state`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.603392Z", "completed_at": "2025-12-13T16:37:55.607298Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.607888Z", "completed_at": "2025-12-13T16:37:55.607895Z"}], "thread_id": "Thread-1", "execution_time": 0.005927562713623047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_sector_hourly", "compiled": true, "compiled_code": "\n\nSELECT\n  hour AS date,\n  sector AS label,\n  groupBitmapMerge(ua_bitmap_state) AS value\nFROM `dbt`.`int_execution_transactions_by_project_hourly_recent`\nGROUP BY date, label\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_sector_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.610651Z", "completed_at": "2025-12-13T16:37:55.614518Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.615116Z", "completed_at": "2025-12-13T16:37:55.615124Z"}], "thread_id": "Thread-1", "execution_time": 0.005724668502807617, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_sector_hourly", "compiled": true, "compiled_code": "\n\nSELECT\n  hour AS date,\n  sector AS label,\n  sum(tx_count) AS value\nFROM `dbt`.`int_execution_transactions_by_project_hourly_recent`\nGROUP BY date, label\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_sector_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.617948Z", "completed_at": "2025-12-13T16:37:55.621798Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.622404Z", "completed_at": "2025-12-13T16:37:55.622412Z"}], "thread_id": "Thread-1", "execution_time": 0.005833864212036133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_sector_hourly", "compiled": true, "compiled_code": "\n\nSELECT\n  hour AS date,\n  sector AS label,\n  round(toFloat64(sum(fee_native_sum)), 2) AS value\nFROM `dbt`.`int_execution_transactions_by_project_hourly_recent`\nGROUP BY date, label\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_sector_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.625063Z", "completed_at": "2025-12-13T16:37:55.629570Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.630143Z", "completed_at": "2025-12-13T16:37:55.630151Z"}], "thread_id": "Thread-1", "execution_time": 0.006295442581176758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_esg_node_client_distribution_date.7f21d27537", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_esg_node_client_distribution`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.632811Z", "completed_at": "2025-12-13T16:37:55.641179Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.641772Z", "completed_at": "2025-12-13T16:37:55.641779Z"}], "thread_id": "Thread-1", "execution_time": 0.01027059555053711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_dynamic_power_consumption", "compiled": true, "compiled_code": "\n\nWITH node_distribution AS (\n    SELECT\n        date,\n        node_category,\n        country_code,\n        country_name,\n        region,\n        sub_region,\n        country_code_alpha3,\n        estimated_total_nodes,  \n        nodes_lower_95,           \n        nodes_upper_95          \n    FROM `dbt`.`int_esg_node_geographic_distribution` n\n    \n        WHERE n.date > (SELECT MAX(date) FROM `dbt`.`int_esg_dynamic_power_consumption`)\n    \n),\n\n-- Get client efficiency from upstream client distribution model\nclient_efficiency_by_category AS (\n    SELECT\n        date,\n        node_category,\n        \n        -- Weighted average client efficiency for this category\n        SUM(category_client_percentage / 100.0 * client_efficiency_factor) AS avg_client_efficiency,\n        \n        -- Client diversity count for resilience bonus\n        COUNT(DISTINCT client_type) AS client_diversity,\n        \n        -- Total estimated client nodes for validation\n        SUM(estimated_client_nodes) AS total_client_nodes,\n        \n        -- Client breakdown for diagnostics\n        groupArray((client_type, category_client_percentage, estimated_client_nodes)) AS client_breakdown\n        \n    FROM `dbt`.`int_esg_node_client_distribution` ncd\n    \n        WHERE ncd.date > (SELECT MAX(date) FROM `dbt`.`int_esg_dynamic_power_consumption`) - INTERVAL 1 DAY\n    \n    GROUP BY date, node_category\n),\n\n-- Base power calculations by hardware tier with CCRI empirical values\npower_per_category AS (\n    SELECT\n        nd.date,\n        nd.node_category,\n        nd.country_code,\n        nd.country_name,\n        nd.region,\n        nd.sub_region,\n        nd.country_code_alpha3,\n        nd.estimated_total_nodes,\n        nd.nodes_lower_95,\n        nd.nodes_upper_95,\n        \n        -- CCRI empirical power consumption (Watts per node)\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 22.0        -- CCRI Tier 4: mean of 16.56-25.97W\n            WHEN 'professional_operator' THEN 48.0  -- CCRI Tier 5: mean of 36.82-59.95W\n            WHEN 'cloud_hosted' THEN 155.0      -- CCRI Tier 6: mean of 139.90-186.76W\n            ELSE 50.0\n        END AS base_power_watts,\n        \n        -- Standard deviation based on CCRI measurement ranges\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 3.3        -- ~15% of 22W (conservative uncertainty)\n            WHEN 'professional_operator' THEN 7.2  -- ~15% of 48W\n            WHEN 'cloud_hosted' THEN 23.0       -- ~15% of 155W\n            ELSE 7.5\n        END AS power_std_watts,\n        \n        -- Data source for traceability\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 'CCRI_Tier4_Empirical'\n            WHEN 'professional_operator' THEN 'CCRI_Tier5_Empirical'\n            WHEN 'cloud_hosted' THEN 'CCRI_Tier6_Empirical'\n            ELSE 'CCRI_Default'\n        END AS power_source,\n        \n        -- Measurement confidence (CCRI empirical data is high quality)\n        0.85 AS measurement_confidence,\n        \n        -- PUE by category  \n        CASE nd.node_category\n            WHEN 'home_staker' THEN 1.0         -- No datacenter overhead\n            WHEN 'professional_operator' THEN 1.58  -- Traditional datacenter\n            WHEN 'cloud_hosted' THEN 1.15       -- Efficient cloud datacenter\n            ELSE 1.1\n        END AS pue_factor,\n        \n        -- Client efficiency from upstream model\n        COALESCE(ce.avg_client_efficiency, 1.0) AS client_efficiency_multiplier,\n        \n        -- Diversity bonus (more client types = better resilience)\n        CASE \n            WHEN ce.client_diversity > 0 THEN 0.95 + 0.05 * least(4, ce.client_diversity) / 4.0\n            ELSE 1.0\n        END AS diversity_bonus,\n        \n        ce.client_breakdown,\n        ce.total_client_nodes\n        \n    FROM node_distribution nd\n    LEFT JOIN client_efficiency_by_category ce ON nd.date = ce.date AND nd.node_category = ce.node_category\n),\n\n-- Apply all efficiency factors\nfinal_power_calculations AS (\n    SELECT\n        p.*,\n        \n        -- Final power per node with all efficiency factors\n        p.base_power_watts * p.client_efficiency_multiplier * p.diversity_bonus AS avg_power_watts_per_node,\n        p.power_std_watts * p.client_efficiency_multiplier * p.diversity_bonus AS power_std_dev_per_node,\n        \n        -- Daily energy consumption (kWh)\n        p.estimated_total_nodes * \n        p.base_power_watts * \n        p.client_efficiency_multiplier * \n        p.diversity_bonus * \n        24.0 / 1000.0 AS daily_energy_kwh_mean\n\n    FROM power_per_category p\n),\n\n-- Carbon intensity lookup with robust fallback\ncarbon_intensity_lookup AS (\n    SELECT DISTINCT\n        p.date,\n        p.country_code_alpha3,\n        \n        -- Robust fallback hierarchy\n        COALESCE(\n            ci_country.carbon_intensity_mean,\n            ci_world.carbon_intensity_mean,\n            450.0\n        ) AS carbon_intensity_gco2_kwh,\n        \n        COALESCE(\n            ci_country.carbon_intensity_std,\n            ci_world.carbon_intensity_std, \n            45.0\n        ) AS carbon_intensity_std_gco2_kwh,\n        \n        CASE \n            WHEN ci_country.carbon_intensity_mean IS NOT NULL THEN 'country_specific'\n            WHEN ci_world.carbon_intensity_mean IS NOT NULL THEN 'world_average'\n            ELSE 'conservative_default'\n        END AS carbon_intensity_source\n        \n    FROM final_power_calculations p\n    LEFT JOIN `dbt`.`int_esg_carbon_intensity_ensemble` ci_country\n        ON p.country_code_alpha3 = ci_country.country_code\n        AND ci_country.month_date = toStartOfMonth(p.date)\n        AND p.country_code_alpha3 IS NOT NULL\n        AND p.country_code_alpha3 != ''\n    LEFT JOIN `dbt`.`int_esg_carbon_intensity_ensemble` ci_world\n        ON ci_world.country_code = 'WORLD'\n        AND ci_world.month_date = toStartOfMonth(p.date)\n    WHERE ci_country.month_date != DATE '1970-01-01' OR ci_world.month_date != DATE '1970-01-01' -- nu;;s ghet repl;ace by date...\n),\n\n-- Final calculations with carbon emissions\nfinal_calculations AS (\n    SELECT\n        p.date AS date,\n        p.node_category AS node_category,\n        p.country_code AS country_code,\n        p.country_code_alpha3 AS country_code_alpha3,\n        p.country_name AS country_name,\n        p.region AS region,\n        p.sub_region AS sub_region,\n        p.estimated_total_nodes AS estimated_total_nodes,\n        p.nodes_lower_95 AS nodes_lower_95,\n        p.nodes_upper_95 AS nodes_upper_95,\n        p.avg_power_watts_per_node AS avg_power_watts_per_node,\n        p.power_std_dev_per_node AS power_std_dev_per_node,\n        p.daily_energy_kwh_mean AS daily_energy_kwh_mean,\n        p.pue_factor AS pue_factor,\n        p.client_efficiency_multiplier AS client_efficiency,\n        p.diversity_bonus,\n        \n        -- CCRI source tracking\n        p.power_source,\n        p.measurement_confidence,\n        p.base_power_watts AS ccri_base_power_watts,\n        \n        -- Carbon intensity from lookup\n        ci.carbon_intensity_gco2_kwh,\n        ci.carbon_intensity_std_gco2_kwh,\n        ci.carbon_intensity_source,\n        \n        -- CO2 calculations\n        p.daily_energy_kwh_mean * p.pue_factor * ci.carbon_intensity_gco2_kwh / 1000.0 AS daily_co2_kg_mean,\n        \n        -- CO2 standard deviation\n        sqrt(\n            pow(p.daily_energy_kwh_mean * p.pue_factor * ci.carbon_intensity_std_gco2_kwh / 1000.0, 2) +\n            pow(p.power_std_dev_per_node * 24 / 1000.0 * p.pue_factor * ci.carbon_intensity_gco2_kwh / 1000.0, 2)\n        ) AS daily_co2_kg_std,\n        \n        -- Diagnostics\n        p.client_breakdown,\n        p.total_client_nodes\n        \n    FROM final_power_calculations p\n    INNER JOIN carbon_intensity_lookup ci\n        ON p.date = ci.date\n        AND COALESCE(p.country_code_alpha3, '') = COALESCE(ci.country_code_alpha3, '')\n)\n\nSELECT\n    date,\n    node_category,\n    country_code,\n    country_name,\n    region,\n    estimated_total_nodes,\n    nodes_lower_95,\n    nodes_upper_95,\n    \n    -- Power consumption metrics\n    round(avg_power_watts_per_node, 2) AS avg_power_watts_per_node,\n    round(power_std_dev_per_node, 2) AS power_std_dev_per_node,\n    round(daily_energy_kwh_mean, 2) AS daily_energy_kwh_mean,\n    round(pue_factor, 3) AS pue_mean,\n    round(client_efficiency, 3) AS client_efficiency_factor,\n    round(diversity_bonus, 3) AS diversity_bonus,\n    \n    -- Carbon emissions\n    round(daily_co2_kg_mean, 4) AS daily_co2_kg_mean,\n    round(daily_co2_kg_std, 4) AS daily_co2_kg_std,\n    round(carbon_intensity_gco2_kwh, 2) AS carbon_intensity_gco2_kwh,\n    round(carbon_intensity_std_gco2_kwh, 2) AS carbon_intensity_std_gco2_kwh,\n    \n    -- Confidence intervals\n    round(greatest(0, daily_co2_kg_mean - 1.96 * daily_co2_kg_std), 4) AS daily_co2_kg_lower_95,\n    round(daily_co2_kg_mean + 1.96 * daily_co2_kg_std, 4) AS daily_co2_kg_upper_95,\n    \n    -- CCRI data quality and source tracking\n    carbon_intensity_source,\n    round(ccri_base_power_watts, 2) AS ccri_base_power_watts,\n    power_source,\n    round(measurement_confidence, 3) AS measurement_confidence,\n    \n    -- Performance comparison with previous estimates\n    round(\n        100.0 * (avg_power_watts_per_node - CASE node_category\n            WHEN 'home_staker' THEN 75.0\n            WHEN 'professional_operator' THEN 200.0  \n            WHEN 'cloud_hosted' THEN 110.0\n            ELSE 100.0\n        END) / CASE node_category\n            WHEN 'home_staker' THEN 75.0\n            WHEN 'professional_operator' THEN 200.0\n            WHEN 'cloud_hosted' THEN 110.0  \n            ELSE 100.0\n        END, 1\n    ) AS power_reduction_vs_previous_pct,\n    \n    -- Diagnostics\n    toJSONString(client_breakdown) AS client_breakdown_json,\n    total_client_nodes AS debug_total_clients,\n    \n    -- Metadata\n    now() AS calculated_at\n\nFROM final_calculations\nWHERE estimated_total_nodes > 0", "relation_name": "`dbt`.`int_esg_dynamic_power_consumption`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.644428Z", "completed_at": "2025-12-13T16:37:55.650471Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.651027Z", "completed_at": "2025-12-13T16:37:55.651034Z"}], "thread_id": "Thread-1", "execution_time": 0.007932186126708984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_esg_node_geographic_distribution_date.d2db5e6651", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_esg_node_geographic_distribution`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.653633Z", "completed_at": "2025-12-13T16:37:55.658146Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.658706Z", "completed_at": "2025-12-13T16:37:55.658713Z"}], "thread_id": "Thread-1", "execution_time": 0.006287813186645508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_topology_latest_date.dd73c240aa", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_topology_latest`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.661519Z", "completed_at": "2025-12-13T16:37:55.670594Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.671210Z", "completed_at": "2025-12-13T16:37:55.671217Z"}], "thread_id": "Thread-1", "execution_time": 0.010970354080200195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transfers_whitelisted_raw", "compiled": true, "compiled_code": "\n\n\n\n\n\n\nWITH tokens AS (\n    SELECT\n        lower(address)                           AS token_address,      \n        lower(replaceAll(address, '0x', ''))     AS token_address_raw,  \n        decimals,\n        symbol,\n        upper(symbol)                            AS symbol_upper,       \n        date_start,                              \n        date_end                                 \n    FROM `dbt`.`tokens_whitelist`\n),\n\nraw_whitelisted_logs AS (\n    SELECT\n        l.block_number,\n        l.block_timestamp,\n        l.transaction_index,\n        l.log_index,\n        concat('0x', lower(replaceAll(l.transaction_hash, '0x', ''))) AS transaction_hash,\n        t.token_address,\n        t.symbol,\n        t.symbol_upper,\n        t.decimals,\n        t.date_start,\n        t.date_end,\n        lower(concat('0x', substring(l.topic1, 25, 40))) AS \"from\",\n        lower(concat('0x', substring(l.topic2, 25, 40))) AS \"to\",\n        toString(\n            reinterpretAsUInt256(\n                reverse(unhex(replaceAll(l.data, '0x', '')))\n            )\n        ) AS value_raw\n    FROM `dbt`.`stg_execution__logs` AS l\n    INNER JOIN tokens t\n        ON lower(l.address) = t.token_address_raw\n    WHERE\n        lower(replaceAll(l.topic0, '0x', '')) =\n          'ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n        AND l.block_timestamp < today()\n        \n          \n  \n\n        \n        \n),\n\nprices_rwa AS (\n    SELECT\n        toDate(date)             AS date,\n        upper(bticker)           AS symbol_upper,\n        price\n    FROM `dbt`.`api_execution_rwa_backedfi_prices_daily`\n),\n\nprices_dune_raw AS (\n    SELECT\n        date,\n        upper(symbol)            AS symbol_upper,\n        price\n    FROM `dbt`.`stg_crawlers_data__dune_prices`\n),\n\nprices_dune AS (\n    SELECT date, symbol_upper, price\n    FROM prices_dune_raw\n    UNION ALL\n    SELECT date, 'WXDAI' AS symbol_upper, price\n    FROM prices_dune_raw\n    WHERE symbol_upper = 'XDAI'\n),\n\nprices AS (\n    SELECT date, symbol_upper, price FROM prices_rwa\n    UNION ALL\n    SELECT date, symbol_upper, price FROM prices_dune\n),\n\nenriched AS (\n    SELECT\n        r.block_number,\n        r.block_timestamp,\n        r.transaction_index,\n        r.log_index,\n        r.transaction_hash,\n        r.\"from\",\n        r.\"to\",\n        r.token_address,\n        r.symbol,\n        r.symbol_upper,\n        r.decimals,\n        r.value_raw,\n        r.date_start,\n        r.date_end,\n        toFloat64OrZero(r.value_raw) / pow(10, r.decimals) AS amount,\n        coalesce(\n            p.price,\n            case\n              when r.symbol_upper IN ('USDC','USDC.E','USDT') then 1.0\n              when r.symbol_upper = 'WXDAI'                   then 1.0   \n              else null\n            end\n        ) AS price\n    FROM raw_whitelisted_logs r\n    LEFT JOIN prices p\n      ON p.date = toDate(r.block_timestamp)\n     AND p.symbol_upper = r.symbol_upper\n)\n\nSELECT\n    block_number,\n    block_timestamp,\n    transaction_index,\n    log_index,\n    transaction_hash,\n    \"from\",\n    \"to\",\n    token_address,\n    symbol,\n    decimals,\n    amount,\n    price,\n    amount * price AS amount_usd,\n    value_raw\nFROM enriched", "relation_name": "`dbt`.`int_execution_transfers_whitelisted_raw`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.673832Z", "completed_at": "2025-12-13T16:37:55.678276Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.678825Z", "completed_at": "2025-12-13T16:37:55.678833Z"}], "thread_id": "Thread-1", "execution_time": 0.0062139034271240234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_rwa_backedfi_prices_daily_date.1d033684e5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_rwa_backedfi_prices_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.681480Z", "completed_at": "2025-12-13T16:37:55.701917Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.702523Z", "completed_at": "2025-12-13T16:37:55.702530Z"}], "thread_id": "Thread-1", "execution_time": 0.022298336029052734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_tokens_balances_daily", "compiled": true, "compiled_code": "\n\n\n\n\n\n\nWITH deltas AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        address,\n        net_delta_raw\n    FROM `dbt`.`int_execution_tokens_address_diffs_daily`\n    WHERE date < today()\n      \n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_tokens_balances_daily` AS x1\n    )\n    AND toStartOfDay(date) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_tokens_balances_daily` AS x2\n    )\n  \n\n      \n      \n      \n      \n),\n\noverall_max_date AS (\n    SELECT \n        --max(date) AS max_date\n     \n    SELECT max(toDate(date)) FROM `dbt`.`int_execution_tokens_address_diffs_daily`\n     AS max_date\n    FROM deltas\n),\n\n\ncurrent_partition AS (\n    SELECT \n        max(toStartOfMonth(date)) AS month\n        ,max(date)  AS max_date\n    FROM `dbt`.`int_execution_tokens_balances_daily`\n    WHERE 1\n      \n      \n),\nprev_balances AS (\n    SELECT \n        t1.token_address,\n        t1.symbol,\n        t1.token_class,\n        t1.address,\n        t1.balance_raw\n    FROM `dbt`.`int_execution_tokens_balances_daily` t1\n    CROSS JOIN current_partition t2\n    WHERE \n        t1.date = t2.max_date\n        \n        \n),\n\nkeys AS (\n    SELECT DISTINCT \n        token_address,\n        symbol,\n        token_class,\n        address\n    FROM (\n        SELECT\n            token_address,\n            symbol,\n            token_class,\n            address\n        FROM prev_balances\n\n        UNION ALL\n\n        SELECT\n            token_address,\n            symbol,\n            token_class,\n            address\n        FROM deltas\n    )\n),\n\ncalendar AS (\n    SELECT\n        k.token_address,\n        k.symbol,\n        k.token_class,\n        k.address,\n        addDays(cp.max_date + 1, offset) AS date\n    FROM keys k\n    CROSS JOIN current_partition cp\n    CROSS JOIN overall_max_date o\n    ARRAY JOIN range(\n        dateDiff('day', cp.max_date, o.max_date)\n    ) AS offset\n),\n\n\n\n\nbalances AS (\n    SELECT\n        c.date AS date,\n        c.token_address AS token_address,\n        c.symbol AS symbol,\n        c.token_class AS token_class,\n        c.address AS address,\n\n        sum(COALESCE(d.net_delta_raw,toInt256(0))) OVER (\n            PARTITION BY c.token_address, c.address\n            ORDER BY c.date\n            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        )\n        \n            + coalesce(p.balance_raw, toInt256(0)) \n        \n        AS balance_raw\n    FROM calendar c\n    LEFT JOIN deltas d\n      ON d.token_address = c.token_address\n     AND d.address       = c.address\n     AND d.date          = c.date\n    \n    LEFT JOIN prev_balances p\n      ON p.token_address = c.token_address\n     AND p.address       = c.address\n    \n),\n\nprices AS (\n    SELECT\n        p.date\n        ,p.symbol\n        ,t.decimals\n        ,p.price\n    FROM `dbt`.`int_execution_token_prices_daily` p\n    INNER JOIN `dbt`.`tokens_whitelist` t\n        ON upper(p.symbol) = upper(t.symbol)\n    WHERE date < today()\n      \n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT max(toStartOfMonth(x1.date))\n      FROM `dbt`.`int_execution_tokens_balances_daily` AS x1\n    )\n    AND toStartOfDay(date) >= (\n      SELECT max(toStartOfDay(x2.date, 'UTC'))\n      FROM `dbt`.`int_execution_tokens_balances_daily` AS x2\n    )\n  \n\n      \n      \n      \n),\n\nfinal AS (\n    SELECT\n        b.date AS date,\n        b.token_address AS token_address,\n        b.symbol AS symbol,\n        b.token_class AS token_class,\n        b.address AS address,\n        b.balance_raw AS balance_raw,\n        b.balance_raw/POWER(10,p.decimals) AS balance,\n        balance * p.price AS balance_usd\n    FROM balances b\n    LEFT JOIN prices p\n      ON p.date = b.date\n     AND upper(p.symbol) = upper(b.symbol)\n    WHERE b.balance_raw != 0\n)\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n    address,\n    balance_raw,\n    balance,\n    balance_usd\nFROM final", "relation_name": "`dbt`.`int_execution_tokens_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.705522Z", "completed_at": "2025-12-13T16:37:55.711316Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.711881Z", "completed_at": "2025-12-13T16:37:55.711889Z"}], "thread_id": "Thread-1", "execution_time": 0.007668018341064453, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_token_prices_daily_date.46ea825600", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_token_prices_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.714460Z", "completed_at": "2025-12-13T16:37:55.718985Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.719587Z", "completed_at": "2025-12-13T16:37:55.719594Z"}], "thread_id": "Thread-1", "execution_time": 0.0063550472259521484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_circles_avatars_date.458ccb6f09", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_circles_avatars`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.722208Z", "completed_at": "2025-12-13T16:37:55.726868Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.727444Z", "completed_at": "2025-12-13T16:37:55.727452Z"}], "thread_id": "Thread-1", "execution_time": 0.006486177444458008, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_crawlers_data_distinct_projects_sectors_totals_value1.058dcfb0ef", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect value1\nfrom `dbt`.`api_crawlers_data_distinct_projects_sectors_totals`\nwhere value1 is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.730140Z", "completed_at": "2025-12-13T16:37:55.734763Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.735340Z", "completed_at": "2025-12-13T16:37:55.735348Z"}], "thread_id": "Thread-1", "execution_time": 0.006556510925292969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_crawlers_data_distinct_projects_sectors_totals_value2.08f4d1c65b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect value2\nfrom `dbt`.`api_crawlers_data_distinct_projects_sectors_totals`\nwhere value2 is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.737902Z", "completed_at": "2025-12-13T16:37:55.742566Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.743140Z", "completed_at": "2025-12-13T16:37:55.743147Z"}], "thread_id": "Thread-1", "execution_time": 0.006468772888183594, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_gas_share_by_project_daily_date.9a0f9c0df3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_gas_share_by_project_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.745811Z", "completed_at": "2025-12-13T16:37:55.750770Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.751379Z", "completed_at": "2025-12-13T16:37:55.751386Z"}], "thread_id": "Thread-1", "execution_time": 0.006903886795043945, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_project_monthly_top5", "compiled": true, "compiled_code": "\nSELECT\n  date,\n  label,\n  value\nFROM `dbt`.`fct_execution_transactions_by_project_monthly_top5`\nWHERE metric = 'ActiveAccounts'\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.754133Z", "completed_at": "2025-12-13T16:37:55.758019Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.758622Z", "completed_at": "2025-12-13T16:37:55.758630Z"}], "thread_id": "Thread-1", "execution_time": 0.005778789520263672, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_project_monthly_top5", "compiled": true, "compiled_code": "\nSELECT\n  date,\n  label,\n  value\nFROM `dbt`.`fct_execution_transactions_by_project_monthly_top5`\nWHERE metric = 'Transactions'\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.761418Z", "completed_at": "2025-12-13T16:37:55.765358Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.765948Z", "completed_at": "2025-12-13T16:37:55.765954Z"}], "thread_id": "Thread-1", "execution_time": 0.0058820247650146484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_project_monthly_top5", "compiled": true, "compiled_code": "\nSELECT\n  date,\n  label,\n  value\nFROM `dbt`.`fct_execution_transactions_by_project_monthly_top5`\nWHERE metric = 'FeesNative'\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.768700Z", "completed_at": "2025-12-13T16:37:55.772573Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.773167Z", "completed_at": "2025-12-13T16:37:55.773174Z"}], "thread_id": "Thread-1", "execution_time": 0.005718708038330078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_sector_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  sector AS label,\n  active_accounts AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_daily`\nWHERE date < today()\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.775915Z", "completed_at": "2025-12-13T16:37:55.779797Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.780415Z", "completed_at": "2025-12-13T16:37:55.780422Z"}], "thread_id": "Thread-1", "execution_time": 0.005773067474365234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_sector_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  sector AS label,\n  txs AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_daily`\nWHERE date < today()\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.783166Z", "completed_at": "2025-12-13T16:37:55.787057Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.787661Z", "completed_at": "2025-12-13T16:37:55.787668Z"}], "thread_id": "Thread-1", "execution_time": 0.005765438079833984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_sector_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  sector AS label,\n  fee_native_sum AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_daily`\nWHERE date < today()\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.790445Z", "completed_at": "2025-12-13T16:37:55.796144Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.796703Z", "completed_at": "2025-12-13T16:37:55.796710Z"}], "thread_id": "Thread-1", "execution_time": 0.007550716400146484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_transactions_by_sector_daily_date.cf19023a9f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_execution_transactions_by_sector_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.799360Z", "completed_at": "2025-12-13T16:37:55.803267Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.803852Z", "completed_at": "2025-12-13T16:37:55.803859Z"}], "thread_id": "Thread-1", "execution_time": 0.005753278732299805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_sector_weekly", "compiled": true, "compiled_code": "\n\nSELECT\n  week AS date,\n  sector AS label,\n  active_accounts AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_weekly`\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_sector_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.806664Z", "completed_at": "2025-12-13T16:37:55.810521Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.811122Z", "completed_at": "2025-12-13T16:37:55.811130Z"}], "thread_id": "Thread-1", "execution_time": 0.005769252777099609, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_sector_weekly", "compiled": true, "compiled_code": "\n\nSELECT\n  week AS date,\n  sector AS label,\n  txs AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_weekly`\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_sector_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.813873Z", "completed_at": "2025-12-13T16:37:55.817808Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.818413Z", "completed_at": "2025-12-13T16:37:55.818420Z"}], "thread_id": "Thread-1", "execution_time": 0.005817413330078125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_sector_weekly", "compiled": true, "compiled_code": "\n\nSELECT\n  week AS date,\n  sector AS label,\n  fee_native_sum AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_weekly`\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_sector_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.821150Z", "completed_at": "2025-12-13T16:37:55.826078Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.826673Z", "completed_at": "2025-12-13T16:37:55.826680Z"}], "thread_id": "Thread-1", "execution_time": 0.006796121597290039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_project_snapshots", "compiled": true, "compiled_code": "\n\nWITH wd AS (\n  SELECT max(date) AS max_date\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n),\nrng AS (\n  SELECT '1D'  AS window,  1  AS days UNION ALL\n  SELECT '7D'  AS window,  7  AS days UNION ALL\n  SELECT '30D' AS window,  30 AS days UNION ALL\n  SELECT '90D' AS window,  90 AS days\n),\nbounds AS (\n  SELECT\n    r.window,\n    r.days,\n    w.max_date,\n    subtractDays(w.max_date, r.days)        AS curr_start,\n    w.max_date                              AS curr_end,\n    subtractDays(w.max_date, 2 * r.days)    AS prev_start,\n    subtractDays(w.max_date, r.days)        AS prev_end\n  FROM rng r\n  CROSS JOIN wd w\n),\n\ncurr_win AS (\n  SELECT\n    b.window,\n    d.project,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.curr_start\n   AND d.date <= b.curr_end\n  GROUP BY b.window, d.project\n),\nprev_win AS (\n  SELECT\n    b.window,\n    d.project,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.prev_start\n   AND d.date <= b.prev_end\n  GROUP BY b.window, d.project\n),\n\n/* all-time from AMT */\ncurr_all AS (\n  SELECT\n    'All' AS window,\n    a.project,\n    sumMerge(a.txs_state)             AS txs,\n    sumMerge(a.fee_state)             AS fee_native,\n    groupBitmapMerge(a.aa_state)      AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_alltime_state` a\n  GROUP BY a.project\n),\n\njoined AS (\n  SELECT\n    c.window,\n    c.project,\n    c.txs        AS txs_curr,\n    p.txs        AS txs_prev,\n    c.fee_native AS fee_curr,\n    p.fee_native AS fee_prev,\n    c.aa_uniques AS aa_curr,\n    p.aa_uniques AS aa_prev\n  FROM curr_win c\n  LEFT JOIN prev_win p\n    ON p.window = c.window AND p.project = c.project\n),\n\nall_windows AS (\n  SELECT window, project, txs, fee_native, aa_uniques FROM curr_win\n  UNION ALL\n  SELECT window, project, txs, fee_native, aa_uniques FROM curr_all\n)\n\nSELECT\n  'Transactions'            AS label,\n  w.window                  AS window,\n  w.project                 AS bucket,\n  toFloat64(w.txs)          AS value,\n  multiIf(\n    w.window = 'All', NULL,\n    round((coalesce(j.txs_curr / nullIf(j.txs_prev, 0), 0) - 1) * 100, 1)\n  )                         AS change_pct\nFROM all_windows w\nLEFT JOIN joined j\n  ON j.window = w.window AND j.project = w.project\n\nUNION ALL\nSELECT\n  'FeesNative',\n  w.window,\n  w.project,\n  round(toFloat64(w.fee_native), 6),\n  multiIf(\n    w.window = 'All', NULL,\n    round((coalesce(j.fee_curr / nullIf(j.fee_prev, 0), 0) - 1) * 100, 1)\n  )\nFROM all_windows w\nLEFT JOIN joined j\n  ON j.window = w.window AND j.project = w.project\n\nUNION ALL\nSELECT\n  'ActiveAccounts',\n  w.window,\n  w.project,\n  toFloat64(w.aa_uniques),\n  multiIf(\n    w.window = 'All', NULL,\n    round((coalesce(j.aa_curr / nullIf(j.aa_prev, 0), 0) - 1) * 100, 1)\n  )\nFROM all_windows w\nLEFT JOIN joined j\n  ON j.window = w.window AND j.project = w.project", "relation_name": "`dbt`.`fct_execution_transactions_by_project_snapshots`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.829456Z", "completed_at": "2025-12-13T16:37:55.834517Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.835137Z", "completed_at": "2025-12-13T16:37:55.835145Z"}], "thread_id": "Thread-1", "execution_time": 0.0070192813873291016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_snapshots", "compiled": true, "compiled_code": "\n\nWITH wd AS (\n  SELECT max(date) AS max_date\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n),\nrng AS (\n  SELECT '1D'  AS window,  1  AS days UNION ALL\n  SELECT '7D'  AS window,  7  AS days UNION ALL\n  SELECT '30D' AS window,  30 AS days UNION ALL\n  SELECT '90D' AS window,  90 AS days\n),\nbounds AS (\n  SELECT\n    r.window,\n    r.days,\n    w.max_date,\n    subtractDays(w.max_date, r.days)        AS curr_start,\n    w.max_date                              AS curr_end,\n    subtractDays(w.max_date, 2 * r.days)    AS prev_start,\n    subtractDays(w.max_date, r.days)        AS prev_end\n  FROM rng r\n  CROSS JOIN wd w\n),\n\ncurr_win AS (\n  SELECT\n    b.window,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.curr_start\n   AND d.date <= b.curr_end\n  GROUP BY b.window\n),\nprev_win AS (\n  SELECT\n    b.window,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.prev_start\n   AND d.date <= b.prev_end\n  GROUP BY b.window\n),\n\ncurr_all AS (\n  SELECT\n    'All' AS window,\n    sumMerge(a.txs_state)           AS txs,\n    sumMerge(a.fee_state)           AS fee_native,\n    groupBitmapMerge(a.aa_state)    AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_alltime_state` a\n),\n\ncurr AS (\n  SELECT * FROM curr_win\n  UNION ALL\n  SELECT * FROM curr_all\n)\n\nSELECT\n  'Transactions'            AS label,\n  c.window                  AS window,\n  toFloat64(c.txs)          AS value,\n  CASE\n    WHEN c.window = 'All' THEN NULL\n    ELSE round((coalesce(c.txs / nullIf(p.txs, 0), 0) - 1) * 100, 1)\n  END AS change_pct\nFROM curr c\nLEFT JOIN prev_win p ON p.window = c.window\n\nUNION ALL\nSELECT\n  'FeesNative',\n  c.window,\n  round(toFloat64(c.fee_native), 6),\n  CASE\n    WHEN c.window = 'All' THEN NULL\n    ELSE round((coalesce(c.fee_native / nullIf(p.fee_native, 0), 0) - 1) * 100, 1)\n  END\nFROM curr c\nLEFT JOIN prev_win p ON p.window = c.window\n\nUNION ALL\nSELECT\n  'ActiveAccounts',\n  c.window,\n  toFloat64(c.aa_uniques),\n  CASE\n    WHEN c.window = 'All' THEN NULL\n    ELSE round((coalesce(c.aa_uniques / nullIf(p.aa_uniques, 0), 0) - 1) * 100, 1)\n  END\nFROM curr c\nLEFT JOIN prev_win p ON p.window = c.window", "relation_name": "`dbt`.`fct_execution_transactions_snapshots`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.837828Z", "completed_at": "2025-12-13T16:37:55.844001Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.844596Z", "completed_at": "2025-12-13T16:37:55.844603Z"}], "thread_id": "Thread-1", "execution_time": 0.008101224899291992, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_sector_hourly_date.e77654a051", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_active_accounts_by_sector_hourly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.847206Z", "completed_at": "2025-12-13T16:37:55.851651Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.852232Z", "completed_at": "2025-12-13T16:37:55.852239Z"}], "thread_id": "Thread-1", "execution_time": 0.006334781646728516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_sector_hourly_date.d5137ceba4", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_by_sector_hourly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.854800Z", "completed_at": "2025-12-13T16:37:55.859507Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.860070Z", "completed_at": "2025-12-13T16:37:55.860077Z"}], "thread_id": "Thread-1", "execution_time": 0.006518125534057617, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_fees_native_by_sector_hourly_date.6d9e2316bf", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_fees_native_by_sector_hourly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.862750Z", "completed_at": "2025-12-13T16:37:55.871320Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.871932Z", "completed_at": "2025-12-13T16:37:55.871940Z"}], "thread_id": "Thread-1", "execution_time": 0.010456323623657227, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_esg_carbon_footprint_uncertainty", "compiled": true, "compiled_code": "\n\nWITH node_country_distribution AS (\n    -- Get node distribution by country and category with their carbon intensities\n    SELECT\n        date,\n        node_category,\n        country_code,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        carbon_intensity_gco2_kwh,\n        daily_energy_kwh_mean,\n        avg_power_watts_per_node,\n        power_std_dev_per_node,\n        daily_co2_kg_mean,\n        daily_co2_kg_std\n    FROM `dbt`.`int_esg_dynamic_power_consumption`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`)\n    \n),\n\n-- Calculate network effective CIF from geographic distribution\nnetwork_effective_cif AS (\n    SELECT\n        date,\n        -- Network Effective CIF = \u03a3(nodes_in_country \u00d7 country_CIF) / total_nodes\n        SUM(estimated_total_nodes * carbon_intensity_gco2_kwh) / \n        NULLIF(SUM(estimated_total_nodes), 0) AS network_weighted_cif,\n        \n        -- Weighted standard deviation of network CIF\n        -- Using variance formula: Var = \u03a3(w_i * (x_i - mean)\u00b2) / \u03a3(w_i)\n        -- Then std = sqrt(var)\n        SQRT(\n            SUM(estimated_total_nodes * pow(carbon_intensity_gco2_kwh, 2)) / NULLIF(SUM(estimated_total_nodes), 0) -\n            pow(SUM(estimated_total_nodes * carbon_intensity_gco2_kwh) / NULLIF(SUM(estimated_total_nodes), 0), 2)\n        ) AS network_cif_std\n    FROM node_country_distribution\n    GROUP BY date\n),\n\ndaily_power_data AS (\n    -- Aggregate power consumption across all categories and countries\n    SELECT\n        date,\n        node_category,\n        \n        -- Node counts with uncertainty\n        SUM(estimated_total_nodes) AS category_nodes,\n        SUM(nodes_lower_95) AS category_nodes_lower_95,\n        SUM(nodes_upper_95) AS category_nodes_upper_95,\n        \n        -- Energy totals with uncertainty calculation\n        SUM(daily_energy_kwh_mean) AS category_energy_kwh_mean,\n        \n        -- Energy standard deviation (propagate uncertainty from power and node count)\n        SQRT(SUM(\n            pow(power_std_dev_per_node * estimated_total_nodes * 24 / 1000.0, 2) + \n            pow(avg_power_watts_per_node * (nodes_upper_95 - nodes_lower_95) / 3.92 * 24 / 1000.0, 2)\n        )) AS category_energy_kwh_std,\n        \n        -- Carbon totals\n        SUM(daily_co2_kg_mean) AS category_co2_kg,\n        SQRT(SUM(pow(daily_co2_kg_std, 2))) AS category_co2_kg_std,\n        \n        -- Weighted averages\n        SUM(daily_energy_kwh_mean * estimated_total_nodes) / NULLIF(SUM(estimated_total_nodes), 0) AS weighted_avg_energy_per_node,\n        SUM(daily_co2_kg_mean * estimated_total_nodes) / NULLIF(SUM(estimated_total_nodes), 0) AS weighted_avg_co2_per_node,\n        \n        -- Country count for this category\n        COUNT(DISTINCT country_code) AS countries_represented\n        \n    FROM node_country_distribution\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`)\n    \n    GROUP BY date, node_category\n),\n\nnetwork_totals AS (\n    -- Calculate network-wide totals with full uncertainty propagation\n    SELECT\n        date,\n        \n        -- Total network size with bounds\n        SUM(category_nodes) AS total_estimated_nodes,\n        SUM(category_nodes_lower_95) AS total_nodes_lower_95,\n        SUM(category_nodes_upper_95) AS total_nodes_upper_95,\n        \n        -- Total energy consumption with uncertainty\n        SUM(category_energy_kwh_mean) AS total_energy_kwh_mean,\n        SQRT(SUM(pow(category_energy_kwh_std, 2))) AS total_energy_kwh_std,\n        \n        -- Total emissions with error propagation\n        SUM(category_co2_kg) AS total_co2_kg_mean,\n        SQRT(SUM(pow(category_co2_kg_std, 2))) AS total_co2_kg_std,\n        \n        -- Category breakdown for energy\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_energy_kwh_mean ELSE 0 END) AS home_staker_energy_kwh,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_energy_kwh_mean ELSE 0 END) AS professional_energy_kwh,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_energy_kwh_mean ELSE 0 END) AS cloud_energy_kwh,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_energy_kwh_mean ELSE 0 END) AS unknown_energy_kwh,\n        \n        -- Category breakdown for carbon\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_co2_kg ELSE 0 END) AS home_staker_co2_kg,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_co2_kg ELSE 0 END) AS professional_co2_kg,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_co2_kg ELSE 0 END) AS cloud_co2_kg,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_co2_kg ELSE 0 END) AS unknown_co2_kg,\n        \n        -- Node breakdown\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_nodes ELSE 0 END) AS home_staker_nodes,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_nodes ELSE 0 END) AS professional_nodes,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_nodes ELSE 0 END) AS cloud_nodes,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_nodes ELSE 0 END) AS unknown_nodes,\n        \n        -- Quality metrics\n        COUNT(DISTINCT CASE WHEN category_nodes > 0 THEN node_category END) AS active_categories,\n        MAX(countries_represented) AS max_countries_in_category\n        \n    FROM daily_power_data\n    GROUP BY date\n),\n\n-- Add Chao-1 population estimates for comparison\nchao1_comparison AS (\n    SELECT\n        nt.date AS date,\n        nt.*,\n        necif.network_weighted_cif,\n        necif.network_cif_std,\n        \n        -- Link to Chao-1 estimates\n        c.observed_successful_nodes AS chao1_observed,\n        c.enhanced_total_reachable AS chao1_estimated,\n        c.connection_success_rate_pct AS chao1_success_rate,\n        c.reachable_discovery_coverage_pct AS chao1_coverage,\n        \n        -- Compare our estimates to Chao-1\n        round(100.0 * nt.total_estimated_nodes / NULLIF(c.enhanced_total_reachable, 0), 1) AS node_estimate_vs_chao1_pct,\n        \n        -- Calculate scaling factor applied\n        round(toFloat64(nt.total_estimated_nodes) / NULLIF(c.observed_successful_nodes, 0), 2) AS applied_scaling_factor\n        \n    FROM network_totals nt\n    JOIN network_effective_cif necif ON nt.date = necif.date\n    LEFT JOIN `dbt`.`int_esg_node_population_chao1` c\n        ON c.observation_date = nt.date\n),\n\nenhanced_statistics AS (\n    SELECT\n        date,\n        \n        -- Node population metrics with bounds\n        total_estimated_nodes,\n        total_nodes_lower_95,\n        total_nodes_upper_95,\n        chao1_observed,\n        chao1_estimated,\n        chao1_success_rate,\n        chao1_coverage,\n        node_estimate_vs_chao1_pct,\n        applied_scaling_factor,\n        \n        -- Network carbon intensity with uncertainty\n        round(network_weighted_cif, 2) AS network_carbon_intensity_gco2_kwh,\n        round(network_cif_std, 2) AS network_carbon_intensity_std,\n        \n        -- Daily energy metrics with full uncertainty bands\n        round(total_energy_kwh_mean, 2) AS daily_energy_kwh_mean,\n        round(total_energy_kwh_std, 2) AS daily_energy_kwh_std,\n        \n        -- Daily energy confidence intervals (95%)\n        round(greatest(0, total_energy_kwh_mean - 1.96 * total_energy_kwh_std), 2) AS daily_energy_kwh_lower_95,\n        round(total_energy_kwh_mean + 1.96 * total_energy_kwh_std, 2) AS daily_energy_kwh_upper_95,\n        \n        -- Daily energy confidence intervals (90%)\n        round(greatest(0, total_energy_kwh_mean - 1.645 * total_energy_kwh_std), 2) AS daily_energy_kwh_lower_90,\n        round(total_energy_kwh_mean + 1.645 * total_energy_kwh_std, 2) AS daily_energy_kwh_upper_90,\n        \n        -- Annual energy projections with uncertainty\n        round(total_energy_kwh_mean * 365 / 1000, 2) AS annual_energy_mwh_mean,\n        round(total_energy_kwh_std * sqrt(365) / 1000, 2) AS annual_energy_mwh_std,\n        \n        -- Annual energy confidence intervals (95%)\n        round(greatest(0, (total_energy_kwh_mean * 365 / 1000) - 1.96 * (total_energy_kwh_std * sqrt(365) / 1000)), 2) AS annual_energy_mwh_lower_95,\n        round((total_energy_kwh_mean * 365 / 1000) + 1.96 * (total_energy_kwh_std * sqrt(365) / 1000), 2) AS annual_energy_mwh_upper_95,\n        \n        -- Annual energy confidence intervals (90%)\n        round(greatest(0, (total_energy_kwh_mean * 365 / 1000) - 1.645 * (total_energy_kwh_std * sqrt(365) / 1000)), 2) AS annual_energy_mwh_lower_90,\n        round((total_energy_kwh_mean * 365 / 1000) + 1.645 * (total_energy_kwh_std * sqrt(365) / 1000), 2) AS annual_energy_mwh_upper_90,\n        \n        -- Carbon emissions (primary metrics)\n        round(total_co2_kg_mean, 2) AS daily_co2_kg_mean,\n        round(total_co2_kg_std, 2) AS daily_co2_kg_std,\n        \n        -- Daily CO2 confidence intervals (95%)\n        round(greatest(0, total_co2_kg_mean - 1.96 * total_co2_kg_std), 2) AS daily_co2_kg_lower_95,\n        round(total_co2_kg_mean + 1.96 * total_co2_kg_std, 2) AS daily_co2_kg_upper_95,\n        \n        -- Daily CO2 confidence intervals (90%)\n        round(greatest(0, total_co2_kg_mean - 1.645 * total_co2_kg_std), 2) AS daily_co2_kg_lower_90,\n        round(total_co2_kg_mean + 1.645 * total_co2_kg_std, 2) AS daily_co2_kg_upper_90,\n        \n        -- Annual CO2 projections\n        round(total_co2_kg_mean * 365 / 1000, 2) AS annual_co2_tonnes_mean,\n        round(total_co2_kg_std * sqrt(365) / 1000, 2) AS annual_co2_tonnes_std,\n        \n        -- Category breakdowns for energy\n        round(home_staker_energy_kwh, 2) AS home_staker_energy_kwh_daily,\n        round(professional_energy_kwh, 2) AS professional_energy_kwh_daily,\n        round(cloud_energy_kwh, 2) AS cloud_energy_kwh_daily,\n        round(unknown_energy_kwh, 2) AS unknown_energy_kwh_daily,\n        \n        -- Category breakdowns for carbon\n        round(home_staker_co2_kg, 2) AS home_staker_co2_kg_daily,\n        round(professional_co2_kg, 2) AS professional_co2_kg_daily,\n        round(cloud_co2_kg, 2) AS cloud_co2_kg_daily,\n        round(unknown_co2_kg, 2) AS unknown_co2_kg_daily,\n        \n        -- Category percentages\n        round(100.0 * home_staker_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS home_staker_pct,\n        round(100.0 * professional_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS professional_pct,\n        round(100.0 * cloud_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS cloud_pct,\n        \n        -- Node distribution\n        home_staker_nodes,\n        professional_nodes,\n        cloud_nodes,\n        unknown_nodes,\n        \n        -- Relative uncertainties\n        round(100.0 * total_energy_kwh_std / NULLIF(total_energy_kwh_mean, 0), 1) AS energy_relative_uncertainty_pct,\n        round(100.0 * total_co2_kg_std / NULLIF(total_co2_kg_mean, 0), 1) AS carbon_relative_uncertainty_pct,\n        \n        -- Quality metrics\n        active_categories,\n        max_countries_in_category AS countries_with_nodes\n        \n    FROM chao1_comparison\n)\n\nSELECT\n    date,\n    \n    -- PRIMARY CARBON FOOTPRINT METRICS WITH BANDS\n    daily_co2_kg_mean,\n    daily_co2_kg_std,\n    daily_co2_kg_lower_95,\n    daily_co2_kg_upper_95,\n    daily_co2_kg_lower_90,\n    daily_co2_kg_upper_90,\n    \n    -- Annual CO2 projections with uncertainty bands\n    annual_co2_tonnes_mean AS annual_co2_tonnes_projected,\n    annual_co2_tonnes_std,\n    round(greatest(0, annual_co2_tonnes_mean - 1.96 * annual_co2_tonnes_std), 2) AS annual_co2_tonnes_lower_95,\n    round(annual_co2_tonnes_mean + 1.96 * annual_co2_tonnes_std, 2) AS annual_co2_tonnes_upper_95,\n    round(greatest(0, annual_co2_tonnes_mean - 1.645 * annual_co2_tonnes_std), 2) AS annual_co2_tonnes_lower_90,\n    round(annual_co2_tonnes_mean + 1.645 * annual_co2_tonnes_std, 2) AS annual_co2_tonnes_upper_90,\n    \n    -- PRIMARY ENERGY METRICS WITH BANDS\n    daily_energy_kwh_mean AS daily_energy_kwh_total,\n    daily_energy_kwh_std,\n    daily_energy_kwh_lower_95,\n    daily_energy_kwh_upper_95,\n    daily_energy_kwh_lower_90,\n    daily_energy_kwh_upper_90,\n    \n    -- Annual energy projections with uncertainty bands\n    annual_energy_mwh_mean AS annual_energy_Mwh_projected,\n    annual_energy_mwh_std,\n    annual_energy_mwh_lower_95,\n    annual_energy_mwh_upper_95,\n    annual_energy_mwh_lower_90,\n    annual_energy_mwh_upper_90,\n    \n    -- NETWORK CARBON INTENSITY WITH UNCERTAINTY\n    network_carbon_intensity_gco2_kwh AS effective_carbon_intensity,\n    network_carbon_intensity_std AS effective_carbon_intensity_std,\n    round(greatest(0, network_carbon_intensity_gco2_kwh - 1.96 * network_carbon_intensity_std), 2) AS effective_carbon_intensity_lower_95,\n    round(network_carbon_intensity_gco2_kwh + 1.96 * network_carbon_intensity_std, 2) AS effective_carbon_intensity_upper_95,\n    \n    -- NODE POPULATION WITH BOUNDS\n    total_estimated_nodes AS estimated_nodes,\n    total_nodes_lower_95 AS nodes_lower_95,\n    total_nodes_upper_95 AS nodes_upper_95,\n    \n    -- Category breakdown for energy (daily)\n    home_staker_energy_kwh_daily,\n    professional_energy_kwh_daily,\n    cloud_energy_kwh_daily,\n    unknown_energy_kwh_daily,\n    \n    -- Category breakdown for emissions (daily)\n    home_staker_co2_kg_daily,\n    professional_co2_kg_daily,\n    cloud_co2_kg_daily,\n    unknown_co2_kg_daily,\n    \n    -- Category percentages\n    home_staker_pct,\n    professional_pct,\n    cloud_pct,\n    \n    -- Node distribution by category\n    home_staker_nodes,\n    professional_nodes,\n    cloud_nodes,\n    unknown_nodes,\n    \n    -- UNCERTAINTY METRICS\n    energy_relative_uncertainty_pct,\n    carbon_relative_uncertainty_pct,\n    \n    -- Quality metrics\n    active_categories AS node_categories_active,\n    countries_with_nodes,\n    \n    -- Comparison with Chao-1 estimates\n    chao1_observed AS baseline_observed_nodes,\n    chao1_estimated AS chao1_total_estimated,\n    node_estimate_vs_chao1_pct,\n    applied_scaling_factor,\n    round(chao1_success_rate, 1) AS network_reachability_pct,\n    round(chao1_coverage, 1) AS discovery_completeness_pct,\n    \n    -- PER-NODE METRICS WITH BOUNDS\n    round(daily_co2_kg_mean / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS grams_co2_per_node_daily,\n    round(daily_energy_kwh_mean / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS wh_per_node_daily,\n    \n    -- Per-node uncertainty bands\n    round(greatest(0, (daily_co2_kg_mean - 1.96 * daily_co2_kg_std) / NULLIF(total_estimated_nodes, 0) * 1000), 1) AS grams_co2_per_node_lower_95,\n    round((daily_co2_kg_mean + 1.96 * daily_co2_kg_std) / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS grams_co2_per_node_upper_95,\n    \n    round(greatest(0, (daily_energy_kwh_mean - 1.96 * daily_energy_kwh_std) / NULLIF(total_estimated_nodes, 0) * 1000), 1) AS wh_per_node_lower_95,\n    round((daily_energy_kwh_mean + 1.96 * daily_energy_kwh_std) / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS wh_per_node_upper_95\n    \nFROM enhanced_statistics\nORDER BY date DESC", "relation_name": "`dbt`.`fct_esg_carbon_footprint_uncertainty`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.874711Z", "completed_at": "2025-12-13T16:37:55.879453Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.880038Z", "completed_at": "2025-12-13T16:37:55.880045Z"}], "thread_id": "Thread-1", "execution_time": 0.00666046142578125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_esg_dynamic_power_consumption_date.d15537ff08", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_esg_dynamic_power_consumption`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.882734Z", "completed_at": "2025-12-13T16:37:55.895198Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.895799Z", "completed_at": "2025-12-13T16:37:55.895806Z"}], "thread_id": "Thread-1", "execution_time": 0.014328241348266602, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_tokens_balance_cohorts_daily", "compiled": true, "compiled_code": "\n\n\n\n\n\n\nWITH\n\nbalances_filtered AS (\n    SELECT\n        b.date,\n        lower(b.token_address)                     AS token_address,\n        upper(b.symbol)                            AS symbol,\n        b.token_class,\n        lower(b.address)                           AS address,\n        cityHash64(lower(b.address)) % 1000        AS address_bucket,\n        b.balance\n    FROM `dbt`.`int_execution_tokens_balances_daily` b\n    WHERE b.date < today()\n      \n        \n  \n\n      \n      \n),\n\nbounds AS (\n    \n    SELECT\n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM balances_filtered\n    \n),\n\nprev_state AS (\n    \n    SELECT\n        cast('' AS String)  AS token_address,\n        cast('' AS String)  AS symbol,\n        cast('' AS String)  AS token_class,\n        cast('' AS String)  AS address,\n        toInt32(0)          AS address_bucket,\n        cast(0  AS Float64) AS balance\n    WHERE 0\n    \n),\n\nseed_sparse AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        address,\n        address_bucket,\n        balance\n    FROM balances_filtered\n\n    UNION ALL\n\n    SELECT\n        addDays(b.min_date, -1) AS date,   \n        p.token_address,\n        p.symbol,\n        p.token_class,\n        p.address,\n        p.address_bucket,\n        p.balance\n    FROM prev_state p\n    CROSS JOIN bounds b\n),\n\naddr_pairs AS (\n    SELECT\n        token_address,\n        symbol,\n        token_class,\n        address,\n        address_bucket\n    FROM seed_sparse\n    GROUP BY\n        token_address,\n        symbol,\n        token_class,\n        address,\n        address_bucket\n),\n\ncalendar AS (\n    SELECT\n        toDate(\n          arrayJoin(\n            range(\n              toUInt32(addDays(min_date, -1)),  \n              toUInt32(max_date) + 1           \n            )\n          )\n        ) AS date\n    FROM bounds\n),\n\naddr_calendar AS (\n    SELECT\n        c.date,\n        a.token_address,\n        a.symbol,\n        a.token_class,\n        a.address,\n        a.address_bucket\n    FROM calendar c\n    CROSS JOIN addr_pairs a\n),\n\ndense_balances AS (\n    SELECT\n        ac.date,\n        ac.token_address,\n        ac.symbol,\n        ac.token_class,\n        ac.address,\n        ac.address_bucket,\n        last_value(s.balance) IGNORE NULLS\n          OVER (\n            PARTITION BY ac.token_address, ac.address\n            ORDER BY ac.date\n            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n          ) AS balance\n    FROM addr_calendar ac\n    LEFT JOIN seed_sparse s\n      ON s.date          = ac.date\n     AND s.token_address = ac.token_address\n     AND s.address       = ac.address\n),\n\npriced AS (\n    SELECT\n        d.date,\n        d.token_address,\n        d.symbol,\n        d.token_class,\n        d.address,\n        d.address_bucket,\n        d.balance,\n        p.price                          AS price_usd,\n        d.balance * p.price              AS balance_usd\n    FROM dense_balances d\n    LEFT JOIN `dbt`.`int_execution_token_prices_daily` p\n      ON p.date   = d.date\n     AND p.symbol = d.symbol\n    WHERE d.balance > 0\n      AND d.date >= (SELECT min_date FROM bounds)  \n      AND d.date <= (SELECT max_date FROM bounds)\n      AND lower(d.address) != '0x0000000000000000000000000000000000000000'\n),\n\nbucketed AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        address,\n        address_bucket,\n        balance_usd,\n        CASE\n            WHEN balance_usd <       10       THEN '0-10'\n            WHEN balance_usd <      100       THEN '10-100'\n            WHEN balance_usd <     1000       THEN '100-1k'\n            WHEN balance_usd <    10000       THEN '1k-10k'\n            WHEN balance_usd <   100000       THEN '10k-100k'\n            WHEN balance_usd <  1000000       THEN '100k-1M'\n            ELSE                                  '1M+'\n        END AS balance_bucket\n    FROM priced\n    WHERE balance_usd IS NOT NULL\n),\n\nagg AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        balance_bucket,\n        address_bucket,\n        countDistinct(address) AS holders_in_bucket,\n        sum(balance_usd)       AS value_usd_in_bucket\n    FROM bucketed\n    GROUP BY\n        date,\n        token_address,\n        symbol,\n        token_class,\n        balance_bucket,\n        address_bucket\n)\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n    balance_bucket,\n    address_bucket,\n    holders_in_bucket,\n    value_usd_in_bucket\nFROM agg\nWHERE date < today()", "relation_name": "`dbt`.`fct_execution_tokens_balance_cohorts_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.898692Z", "completed_at": "2025-12-13T16:37:55.909263Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.909877Z", "completed_at": "2025-12-13T16:37:55.909884Z"}], "thread_id": "Thread-1", "execution_time": 0.01257181167602539, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_tokens_value_daily", "compiled": true, "compiled_code": "\n\n\n\n\nWITH\n\nsparse_supply AS (\n    SELECT\n        b.date,\n        b.token_address,\n        any(b.symbol)      AS symbol,\n        any(b.token_class) AS token_class,\n\n        sumIf(\n            b.balance,\n            lower(b.address) != '0x0000000000000000000000000000000000000000'\n        ) AS supply,\n\n        toUInt64(\n          countDistinctIf(\n              b.address,\n              b.balance > 0\n              AND lower(b.address) != '0x0000000000000000000000000000000000000000'\n          )\n        ) AS holders\n    FROM `dbt`.`int_execution_tokens_balances_daily` b\n    WHERE b.date < today()\n      \n        \n  \n\n      \n    GROUP BY b.date, b.token_address\n),\n\nbounds AS (\n    SELECT\n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM sparse_supply\n),\n\ntoken_list AS (\n    SELECT\n        token_address,\n        any(symbol)      AS symbol,\n        any(token_class) AS token_class\n    FROM sparse_supply\n    GROUP BY token_address\n),\n\nprev_supply AS (\n    \n    SELECT\n        cast('' AS String)  AS token_address,\n        cast('' AS String)  AS symbol,\n        cast('' AS String)  AS token_class,\n        cast(0  AS Float64) AS supply,\n        cast(0  AS UInt64)  AS holders\n    WHERE 0\n    \n),\n\nprev_supply_min AS (\n    SELECT\n        (SELECT min_date FROM bounds) AS date,\n        p.token_address,\n        p.symbol,\n        p.token_class,\n        p.supply,\n        p.holders\n    FROM prev_supply p\n    LEFT JOIN sparse_supply s\n      ON s.token_address = p.token_address\n     AND s.date = (SELECT min_date FROM bounds)\n    WHERE s.token_address IS NULL\n),\n\nsupply_seed AS (\n    SELECT * FROM sparse_supply\n    UNION ALL\n    SELECT * FROM prev_supply_min\n),\n\ncalendar AS (\n    SELECT\n        toDate(arrayJoin(\n            range(\n                toUInt32((SELECT min_date FROM bounds)),\n                toUInt32((SELECT max_date FROM bounds)) + 1\n            )\n        )) AS date\n),\n\ntoken_calendar AS (\n    SELECT\n        c.date,\n        t.token_address,\n        t.symbol,\n        t.token_class\n    FROM calendar c\n    CROSS JOIN token_list t\n),\n\ndense_supply AS (\n    SELECT\n        tc.date,\n        tc.token_address,\n        tc.symbol,\n        tc.token_class,\n\n        last_value(s.supply) IGNORE NULLS\n          OVER (PARTITION BY tc.token_address ORDER BY tc.date\n                ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS supply,\n\n        last_value(s.holders) IGNORE NULLS\n          OVER (PARTITION BY tc.token_address ORDER BY tc.date\n                ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS holders\n    FROM token_calendar tc\n    LEFT JOIN supply_seed s\n      ON s.token_address = tc.token_address\n     AND s.date = tc.date\n),\n\nflows AS (\n    SELECT\n        t.date,\n        t.token_address,\n        t.symbol,\n        t.token_class,\n        t.volume_token,\n        t.volume_usd,\n        t.transfer_count,\n        t.ua_bitmap_state,\n        t.active_senders,\n        t.unique_receivers\n    FROM `dbt`.`int_execution_tokens_transfers_daily` t\n    WHERE t.date < today()\n      \n        \n  \n\n      \n),\n\njoined AS (\n    SELECT\n        coalesce(b.date, f.date) AS date,\n        coalesce(b.token_address, f.token_address) AS token_address,\n        coalesce(b.symbol, f.symbol) AS symbol,\n        coalesce(b.token_class, f.token_class) AS token_class,\n\n        b.supply,\n        b.holders,\n\n        f.volume_token,\n        f.volume_usd,\n        f.transfer_count,\n        f.ua_bitmap_state,\n        f.active_senders,\n        f.unique_receivers,\n\n        p.price AS price_usd\n    FROM dense_supply b\n    FULL OUTER JOIN flows f\n      ON b.date = f.date\n     AND b.token_address = f.token_address\n\n    LEFT JOIN `dbt`.`int_execution_token_prices_daily` p\n      ON p.date = coalesce(b.date, f.date)\n     AND p.symbol = upper(coalesce(b.symbol, f.symbol))\n)\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n\n    supply,\n    holders,\n    price_usd,\n    supply * price_usd AS value_usd,\n\n    volume_token,\n    volume_usd,\n    transfer_count,\n    ua_bitmap_state,\n    active_senders,\n    unique_receivers\nFROM joined\nWHERE date < today()\nORDER BY date, token_address", "relation_name": "`dbt`.`int_execution_tokens_value_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.912679Z", "completed_at": "2025-12-13T16:37:55.917311Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.917875Z", "completed_at": "2025-12-13T16:37:55.917882Z"}], "thread_id": "Thread-1", "execution_time": 0.006524562835693359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_tokens_balances_daily_date.a8a2d84af0", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_tokens_balances_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.920488Z", "completed_at": "2025-12-13T16:37:55.925229Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.925789Z", "completed_at": "2025-12-13T16:37:55.925796Z"}], "thread_id": "Thread-1", "execution_time": 0.0065343379974365234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_project_monthly_top5_date.52939ba037", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_active_accounts_by_project_monthly_top5`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.928403Z", "completed_at": "2025-12-13T16:37:55.933036Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.933609Z", "completed_at": "2025-12-13T16:37:55.933616Z"}], "thread_id": "Thread-1", "execution_time": 0.006438493728637695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_project_monthly_top5_date.3e677f077f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_by_project_monthly_top5`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.936191Z", "completed_at": "2025-12-13T16:37:55.942076Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.942653Z", "completed_at": "2025-12-13T16:37:55.942660Z"}], "thread_id": "Thread-1", "execution_time": 0.007710933685302734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_fees_native_by_project_monthly_top5_date.32ac91a2c0", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_fees_native_by_project_monthly_top5`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.945239Z", "completed_at": "2025-12-13T16:37:55.949878Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.950470Z", "completed_at": "2025-12-13T16:37:55.950478Z"}], "thread_id": "Thread-1", "execution_time": 0.0064580440521240234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_sector_daily_date.2ce83bd86d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_active_accounts_by_sector_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.953053Z", "completed_at": "2025-12-13T16:37:55.957478Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.958038Z", "completed_at": "2025-12-13T16:37:55.958045Z"}], "thread_id": "Thread-1", "execution_time": 0.006238698959350586, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_sector_daily_date.7d6d9bbca5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_by_sector_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.960651Z", "completed_at": "2025-12-13T16:37:55.965302Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.965855Z", "completed_at": "2025-12-13T16:37:55.965862Z"}], "thread_id": "Thread-1", "execution_time": 0.006449460983276367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_fees_native_by_sector_daily_date.848e5f723c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_fees_native_by_sector_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.968442Z", "completed_at": "2025-12-13T16:37:55.973196Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.973753Z", "completed_at": "2025-12-13T16:37:55.973761Z"}], "thread_id": "Thread-1", "execution_time": 0.006541728973388672, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_sector_weekly_date.e42928d899", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_active_accounts_by_sector_weekly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.976373Z", "completed_at": "2025-12-13T16:37:55.980760Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.981334Z", "completed_at": "2025-12-13T16:37:55.981341Z"}], "thread_id": "Thread-1", "execution_time": 0.006253957748413086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_sector_weekly_date.4bd3931428", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_by_sector_weekly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.983966Z", "completed_at": "2025-12-13T16:37:55.989855Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.990432Z", "completed_at": "2025-12-13T16:37:55.990440Z"}], "thread_id": "Thread-1", "execution_time": 0.007706642150878906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_fees_native_by_sector_weekly_date.fde4f7e3e7", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_fees_native_by_sector_weekly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:55.993054Z", "completed_at": "2025-12-13T16:37:55.996998Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:55.997612Z", "completed_at": "2025-12-13T16:37:55.997620Z"}], "thread_id": "Thread-1", "execution_time": 0.0058193206787109375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_project_ranges_top20", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT\n    t.window,\n    t.bucket,\n    toFloat64(t.value) AS value\n  FROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\n  WHERE t.label = 'ActiveAccounts'\n    AND t.window IN ('All','7D','30D','90D')\n    AND t.bucket IS NOT NULL\n),\nranked AS (\n  SELECT\n    window,\n    bucket,\n    value,\n    row_number() OVER (PARTITION BY window ORDER BY value DESC, bucket ASC) AS rn\n  FROM base\n)\nSELECT\n  window AS range,\n  if(rn <= 20, bucket, 'Others') AS label,\n  sum(value) AS value\nFROM ranked\nGROUP BY range, label\nHAVING value > 0\nORDER BY\n  multiIf(range = 'All', 1, range = '90D', 2, range = '30D', 3, range = '7D', 4, 5),\n  value DESC,\n  label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_project_ranges_top20`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.000372Z", "completed_at": "2025-12-13T16:37:56.004247Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.004828Z", "completed_at": "2025-12-13T16:37:56.004836Z"}], "thread_id": "Thread-1", "execution_time": 0.005722761154174805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_project_total", "compiled": true, "compiled_code": "\n\nSELECT bucket AS label, value\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` t\nWHERE t.label = 'ActiveAccounts' AND window = 'All'\nORDER BY value DESC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_project_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.007499Z", "completed_at": "2025-12-13T16:37:56.011433Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.012011Z", "completed_at": "2025-12-13T16:37:56.012018Z"}], "thread_id": "Thread-1", "execution_time": 0.005825996398925781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_project_ranges_top20", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT\n    t.window,\n    t.bucket,\n    toFloat64(t.value) AS value\n  FROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\n  WHERE t.label = 'Transactions'\n    AND t.window IN ('All','7D','30D','90D')\n    AND t.bucket IS NOT NULL\n),\nranked AS (\n  SELECT\n    window,\n    bucket,\n    value,\n    row_number() OVER (PARTITION BY window ORDER BY value DESC, bucket ASC) AS rn\n  FROM base\n)\nSELECT\n  window AS range,\n  if(rn <= 20, bucket, 'Others') AS label,\n  sum(value) AS value\nFROM ranked\nGROUP BY range, label\nHAVING value > 0\nORDER BY\n  multiIf(range = 'All', 1, range = '90D', 2, range = '30D', 3, range = '7D', 4, 5),\n  value DESC,\n  label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_project_ranges_top20`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.014682Z", "completed_at": "2025-12-13T16:37:56.018538Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.019137Z", "completed_at": "2025-12-13T16:37:56.019145Z"}], "thread_id": "Thread-1", "execution_time": 0.005757570266723633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_project_total", "compiled": true, "compiled_code": "\n\nSELECT t.bucket AS label, t.value\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'Transactions' AND t.window = 'All'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_by_project_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.021941Z", "completed_at": "2025-12-13T16:37:56.025876Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.026482Z", "completed_at": "2025-12-13T16:37:56.026489Z"}], "thread_id": "Thread-1", "execution_time": 0.005901336669921875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_project_ranges_top20", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT\n    t.window,\n    t.bucket,\n    toFloat64(t.value) AS value\n  FROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\n  WHERE t.label = 'FeesNative'\n    AND t.window IN ('All','7D','30D','90D')\n    AND t.bucket IS NOT NULL\n),\nranked AS (\n  SELECT\n    window,\n    bucket,\n    value,\n    row_number() OVER (PARTITION BY window ORDER BY value DESC, bucket ASC) AS rn\n  FROM base\n)\nSELECT\n  window AS range,\n  if(rn <= 20, bucket, 'Others') AS label,\n  sum(value) AS value\nFROM ranked\nGROUP BY range, label\nHAVING value > 0\nORDER BY\n  multiIf(range = 'All', 1, range = '90D', 2, range = '30D', 3, range = '7D', 4, 5),\n  value DESC,\n  label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_project_ranges_top20`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.029161Z", "completed_at": "2025-12-13T16:37:56.034249Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.034835Z", "completed_at": "2025-12-13T16:37:56.034842Z"}], "thread_id": "Thread-1", "execution_time": 0.007002353668212891, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_project_total", "compiled": true, "compiled_code": "\n\nSELECT t.bucket AS label, t.value\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'FeesNative' AND t.window = 'All'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_project_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.037541Z", "completed_at": "2025-12-13T16:37:56.041387Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.041963Z", "completed_at": "2025-12-13T16:37:56.041970Z"}], "thread_id": "Thread-1", "execution_time": 0.0056858062744140625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_7d", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'Transactions' AND window = '7D'", "relation_name": "`dbt`.`api_execution_transactions_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.044648Z", "completed_at": "2025-12-13T16:37:56.048573Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.049178Z", "completed_at": "2025-12-13T16:37:56.049185Z"}], "thread_id": "Thread-1", "execution_time": 0.005791902542114258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_7d", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'ActiveAccounts' AND window = '7D'", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.051885Z", "completed_at": "2025-12-13T16:37:56.055758Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.056356Z", "completed_at": "2025-12-13T16:37:56.056363Z"}], "thread_id": "Thread-1", "execution_time": 0.005759239196777344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_total", "compiled": true, "compiled_code": "\nSELECT value\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'ActiveAccounts' AND window = 'All'", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.059017Z", "completed_at": "2025-12-13T16:37:56.062852Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.063460Z", "completed_at": "2025-12-13T16:37:56.063467Z"}], "thread_id": "Thread-1", "execution_time": 0.0057566165924072266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_7d", "compiled": true, "compiled_code": "\n\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'FeesNative' AND window = '7D'", "relation_name": "`dbt`.`api_execution_transactions_fees_native_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.066148Z", "completed_at": "2025-12-13T16:37:56.071151Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.071732Z", "completed_at": "2025-12-13T16:37:56.071739Z"}], "thread_id": "Thread-1", "execution_time": 0.006921291351318359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_total", "compiled": true, "compiled_code": "\n\nSELECT value\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'FeesNative' AND window = 'All'", "relation_name": "`dbt`.`api_execution_transactions_fees_native_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.074395Z", "completed_at": "2025-12-13T16:37:56.078243Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.078822Z", "completed_at": "2025-12-13T16:37:56.078829Z"}], "thread_id": "Thread-1", "execution_time": 0.00573277473449707, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_total", "compiled": true, "compiled_code": "\n\nSELECT value\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'Transactions' AND window = 'All'", "relation_name": "`dbt`.`api_execution_transactions_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.081490Z", "completed_at": "2025-12-13T16:37:56.085416Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.085990Z", "completed_at": "2025-12-13T16:37:56.085997Z"}], "thread_id": "Thread-1", "execution_time": 0.005799531936645508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_emissions_annualised_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    annual_co2_tonnes_projected\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date DESC \nLIMIT 1", "relation_name": "`dbt`.`api_esg_carbon_emissions_annualised_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.088821Z", "completed_at": "2025-12-13T16:37:56.092837Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.093467Z", "completed_at": "2025-12-13T16:37:56.093474Z"}], "thread_id": "Thread-1", "execution_time": 0.005973339080810547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_emissions_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    AVG(daily_co2_kg_mean) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_value,\n    AVG(daily_co2_kg_lower_90) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_90,\n    AVG(daily_co2_kg_upper_90) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_90,\n    AVG(daily_co2_kg_lower_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_95,\n    AVG(daily_co2_kg_upper_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_95\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date", "relation_name": "`dbt`.`api_esg_carbon_emissions_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.096435Z", "completed_at": "2025-12-13T16:37:56.100454Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.101052Z", "completed_at": "2025-12-13T16:37:56.101059Z"}], "thread_id": "Thread-1", "execution_time": 0.00613093376159668, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_timeseries_bands", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    daily_co2_kg_mean AS value,\n    daily_co2_kg_lower_95 AS lower_95,\n    daily_co2_kg_upper_95 AS upper_95,\n    daily_co2_kg_lower_90 AS lower_90,\n    daily_co2_kg_upper_90 AS upper_90,\n    \n    -- Moving averages for smoothing\n    AVG(daily_co2_kg_mean) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_value,\n    AVG(daily_co2_kg_lower_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_95,\n    AVG(daily_co2_kg_upper_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_95,\n    \n    -- Month-to-date statistics\n    AVG(daily_co2_kg_mean) OVER (PARTITION BY toStartOfMonth(date) ORDER BY date) AS mtd_avg,\n    SUM(daily_co2_kg_mean) OVER (PARTITION BY toStartOfMonth(date) ORDER BY date) AS mtd_total\n    \nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`", "relation_name": "`dbt`.`api_esg_carbon_timeseries_bands`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.103854Z", "completed_at": "2025-12-13T16:37:56.108228Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.108824Z", "completed_at": "2025-12-13T16:37:56.108831Z"}], "thread_id": "Thread-1", "execution_time": 0.006233692169189453, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_cif_network_vs_countries_daily", "compiled": true, "compiled_code": "\n\n\nWITH network_daily_cif AS (\n    -- Get network's daily effective carbon intensity\n    SELECT\n        date,\n        effective_carbon_intensity AS carbon_intensity,\n        'GNOSIS' AS entity_code\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE effective_carbon_intensity IS NOT NULL\n        AND effective_carbon_intensity > 0\n),\n\ncountry_monthly_cif AS (\n    -- Get all monthly country carbon intensities \n    SELECT\n        ci.country_code,\n        ci.carbon_intensity_mean AS carbon_intensity,\n        ci.month_date\n    FROM `dbt`.`int_esg_carbon_intensity_ensemble` ci\n    WHERE ci.country_code != 'WORLD'\n        AND ci.carbon_intensity_mean IS NOT NULL\n        AND ci.carbon_intensity_mean > 0\n        AND ci.country_code IN (\n            'USA',  -- United States\n            'DEU',  -- Germany  \n            'CHN',  -- China\n            'FRA',  -- France\n            'SWE',  -- Sweden \n            'AUS',  -- Australia\n            'BRA',  -- Brazil\n            'ISL'   -- Iceland\n        )\n),\n\ncountry_timeseries AS (\n    -- Join countries to dates using the correct month's CIF\n    SELECT\n        nd.date,\n        cm.carbon_intensity,\n        cm.country_code AS entity_code\n    FROM network_daily_cif nd\n    JOIN country_monthly_cif cm \n        ON cm.month_date = toStartOfMonth(nd.date)  -- Match date to its month\n),\n\n-- Combine network and country data\ncombined_data AS (\n    SELECT * FROM network_daily_cif\n    UNION ALL\n    SELECT * FROM country_timeseries\n),\n\n-- Add comparison metrics\nwith_comparisons AS (\n    SELECT\n        cd.*,\n        nd.carbon_intensity AS network_cif\n    FROM combined_data cd\n    LEFT JOIN network_daily_cif nd ON cd.date = nd.date\n)\n\nSELECT\n    date,\n    entity_code,\n    round(carbon_intensity, 1) AS carbon_intensity_gco2_kwh\nFROM with_comparisons\nORDER BY date, entity_code, carbon_intensity_gco2_kwh DESC", "relation_name": "`dbt`.`api_esg_cif_network_vs_countries_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.111581Z", "completed_at": "2025-12-13T16:37:56.116767Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.117364Z", "completed_at": "2025-12-13T16:37:56.117371Z"}], "thread_id": "Thread-1", "execution_time": 0.007058143615722656, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_energy_consumption_annualised_latest", "compiled": true, "compiled_code": "\n\n\nSELECT\n    annual_energy_Mwh_projected\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nORDER BY date DESC \nLIMIT 1", "relation_name": "`dbt`.`api_esg_energy_consumption_annualised_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.119979Z", "completed_at": "2025-12-13T16:37:56.123937Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.124551Z", "completed_at": "2025-12-13T16:37:56.124558Z"}], "thread_id": "Thread-1", "execution_time": 0.005811214447021484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_energy_monthly", "compiled": true, "compiled_code": "\n\n\nSELECT toStartOfMonth(date) AS date, SUM(daily_energy_kwh_total) AS value\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nGROUP BY 1\nORDER BY date", "relation_name": "`dbt`.`api_esg_energy_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.127313Z", "completed_at": "2025-12-13T16:37:56.131218Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.131807Z", "completed_at": "2025-12-13T16:37:56.131814Z"}], "thread_id": "Thread-1", "execution_time": 0.005764007568359375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_estimated_nodes_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT \n    date\n    ,baseline_observed_nodes\n    ,estimated_nodes\n    ,nodes_lower_95\n    ,nodes_upper_95\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date", "relation_name": "`dbt`.`api_esg_estimated_nodes_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.134575Z", "completed_at": "2025-12-13T16:37:56.138792Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.139405Z", "completed_at": "2025-12-13T16:37:56.139411Z"}], "thread_id": "Thread-1", "execution_time": 0.006094694137573242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_info_annual_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,label\n    ,mean_val\n    ,lower_95\n    ,upper_95\n    ,lower_90\n    ,upper_90\nFROM (\n    SELECT \n        date\n        ,'Energy (MWh)' AS label\n        ,annual_energy_Mwh_projected AS mean_val\n        ,annual_energy_mwh_lower_95 AS lower_95\n        ,annual_energy_mwh_upper_95 AS upper_95\n        ,annual_energy_mwh_lower_90 AS lower_90\n        ,annual_energy_mwh_upper_90 AS upper_90\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT \n        date\n        ,'CO2e (tonnes)' AS label\n        ,annual_co2_tonnes_projected AS mean_val\n        ,annual_co2_tonnes_lower_95 AS lower_95\n        ,annual_co2_tonnes_upper_95 AS upper_95\n        ,annual_co2_tonnes_lower_90 AS lower_90\n        ,annual_co2_tonnes_upper_90 AS upper_90\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_esg_info_annual_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.142174Z", "completed_at": "2025-12-13T16:37:56.149003Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.149620Z", "completed_at": "2025-12-13T16:37:56.149627Z"}], "thread_id": "Thread-1", "execution_time": 0.008737325668334961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_info_category_daily", "compiled": true, "compiled_code": "\n\n\n\n\nSELECT \n    date\n    ,label\n    ,category\n    ,value\nFROM (\n    SELECT date, 'Home Staker' AS label, 'CO2e (kg)' AS category, home_staker_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'CO2e (kg)' AS category, professional_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'CO2e (kg)' AS category, cloud_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'CO2e (kg)' AS category, unknown_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n\n    UNION ALL \n\n    SELECT date, 'Home Staker' AS label, 'Energy (kWh)' AS category, home_staker_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'Energy (kWh)' AS category, professional_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'Energy (kWh)' AS category, cloud_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'Energy (kWh)' AS category, unknown_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n\n    UNION ALL \n\n    SELECT date, 'Home Staker' AS label, 'Nodes' AS category, CAST(home_staker_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'Nodes' AS category, CAST(professional_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'Nodes' AS category, CAST(cloud_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'Nodes' AS category, CAST(unknown_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n)\nORDER BY date, label, category", "relation_name": "`dbt`.`api_esg_info_category_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.152353Z", "completed_at": "2025-12-13T16:37:56.157053Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.157653Z", "completed_at": "2025-12-13T16:37:56.157660Z"}], "thread_id": "Thread-1", "execution_time": 0.0066280364990234375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_esg_carbon_footprint_uncertainty_date.7d5415c9ba", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_esg_carbon_footprint_uncertainty`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.160361Z", "completed_at": "2025-12-13T16:37:56.166040Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.166654Z", "completed_at": "2025-12-13T16:37:56.166661Z"}], "thread_id": "Thread-1", "execution_time": 0.007614612579345703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_tokens_balance_cohorts_daily_agg", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n    balance_bucket,\n    sum(holders_in_bucket)   AS holders_in_bucket,\n    sum(value_usd_in_bucket) AS value_usd_in_bucket\nFROM `dbt`.`fct_execution_tokens_balance_cohorts_daily`   -- sharded fact\nWHERE date < today()\nGROUP BY\n    date,\n    token_address,\n    symbol,\n    token_class,\n    balance_bucket", "relation_name": "`dbt`.`fct_execution_tokens_balance_cohorts_daily_agg`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.169393Z", "completed_at": "2025-12-13T16:37:56.173992Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.174598Z", "completed_at": "2025-12-13T16:37:56.174605Z"}], "thread_id": "Thread-1", "execution_time": 0.0065174102783203125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_tokens_balance_cohorts_daily_date.22eb70fc3b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_execution_tokens_balance_cohorts_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.177232Z", "completed_at": "2025-12-13T16:37:56.181089Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.181696Z", "completed_at": "2025-12-13T16:37:56.181703Z"}], "thread_id": "Thread-1", "execution_time": 0.005733489990234375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_active_senders_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  symbol          AS token,\n  token_class,\n  active_senders  AS value\nFROM `dbt`.`int_execution_tokens_value_daily`\nWHERE date < today()\nORDER BY\n  date,\n  token", "relation_name": "`dbt`.`api_execution_tokens_active_senders_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.184448Z", "completed_at": "2025-12-13T16:37:56.188304Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.188887Z", "completed_at": "2025-12-13T16:37:56.188894Z"}], "thread_id": "Thread-1", "execution_time": 0.005709171295166016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_holders_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  symbol      AS token,\n  token_class,\n  holders     AS value\nFROM `dbt`.`int_execution_tokens_value_daily`\nWHERE date < today()\nORDER BY\n  date,\n  token", "relation_name": "`dbt`.`api_execution_tokens_holders_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.191633Z", "completed_at": "2025-12-13T16:37:56.195449Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.196022Z", "completed_at": "2025-12-13T16:37:56.196029Z"}], "thread_id": "Thread-1", "execution_time": 0.005667448043823242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_holders_latest_by_token", "compiled": true, "compiled_code": "\n\nSELECT\n  symbol      AS token,\n  toUInt64(argMax(holders, date)) AS value\nFROM `dbt`.`int_execution_tokens_value_daily`\nWHERE date < today()\nGROUP BY token_address, symbol\nORDER BY token", "relation_name": "`dbt`.`api_execution_tokens_holders_latest_by_token`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.198673Z", "completed_at": "2025-12-13T16:37:56.202566Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.203161Z", "completed_at": "2025-12-13T16:37:56.203169Z"}], "thread_id": "Thread-1", "execution_time": 0.0057392120361328125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_supply_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  symbol      AS token,\n  token_class,\n  supply      AS value\nFROM `dbt`.`int_execution_tokens_value_daily`\nWHERE date < today()\nORDER BY\n  date,\n  token", "relation_name": "`dbt`.`api_execution_tokens_supply_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.205858Z", "completed_at": "2025-12-13T16:37:56.211030Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.211635Z", "completed_at": "2025-12-13T16:37:56.211642Z"}], "thread_id": "Thread-1", "execution_time": 0.007126569747924805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_supply_latest_by_token", "compiled": true, "compiled_code": "\n\nSELECT\n  symbol      AS token,\n  argMax(supply, date) AS value\nFROM `dbt`.`int_execution_tokens_value_daily`\nWHERE date < today()\nGROUP BY token_address, symbol\nORDER BY token", "relation_name": "`dbt`.`api_execution_tokens_supply_latest_by_token`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.214323Z", "completed_at": "2025-12-13T16:37:56.218201Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.218784Z", "completed_at": "2025-12-13T16:37:56.218791Z"}], "thread_id": "Thread-1", "execution_time": 0.005721092224121094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_volume_usd_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  symbol      AS token,\n  token_class,\n  volume_usd  AS value\nFROM `dbt`.`int_execution_tokens_value_daily`\nWHERE date < today()\nORDER BY\n  date,\n  token", "relation_name": "`dbt`.`api_execution_tokens_volume_usd_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.221499Z", "completed_at": "2025-12-13T16:37:56.225920Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.226498Z", "completed_at": "2025-12-13T16:37:56.226505Z"}], "thread_id": "Thread-1", "execution_time": 0.006239891052246094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_tokens_value_daily_date.6a47b14dc9", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_tokens_value_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.229056Z", "completed_at": "2025-12-13T16:37:56.233541Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.234114Z", "completed_at": "2025-12-13T16:37:56.234124Z"}], "thread_id": "Thread-1", "execution_time": 0.006289005279541016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_carbon_emissions_daily_date.51296759dc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_carbon_emissions_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.236670Z", "completed_at": "2025-12-13T16:37:56.241056Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.241635Z", "completed_at": "2025-12-13T16:37:56.241642Z"}], "thread_id": "Thread-1", "execution_time": 0.006180763244628906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_carbon_timeseries_bands_date.bd7a9a51aa", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_carbon_timeseries_bands`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.244200Z", "completed_at": "2025-12-13T16:37:56.249770Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.250335Z", "completed_at": "2025-12-13T16:37:56.250342Z"}], "thread_id": "Thread-1", "execution_time": 0.00740814208984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_cif_network_vs_countries_daily_date.efb633caf8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_cif_network_vs_countries_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.252888Z", "completed_at": "2025-12-13T16:37:56.257317Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.257867Z", "completed_at": "2025-12-13T16:37:56.257874Z"}], "thread_id": "Thread-1", "execution_time": 0.006196260452270508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_energy_monthly_date.8745f6e20b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_energy_monthly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.260450Z", "completed_at": "2025-12-13T16:37:56.264861Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.265434Z", "completed_at": "2025-12-13T16:37:56.265442Z"}], "thread_id": "Thread-1", "execution_time": 0.006209850311279297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_estimated_nodes_daily_date.2276da231f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_estimated_nodes_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.267973Z", "completed_at": "2025-12-13T16:37:56.272469Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.273020Z", "completed_at": "2025-12-13T16:37:56.273027Z"}], "thread_id": "Thread-1", "execution_time": 0.0063092708587646484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_info_annual_daily_date.506342e106", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_info_annual_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.275598Z", "completed_at": "2025-12-13T16:37:56.280202Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.280754Z", "completed_at": "2025-12-13T16:37:56.280761Z"}], "thread_id": "Thread-1", "execution_time": 0.006384372711181641, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_info_category_daily_date.26de97e343", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_info_category_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.283529Z", "completed_at": "2025-12-13T16:37:56.287430Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.288007Z", "completed_at": "2025-12-13T16:37:56.288014Z"}], "thread_id": "Thread-1", "execution_time": 0.005749940872192383, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_balance_cohorts_holders_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  symbol                         AS token,   \n  balance_bucket                 AS label,   \n  holders_in_bucket              AS value    \nFROM `dbt`.`fct_execution_tokens_balance_cohorts_daily_agg`\nWHERE date < today()\nORDER BY\n  date,\n  token,\n  label", "relation_name": "`dbt`.`api_execution_tokens_balance_cohorts_holders_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.290740Z", "completed_at": "2025-12-13T16:37:56.295863Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.296478Z", "completed_at": "2025-12-13T16:37:56.296485Z"}], "thread_id": "Thread-1", "execution_time": 0.0071027278900146484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_balance_cohorts_value_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  symbol                         AS token,   \n  balance_bucket                 AS label,   \n  value_usd_in_bucket            AS value    \nFROM `dbt`.`fct_execution_tokens_balance_cohorts_daily_agg`\nWHERE date < today()\nORDER BY\n  date,\n  token,\n  label", "relation_name": "`dbt`.`api_execution_tokens_balance_cohorts_value_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.299156Z", "completed_at": "2025-12-13T16:37:56.303578Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.304156Z", "completed_at": "2025-12-13T16:37:56.304164Z"}], "thread_id": "Thread-1", "execution_time": 0.006238460540771484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_tokens_balance_cohorts_daily_agg_date.29fb40af80", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_execution_tokens_balance_cohorts_daily_agg`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.306705Z", "completed_at": "2025-12-13T16:37:56.311124Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.311688Z", "completed_at": "2025-12-13T16:37:56.311695Z"}], "thread_id": "Thread-1", "execution_time": 0.006205558776855469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_tokens_active_senders_daily_date.6606045079", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_tokens_active_senders_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.314299Z", "completed_at": "2025-12-13T16:37:56.318778Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.319359Z", "completed_at": "2025-12-13T16:37:56.319366Z"}], "thread_id": "Thread-1", "execution_time": 0.006289005279541016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_tokens_holders_daily_date.366662102e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_tokens_holders_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.322018Z", "completed_at": "2025-12-13T16:37:56.326441Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.326990Z", "completed_at": "2025-12-13T16:37:56.326997Z"}], "thread_id": "Thread-1", "execution_time": 0.006304740905761719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_tokens_supply_daily_date.cbf90243fc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_tokens_supply_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.329548Z", "completed_at": "2025-12-13T16:37:56.335057Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.335634Z", "completed_at": "2025-12-13T16:37:56.335642Z"}], "thread_id": "Thread-1", "execution_time": 0.007299900054931641, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_tokens_volume_usd_daily_date.4e78375eda", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_tokens_volume_usd_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.338162Z", "completed_at": "2025-12-13T16:37:56.423132Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.423700Z", "completed_at": "2025-12-13T16:37:56.423711Z"}], "thread_id": "Thread-1", "execution_time": 0.08678936958312988, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_tokens_balance_cohorts_holders_daily_date.d7138b9b9d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_tokens_balance_cohorts_holders_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-13T16:37:56.426361Z", "completed_at": "2025-12-13T16:37:56.430916Z"}, {"name": "execute", "started_at": "2025-12-13T16:37:56.431495Z", "completed_at": "2025-12-13T16:37:56.431502Z"}], "thread_id": "Thread-1", "execution_time": 0.006396055221557617, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_tokens_balance_cohorts_value_daily_date.e54ff2f979", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_tokens_balance_cohorts_value_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}], "elapsed_time": 5.709794282913208, "args": {"strict_mode": false, "indirect_selection": "eager", "state_modified_compare_more_unrendered_values": false, "cache_selected_only": false, "profiles_dir": "/home/runner/work/dbt-cerebro/dbt-cerebro", "vars": {}, "static_parser": true, "log_path": "/home/runner/work/dbt-cerebro/dbt-cerebro/logs", "macro_debugging": false, "use_colors": true, "populate_cache": true, "partial_parse_file_diff": true, "printer_width": 80, "compile": true, "introspect": true, "log_level_file": "debug", "static": false, "quiet": false, "empty_catalog": false, "require_yaml_configuration_for_mf_time_spines": false, "source_freshness_run_project_hooks": false, "log_file_max_bytes": 10485760, "project_dir": "/home/runner/work/dbt-cerebro/dbt-cerebro", "invocation_command": "dbt docs generate", "write_json": true, "select": [], "warn_error_options": {"include": [], "exclude": []}, "require_batched_execution_for_custom_microbatch_strategy": false, "partial_parse": true, "print": true, "send_anonymous_usage_stats": true, "show_resource_report": false, "require_explicit_package_overrides_for_builtin_materializations": true, "exclude": [], "which": "generate", "log_format": "default", "state_modified_compare_vars": false, "use_colors_file": true, "require_nested_cumulative_type_params": false, "defer": false, "log_level": "info", "favor_state": false, "version_check": true, "require_resource_names_without_spaces": false, "skip_nodes_if_on_run_start_fails": false, "log_format_file": "debug"}}