{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.4", "generated_at": "2026-02-12T22:49:50.395244Z", "invocation_id": "b6409e3b-3ccd-4e5b-ae7a-b5e771446992", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.694817Z", "completed_at": "2026-02-12T22:49:45.705474Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.706089Z", "completed_at": "2026-02-12T22:49:45.706106Z"}], "thread_id": "Thread-1", "execution_time": 0.012610673904418945, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_labels", "compiled": true, "compiled_code": "\n\nSELECT \n    validator_index\n    ,pubkey\n    ,withdrawal_credentials\nFROM stg_consensus__validators\nWHERE slot = (SELECT MAX(slot) FROM stg_consensus__validators)", "relation_name": "`dbt`.`int_consensus_validators_labels`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.709040Z", "completed_at": "2026-02-12T22:49:45.717778Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.718391Z", "completed_at": "2026-02-12T22:49:45.718398Z"}], "thread_id": "Thread-1", "execution_time": 0.01068878173828125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_blocks_clients_version_daily", "compiled": true, "compiled_code": "\n\n\n\nWITH\n\ndeduped_blocks AS (\n    SELECT\n        block_timestamp,\n        \narrayFilter(\n    x -> x != '',\n    /* split on every \u201cnon word-ish\u201d character (dash, @, space, etc.) */\n    splitByRegexp(\n        '[^A-Za-z0-9\\\\.]+',            -- \u21fd anything that isn\u2019t a\u2013z, 0\u20139 or \u201c.\u201d\n        arrayStringConcat(\n            arrayMap(\n                i -> if(\n                    reinterpretAsUInt8(substring(unhex(coalesce(extra_data, '')), i, 1)) BETWEEN 32 AND 126,\n                    reinterpretAsString(substring(unhex(coalesce(extra_data, '')), i, 1)),\n                    ' '\n                ),\n                range(1, length(unhex(coalesce(extra_data, ''))) + 1)\n            ),\n            ''\n        )\n    )\n)\n AS decoded_extra_data\n    FROM (\n        \n\nSELECT block_timestamp, extra_data\nFROM (\n    SELECT\n        block_timestamp, extra_data,\n        ROW_NUMBER() OVER (\n            PARTITION BY block_number\n            ORDER BY insert_version DESC\n        ) AS _dedup_rn\n    FROM `execution`.`blocks`\n    \n    WHERE \n    block_timestamp > '1970-01-01'\n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_blocks_clients_version_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_blocks_clients_version_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n\n    \n)\nWHERE _dedup_rn = 1\n\n    )\n),\n\nclients_version AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date\n        ,multiIf(\n             lower(decoded_extra_data[1]) = 'choose'\n            OR lower(decoded_extra_data[1]) = 'mysticryuujin'\n            OR lower(decoded_extra_data[1]) = 'sanae.io'\n            OR decoded_extra_data[1] = ''  ,\n            'Unknown',\n            decoded_extra_data[1]\n        )   AS client\n        ,IF(length(decoded_extra_data)>1,\n            IF(decoded_extra_data[2]='Ethereum',decoded_extra_data[3],decoded_extra_data[2]),\n            ''\n        ) AS version\n        ,COUNT(*) AS cnt\n    FROM deduped_blocks\n    GROUP BY 1, 2, 3\n)\n\nSELECT\n    *\nFROM clients_version", "relation_name": "`dbt`.`int_execution_blocks_clients_version_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.721334Z", "completed_at": "2026-02-12T22:49:45.727464Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.728066Z", "completed_at": "2026-02-12T22:49:45.728074Z"}], "thread_id": "Thread-1", "execution_time": 0.008061408996582031, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_blocks_gas_usage_daily", "compiled": true, "compiled_code": "\n\n\n\nWITH deduped_blocks AS (\n    \n\nSELECT block_timestamp, gas_used, gas_limit\nFROM (\n    SELECT\n        block_timestamp, gas_used, gas_limit,\n        ROW_NUMBER() OVER (\n            PARTITION BY block_number\n            ORDER BY insert_version DESC\n        ) AS _dedup_rn\n    FROM `execution`.`blocks`\n    \n    WHERE \n    block_timestamp > '1970-01-01'\n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_blocks_gas_usage_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_blocks_gas_usage_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n\n    \n)\nWHERE _dedup_rn = 1\n\n)\n\nSELECT\n  toDate(block_timestamp)         AS date,\n  SUM(gas_used)                   AS gas_used_sum,\n  SUM(gas_limit)                  AS gas_limit_sum,\n  gas_used_sum / NULLIF(gas_limit_sum, 0) AS gas_used_fraq\nFROM deduped_blocks\nGROUP BY date", "relation_name": "`dbt`.`int_execution_blocks_gas_usage_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.731019Z", "completed_at": "2026-02-12T22:49:45.735075Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.735721Z", "completed_at": "2026-02-12T22:49:45.735728Z"}], "thread_id": "Thread-1", "execution_time": 0.0061419010162353516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__attestations", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    attestation_index,\n    aggregation_bits,\n    signature,\n    attestation_slot,\n    committee_index,\n    beacon_block_root,\n    source_epoch,\n    source_root,\n    target_epoch,\n    target_root,\n    slot_timestamp\nFROM \n    `consensus`.`attestations` FINAL", "relation_name": "`dbt`.`stg_consensus__attestations`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.738726Z", "completed_at": "2026-02-12T22:49:45.742710Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.743303Z", "completed_at": "2026-02-12T22:49:45.743311Z"}], "thread_id": "Thread-1", "execution_time": 0.005900859832763672, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__blob_commitments", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    commitment_index,\n    commitment,\n    slot_timestamp\nFROM \n    `consensus`.`blob_commitments` FINAL", "relation_name": "`dbt`.`stg_consensus__blob_commitments`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.746144Z", "completed_at": "2026-02-12T22:49:45.751442Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.752077Z", "completed_at": "2026-02-12T22:49:45.752084Z"}], "thread_id": "Thread-1", "execution_time": 0.0073320865631103516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__blocks", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    proposer_index,\n    parent_root,\n    state_root,\n    signature,\n    version,\n    randao_reveal,\n    graffiti,\n    eth1_deposit_root,\n    eth1_deposit_count,\n    eth1_block_hash,\n    sync_aggregate_participation,\n    withdrawals_count,\n    blob_kzg_commitments_count,\n    execution_requests_count,\n    slot_timestamp\nFROM \n    `consensus`.`blocks` FINAL", "relation_name": "`dbt`.`stg_consensus__blocks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.755164Z", "completed_at": "2026-02-12T22:49:45.759036Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.759658Z", "completed_at": "2026-02-12T22:49:45.759666Z"}], "thread_id": "Thread-1", "execution_time": 0.006016731262207031, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__deposits", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    deposit_index,\n    pubkey,\n    withdrawal_credentials,\n    amount,\n    signature,\n    proof,\n    slot_timestamp\nFROM \n    `consensus`.`deposits` FINAL", "relation_name": "`dbt`.`stg_consensus__deposits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.762570Z", "completed_at": "2026-02-12T22:49:45.766444Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.767054Z", "completed_at": "2026-02-12T22:49:45.767062Z"}], "thread_id": "Thread-1", "execution_time": 0.005827426910400391, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__execution_requests", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    payload,\n    deposits_count,\n    withdrawals_count,\n    consolidations_count,\n    slot_timestamp\nFROM \n    `consensus`.`execution_requests` FINAL", "relation_name": "`dbt`.`stg_consensus__execution_requests`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.769915Z", "completed_at": "2026-02-12T22:49:45.773821Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.774438Z", "completed_at": "2026-02-12T22:49:45.774445Z"}], "thread_id": "Thread-1", "execution_time": 0.005903005599975586, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__rewards", "compiled": true, "compiled_code": "\n\nSELECT\n    slot\n    proposer_index,\n    total,\n    attestations,\n    sync_aggregate,\n    proposer_slashings,\n    attester_slashings,\n    slot_timestamp\nFROM \n    `consensus`.`rewards` FINAL", "relation_name": "`dbt`.`stg_consensus__rewards`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.777302Z", "completed_at": "2026-02-12T22:49:45.781388Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.782003Z", "completed_at": "2026-02-12T22:49:45.782010Z"}], "thread_id": "Thread-1", "execution_time": 0.006017446517944336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__specs", "compiled": true, "compiled_code": "\n\nSELECT\n    parameter_name,\n    parameter_value,\nFROM \n    `consensus`.`specs` FINAL", "relation_name": "`dbt`.`stg_consensus__specs`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.784757Z", "completed_at": "2026-02-12T22:49:45.788739Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.789332Z", "completed_at": "2026-02-12T22:49:45.789339Z"}], "thread_id": "Thread-1", "execution_time": 0.005942344665527344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__time_helpers", "compiled": true, "compiled_code": "\n\nSELECT\n    genesis_time_unix,\n    seconds_per_slot,\n    slots_per_epoch\nFROM \n    `consensus`.`time_helpers` FINAL", "relation_name": "`dbt`.`stg_consensus__time_helpers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.792256Z", "completed_at": "2026-02-12T22:49:45.797273Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.797932Z", "completed_at": "2026-02-12T22:49:45.797939Z"}], "thread_id": "Thread-1", "execution_time": 0.007105827331542969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__validators", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    validator_index,\n    balance,\n    status,\n    pubkey,\n    withdrawal_credentials,\n    effective_balance,\n    slashed,\n    activation_eligibility_epoch,\n    activation_epoch,\n    exit_epoch,\n    withdrawable_epoch,\n    slot_timestamp\nFROM \n    `consensus`.`validators` FINAL\nWHERE balance > 0", "relation_name": "`dbt`.`stg_consensus__validators`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.801003Z", "completed_at": "2026-02-12T22:49:45.804866Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.805488Z", "completed_at": "2026-02-12T22:49:45.805496Z"}], "thread_id": "Thread-1", "execution_time": 0.005834341049194336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__withdrawals", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    block_number,\n    block_hash,\n    withdrawal_index,\n    validator_index,\n    address,\n    amount,\n    slot_timestamp\nFROM \n    `consensus`.`withdrawals` FINAL", "relation_name": "`dbt`.`stg_consensus__withdrawals`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.808568Z", "completed_at": "2026-02-12T22:49:45.812482Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.813103Z", "completed_at": "2026-02-12T22:49:45.813110Z"}], "thread_id": "Thread-1", "execution_time": 0.005907297134399414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__country_codes", "compiled": true, "compiled_code": "\n\n\nSELECT\n    \"name\",\n    \"alpha-2\",\n    \"alpha-3\",\n    \"country-code\",\n    \"iso_3166-2\",\n    \"region\",\n    \"sub-region\",\n    \"intermediate-region\",\n    \"region-code\",\n    \"sub-region-code\",\n    \"intermediate-region-code\"\nFROM\n    `crawlers_data`.`country_codes`", "relation_name": "`dbt`.`stg_crawlers_data__country_codes`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.815887Z", "completed_at": "2026-02-12T22:49:45.819895Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.820537Z", "completed_at": "2026-02-12T22:49:45.820544Z"}], "thread_id": "Thread-1", "execution_time": 0.005949258804321289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_bridge_flows", "compiled": true, "compiled_code": "\n\n-- Production version: Expects transaction-level data from Dune (with timestamp)\n\nSELECT\n  timestamp,\n  bridge,\n  source_chain,\n  dest_chain,\n  token,\n  toFloat64(amount_token) AS amount_token,\n  toFloat64(amount_usd)   AS amount_usd,\n  toFloat64(net_usd)      AS net_usd,         \n  CASE\n    WHEN dest_chain   = 'gnosis' THEN 'in'\n    WHEN source_chain = 'gnosis' THEN 'out'\n    ELSE 'xchain'\n  END AS direction\nFROM `crawlers_data`.`dune_bridge_flows`", "relation_name": "`dbt`.`stg_crawlers_data__dune_bridge_flows`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.823487Z", "completed_at": "2026-02-12T22:49:45.827437Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.828012Z", "completed_at": "2026-02-12T22:49:45.828019Z"}], "thread_id": "Thread-1", "execution_time": 0.005856752395629883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_bridge_flows_v2", "compiled": true, "compiled_code": "\n\n-- V2: Expects pre-aggregated daily data from Dune (with date, txs columns)\n-- Use this version when Dune queries are updated to output daily aggregates\n\nSELECT\n  date,\n  bridge,\n  source_chain,\n  dest_chain,\n  token,\n  toFloat64(amount_token) AS volume_token,   \n  toFloat64(amount_usd)   AS volume_usd,\n  toFloat64(net_usd)      AS net_usd,\n  toUInt64(txs)           AS txs,\n  CASE\n    WHEN dest_chain   = 'gnosis' THEN 'in'\n    WHEN source_chain = 'gnosis' THEN 'out'\n    ELSE 'xchain'\n  END AS direction\nFROM `crawlers_data`.`dune_bridge_flows`", "relation_name": "`dbt`.`stg_crawlers_data__dune_bridge_flows_v2`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.830835Z", "completed_at": "2026-02-12T22:49:45.835643Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.836242Z", "completed_at": "2026-02-12T22:49:45.836250Z"}], "thread_id": "Thread-1", "execution_time": 0.0067882537841796875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_gno_supply", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    label,\n    block_date,\n    supply\nFROM `crawlers_data`.`dune_gno_supply`", "relation_name": "`dbt`.`stg_crawlers_data__dune_gno_supply`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.839123Z", "completed_at": "2026-02-12T22:49:45.842998Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.843613Z", "completed_at": "2026-02-12T22:49:45.843621Z"}], "thread_id": "Thread-1", "execution_time": 0.005876779556274414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_prices", "compiled": true, "compiled_code": "\n\nSELECT\n  toDate(block_date)                    AS date,\n  upper(symbol)                         AS symbol,\n  anyLast(toFloat64(price))             AS price   \nFROM `crawlers_data`.`dune_prices`\nGROUP BY date, symbol\nORDER BY date, symbol", "relation_name": "`dbt`.`stg_crawlers_data__dune_prices`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.846601Z", "completed_at": "2026-02-12T22:49:45.850660Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.851296Z", "completed_at": "2026-02-12T22:49:45.851303Z"}], "thread_id": "Thread-1", "execution_time": 0.006164073944091797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__ember_electricity_data", "compiled": true, "compiled_code": "\n\n\nSELECT\n    \"Area\",\n    \"ISO 3 code\",\n    \"Date\",\n    \"Area type\",\n    \"Continent\",\n    \"Ember region\",\n    \"EU\" ,\n    \"OECD\",\n    \"G20\",\n    \"G7\",\n    \"ASEAN\",\n    \"Category\",\n    \"Subcategory\",\n    \"Variable\",\n    \"Unit\",\n    \"Value\",\n    \"YoY absolute change\",\n    \"YoY % change\" \nFROM\n    `crawlers_data`.`ember_electricity_data`", "relation_name": "`dbt`.`stg_crawlers_data__ember_electricity_data`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.854349Z", "completed_at": "2026-02-12T22:49:45.858849Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.859497Z", "completed_at": "2026-02-12T22:49:45.859504Z"}], "thread_id": "Thread-1", "execution_time": 0.006499290466308594, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__ipinfo", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    ip,\n    hostname,\n    city,\n    region,\n    country,\n    loc,\n    org,\n    postal,\n    timezone,\n    asn,\n    company,\n    carrier,\n    is_bogon,\n    is_mobile,\n    multiIf(\n      lowerUTF8(org) ILIKE '%amazon web services%' OR lowerUTF8(org) ILIKE '%amazon data services%' OR lowerUTF8(org) ILIKE '%aws%' OR lowerUTF8(org) ILIKE '%amazon.com%', 'AWS',\n      (lowerUTF8(org) ILIKE '%google cloud%' OR lowerUTF8(org) ILIKE '%google llc%' OR lowerUTF8(org) ILIKE '%gcp%' OR lowerUTF8(org) ILIKE '%google%') AND lowerUTF8(org) NOT ILIKE '%fiber%', 'Google',\n      lowerUTF8(org) ILIKE '%microsoft azure%' OR lowerUTF8(org) ILIKE '%azure%' OR lowerUTF8(org) ILIKE '%microsoft corporation%' OR lowerUTF8(org) ILIKE '%msft%', 'Azure',\n      lowerUTF8(org) ILIKE '%oracle cloud%' OR lowerUTF8(org) ILIKE '%oracle america%' OR lowerUTF8(org) ILIKE '%oci%', 'Oracle Cloud',\n      lowerUTF8(org) ILIKE '%alibaba cloud%' OR lowerUTF8(org) ILIKE '%aliyun%' OR lowerUTF8(org) ILIKE '%alibaba%', 'Alibaba Cloud',\n\n      lowerUTF8(org) ILIKE '%cloudflare%', 'Cloudflare',\n      (lowerUTF8(org) ILIKE '%akamai%' AND lowerUTF8(org) NOT ILIKE '%linode%'), 'Akamai',\n      lowerUTF8(org) ILIKE '%fastly%', 'Fastly',\n\n      lowerUTF8(org) ILIKE '%digitalocean%' OR lowerUTF8(org) ILIKE '%digital ocean%', 'DigitalOcean',\n      lowerUTF8(org) ILIKE '%ovh%', 'OVHcloud',\n      lowerUTF8(org) ILIKE '%hetzner%', 'Hetzner',\n      lowerUTF8(org) ILIKE '%scaleway%' OR lowerUTF8(org) ILIKE '%online s.a.s%' OR lowerUTF8(org) ILIKE '%iliad%', 'Scaleway',\n      lowerUTF8(org) ILIKE '%linode%', 'Linode',\n      lowerUTF8(org) ILIKE '%vultr%' OR lowerUTF8(org) ILIKE '%choopa%', 'Vultr',\n      lowerUTF8(org) ILIKE '%equinix metal%' OR lowerUTF8(org) ILIKE '%packet host%' OR lowerUTF8(org) ILIKE '%packet, inc%', 'Equinix Metal',\n      lowerUTF8(org) ILIKE '%fly.io%' OR lowerUTF8(org) ILIKE '%fly io%', 'Fly.io',\n      lowerUTF8(org) ILIKE '%netlify%', 'Netlify',\n      lowerUTF8(org) ILIKE '%vercel%' OR lowerUTF8(org) ILIKE '%zeit%', 'Vercel',\n      lowerUTF8(org) ILIKE '%heroku%', 'Heroku',\n      lowerUTF8(org) ILIKE '%render.com%' OR lowerUTF8(org) ILIKE '% render %', 'Render',\n\n      -- Carrier / transit networks (keep as its own bucket; change to 'Public ISP (Home/Office)' if you prefer)\n      lowerUTF8(org) ILIKE '%cogent%' OR lowerUTF8(org) ILIKE '%lumen%' OR lowerUTF8(org) ILIKE '%level 3%' OR lowerUTF8(org) ILIKE '%centurylink%' OR\n      lowerUTF8(org) ILIKE '%telia carrier%' OR lowerUTF8(org) ILIKE '%arelion%' OR lowerUTF8(org) ILIKE '%gtt%' OR lowerUTF8(org) ILIKE '%hurricane electric%' OR\n      lowerUTF8(org) ILIKE '%he.net%' OR lowerUTF8(org) ILIKE '%ntt communications%' OR lowerUTF8(org) ILIKE '%tata communications%' OR lowerUTF8(org) ILIKE '%zayo%' OR\n      lowerUTF8(org) ILIKE '%kddi%' OR lowerUTF8(org) ILIKE '%sparkle%' OR lowerUTF8(org) ILIKE '%backbone%' OR lowerUTF8(org) ILIKE '%chinanet-backbone%', 'Carrier/Transit',\n\n      -- Education / government \u2192 treat like public access\n      lowerUTF8(org) ILIKE '%university%' OR lowerUTF8(org) ILIKE '%college%' OR lowerUTF8(org) ILIKE '%school%' OR lowerUTF8(org) ILIKE '%ministry%' OR lowerUTF8(org) ILIKE '%government%', 'Public ISP (Home/Office)',\n\n      -- Generic hosting/CDN hints\n      lowerUTF8(org) ILIKE '%datacenter%' OR lowerUTF8(org) ILIKE '%data center%' OR lowerUTF8(org) ILIKE '%colo%' OR lowerUTF8(org) ILIKE '%hosting%' OR lowerUTF8(org) ILIKE '%vps%' OR lowerUTF8(org) ILIKE '%server%' OR lowerUTF8(org) ILIKE '%incapsula%' OR lowerUTF8(org) ILIKE '%imperva%', 'Hosting/CDN (Other)',\n\n      -- Fallback for residential & office ISPs\n      lowerUTF8(org) ILIKE '%telecom%' OR lowerUTF8(org) ILIKE '%telekom%' OR lowerUTF8(org) ILIKE '%telecommunications%' OR lowerUTF8(org) ILIKE '%communications%' OR lowerUTF8(org) ILIKE '%wireless%' OR\n      lowerUTF8(org) ILIKE '%cable%' OR lowerUTF8(org) ILIKE '%broadband%' OR lowerUTF8(org) ILIKE '%internet%' OR lowerUTF8(org) ILIKE '%fibre%' OR lowerUTF8(org) ILIKE '%fiber%' OR lowerUTF8(org) ILIKE '%mobile%', 'Public ISP (Home/Office)',\n      lowerUTF8(org) = '', 'Unknown',\n      'Public ISP (Home/Office)'\n  ) AS generic_provider\n  FROM `crawlers_data`.`ipinfo` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_crawlers_data__ipinfo`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.862309Z", "completed_at": "2026-02-12T22:49:45.866363Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.866999Z", "completed_at": "2026-02-12T22:49:45.867007Z"}], "thread_id": "Thread-1", "execution_time": 0.006002664566040039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_agent_semvers_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    agent_version_semver,\n    agent_version_semver_str,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_agent_semvers_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.870007Z", "completed_at": "2026-02-12T22:49:45.874025Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.874685Z", "completed_at": "2026-02-12T22:49:45.874693Z"}], "thread_id": "Thread-1", "execution_time": 0.006152153015136719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_cloud_provider_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    cloud_provider,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_cloud_provider_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.877639Z", "completed_at": "2026-02-12T22:49:45.882569Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.883181Z", "completed_at": "2026-02-12T22:49:45.883188Z"}], "thread_id": "Thread-1", "execution_time": 0.0068759918212890625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_countries_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    country_name,\n    country,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_countries_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_countries_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.886132Z", "completed_at": "2026-02-12T22:49:45.890013Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.890645Z", "completed_at": "2026-02-12T22:49:45.890652Z"}], "thread_id": "Thread-1", "execution_time": 0.005855560302734375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_quic_support_over_7d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    crawl_created_at,\n    quic_support,\n    __count,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_quic_support_over_7d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_quic_support_over_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.893635Z", "completed_at": "2026-02-12T22:49:45.897733Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.898337Z", "completed_at": "2026-02-12T22:49:45.898345Z"}], "thread_id": "Thread-1", "execution_time": 0.006211996078491211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__storage_diffs", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n    SELECT \n        block_number,\n        transaction_index,\n        CONCAT('0x', transaction_hash) AS transaction_hash,\n        CONCAT('0x', address) AS address,\n        slot,\n        from_value,\n        to_value,\n        block_timestamp\n    FROM \n        `execution`.`storage_diffs`\n)\n\nSELECT\n    *\nFROM source", "relation_name": "`dbt`.`stg_execution__storage_diffs`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.901292Z", "completed_at": "2026-02-12T22:49:45.905167Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.905783Z", "completed_at": "2026-02-12T22:49:45.905790Z"}], "thread_id": "Thread-1", "execution_time": 0.005934238433837891, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__discovery_id_prefixes_x_peer_ids", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    discovery_id_prefix,\n    peer_id\n  FROM `nebula_discv4`.`discovery_id_prefixes_x_peer_ids` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.908683Z", "completed_at": "2026-02-12T22:49:45.912574Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.913167Z", "completed_at": "2026-02-12T22:49:45.913175Z"}], "thread_id": "Thread-1", "execution_time": 0.005802631378173828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__neighbors", "compiled": true, "compiled_code": "\n\nWITH \n\nsource AS (\n  SELECT \n    crawl_id,\n    crawl_created_at,\n    peer_discovery_id_prefix,\n    neighbor_discovery_id_prefix,\n    error_bits\n  FROM `nebula_discv4`.`neighbors` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__neighbors`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.916102Z", "completed_at": "2026-02-12T22:49:45.921103Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.921741Z", "completed_at": "2026-02-12T22:49:45.921749Z"}], "thread_id": "Thread-1", "execution_time": 0.0070683956146240234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__visits", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    crawl_id,\n    peer_id,\n    agent_version,\n    protocols,\n    dial_maddrs,\n    filtered_maddrs,\n    extra_maddrs,\n    dial_errors,\n    connect_maddr,\n    crawl_error,\n    visit_started_at,\n    visit_ended_at,\n    peer_properties\n  FROM `nebula_discv4`.`visits` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__visits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.924786Z", "completed_at": "2026-02-12T22:49:45.928720Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.929317Z", "completed_at": "2026-02-12T22:49:45.929324Z"}], "thread_id": "Thread-1", "execution_time": 0.005886554718017578, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__discovery_id_prefixes_x_peer_ids", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    discovery_id_prefix,\n    peer_id\n  FROM `nebula`.`discovery_id_prefixes_x_peer_ids` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.932270Z", "completed_at": "2026-02-12T22:49:45.936175Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.936799Z", "completed_at": "2026-02-12T22:49:45.936807Z"}], "thread_id": "Thread-1", "execution_time": 0.005956888198852539, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__neighbors", "compiled": true, "compiled_code": "\n\nWITH \n\nsource AS (\n  SELECT \n    crawl_id,\n    crawl_created_at,\n    peer_discovery_id_prefix,\n    neighbor_discovery_id_prefix,\n    error_bits\n  FROM `nebula`.`neighbors` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__neighbors`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.939788Z", "completed_at": "2026-02-12T22:49:45.943801Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.944437Z", "completed_at": "2026-02-12T22:49:45.944445Z"}], "thread_id": "Thread-1", "execution_time": 0.005999565124511719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__visits", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    crawl_id,\n    peer_id,\n    agent_version,\n    protocols,\n    dial_maddrs,\n    filtered_maddrs,\n    extra_maddrs,\n    dial_errors,\n    connect_maddr,\n    crawl_error,\n    visit_started_at,\n    visit_ended_at,\n    peer_properties\n  FROM `nebula`.`visits` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__visits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.947532Z", "completed_at": "2026-02-12T22:49:45.949495Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.950082Z", "completed_at": "2026-02-12T22:49:45.950089Z"}], "thread_id": "Thread-1", "execution_time": 0.004150867462158203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.contracts_abi", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.952807Z", "completed_at": "2026-02-12T22:49:45.954768Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.955339Z", "completed_at": "2026-02-12T22:49:45.955346Z"}], "thread_id": "Thread-1", "execution_time": 0.003976583480834961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.contracts_whitelist", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.958040Z", "completed_at": "2026-02-12T22:49:45.961017Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.961607Z", "completed_at": "2026-02-12T22:49:45.961615Z"}], "thread_id": "Thread-1", "execution_time": 0.004815578460693359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.event_signatures", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.964995Z", "completed_at": "2026-02-12T22:49:45.966872Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.967451Z", "completed_at": "2026-02-12T22:49:45.967459Z"}], "thread_id": "Thread-1", "execution_time": 0.004342794418334961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.function_signatures", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.970381Z", "completed_at": "2026-02-12T22:49:45.972276Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.972863Z", "completed_at": "2026-02-12T22:49:45.972870Z"}], "thread_id": "Thread-1", "execution_time": 0.003965854644775391, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.tokens_whitelist", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.975649Z", "completed_at": "2026-02-12T22:49:45.985151Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.985750Z", "completed_at": "2026-02-12T22:49:45.985757Z"}], "thread_id": "Thread-1", "execution_time": 0.011472702026367188, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_validators_labels_validator_index.ecfc429170", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect validator_index\nfrom `dbt`.`int_consensus_validators_labels`\nwhere validator_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.988450Z", "completed_at": "2026-02-12T22:49:45.995341Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:45.995936Z", "completed_at": "2026-02-12T22:49:45.995944Z"}], "thread_id": "Thread-1", "execution_time": 0.00879049301147461, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_consensus_validators_labels_validator_index.b102725776", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    validator_index as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_consensus_validators_labels`\nwhere validator_index is not null\ngroup by validator_index\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:45.998739Z", "completed_at": "2026-02-12T22:49:46.003716Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.004374Z", "completed_at": "2026-02-12T22:49:46.004382Z"}], "thread_id": "Thread-1", "execution_time": 0.006981372833251953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_blocks_clients_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\nclients_blocks AS (\n    SELECT\n        date\n        ,client\n        ,SUM(cnt) AS cnt\n    FROM `dbt`.`int_execution_blocks_clients_version_daily`\n    WHERE date < today()\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,client\n    ,cnt\n    ,cnt/(SUM(cnt) OVER (PARTITION BY date)) AS fraq\nFROM \n    clients_blocks", "relation_name": "`dbt`.`fct_execution_blocks_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.007243Z", "completed_at": "2026-02-12T22:49:46.011809Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.012386Z", "completed_at": "2026-02-12T22:49:46.012393Z"}], "thread_id": "Thread-1", "execution_time": 0.006654024124145508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_blocks_clients_version_daily_date.dd5f7f1301", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_blocks_clients_version_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.015160Z", "completed_at": "2026-02-12T22:49:46.019069Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.019685Z", "completed_at": "2026-02-12T22:49:46.019693Z"}], "thread_id": "Thread-1", "execution_time": 0.005824089050292969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_gas_usage_pct_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  ROUND(gas_used_fraq * 100, 2) AS value\nFROM `dbt`.`int_execution_blocks_gas_usage_daily`\nWHERE date < today()   \nORDER BY date", "relation_name": "`dbt`.`api_execution_blocks_gas_usage_pct_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.022594Z", "completed_at": "2026-02-12T22:49:46.026535Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.027134Z", "completed_at": "2026-02-12T22:49:46.027141Z"}], "thread_id": "Thread-1", "execution_time": 0.005964517593383789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_blocks_gas_usage_monthly", "compiled": true, "compiled_code": "\n\nWITH monthly AS (\n  SELECT\n    date_trunc('month', date) AS month,\n    SUM(gas_used_sum)         AS gas_used_sum_monthly,\n    SUM(gas_limit_sum)        AS gas_limit_sum_monthly\n  FROM `dbt`.`int_execution_blocks_gas_usage_daily`\n  GROUP BY month\n)\nSELECT\n  month,\n  gas_used_sum_monthly,\n  gas_limit_sum_monthly,\n  gas_used_sum_monthly / NULLIF(gas_limit_sum_monthly, 0) AS used\nFROM monthly", "relation_name": "`dbt`.`fct_execution_blocks_gas_usage_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.029961Z", "completed_at": "2026-02-12T22:49:46.034637Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.035203Z", "completed_at": "2026-02-12T22:49:46.035210Z"}], "thread_id": "Thread-1", "execution_time": 0.006666421890258789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_blocks_gas_usage_daily_date.1b2b9e203e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_blocks_gas_usage_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.037966Z", "completed_at": "2026-02-12T22:49:46.043542Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.044132Z", "completed_at": "2026-02-12T22:49:46.044139Z"}], "thread_id": "Thread-1", "execution_time": 0.007521629333496094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_attestations_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,slot - attestation_slot AS inclusion_delay\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__attestations`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_attestations_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_attestations_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_attestations_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.046990Z", "completed_at": "2026-02-12T22:49:46.052700Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.053273Z", "completed_at": "2026-02-12T22:49:46.053280Z"}], "thread_id": "Thread-1", "execution_time": 0.007686614990234375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__attestations_attestation_index.58b9a4912c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect attestation_index\nfrom `dbt`.`stg_consensus__attestations`\nwhere attestation_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.055949Z", "completed_at": "2026-02-12T22:49:46.060427Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.061008Z", "completed_at": "2026-02-12T22:49:46.061016Z"}], "thread_id": "Thread-1", "execution_time": 0.006334066390991211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__attestations_committee_index.5a5ae311f8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect committee_index\nfrom `dbt`.`stg_consensus__attestations`\nwhere committee_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.063695Z", "completed_at": "2026-02-12T22:49:46.068218Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.068835Z", "completed_at": "2026-02-12T22:49:46.068842Z"}], "thread_id": "Thread-1", "execution_time": 0.006417989730834961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__attestations_slot_timestamp.590b7f0b9d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__attestations`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.071855Z", "completed_at": "2026-02-12T22:49:46.077064Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.077681Z", "completed_at": "2026-02-12T22:49:46.077689Z"}], "thread_id": "Thread-1", "execution_time": 0.0074579715728759766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_blob_commitments_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__blob_commitments`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_blob_commitments_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_blob_commitments_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_consensus_blob_commitments_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.080484Z", "completed_at": "2026-02-12T22:49:46.084938Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.085526Z", "completed_at": "2026-02-12T22:49:46.085534Z"}], "thread_id": "Thread-1", "execution_time": 0.006346225738525391, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__blob_commitments_commitment_index.ddcbbbd385", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect commitment_index\nfrom `dbt`.`stg_consensus__blob_commitments`\nwhere commitment_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.088180Z", "completed_at": "2026-02-12T22:49:46.093652Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.094222Z", "completed_at": "2026-02-12T22:49:46.094229Z"}], "thread_id": "Thread-1", "execution_time": 0.0073146820068359375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__blob_commitments_slot_timestamp.969dc885e2", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__blob_commitments`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.097001Z", "completed_at": "2026-02-12T22:49:46.102461Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.103078Z", "completed_at": "2026-02-12T22:49:46.103086Z"}], "thread_id": "Thread-1", "execution_time": 0.007437229156494141, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_graffiti_daily", "compiled": true, "compiled_code": "\n\nWITH\n    -- Canonical lists\n    ['nethermind','erigon','geth','besu','reth'] AS el_keys,\n    ['Nethermind','Erigon','Geth','Besu','Reth'] AS el_names,\n    ['lighthouse','teku','prysm','lodestar','nimbus'] AS cl_keys,\n    ['Lighthouse','Teku','Prysm','Lodestar','Nimbus'] AS cl_names,\n\n    -- Platform/hosting brands \n    ['dappnode','avado','allnodes','twinstake','stakewise','gateway','kleros',\n     'filoozom','kpk-validators','hopr','digitalconsultantsllc',\n     'synthex'] AS brand_keys,\n    ['DappNode','Avado','Allnodes','Twinstake','StakeWise','gateway.fm','kleros.io',\n     'filoozom.eth','kpk-validators','HOPR','DigitalConsultantsLLC.xyz',\n     'Synthex'] AS brand_names,\n\n\nfinal AS (\n    SELECT\n        date\n        ,graffiti\n        ,cnt\n        -- Lowercased text to search in\n        ,lowerUTF8(graffiti) AS g\n\n        -- Detect any brand first (highest precedence)\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, brand_keys) AS brands_found\n        ,if(length(brands_found) > 0,\n            arrayElement(brand_names, indexOf(brand_keys, brands_found[1])),\n            null) AS brand_label\n\n        -- Detect EL/CL clients (order-insensitive, separator-agnostic)\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, el_keys) AS el_found\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, cl_keys) AS cl_found\n\n        -- Pick the first match per side by priority order above\n        ,if(length(el_found) > 0,\n            arrayElement(el_names, indexOf(el_keys, el_found[1])),\n            null) AS el_label\n\n        ,if(length(cl_found) > 0,\n            arrayElement(cl_names, indexOf(cl_keys, cl_found[1])),\n            null) AS cl_label\n\n        -- Final label priority:\n        -- 1) Brand/platform if any\n        -- 2) EL+CL combo if both found\n        -- 3) Single client if only one side found\n        -- 4) Other\n        ,coalesce(\n            brand_label,\n            if(el_label IS NOT NULL AND cl_label IS NOT NULL, concat(el_label, '+', cl_label), null),\n            el_label,\n            cl_label,\n            if(graffiti = 'None', graffiti, null),\n            'Other'\n        ) AS label\n    FROM (\n        SELECT\n            toStartOfDay(slot_timestamp) AS date\n            ,IF(graffiti='0x0000000000000000000000000000000000000000000000000000000000000000', \n                'None', \n                unhex(right(graffiti,-2))\n            ) AS graffiti\n            ,COUNT(*) AS cnt\n        FROM `dbt`.`stg_consensus__blocks`\n        WHERE\n            slot_timestamp < today()\n            \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_graffiti_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_graffiti_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n        GROUP BY 1, 2\n    )\n)\n\nSELECT\n    date\n    ,graffiti\n    ,label\n    ,cnt\nFROM final", "relation_name": "`dbt`.`int_consensus_graffiti_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.105741Z", "completed_at": "2026-02-12T22:49:46.110400Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.111001Z", "completed_at": "2026-02-12T22:49:46.111008Z"}], "thread_id": "Thread-1", "execution_time": 0.006521940231323242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__blocks_eth1_block_hash.0ea22711e9", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect eth1_block_hash\nfrom `dbt`.`stg_consensus__blocks`\nwhere eth1_block_hash is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.113783Z", "completed_at": "2026-02-12T22:49:46.118291Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.118879Z", "completed_at": "2026-02-12T22:49:46.118886Z"}], "thread_id": "Thread-1", "execution_time": 0.00646662712097168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__blocks_proposer_index.67fbc80e41", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect proposer_index\nfrom `dbt`.`stg_consensus__blocks`\nwhere proposer_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.121525Z", "completed_at": "2026-02-12T22:49:46.126049Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.126696Z", "completed_at": "2026-02-12T22:49:46.126703Z"}], "thread_id": "Thread-1", "execution_time": 0.00644230842590332, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__blocks_slot_timestamp.fbaaf552e6", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__blocks`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.129341Z", "completed_at": "2026-02-12T22:49:46.133841Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.134407Z", "completed_at": "2026-02-12T22:49:46.134440Z"}], "thread_id": "Thread-1", "execution_time": 0.006367683410644531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_consensus__blocks_eth1_block_hash.9c6bcdba18", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    eth1_block_hash as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_consensus__blocks`\nwhere eth1_block_hash is not null\ngroup by eth1_block_hash\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.137069Z", "completed_at": "2026-02-12T22:49:46.142641Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.143210Z", "completed_at": "2026-02-12T22:49:46.143217Z"}], "thread_id": "Thread-1", "execution_time": 0.007398128509521484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__deposits_deposit_index.e7a756cb32", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect deposit_index\nfrom `dbt`.`stg_consensus__deposits`\nwhere deposit_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.145890Z", "completed_at": "2026-02-12T22:49:46.150406Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.150996Z", "completed_at": "2026-02-12T22:49:46.151003Z"}], "thread_id": "Thread-1", "execution_time": 0.0063784122467041016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__deposits_slot_timestamp.761249155f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__deposits`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.153656Z", "completed_at": "2026-02-12T22:49:46.158092Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.158681Z", "completed_at": "2026-02-12T22:49:46.158689Z"}], "thread_id": "Thread-1", "execution_time": 0.006298065185546875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__execution_requests_slot_timestamp.fa392e26f6", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__execution_requests`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.161353Z", "completed_at": "2026-02-12T22:49:46.165818Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.166390Z", "completed_at": "2026-02-12T22:49:46.166398Z"}], "thread_id": "Thread-1", "execution_time": 0.006365537643432617, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__rewards_proposer_index.ea1712fd1f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect proposer_index\nfrom `dbt`.`stg_consensus__rewards`\nwhere proposer_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.169088Z", "completed_at": "2026-02-12T22:49:46.173559Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.174128Z", "completed_at": "2026-02-12T22:49:46.174135Z"}], "thread_id": "Thread-1", "execution_time": 0.00636601448059082, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__rewards_slot_timestamp.7144033664", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__rewards`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.176838Z", "completed_at": "2026-02-12T22:49:46.182431Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.183028Z", "completed_at": "2026-02-12T22:49:46.183035Z"}], "thread_id": "Thread-1", "execution_time": 0.007508516311645508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_forks", "compiled": true, "compiled_code": "\n\nWITH\n\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\nfork_version AS (\n    SELECT\n        IF(fork_name='GENESIS', 'PHASE0', fork_name) AS fork_name\n        ,parameter_value\n    FROM (\n        SELECT\n            arrayElement(splitByChar('_', ifNull(parameter_name, '')), 1) AS fork_name\n            ,parameter_value\n        FROM `dbt`.`stg_consensus__specs`\n        WHERE parameter_name LIKE '%_FORK_VERSION'\n    )\n),\n\nfork_epoch AS (\n    SELECT\n        arrayElement(splitByChar('_', ifNull(parameter_name, '')), 1) AS fork_name\n        ,parameter_value\n    FROM `dbt`.`stg_consensus__specs`\n    WHERE parameter_name LIKE '%_FORK_EPOCH'\n\n    UNION ALL \n\n    SELECT 'PHASE0' AS fork_name, '0' AS parameter_value \n)\n\nSELECT \n  t1.cl_fork_name AS fork_name\n  ,t2.parameter_value AS fork_version \n  ,t1.fork_digest AS fork_digest\n  ,t3.parameter_value AS fork_epoch \n  ,IF(CAST(t3.parameter_value AS Int) = -1, NULL,\n    addSeconds(\n          toDateTime(t4.genesis_time_unix, 'UTC'),\n          CAST(t3.parameter_value AS Int) * (t4.seconds_per_slot * t4.slots_per_epoch )\n      )\n   ) AS fork_time\nFROM \n  fork_digests t1\nINNER JOIN\n  fork_version t2\n  ON LOWER(t2.fork_name) = LOWER(t1.cl_fork_name)\nINNER JOIN\n  fork_epoch t3\n  ON LOWER(t3.fork_name) = LOWER(t1.cl_fork_name)\nCROSS JOIN `dbt`.`stg_consensus__time_helpers` t4", "relation_name": "`dbt`.`fct_consensus_forks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.185886Z", "completed_at": "2026-02-12T22:49:46.191343Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.191963Z", "completed_at": "2026-02-12T22:49:46.191971Z"}], "thread_id": "Thread-1", "execution_time": 0.007369518280029297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_blocks_daily", "compiled": true, "compiled_code": "\n\nWITH\n\ntime_helpers AS (\n    SELECT\n        genesis_time_unix,\n        seconds_per_slot\n    FROM \n        `dbt`.`stg_consensus__time_helpers`\n)\n\nSELECT\n    date\n    ,cnt AS blocks_produced\n    ,total_blob_commitments\n    ,blocks_with_zero_blob_commitments\n    ,CASE\n        WHEN toStartOfDay(toDateTime(genesis_time_unix)) = date \n            THEN CAST((86400 - toUnixTimestamp(toDateTime(genesis_time_unix)) % 86400) / seconds_per_slot - cnt AS UInt64)\n        ELSE CAST(86400 / seconds_per_slot - cnt AS UInt64)\n    END AS blocks_missed\nFROM (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date\n        ,COUNT(*) AS cnt\n        ,SUM(blob_kzg_commitments_count) AS total_blob_commitments\n        ,SUM(IF(blob_kzg_commitments_count = 0, 1, 0)) AS blocks_with_zero_blob_commitments\n    FROM `dbt`.`stg_consensus__blocks`\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_blocks_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_blocks_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    GROUP BY 1\n) t1\nCROSS JOIN time_helpers t2", "relation_name": "`dbt`.`int_consensus_blocks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.194890Z", "completed_at": "2026-02-12T22:49:46.200103Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.200722Z", "completed_at": "2026-02-12T22:49:46.200730Z"}], "thread_id": "Thread-1", "execution_time": 0.007173061370849609, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_credentials_daily", "compiled": true, "compiled_code": "\n\n\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,leftUTF8(withdrawal_credentials, 4) AS credentials_type\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__validators`\n\n  \n    \n    \n\n   WHERE \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_credentials_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_credentials_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_credentials_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.203791Z", "completed_at": "2026-02-12T22:49:46.209096Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.209729Z", "completed_at": "2026-02-12T22:49:46.209737Z"}], "thread_id": "Thread-1", "execution_time": 0.007540702819824219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_entry_queue_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nqueue_activation AS (\n    SELECT\n        validator_index\n        ,date\n        ,epoch_eligibility\n        ,epoch_activation\n        ,(epoch_activation - epoch_eligibility) * 16 * 5 /(60 * 60 * 24) AS activation_days\n    FROM (\n        SELECT \n            validator_index\n            ,toStartOfDay(argMin(slot_timestamp,slot)) AS date\n            ,argMin(activation_eligibility_epoch,slot) AS epoch_eligibility\n            ,argMin(activation_epoch,slot) AS epoch_activation\n        FROM `dbt`.`stg_consensus__validators`\n        WHERE \n            activation_epoch < 18446744073709551615\n            \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_entry_queue_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_entry_queue_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n        GROUP BY 1\n    )\n)\n\nSELECT\n    date\n    ,validator_count\n    ,q_activation[1] AS q05\n    ,q_activation[2] AS q10\n    ,q_activation[3] AS q25\n    ,q_activation[4] AS q50\n    ,q_activation[5] AS q75\n    ,q_activation[6] AS q90\n    ,q_activation[7] AS q95\n    ,mean\nFROM (\n    SELECT\n        date,\n        count() AS validator_count\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(activation_days) AS q_activation\n        ,avg(activation_days) AS  mean\n    FROM queue_activation\n    GROUP BY date\n)", "relation_name": "`dbt`.`int_consensus_entry_queue_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.212580Z", "completed_at": "2026-02-12T22:49:46.218003Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.218644Z", "completed_at": "2026-02-12T22:49:46.218651Z"}], "thread_id": "Thread-1", "execution_time": 0.007438182830810547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_balances_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,SUM(balance/POWER(10,9)) AS balance\n    ,SUM(effective_balance/POWER(10,9)) AS effective_balance\nFROM `dbt`.`stg_consensus__validators`\nWHERE \n    slot_timestamp < today()\n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_validators_balances_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_validators_balances_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\nGROUP BY date", "relation_name": "`dbt`.`int_consensus_validators_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.221580Z", "completed_at": "2026-02-12T22:49:46.226913Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.227912Z", "completed_at": "2026-02-12T22:49:46.227921Z"}], "thread_id": "Thread-1", "execution_time": 0.007807254791259766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_status_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,status\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__validators`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_validators_status_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_validators_status_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_validators_status_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.230780Z", "completed_at": "2026-02-12T22:49:46.237304Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.237935Z", "completed_at": "2026-02-12T22:49:46.237942Z"}], "thread_id": "Thread-1", "execution_time": 0.008581876754760742, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_withdrawal_credentials_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,withdrawal_credentials\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__validators`\nWHERE\n    slot_timestamp < today()\n    AND status LIKE 'active_%'\n\n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_withdrawal_credentials_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_withdrawal_credentials_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_withdrawal_credentials_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.240751Z", "completed_at": "2026-02-12T22:49:46.245293Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.245883Z", "completed_at": "2026-02-12T22:49:46.245890Z"}], "thread_id": "Thread-1", "execution_time": 0.0064089298248291016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__validators_slot_timestamp.e395d1a15a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__validators`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.248545Z", "completed_at": "2026-02-12T22:49:46.252964Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.253546Z", "completed_at": "2026-02-12T22:49:46.253553Z"}], "thread_id": "Thread-1", "execution_time": 0.006289005279541016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__validators_validator_index.3356b32a86", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect validator_index\nfrom `dbt`.`stg_consensus__validators`\nwhere validator_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.256244Z", "completed_at": "2026-02-12T22:49:46.260632Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.261195Z", "completed_at": "2026-02-12T22:49:46.261202Z"}], "thread_id": "Thread-1", "execution_time": 0.006220102310180664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_consensus__validators_validator_index.e1e5562382", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    validator_index as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_consensus__validators`\nwhere validator_index is not null\ngroup by validator_index\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.263926Z", "completed_at": "2026-02-12T22:49:46.271500Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.272100Z", "completed_at": "2026-02-12T22:49:46.272107Z"}], "thread_id": "Thread-1", "execution_time": 0.009472131729125977, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_deposits_withdrawals_daily", "compiled": true, "compiled_code": "\n\nWITH\n\ndeposists AS (\n    SELECT \n        toStartOfDay(slot_timestamp) AS date\n        ,SUM(amount) AS amount\n        ,COUNT(*) AS cnt\n    FROM `dbt`.`stg_consensus__deposits`\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_deposits_withdrawals_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_deposits_withdrawals_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    GROUP BY 1\n),\n\ndeposists_requests AS (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date\n        ,SUM(toUInt64(JSONExtractString(deposit, 'amount'))) AS amount\n        ,COUNT() AS cnt\n    FROM `dbt`.`stg_consensus__execution_requests`\n    ARRAY JOIN JSONExtractArrayRaw(payload, 'deposits') AS deposit\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_deposits_withdrawals_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_deposits_withdrawals_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    GROUP BY 1\n),\n\nwithdrawals AS (\n    SELECT \n        toStartOfDay(slot_timestamp) AS date \n        ,SUM(amount) AS amount\n        ,COUNT(*) AS cnt\n    FROM `dbt`.`stg_consensus__withdrawals`\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_deposits_withdrawals_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_deposits_withdrawals_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    GROUP BY 1\n)\n\n\nSELECT\n    label\n    ,date\n    ,SUM(amount/POWER(10,9)) AS total_amount\n    ,SUM(cnt) AS cnt\nFROM (\n    SELECT 'Deposits' AS label, * FROM deposists\n    UNION ALL\n    SELECT 'Deposits' AS label, * FROM deposists_requests\n    UNION ALL\n    SELECT 'Withdrawals' AS label, * FROM withdrawals\n)\nGROUP BY label, date", "relation_name": "`dbt`.`int_consensus_deposits_withdrawals_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.275064Z", "completed_at": "2026-02-12T22:49:46.368879Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.369569Z", "completed_at": "2026-02-12T22:49:46.369579Z"}], "thread_id": "Thread-1", "execution_time": 0.0959467887878418, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_per_index_apy_daily", "compiled": true, "compiled_code": "\n\n\n\n\n\n\nWITH\n\nwithdrawals AS (\n    SELECT \n        toStartOfDay(slot_timestamp) AS date \n        ,validator_index\n        ,SUM(amount) AS amount\n    FROM `dbt`.`stg_consensus__withdrawals`\n    WHERE\n        1=1\n        \n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_validators_per_index_apy_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_validators_per_index_apy_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n        \n    GROUP BY 1, 2\n),\n\n\n\ncurrent_partition AS (\n    SELECT \n        max(toStartOfMonth(date)) AS month\n        ,max(date)  AS max_date\n    FROM `dbt`.`int_consensus_validators_per_index_apy_daily`\n    \n),\nprev_balance AS (\n    SELECT \n        t1.validator_index\n        ,argMax(t1.balance, t1.date) AS balance\n        ,argMax(t1.withdrawaled_amount, t1.date) AS withdrawaled_amount\n    FROM `dbt`.`int_consensus_validators_per_index_apy_daily` t1\n    CROSS JOIN current_partition t2\n    WHERE \n        toStartOfMonth(t1.date) = t2.month\n        \n        AND \n        t1.date < t2.max_date\n        \n    GROUP BY t1.validator_index\n),\n\n\nvalidators AS (\n    SELECT\n        toStartOfDay(t1.slot_timestamp, 'UTC') AS date,\n        t1.validator_index,\n        t1.pubkey,\n        t1.balance,\n        COALESCE(\n            lagInFrame(toNullable(t1.balance), 1, NULL) OVER (\n                PARTITION BY t1.validator_index\n                ORDER BY date\n                ROWS BETWEEN 1 PRECEDING AND CURRENT ROW\n            ),\n            \n                t2.balance\n            \n        ) AS prev_balance,\n        COALESCE(t3.amount,0) AS withdrawaled_amount,\n        COALESCE(\n            lagInFrame(toNullable(t3.amount), 1, NULL) OVER (\n                PARTITION BY t3.validator_index\n                ORDER BY date\n                ROWS BETWEEN 1 PRECEDING AND CURRENT ROW\n            ),\n            \n                t2.withdrawaled_amount\n            \n        ) AS prev_withdrawaled_amount,\n        t1.balance - prev_balance AS balance_diff,\n        t1.status AS status\n    FROM `dbt`.`stg_consensus__validators` t1\n    \n    LEFT JOIN prev_balance t2\n    ON t2.validator_index = t1.validator_index\n    \n    LEFT JOIN withdrawals t3\n    ON t3.date = toStartOfDay(t1.slot_timestamp, 'UTC')\n    AND t3.validator_index = t1.validator_index\n    WHERE\n        (t1.status LIKE 'active_%' OR t1.status = 'pending_queued')\n        \n        \n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(slot_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_validators_per_index_apy_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(slot_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_validators_per_index_apy_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n        \n)\n\nSELECT \n    t1.date AS date\n    ,t1.validator_index AS validator_index\n    ,t1.status AS status\n    ,t1.balance AS balance\n    ,t1.balance - t1.prev_balance AS balance_diff_original\n    ,t1.withdrawaled_amount AS withdrawaled_amount\n    ,greatest(\n            -- balance + withdrawaled_amount mod 32 mGNO ()\n            t1.balance + t1.withdrawaled_amount \n            - MOD(t1.balance + t1.withdrawaled_amount,32000000000) \n            + toUInt64(roundBankers(MOD(t1.balance + t1.withdrawaled_amount, 32000000000) / 32000000000) * 32000000000)\n\n        - (\n            -- balance + withdrawaled_amount mod 32 mGNO ()\n            t1.prev_balance + t1.prev_withdrawaled_amount \n            - MOD(t1.prev_balance + t1.prev_withdrawaled_amount,32000000000)\n            + toUInt64(roundBankers(MOD(t1.prev_balance + t1.prev_withdrawaled_amount, 32000000000) / 32000000000) * 32000000000)\n        )\n    ,0) AS deposited_amount\n    ,balance_diff_original - deposited_amount + withdrawaled_amount AS eff_balance_diff\n   -- ,eff_balance_diff/IF(t1.prev_balance=0, deposited_amount, toInt64(t1.prev_balance)) AS rate\n    ,eff_balance_diff/(toInt64(t1.prev_balance) + deposited_amount) AS rate\n    ,ROUND((POWER((1+rate),365) - 1) * 100,2) AS apy\nFROM validators t1", "relation_name": "`dbt`.`int_consensus_validators_per_index_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.372553Z", "completed_at": "2026-02-12T22:49:46.377470Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.378059Z", "completed_at": "2026-02-12T22:49:46.378067Z"}], "thread_id": "Thread-1", "execution_time": 0.006987094879150391, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__withdrawals_block_hash.ca4d2a4653", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect block_hash\nfrom `dbt`.`stg_consensus__withdrawals`\nwhere block_hash is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.380772Z", "completed_at": "2026-02-12T22:49:46.385221Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.385836Z", "completed_at": "2026-02-12T22:49:46.385844Z"}], "thread_id": "Thread-1", "execution_time": 0.006325483322143555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__withdrawals_slot_timestamp.572376d120", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect slot_timestamp\nfrom `dbt`.`stg_consensus__withdrawals`\nwhere slot_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.388615Z", "completed_at": "2026-02-12T22:49:46.393021Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.393631Z", "completed_at": "2026-02-12T22:49:46.393638Z"}], "thread_id": "Thread-1", "execution_time": 0.006404399871826172, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__withdrawals_validator_index.a457d1ccde", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect validator_index\nfrom `dbt`.`stg_consensus__withdrawals`\nwhere validator_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.396319Z", "completed_at": "2026-02-12T22:49:46.400804Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.401372Z", "completed_at": "2026-02-12T22:49:46.401379Z"}], "thread_id": "Thread-1", "execution_time": 0.006403446197509766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_consensus__withdrawals_withdrawal_index.6ed4b7c2a7", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect withdrawal_index\nfrom `dbt`.`stg_consensus__withdrawals`\nwhere withdrawal_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.404082Z", "completed_at": "2026-02-12T22:49:46.408496Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.409075Z", "completed_at": "2026-02-12T22:49:46.409083Z"}], "thread_id": "Thread-1", "execution_time": 0.006330251693725586, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_consensus__withdrawals_block_hash.376679d9e9", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    block_hash as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_consensus__withdrawals`\nwhere block_hash is not null\ngroup by block_hash\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.411808Z", "completed_at": "2026-02-12T22:49:46.417375Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.417964Z", "completed_at": "2026-02-12T22:49:46.417971Z"}], "thread_id": "Thread-1", "execution_time": 0.007445335388183594, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_consensus__withdrawals_validator_index.464577ebff", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    validator_index as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_consensus__withdrawals`\nwhere validator_index is not null\ngroup by validator_index\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.420773Z", "completed_at": "2026-02-12T22:49:46.426284Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.426938Z", "completed_at": "2026-02-12T22:49:46.426945Z"}], "thread_id": "Thread-1", "execution_time": 0.007555484771728516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_bridges_flows_daily", "compiled": true, "compiled_code": "\n\n-- Production version: Aggregates transaction-level data to daily\n\nWITH base AS (\n    SELECT\n        toDate(timestamp) AS date, \n        bridge,\n        source_chain,\n        dest_chain,\n        token,\n        direction,\n        sum(amount_token) AS volume_token,\n        sum(amount_usd) AS volume_usd,\n        sum(net_usd) AS net_usd,\n        count() AS txs \n    FROM `dbt`.`stg_crawlers_data__dune_bridge_flows`\n    WHERE timestamp < today()\n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_bridges_flows_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_bridges_flows_daily` AS x2\n      WHERE 1=1 \n    )\n  \n \n    GROUP BY date, bridge, source_chain, dest_chain, token, direction\n)\n\nSELECT * FROM base", "relation_name": "`dbt`.`int_bridges_flows_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.429842Z", "completed_at": "2026-02-12T22:49:46.434764Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.435345Z", "completed_at": "2026-02-12T22:49:46.435352Z"}], "thread_id": "Thread-1", "execution_time": 0.0069882869720458984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_bridge_flows_bridge.6a40a61451", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect bridge\nfrom `dbt`.`stg_crawlers_data__dune_bridge_flows`\nwhere bridge is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.438036Z", "completed_at": "2026-02-12T22:49:46.442435Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.443006Z", "completed_at": "2026-02-12T22:49:46.443013Z"}], "thread_id": "Thread-1", "execution_time": 0.006235599517822266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_bridge_flows_dest_chain.7493c99994", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect dest_chain\nfrom `dbt`.`stg_crawlers_data__dune_bridge_flows`\nwhere dest_chain is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.445695Z", "completed_at": "2026-02-12T22:49:46.450190Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.450778Z", "completed_at": "2026-02-12T22:49:46.450785Z"}], "thread_id": "Thread-1", "execution_time": 0.00635981559753418, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_bridge_flows_source_chain.46658efe1d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect source_chain\nfrom `dbt`.`stg_crawlers_data__dune_bridge_flows`\nwhere source_chain is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.453456Z", "completed_at": "2026-02-12T22:49:46.459100Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.459702Z", "completed_at": "2026-02-12T22:49:46.459709Z"}], "thread_id": "Thread-1", "execution_time": 0.007584333419799805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_bridge_flows_timestamp.0ab9971d11", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect timestamp\nfrom `dbt`.`stg_crawlers_data__dune_bridge_flows`\nwhere timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.462362Z", "completed_at": "2026-02-12T22:49:46.466796Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.467360Z", "completed_at": "2026-02-12T22:49:46.467368Z"}], "thread_id": "Thread-1", "execution_time": 0.0063364505767822266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_bridge_flows_token.47697e500b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect token\nfrom `dbt`.`stg_crawlers_data__dune_bridge_flows`\nwhere token is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.470021Z", "completed_at": "2026-02-12T22:49:46.475300Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.475885Z", "completed_at": "2026-02-12T22:49:46.475892Z"}], "thread_id": "Thread-1", "execution_time": 0.007169246673583984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_bridges_flows_daily_v2", "compiled": true, "compiled_code": "\n\n-- V2: Passthrough version - expects pre-aggregated daily data from staging\n-- Use this version when Dune queries are updated to output daily aggregates\n\nSELECT\n    date,\n    bridge,\n    source_chain,\n    dest_chain,\n    token,\n    direction,\n    volume_token,\n    volume_usd,\n    net_usd,\n    txs\nFROM `dbt`.`stg_crawlers_data__dune_bridge_flows_v2`\nWHERE date < today()\n\n  \n", "relation_name": "`dbt`.`int_bridges_flows_daily_v2`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.478636Z", "completed_at": "2026-02-12T22:49:46.482553Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.483156Z", "completed_at": "2026-02-12T22:49:46.483164Z"}], "thread_id": "Thread-1", "execution_time": 0.005901336669921875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_crawlers_data_gno_supply_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  label,\n  block_date AS date,\n  supply    \nFROM `dbt`.`stg_crawlers_data__dune_gno_supply`\nORDER BY date, label", "relation_name": "`dbt`.`api_crawlers_data_gno_supply_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.486044Z", "completed_at": "2026-02-12T22:49:46.494009Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.494656Z", "completed_at": "2026-02-12T22:49:46.494664Z"}], "thread_id": "Thread-1", "execution_time": 0.009998083114624023, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_info_daily", "compiled": true, "compiled_code": "\n\n\n\nWITH deduped_transactions AS (\n    SELECT\n        block_timestamp,\n        transaction_type,\n        success,\n        CAST(value_string AS UInt256) AS value,\n        gas_used,\n        gas_price\n    FROM (\n        \n\nSELECT block_timestamp, transaction_type, success, value_string, gas_used, gas_price\nFROM (\n    SELECT\n        block_timestamp, transaction_type, success, value_string, gas_used, gas_price,\n        ROW_NUMBER() OVER (\n            PARTITION BY block_number, transaction_index\n            ORDER BY insert_version DESC\n        ) AS _dedup_rn\n    FROM `execution`.`transactions`\n    \n    WHERE \n    block_timestamp < today()\n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_transactions_info_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_transactions_info_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n\n    \n)\nWHERE _dedup_rn = 1\n\n    )\n),\n\ntx AS (\n  SELECT\n    block_timestamp,\n    toDate(block_timestamp)             AS date,\n    toString(transaction_type)          AS transaction_type,\n    coalesce(success, 0)                AS success,\n    toFloat64(value) / 1e18             AS value_native,\n    toFloat64(coalesce(gas_used, 0))    AS gas_used,\n    toFloat64(coalesce(gas_price, 0))   AS gas_price\n  FROM deduped_transactions\n),\n\nagg_base AS (\n  SELECT\n    date,\n    transaction_type,\n    success,\n    COUNT()                     AS n_txs,\n    SUM(value_native)           AS xdai_value_sum_raw,\n    AVG(value_native)           AS xdai_value_avg_raw,\n    median(value_native)        AS xdai_value_median_raw,\n    SUM(gas_used)               AS gas_used_sum_raw,          -- \u201cgas units\u201d\n    AVG(gas_price)              AS gas_price_avg_raw_wei,     -- in wei\n    median(gas_price)           AS gas_price_med_raw_wei,     -- in wei\n    SUM(gas_used * gas_price)   AS fee_sum_raw_wei            -- in wei\n  FROM tx\n  GROUP BY date, transaction_type, success\n),\n\nagg AS (\n  SELECT\n    date,\n    transaction_type,\n    success,\n    n_txs,\n    xdai_value_sum_raw                       AS xdai_value,\n    xdai_value_avg_raw                       AS xdai_value_avg,\n    xdai_value_median_raw                    AS xdai_value_median,\n    gas_used_sum_raw                         AS gas_used,\n    CAST(gas_price_avg_raw_wei / 1e9 AS Int32)   AS gas_price_avg,       -- Gwei\n    CAST(gas_price_med_raw_wei / 1e9 AS Int32)   AS gas_price_median,    -- Gwei\n    fee_sum_raw_wei / 1e18                   AS fee_native_sum          -- xDai\n  FROM agg_base\n),\n\npx AS (\n  SELECT\n    date,\n    price\n  FROM `dbt`.`stg_crawlers_data__dune_prices`\n  WHERE symbol = 'XDAI'\n  \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_transactions_info_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(date) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_transactions_info_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n)\n\nSELECT\n  a.date,\n  a.transaction_type,\n  a.success,\n  a.n_txs,\n  a.xdai_value,\n  a.xdai_value_avg,\n  a.xdai_value_median,\n  a.gas_used,\n  a.gas_price_avg,\n  a.gas_price_median,\n  a.fee_native_sum,\n  a.fee_native_sum * coalesce(px.price, 1.0) AS fee_usd_sum\nFROM agg a\nLEFT JOIN px\n  ON px.date = a.date", "relation_name": "`dbt`.`int_execution_transactions_info_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.497470Z", "completed_at": "2026-02-12T22:49:46.503363Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.503971Z", "completed_at": "2026-02-12T22:49:46.503978Z"}], "thread_id": "Thread-1", "execution_time": 0.007858753204345703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_prices_date.a7e4d781b8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`stg_crawlers_data__dune_prices`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.506769Z", "completed_at": "2026-02-12T22:49:46.512576Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.513189Z", "completed_at": "2026-02-12T22:49:46.513196Z"}], "thread_id": "Thread-1", "execution_time": 0.007726192474365234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_carbon_intensity_ensemble", "compiled": true, "compiled_code": "\n\nWITH ember_monthly AS (\n    -- Monthly carbon intensity from Ember with enhanced uncertainty\n    SELECT\n        toDate(\"Date\") AS month_date,\n        CASE \n            WHEN \"Area\" = 'World' THEN 'WORLD'  -- World average as special country code\n            ELSE \"ISO 3 code\"\n        END AS country_code,\n        \"Value\" AS carbon_intensity_gco2_kwh,\n        COALESCE(\"Continent\", 'World') AS continent,\n        'ember' AS source,\n        0.85 AS base_confidence\n    FROM `dbt`.`stg_crawlers_data__ember_electricity_data`\n    WHERE   \n        \"Unit\" = 'gCO2/kWh'\n        AND (\n            (\"ISO 3 code\" IS NOT NULL AND \"ISO 3 code\" != '') OR \n            (\"Area\" = 'World')  -- Include World data\n        )\n        AND \"Value\" IS NOT NULL\n        AND \"Value\" > 0\n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(\"Date\")) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.month_date)), -0))\n      FROM `dbt`.`int_esg_carbon_intensity_ensemble` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(\"Date\") >= (\n      SELECT addDays(max(toDate(x2.month_date)), -0)\n      FROM `dbt`.`int_esg_carbon_intensity_ensemble` AS x2\n      WHERE 1=1 \n    )\n  \n\n),\n\n-- Enhanced uncertainty modeling for monthly data\nuncertainty_enhanced AS (\n    SELECT\n        month_date,\n        country_code,\n        continent,\n        carbon_intensity_gco2_kwh AS base_ci,\n        \n        -- Calculate temporal uncertainty based on grid characteristics\n        -- Higher uncertainty for countries with more variable generation\n        carbon_intensity_gco2_kwh * (\n            CASE \n                -- High renewable countries have more temporal variation\n                WHEN carbon_intensity_gco2_kwh < 100 THEN 0.25  -- Low carbon grids (solar/wind heavy)\n                WHEN carbon_intensity_gco2_kwh < 300 THEN 0.20  -- Medium carbon grids  \n                WHEN carbon_intensity_gco2_kwh < 600 THEN 0.15  -- High carbon grids (more stable)\n                ELSE 0.12  -- Very high carbon grids (coal/gas baseload)\n            END\n        ) AS temporal_uncertainty,\n        \n        -- Data quality uncertainty (monthly averages hide daily/hourly variation)\n        carbon_intensity_gco2_kwh * 0.10 AS measurement_uncertainty,\n        \n        -- Continent-based seasonal adjustment factors\n        CASE continent\n            -- Europe & Asia (mostly Northern Hemisphere, heating-dominant)\n            WHEN 'Europe' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.18  -- Winter heating peak\n                    WHEN month(month_date) IN (6, 7, 8) THEN 0.92   -- Summer low + solar\n                    WHEN month(month_date) IN (3, 4, 11) THEN 1.08  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- Asia (mix of climates, but mostly Northern Hemisphere)\n            WHEN 'Asia' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.12  -- Winter (heating + industrial)\n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.08   -- Summer (cooling demand)\n                    WHEN month(month_date) IN (4, 5, 9, 10) THEN 1.05  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- North America (heating-dominant north, cooling-dominant south)\n            WHEN 'North America' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.15  -- Winter heating\n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.12   -- Summer cooling\n                    WHEN month(month_date) IN (4, 5, 9, 10) THEN 1.03  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- Oceania (Southern Hemisphere - reversed seasons)\n            WHEN 'Oceania' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.15   -- Southern winter\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.95  -- Southern summer\n                    WHEN month(month_date) IN (3, 4, 9, 10) THEN 1.05  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- South America (Southern Hemisphere + tropical)\n            WHEN 'South America' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.10   -- Southern winter (milder)\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.98  -- Southern summer\n                    ELSE 1.0\n                END\n                \n            -- Africa (mix of Northern/Southern + tropical, minimal variation)\n            WHEN 'Africa' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.05   -- Slight dry season effect\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.98  -- Wet season\n                    ELSE 1.0\n                END\n                \n            -- World/Default (minimal adjustment)\n            ELSE 1.0\n        END AS seasonal_factor,\n        \n        source,\n        base_confidence\n        \n    FROM ember_monthly\n),\n\n-- Final aggregation with confidence intervals\nfinal_estimates AS (\n    SELECT\n        month_date,\n        country_code,\n        \n        -- Point estimates with seasonal adjustment\n        round(base_ci * seasonal_factor, 2) AS carbon_intensity_mean,\n        \n        -- Combined uncertainty (temporal + measurement)\n        round(sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS carbon_intensity_std,\n        \n        -- Confidence intervals for Monte Carlo sampling\n        round(greatest(0, base_ci * seasonal_factor - 1.96 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2))), 2) AS ci_lower_95,\n        round(base_ci * seasonal_factor + 1.96 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS ci_upper_95,\n        \n        round(greatest(0, base_ci * seasonal_factor - 1.645 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2))), 2) AS ci_lower_90,\n        round(base_ci * seasonal_factor + 1.645 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS ci_upper_90,\n        \n        -- Coefficient of variation for uncertainty assessment\n        round(sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor), 3) AS coefficient_of_variation,\n        \n        -- Raw values for diagnostics\n        round(base_ci, 2) AS base_carbon_intensity,\n        round(temporal_uncertainty, 2) AS temporal_std,\n        round(measurement_uncertainty, 2) AS measurement_std,\n        round(seasonal_factor, 3) AS seasonal_adjustment,\n        continent,\n        \n        -- Data quality indicators\n        arrayPushFront([], source) AS sources_used,\n        base_confidence AS confidence_score,\n        1 AS n_sources,\n        \n        -- Uncertainty category for diagnostics\n        CASE \n            WHEN sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor) < 0.15 THEN 'Low'\n            WHEN sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor) < 0.25 THEN 'Medium' \n            ELSE 'High'\n        END AS uncertainty_category\n        \n    FROM uncertainty_enhanced\n)\n\nSELECT\n    month_date,\n    country_code,\n    \n    -- Core metrics for carbon footprint calculation\n    carbon_intensity_mean,\n    carbon_intensity_std,\n    ci_lower_95,\n    ci_upper_95,\n    ci_lower_90,\n    ci_upper_90,\n    \n    -- Uncertainty analysis\n    coefficient_of_variation,\n    uncertainty_category,\n    \n    -- Component breakdown for diagnostics\n    base_carbon_intensity,\n    temporal_std,\n    measurement_std,\n    seasonal_adjustment,\n    \n    -- Data provenance and quality\n    sources_used,\n    confidence_score,\n    n_sources,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM final_estimates", "relation_name": "`dbt`.`int_esg_carbon_intensity_ensemble`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.515938Z", "completed_at": "2026-02-12T22:49:46.520400Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.520992Z", "completed_at": "2026-02-12T22:49:46.521000Z"}], "thread_id": "Thread-1", "execution_time": 0.006328105926513672, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__ember_electricity_data_Date.d1114ec663", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect Date\nfrom `dbt`.`stg_crawlers_data__ember_electricity_data`\nwhere Date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.523749Z", "completed_at": "2026-02-12T22:49:46.527680Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.528286Z", "completed_at": "2026-02-12T22:49:46.528294Z"}], "thread_id": "Thread-1", "execution_time": 0.005908489227294922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,any_value(toInt32(floor(__total))) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d` \nGROUP BY 1, 2\nORDER BY date ASC, client ASC", "relation_name": "`dbt`.`api_probelab_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.531174Z", "completed_at": "2026-02-12T22:49:46.535120Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.535736Z", "completed_at": "2026-02-12T22:49:46.535744Z"}], "thread_id": "Thread-1", "execution_time": 0.006029605865478516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_version_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,agent_version_semver_str AS version\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d` \nORDER BY date ASC, client ASC, version ASC", "relation_name": "`dbt`.`api_probelab_clients_version_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.538517Z", "completed_at": "2026-02-12T22:49:46.543382Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.543975Z", "completed_at": "2026-02-12T22:49:46.543982Z"}], "thread_id": "Thread-1", "execution_time": 0.006742000579833984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_agent_semvers_avg_1d_max_crawl_created_at.8219363436", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect max_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d`\nwhere max_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.546675Z", "completed_at": "2026-02-12T22:49:46.552728Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.553304Z", "completed_at": "2026-02-12T22:49:46.553311Z"}], "thread_id": "Thread-1", "execution_time": 0.007909536361694336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_agent_semvers_avg_1d_min_crawl_created_at.c13768a358", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect min_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d`\nwhere min_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.556035Z", "completed_at": "2026-02-12T22:49:46.559912Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.560524Z", "completed_at": "2026-02-12T22:49:46.560532Z"}], "thread_id": "Thread-1", "execution_time": 0.005826711654663086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_cloud_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,cloud_provider AS cloud\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d` \nORDER BY date ASC, client ASC, cloud ASC", "relation_name": "`dbt`.`api_probelab_clients_cloud_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.563300Z", "completed_at": "2026-02-12T22:49:46.567989Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.568578Z", "completed_at": "2026-02-12T22:49:46.568585Z"}], "thread_id": "Thread-1", "execution_time": 0.006554603576660156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_cloud_provider_avg_1d_max_crawl_created_at.d05a72e66c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect max_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d`\nwhere max_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.571210Z", "completed_at": "2026-02-12T22:49:46.575879Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.576461Z", "completed_at": "2026-02-12T22:49:46.576469Z"}], "thread_id": "Thread-1", "execution_time": 0.006510734558105469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_cloud_provider_avg_1d_min_crawl_created_at.68ec277b94", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect min_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d`\nwhere min_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.579210Z", "completed_at": "2026-02-12T22:49:46.583083Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.583693Z", "completed_at": "2026-02-12T22:49:46.583700Z"}], "thread_id": "Thread-1", "execution_time": 0.005774021148681641, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_country_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,country\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_countries_avg_1d` \nORDER BY date ASC, client ASC, country ASC", "relation_name": "`dbt`.`api_probelab_clients_country_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.586482Z", "completed_at": "2026-02-12T22:49:46.592324Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.592916Z", "completed_at": "2026-02-12T22:49:46.592923Z"}], "thread_id": "Thread-1", "execution_time": 0.007850885391235352, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_countries_avg_1d_max_crawl_created_at.b401aa1bdb", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect max_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_countries_avg_1d`\nwhere max_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.595563Z", "completed_at": "2026-02-12T22:49:46.600249Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.600840Z", "completed_at": "2026-02-12T22:49:46.600847Z"}], "thread_id": "Thread-1", "execution_time": 0.006540775299072266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_countries_avg_1d_min_crawl_created_at.69cddc52ad", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect min_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_countries_avg_1d`\nwhere min_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.603576Z", "completed_at": "2026-02-12T22:49:46.607406Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.608020Z", "completed_at": "2026-02-12T22:49:46.608028Z"}], "thread_id": "Thread-1", "execution_time": 0.005759239196777344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_quic_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,quic_support AS quic\n    ,__count AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_quic_support_over_7d` \nORDER BY date ASC, client ASC, quic ASC", "relation_name": "`dbt`.`api_probelab_clients_quic_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.610789Z", "completed_at": "2026-02-12T22:49:46.615453Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.616024Z", "completed_at": "2026-02-12T22:49:46.616031Z"}], "thread_id": "Thread-1", "execution_time": 0.006623983383178711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_quic_support_over_7d_crawl_created_at.18c921e476", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_quic_support_over_7d`\nwhere crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.618737Z", "completed_at": "2026-02-12T22:49:46.623453Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.624027Z", "completed_at": "2026-02-12T22:49:46.624034Z"}], "thread_id": "Thread-1", "execution_time": 0.006605386734008789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_quic_support_over_7d_max_crawl_created_at.5d67ad70ef", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect max_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_quic_support_over_7d`\nwhere max_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.626701Z", "completed_at": "2026-02-12T22:49:46.631519Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.632085Z", "completed_at": "2026-02-12T22:49:46.632093Z"}], "thread_id": "Thread-1", "execution_time": 0.006696939468383789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__probelab_quic_support_over_7d_min_crawl_created_at.4d6a3c258b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect min_crawl_created_at\nfrom `dbt`.`stg_crawlers_data__probelab_quic_support_over_7d`\nwhere min_crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.634834Z", "completed_at": "2026-02-12T22:49:46.641333Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.641948Z", "completed_at": "2026-02-12T22:49:46.641955Z"}], "thread_id": "Thread-1", "execution_time": 0.008456707000732422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_state_size_full_diff_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\n\nstate_size_diff AS (\n    SELECT \n        toStartOfDay(block_timestamp) AS date \n        ,SUM(IF(to_value!='0000000000000000000000000000000000000000000000000000000000000000',32,-32)) AS bytes_diff\n    FROM \n        `dbt`.`stg_execution__storage_diffs`\n    \n  \n    \n    \n\n   WHERE \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_state_size_full_diff_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_state_size_full_diff_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT\n    *\nFROM state_size_diff", "relation_name": "`dbt`.`int_execution_state_size_full_diff_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.644742Z", "completed_at": "2026-02-12T22:49:46.649344Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.649965Z", "completed_at": "2026-02-12T22:49:46.649972Z"}], "thread_id": "Thread-1", "execution_time": 0.0065593719482421875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__storage_diffs_transaction_hash.355bce9dc8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect transaction_hash\nfrom `dbt`.`stg_execution__storage_diffs`\nwhere transaction_hash is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.652626Z", "completed_at": "2026-02-12T22:49:46.657032Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.657620Z", "completed_at": "2026-02-12T22:49:46.657628Z"}], "thread_id": "Thread-1", "execution_time": 0.0062410831451416016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_execution__storage_diffs_transaction_index.c3d3eabba2", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect transaction_index\nfrom `dbt`.`stg_execution__storage_diffs`\nwhere transaction_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.660275Z", "completed_at": "2026-02-12T22:49:46.664695Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.665260Z", "completed_at": "2026-02-12T22:49:46.665267Z"}], "thread_id": "Thread-1", "execution_time": 0.006302833557128906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_execution__storage_diffs_transaction_hash.ead3d5cd43", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    transaction_hash as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_execution__storage_diffs`\nwhere transaction_hash is not null\ngroup by transaction_hash\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.667929Z", "completed_at": "2026-02-12T22:49:46.672654Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.673231Z", "completed_at": "2026-02-12T22:49:46.673238Z"}], "thread_id": "Thread-1", "execution_time": 0.006561994552612305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__discovery_id_prefixes_x_peer_ids_peer_id.fa91b6f34a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.675873Z", "completed_at": "2026-02-12T22:49:46.681721Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.682287Z", "completed_at": "2026-02-12T22:49:46.682294Z"}], "thread_id": "Thread-1", "execution_time": 0.007663726806640625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv4__discovery_id_prefixes_x_peer_ids_peer_id.ee76ad9364", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.684981Z", "completed_at": "2026-02-12T22:49:46.689448Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.690024Z", "completed_at": "2026-02-12T22:49:46.690032Z"}], "thread_id": "Thread-1", "execution_time": 0.0063648223876953125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__neighbors_crawl_created_at.08104da64e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_created_at\nfrom `dbt`.`stg_nebula_discv4__neighbors`\nwhere crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.692678Z", "completed_at": "2026-02-12T22:49:46.697104Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.697688Z", "completed_at": "2026-02-12T22:49:46.697696Z"}], "thread_id": "Thread-1", "execution_time": 0.006262302398681641, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__neighbors_crawl_id.8726626b01", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_id\nfrom `dbt`.`stg_nebula_discv4__neighbors`\nwhere crawl_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.700319Z", "completed_at": "2026-02-12T22:49:46.704718Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.705274Z", "completed_at": "2026-02-12T22:49:46.705281Z"}], "thread_id": "Thread-1", "execution_time": 0.006264448165893555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv4__neighbors_crawl_id.8f71244658", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    crawl_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv4__neighbors`\nwhere crawl_id is not null\ngroup by crawl_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.708041Z", "completed_at": "2026-02-12T22:49:46.715524Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.716129Z", "completed_at": "2026-02-12T22:49:46.716136Z"}], "thread_id": "Thread-1", "execution_time": 0.00946354866027832, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_peers", "compiled": true, "compiled_code": "\n\n\n\n\nWITH\n\n  peers AS (\n    SELECT \n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors\n  FROM `dbt`.`stg_nebula_discv4__visits` A\n  WHERE\n      toString(peer_properties.network_id) = '100'\n      \n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(visit_ended_at)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.visit_ended_at)), -0))\n      FROM `dbt`.`int_p2p_discv4_peers` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(visit_ended_at) >= (\n      SELECT addDays(max(toDate(x2.visit_ended_at)), -0)\n      FROM `dbt`.`int_p2p_discv4_peers` AS x2\n      WHERE 1=1 \n    )\n  \n\n      \n  ),\n\n  parsed AS (\n    SELECT\n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors,\n      -- break into slash-delimited parts\n      splitByChar('/', agent_version)                        AS slash_parts,\n      length(slash_parts)                                    AS sp_len,\n\n      -- if 4+ parts, take last two as platform+runtime; otherwise only platform\n      IF(\n        length(slash_parts) > 3,\n        arrayElement(slash_parts, sp_len-1),\n        arrayElement(slash_parts, sp_len)\n      )                                                       AS platform,\n\n      IF(\n        length(slash_parts) > 3,\n        arrayElement(slash_parts, sp_len),\n        ''\n      )                                                       AS runtime,\n\n      -- head_parts = everything before the last 1 or 2 elements\n      arraySlice(\n        slash_parts,\n        1,\n        sp_len - IF(sp_len > 3, 2, 1)\n      )                                                       AS head_parts\n\n    FROM peers\n  ),\n\n  exploded AS (\n    SELECT\n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors,\n      head_parts[1]                                          AS client,\n\n      -- if head_parts has 3 elements, the middle is variant\n      IF(\n        length(head_parts) = 3,\n        head_parts[2],\n        ''\n      )                                                       AS variant,\n\n      -- the last element of head_parts is our raw \u201cver_blob\u201d\n      arrayElement(head_parts, length(head_parts))            AS ver_blob,\n\n      platform,\n      runtime,\n\n      -- split out \u201c+\u201d-style metadata\n      IF(ver_blob LIKE '%+%', arrayElement(splitByChar('+', ver_blob), 1), ver_blob) AS pre_blob,\n      IF(ver_blob LIKE '%+%', arrayElement(splitByChar('+', ver_blob), 2), '')        AS plus_build\n\n    FROM parsed\n  ),\n\nbasic_info AS (\n  SELECT\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    --replaceRegexpAll(connect_maddr, '^/ip4/([0-9.]+)/tcp/[0-9]+$', '\\\\1') AS ip,\n    arrayElement(splitByChar('/', ifNull(connect_maddr, '')), 3) AS ip,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    IF(\n      plus_build != '',\n      arrayElement(splitByChar('-', pre_blob), 1),\n      splitByChar('-', ver_blob)[1]\n    )                                                       AS version,\n    IF(\n      plus_build != '',\n      IF(\n        length(splitByChar('-', pre_blob)) >= 2,\n        arrayElement(splitByChar('-', pre_blob), 2),\n        ''\n      ),\n      IF(\n        length(splitByChar('-', ver_blob)) = 3,\n        arrayElement(splitByChar('-', ver_blob), 2),\n        ''\n      )\n    )                                                       AS channel,\n    IF(\n      plus_build != '',\n      plus_build,\n      IF(\n        length(splitByChar('-', ver_blob)) > 1,\n        arrayElement(splitByChar('-', ver_blob), -1),\n        ''\n      )\n    )                                                       AS build,\n    platform,\n    runtime\n  FROM exploded\n)\n\nSELECT\n  t1.visit_ended_at,\n  t1.peer_id,\n  t1.agent_version,\n  t1.ip,\n  t1.peer_properties,\n  t1.crawl_error,\n  t1.dial_errors,\n  t1.client,\n  t1.variant,\n  t1.version,\n  t1.channel,\n  t1.build,\n  t1.platform,\n  t1.runtime,\n  t2.hostname   AS peer_hostname,\n  t2.city       AS peer_city,\n  t2.country    AS peer_country,\n  t2.org        AS peer_org,\n  t2.loc        AS peer_loc,\n  t2.generic_provider AS generic_provider\nFROM\n  basic_info t1\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS t2\n  ON t2.ip = t1.ip", "relation_name": "`dbt`.`int_p2p_discv4_peers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.718932Z", "completed_at": "2026-02-12T22:49:46.724568Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.725183Z", "completed_at": "2026-02-12T22:49:46.725191Z"}], "thread_id": "Thread-1", "execution_time": 0.00763249397277832, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_visits_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nvisits_info AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,COUNT(visit_ended_at) AS total_visits\n        ,SUM(IF( empty(dial_errors) = 1 OR crawl_error IS NULL, 1, 0)) AS successful_visits\n        ,COUNT(DISTINCT crawl_id) AS crawls\n    FROM `dbt`.`stg_nebula_discv4__visits`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        toString(peer_properties.network_id) = '100'\n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(visit_ended_at)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_p2p_discv4_visits_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(visit_ended_at) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_p2p_discv4_visits_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT * FROM visits_info", "relation_name": "`dbt`.`int_p2p_discv4_visits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.727970Z", "completed_at": "2026-02-12T22:49:46.733719Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.734277Z", "completed_at": "2026-02-12T22:49:46.734285Z"}], "thread_id": "Thread-1", "execution_time": 0.0076961517333984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__visits_crawl_id.1047c05835", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_id\nfrom `dbt`.`stg_nebula_discv4__visits`\nwhere crawl_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.736867Z", "completed_at": "2026-02-12T22:49:46.741336Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.741939Z", "completed_at": "2026-02-12T22:49:46.741946Z"}], "thread_id": "Thread-1", "execution_time": 0.006315469741821289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__visits_peer_id.4d2f8a686c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`stg_nebula_discv4__visits`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.744555Z", "completed_at": "2026-02-12T22:49:46.748971Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.749564Z", "completed_at": "2026-02-12T22:49:46.749571Z"}], "thread_id": "Thread-1", "execution_time": 0.006261110305786133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__visits_visit_ended_at.a94c7d50d3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect visit_ended_at\nfrom `dbt`.`stg_nebula_discv4__visits`\nwhere visit_ended_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.752189Z", "completed_at": "2026-02-12T22:49:46.756687Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.757248Z", "completed_at": "2026-02-12T22:49:46.757255Z"}], "thread_id": "Thread-1", "execution_time": 0.0063092708587646484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv4__visits_visit_started_at.de065da8ac", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect visit_started_at\nfrom `dbt`.`stg_nebula_discv4__visits`\nwhere visit_started_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.759922Z", "completed_at": "2026-02-12T22:49:46.764467Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.765038Z", "completed_at": "2026-02-12T22:49:46.765046Z"}], "thread_id": "Thread-1", "execution_time": 0.006438016891479492, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv4__visits_crawl_id.41e26560eb", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    crawl_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv4__visits`\nwhere crawl_id is not null\ngroup by crawl_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.767717Z", "completed_at": "2026-02-12T22:49:46.773170Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.773754Z", "completed_at": "2026-02-12T22:49:46.773761Z"}], "thread_id": "Thread-1", "execution_time": 0.007315158843994141, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv4__visits_peer_id.3b9792bf3e", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv4__visits`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.776396Z", "completed_at": "2026-02-12T22:49:46.781085Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.781737Z", "completed_at": "2026-02-12T22:49:46.781751Z"}], "thread_id": "Thread-1", "execution_time": 0.006667375564575195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__discovery_id_prefixes_x_peer_ids_peer_id.db4024f2cc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.784479Z", "completed_at": "2026-02-12T22:49:46.789180Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.789760Z", "completed_at": "2026-02-12T22:49:46.789767Z"}], "thread_id": "Thread-1", "execution_time": 0.006605863571166992, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv5__discovery_id_prefixes_x_peer_ids_peer_id.f54e03ba37", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.792517Z", "completed_at": "2026-02-12T22:49:46.797140Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.797720Z", "completed_at": "2026-02-12T22:49:46.797727Z"}], "thread_id": "Thread-1", "execution_time": 0.006551265716552734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__neighbors_crawl_created_at.76b1283e34", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_created_at\nfrom `dbt`.`stg_nebula_discv5__neighbors`\nwhere crawl_created_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.800382Z", "completed_at": "2026-02-12T22:49:46.804864Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.805453Z", "completed_at": "2026-02-12T22:49:46.805461Z"}], "thread_id": "Thread-1", "execution_time": 0.006350040435791016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__neighbors_crawl_id.a789b348b9", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_id\nfrom `dbt`.`stg_nebula_discv5__neighbors`\nwhere crawl_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.808079Z", "completed_at": "2026-02-12T22:49:46.812622Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.813181Z", "completed_at": "2026-02-12T22:49:46.813189Z"}], "thread_id": "Thread-1", "execution_time": 0.006395816802978516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv5__neighbors_crawl_id.27d1de0819", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    crawl_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv5__neighbors`\nwhere crawl_id is not null\ngroup by crawl_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.815900Z", "completed_at": "2026-02-12T22:49:46.824891Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.825496Z", "completed_at": "2026-02-12T22:49:46.825504Z"}], "thread_id": "Thread-1", "execution_time": 0.010883092880249023, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_peers", "compiled": true, "compiled_code": "\n\n\n\n\nWITH\n\n-- Known fork digests \u2192 names\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\n-- Known fork versions \u2192 names\nfork_version AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_version,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0x00000064','Phase0'),\n      ('0x01000064','Altair'),\n      ('0x02000064','Bellatrix'),\n      ('0x03000064','Capella'),\n      ('0x04000064','Deneb'),\n      ('0x05000064','Electra'),\n      ('0x06000064','Fulu')\n    ]) AS tup\n  )\n),\n\n/* Pull only relevant rows from source and normalize Dynamic\u2192String once */\npeers AS (\n  SELECT \n    t1.crawl_id,\n    t1.visit_ended_at,\n    t1.peer_id,\n    t1.connect_maddr,\n    -- Dynamic JSON leaves \u2192 String for safe joins/filters\n    toString(t1.peer_properties.fork_digest)         AS fork_digest,\n    toString(t1.peer_properties.next_fork_version)   AS next_fork_version,\n\n    -- Map to fork names\n    t2.cl_fork_name                                  AS cl_fork_name,\n    coalesce(t3.cl_fork_name, toString(t1.peer_properties.next_fork_version))\n                                                    AS cl_next_fork_name,\n\n    t1.agent_version,\n    --t1.peer_properties,\n    t1.crawl_error,\n    t1.dial_errors\n  FROM `dbt`.`stg_nebula_discv5__visits` AS t1\n  LEFT JOIN fork_digests t2\n    ON toString(t1.peer_properties.fork_digest) = t2.fork_digest\n  LEFT JOIN fork_version t3\n    ON toString(t1.peer_properties.next_fork_version) = t3.fork_version\n  WHERE\n    (\n      toString(t1.peer_properties.fork_digest) IN (SELECT fork_digest FROM fork_digests)\n      OR toString(t1.peer_properties.next_fork_version) LIKE '%064'\n    )\n    \n      \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(visit_ended_at)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.visit_ended_at)), -0))\n      FROM `dbt`.`int_p2p_discv5_peers` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(visit_ended_at) >= (\n      SELECT addDays(max(toDate(x2.visit_ended_at)), -0)\n      FROM `dbt`.`int_p2p_discv5_peers` AS x2\n      WHERE 1=1 \n    )\n  \n\n    \n),\n\n/* Split and locate version token via regex */\nparsed AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n    --peer_properties,\n    crawl_error,\n    dial_errors,\n    agent_version,\n\n    splitByChar('/', agent_version)                                         AS parts,\n    length(splitByChar('/', agent_version))                                 AS parts_len,\n    arraySlice(splitByChar('/', agent_version), 2)                         AS tail,\n    length(arraySlice(splitByChar('/', agent_version), 2))                 AS tail_len,\n\n    splitByChar('/', agent_version)[1]                                     AS client,\n\n    -- first tail index that looks like a version (v?digits(.digits){0,3}\u2026)\n    arrayFirstIndex(x ->\n        (substring(x, 1, 1) = 'v' OR match(x, '^[0-9]')) AND\n        match(x, '^v?[0-9]+(\\\\.[0-9]+){0,3}([\\\\-\\\\w\\\\.\\\\+]+)?$')\n      , arraySlice(splitByChar('/', agent_version), 2))                    AS ver_idx_tail\n  FROM peers\n),\n\n/* Derive variant, version blob, platform, runtime */\nwith_parts AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n   -- peer_properties,\n    crawl_error,\n    dial_errors,\n    agent_version,\n    parts,\n    parts_len,\n    tail,\n    tail_len,\n    client,\n    ver_idx_tail,\n\n    /* variant: exactly one token between client and version */\n    IF(ver_idx_tail > 1, tail[1], '')                                       AS variant,\n\n    /* raw version token (may include '-' channel and/or '+' build) */\n    IF(ver_idx_tail > 0, tail[ver_idx_tail], '')                            AS ver_blob,\n\n    /* tokens after version for platform/runtime */\n    IF(ver_idx_tail > 0 AND tail_len >= ver_idx_tail + 1, tail[ver_idx_tail + 1], '')\n      AS platform,\n    IF(ver_idx_tail > 0 AND tail_len >= ver_idx_tail + 2, tail[ver_idx_tail + 2], '')\n      AS runtime\n  FROM parsed\n),\n\n/* Split version blob and prep hyphen parts; also clean runtime */\nexploded AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n   -- peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    ver_blob,\n\n    -- strip leading '-' in runtime\n    replaceRegexpOne(runtime, '^-+', '')                                    AS runtime,\n    platform,\n\n    /* version blob split around '+' */\n    IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[1], ver_blob) AS pre_blob,\n    IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[2], '')       AS plus_build,\n\n    /* hyphen parts for channel/build logic (work off pre_blob) */\n    splitByChar('-', IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[1], ver_blob))\n                                                                            AS hy_parts\n  FROM with_parts\n),\n\nbasic_info AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    replaceRegexpAll(connect_maddr, '^/ip4/([0-9.]+)/tcp/[0-9]+$', '\\\\1') AS ip,\n    fork_digest,\n    cl_fork_name,\n    cl_next_fork_name,\n    next_fork_version,\n   -- peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    IF(length(hy_parts) >= 1, hy_parts[1], '')                                AS version,\n    IF(length(hy_parts) >= 3, hy_parts[2], '')                                 AS channel,\n    IF(\n      plus_build != '',\n      plus_build,\n      IF(length(hy_parts) >= 2, hy_parts[length(hy_parts)], '')\n    )                                                                          AS build,\n    platform,\n    runtime\n  FROM exploded\n)\n\nSELECT\n  t1.crawl_id,\n  t1.visit_ended_at,\n  t1.peer_id,\n  t1.agent_version,\n  t1.ip,\n  t1.fork_digest,\n  t1.cl_fork_name,\n  t1.cl_next_fork_name,\n  t1.next_fork_version,\n  t1.crawl_error,\n  t1.dial_errors,\n  t1.client,\n  t1.variant,\n  t1.version,\n  t1.channel,\n  t1.build,\n  CASE\n      WHEN t1.platform = '' THEN 'Unknown'\n      WHEN t1.platform = 'aarch64-linux' THEN 'linux-aarch_64'\n      WHEN t1.platform = 'x86_64-linux' THEN 'linux-x86_64'\n      WHEN t1.platform = 'x86_64-windows' THEN 'windows-x86_64'\n      ELSE t1.platform\n  END AS platform,\n  t1.runtime,\n  t2.hostname   AS peer_hostname,\n  t2.city       AS peer_city,\n  t2.country    AS peer_country,\n  t2.org        AS peer_org,\n  t2.loc        AS peer_loc,\n  t2.generic_provider AS generic_provider\nFROM\n  basic_info t1\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS t2\n  ON t2.ip = t1.ip", "relation_name": "`dbt`.`int_p2p_discv5_peers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.828248Z", "completed_at": "2026-02-12T22:49:46.833787Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.834387Z", "completed_at": "2026-02-12T22:49:46.834395Z"}], "thread_id": "Thread-1", "execution_time": 0.007550239562988281, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_visits_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\nvisits_info AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,COUNT(visit_ended_at) AS total_visits\n        ,SUM(IF( empty(dial_errors) = 1 OR crawl_error IS NULL, 1, 0)) AS successful_visits\n        ,COUNT(DISTINCT crawl_id) AS crawls\n    FROM `dbt`.`stg_nebula_discv5__visits`\n    WHERE\n      toStartOfDay(visit_ended_at) < today()\n      AND\n      (\n        toString(peer_properties.fork_digest) IN (SELECT fork_digest FROM fork_digests)\n        OR toString(peer_properties.next_fork_version) LIKE '%064'\n      )\n      \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(visit_ended_at)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_p2p_discv5_visits_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(visit_ended_at) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_p2p_discv5_visits_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT * FROM visits_info", "relation_name": "`dbt`.`int_p2p_discv5_visits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.837151Z", "completed_at": "2026-02-12T22:49:46.841593Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.842157Z", "completed_at": "2026-02-12T22:49:46.842164Z"}], "thread_id": "Thread-1", "execution_time": 0.006253957748413086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__visits_crawl_id.9cb9b578fa", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_id\nfrom `dbt`.`stg_nebula_discv5__visits`\nwhere crawl_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.844790Z", "completed_at": "2026-02-12T22:49:46.849221Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.849803Z", "completed_at": "2026-02-12T22:49:46.849811Z"}], "thread_id": "Thread-1", "execution_time": 0.00626826286315918, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__visits_peer_id.216f34e1f7", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`stg_nebula_discv5__visits`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.852491Z", "completed_at": "2026-02-12T22:49:46.857045Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.857626Z", "completed_at": "2026-02-12T22:49:46.857634Z"}], "thread_id": "Thread-1", "execution_time": 0.006449460983276367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__visits_visit_ended_at.2fa2ff079f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect visit_ended_at\nfrom `dbt`.`stg_nebula_discv5__visits`\nwhere visit_ended_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.860245Z", "completed_at": "2026-02-12T22:49:46.865843Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.866425Z", "completed_at": "2026-02-12T22:49:46.866433Z"}], "thread_id": "Thread-1", "execution_time": 0.007471561431884766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_nebula_discv5__visits_visit_started_at.7bc42b8695", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect visit_started_at\nfrom `dbt`.`stg_nebula_discv5__visits`\nwhere visit_started_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.869046Z", "completed_at": "2026-02-12T22:49:46.873498Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.874068Z", "completed_at": "2026-02-12T22:49:46.874075Z"}], "thread_id": "Thread-1", "execution_time": 0.006319999694824219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv5__visits_crawl_id.73f88f1c7e", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    crawl_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv5__visits`\nwhere crawl_id is not null\ngroup by crawl_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.876697Z", "completed_at": "2026-02-12T22:49:46.881025Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.881615Z", "completed_at": "2026-02-12T22:49:46.881622Z"}], "thread_id": "Thread-1", "execution_time": 0.006155490875244141, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_stg_nebula_discv5__visits_peer_id.dcf6d33c4b", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`stg_nebula_discv5__visits`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.884345Z", "completed_at": "2026-02-12T22:49:46.889838Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.890452Z", "completed_at": "2026-02-12T22:49:46.890460Z"}], "thread_id": "Thread-1", "execution_time": 0.007460832595825195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_AgentResultMapping_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '99c43743a2dbd406160cc43cf08113b17178789c'\n\n      \n        AND block_timestamp >= toDateTime('2025-06-10')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_AgentResultMapping_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_AgentResultMapping_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.893155Z", "completed_at": "2026-02-12T22:49:46.898529Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.899129Z", "completed_at": "2026-02-12T22:49:46.899136Z"}], "thread_id": "Thread-1", "execution_time": 0.007298707962036133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_BalancerV2_Vault_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'ba12222222228d8ba445958a75a0704d566bf2c8'\n\n      \n        AND block_timestamp >= toDateTime('2021-01-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_BalancerV2_Vault_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'ba12222222228d8ba445958a75a0704d566bf2c8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_BalancerV2_Vault_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.901954Z", "completed_at": "2026-02-12T22:49:46.907345Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.907944Z", "completed_at": "2026-02-12T22:49:46.907952Z"}], "thread_id": "Thread-1", "execution_time": 0.007275104522705078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_BalancerV3_Vault_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'ba1333333333a1ba1108e8412f11850a5c319ba9'\n\n      \n        AND block_timestamp >= toDateTime('2024-01-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_BalancerV3_Vault_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'ba1333333333a1ba1108e8412f11850a5c319ba9'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_BalancerV3_Vault_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.910774Z", "completed_at": "2026-02-12T22:49:46.917446Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.918046Z", "completed_at": "2026-02-12T22:49:46.918053Z"}], "thread_id": "Thread-1", "execution_time": 0.00871133804321289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_ConditionalTokens_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n\n      \n        AND block_timestamp >= toDateTime('2020-09-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_ConditionalTokens_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_ConditionalTokens_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.920808Z", "completed_at": "2026-02-12T22:49:46.926169Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.926788Z", "completed_at": "2026-02-12T22:49:46.926795Z"}], "thread_id": "Thread-1", "execution_time": 0.007269144058227539, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_FPMMDeterministicFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n\n      \n        AND block_timestamp >= toDateTime('2020-09-04')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_FPMMDeterministicFactory_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_FPMMDeterministicFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.929667Z", "completed_at": "2026-02-12T22:49:46.935007Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.935614Z", "completed_at": "2026-02-12T22:49:46.935621Z"}], "thread_id": "Thread-1", "execution_time": 0.007334232330322266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_GBCDeposit_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '0b98057ea310f4d31f2a452b414647007d1645d9'\n\n      \n        AND block_timestamp >= toDateTime('2021-12-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_GBCDeposit_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_GBCDeposit_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.938433Z", "completed_at": "2026-02-12T22:49:46.943846Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.944472Z", "completed_at": "2026-02-12T22:49:46.944480Z"}], "thread_id": "Thread-1", "execution_time": 0.007479667663574219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_OmenAgentResultMapping_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n\n      \n        AND block_timestamp >= toDateTime('2024-09-30')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_OmenAgentResultMapping_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_OmenAgentResultMapping_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.947229Z", "completed_at": "2026-02-12T22:49:46.952655Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.953251Z", "completed_at": "2026-02-12T22:49:46.953259Z"}], "thread_id": "Thread-1", "execution_time": 0.007324695587158203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Realitio_v2_1_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n\n      \n        AND block_timestamp >= toDateTime('2021-01-13')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_Realitio_v2_1_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Realitio_v2_1_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.956011Z", "completed_at": "2026-02-12T22:49:46.961579Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.962176Z", "completed_at": "2026-02-12T22:49:46.962184Z"}], "thread_id": "Thread-1", "execution_time": 0.007524013519287109, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_MarketFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n\n      \n        AND block_timestamp >= toDateTime('2024-10-08')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_Seer_MarketFactory_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_MarketFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.964949Z", "completed_at": "2026-02-12T22:49:46.972050Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.972670Z", "completed_at": "2026-02-12T22:49:46.972678Z"}], "thread_id": "Thread-1", "execution_time": 0.009037017822265625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_Wrapped1155Factory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n\n      \n        AND block_timestamp >= toDateTime('2024-02-07')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_Seer_Wrapped1155Factory_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_Wrapped1155Factory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.975429Z", "completed_at": "2026-02-12T22:49:46.980855Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.981472Z", "completed_at": "2026-02-12T22:49:46.981480Z"}], "thread_id": "Thread-1", "execution_time": 0.007396221160888672, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n\n      \n        AND block_timestamp >= toDateTime('2022-03-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.984238Z", "completed_at": "2026-02-12T22:49:46.989886Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.990504Z", "completed_at": "2026-02-12T22:49:46.990512Z"}], "thread_id": "Thread-1", "execution_time": 0.007573604583740234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraPool_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n  \n    \n  \n  \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE lower(replaceAll(address, '0x', '')) IN (SELECT lower(replaceAll(cw.address, '0x', '')) FROM `dbt`.`contracts_whitelist` cw WHERE cw.contract_type = 'SwaprPool')\n\n      \n        AND block_timestamp >= toDateTime('2022-03-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') IN (SELECT lower(replaceAll(cw.address, '0x', '')) FROM `dbt`.`contracts_whitelist` cw WHERE cw.contract_type = 'SwaprPool')\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraPool_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:46.993365Z", "completed_at": "2026-02-12T22:49:46.998789Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:46.999373Z", "completed_at": "2026-02-12T22:49:46.999380Z"}], "thread_id": "Thread-1", "execution_time": 0.007325887680053711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_UniswapV3_Factory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'e32f7dd7e3f098d518ff19a22d5f028e076489b1'\n\n      \n        AND block_timestamp >= toDateTime('2022-04-22')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_UniswapV3_Factory_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e32f7dd7e3f098d518ff19a22d5f028e076489b1'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_UniswapV3_Factory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.002119Z", "completed_at": "2026-02-12T22:49:47.007862Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.008458Z", "completed_at": "2026-02-12T22:49:47.008466Z"}], "thread_id": "Thread-1", "execution_time": 0.007694721221923828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_UniswapV3_Pool_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n  \n    \n  \n  \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE lower(replaceAll(address, '0x', '')) IN (SELECT lower(replaceAll(cw.address, '0x', '')) FROM `dbt`.`contracts_whitelist` cw WHERE cw.contract_type = 'UniswapV3Pool')\n\n      \n        AND block_timestamp >= toDateTime('2022-04-22')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_UniswapV3_Pool_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') IN (SELECT lower(replaceAll(cw.address, '0x', '')) FROM `dbt`.`contracts_whitelist` cw WHERE cw.contract_type = 'UniswapV3Pool')\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_UniswapV3_Pool_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.011280Z", "completed_at": "2026-02-12T22:49:47.018022Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.018644Z", "completed_at": "2026-02-12T22:49:47.018652Z"}], "thread_id": "Thread-1", "execution_time": 0.00865936279296875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_aaveV3_PoolConfigurator_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '7304979ec9e4eaa0273b6a037a31c4e9e5a75d16'\n\n      \n        AND block_timestamp >= toDateTime('2023-10-04')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_aaveV3_PoolConfigurator_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '7304979ec9e4eaa0273b6a037a31c4e9e5a75d16'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_aaveV3_PoolConfigurator_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.021373Z", "completed_at": "2026-02-12T22:49:47.026806Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.027399Z", "completed_at": "2026-02-12T22:49:47.027406Z"}], "thread_id": "Thread-1", "execution_time": 0.007328510284423828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_aaveV3_PoolInstance_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'b50201558b00496a145fe76f7424749556e326d8'\n\n      \n        AND block_timestamp >= toDateTime('2023-10-04')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_aaveV3_PoolInstance_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'b50201558b00496a145fe76f7424749556e326d8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_aaveV3_PoolInstance_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.030203Z", "completed_at": "2026-02-12T22:49:47.035701Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.036285Z", "completed_at": "2026-02-12T22:49:47.036292Z"}], "thread_id": "Thread-1", "execution_time": 0.007498741149902344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_agave_LendingPool_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '5e15d5e33d318dced84bfe3f4eace07909be6d9c'\n\n      \n        AND block_timestamp >= toDateTime('2022-04-19')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_agave_LendingPool_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '5e15d5e33d318dced84bfe3f4eace07909be6d9c'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_agave_LendingPool_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.039008Z", "completed_at": "2026-02-12T22:49:47.044597Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.045194Z", "completed_at": "2026-02-12T22:49:47.045201Z"}], "thread_id": "Thread-1", "execution_time": 0.0075147151947021484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_TSLAx_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '19972d1750f959dd14cf436da6360185bd54cea0'\n\n      \n        AND block_timestamp >= toDateTime('2025-01-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_backedfi_TSLAx_Oracle_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '19972d1750f959dd14cf436da6360185bd54cea0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_TSLAx_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.047954Z", "completed_at": "2026-02-12T22:49:47.053357Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.053966Z", "completed_at": "2026-02-12T22:49:47.053973Z"}], "thread_id": "Thread-1", "execution_time": 0.007297039031982422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bC3M_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '83ec02059f686e747392a22ddfed7833ba0d7ce3'\n\n      \n        AND block_timestamp >= toDateTime('2023-07-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_backedfi_bC3M_Oracle_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83ec02059f686e747392a22ddfed7833ba0d7ce3'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bC3M_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.056713Z", "completed_at": "2026-02-12T22:49:47.062168Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.062776Z", "completed_at": "2026-02-12T22:49:47.062784Z"}], "thread_id": "Thread-1", "execution_time": 0.007349729537963867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bCOIN_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '69b2d456e8830847f488afdde2a636bfb26218c6'\n\n      \n        AND block_timestamp >= toDateTime('2025-01-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_backedfi_bCOIN_Oracle_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '69b2d456e8830847f488afdde2a636bfb26218c6'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bCOIN_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.065481Z", "completed_at": "2026-02-12T22:49:47.072053Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.072697Z", "completed_at": "2026-02-12T22:49:47.072704Z"}], "thread_id": "Thread-1", "execution_time": 0.008515596389770508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bCSPX_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '1332d2b4dc83238b621b7f7d0f72fec58bb81a9b'\n\n      \n        AND block_timestamp >= toDateTime('2024-11-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_backedfi_bCSPX_Oracle_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '1332d2b4dc83238b621b7f7d0f72fec58bb81a9b'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bCSPX_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.075400Z", "completed_at": "2026-02-12T22:49:47.080791Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.081381Z", "completed_at": "2026-02-12T22:49:47.081389Z"}], "thread_id": "Thread-1", "execution_time": 0.007324934005737305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bHIGH_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '9e8e794ad6ecdb6d5c7eabe059d30e907f58859b'\n\n      \n        AND block_timestamp >= toDateTime('2023-06-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_backedfi_bHIGH_Oracle_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9e8e794ad6ecdb6d5c7eabe059d30e907f58859b'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bHIGH_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.084115Z", "completed_at": "2026-02-12T22:49:47.089569Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.090163Z", "completed_at": "2026-02-12T22:49:47.090170Z"}], "thread_id": "Thread-1", "execution_time": 0.007325887680053711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bIB01_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '788d911ae7c95121a89a0f0306db65d87422e1de'\n\n      \n        AND block_timestamp >= toDateTime('2023-04-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_backedfi_bIB01_Oracle_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '788d911ae7c95121a89a0f0306db65d87422e1de'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bIB01_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.092886Z", "completed_at": "2026-02-12T22:49:47.098220Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.098839Z", "completed_at": "2026-02-12T22:49:47.098846Z"}], "thread_id": "Thread-1", "execution_time": 0.007235288619995117, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bIBTA_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '9f9953d8a2c5366f098754d48f2d69b144ce03da'\n\n      \n        AND block_timestamp >= toDateTime('2023-04-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_backedfi_bIBTA_Oracle_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9f9953d8a2c5366f098754d48f2d69b144ce03da'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bIBTA_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.101598Z", "completed_at": "2026-02-12T22:49:47.106966Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.107574Z", "completed_at": "2026-02-12T22:49:47.107582Z"}], "thread_id": "Thread-1", "execution_time": 0.007359504699707031, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bMSTR_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'c8429803dcda7df86822ab173ea285c10bf1eb66'\n\n      \n        AND block_timestamp >= toDateTime('2025-01-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_backedfi_bMSTR_Oracle_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'c8429803dcda7df86822ab173ea285c10bf1eb66'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bMSTR_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.110304Z", "completed_at": "2026-02-12T22:49:47.116810Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.117455Z", "completed_at": "2026-02-12T22:49:47.117463Z"}], "thread_id": "Thread-1", "execution_time": 0.008442163467407227, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bNVDA_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '1d3be4d05eba2aa6c4eede85a74f491c31766e64'\n\n      \n        AND block_timestamp >= toDateTime('2025-01-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_backedfi_bNVDA_Oracle_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '1d3be4d05eba2aa6c4eede85a74f491c31766e64'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bNVDA_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.120259Z", "completed_at": "2026-02-12T22:49:47.125701Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.126338Z", "completed_at": "2026-02-12T22:49:47.126345Z"}], "thread_id": "Thread-1", "execution_time": 0.0075283050537109375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v1_Hub_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '29b9a7fbb8995b2423a71cc17cf9810798f6c543'\n\n      \n        AND block_timestamp >= toDateTime('2020-10-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_circles_v1_Hub_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '29b9a7fbb8995b2423a71cc17cf9810798f6c543'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v1_Hub_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.129152Z", "completed_at": "2026-02-12T22:49:47.134630Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.135221Z", "completed_at": "2026-02-12T22:49:47.135228Z"}], "thread_id": "Thread-1", "execution_time": 0.0074138641357421875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_CirclesBackingFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'eced91232c609a42f6016860e8223b8aecaa7bd0'\n\n      \n        AND block_timestamp >= toDateTime('2025-04-25')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_circles_v2_CirclesBackingFactory_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'eced91232c609a42f6016860e8223b8aecaa7bd0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_CirclesBackingFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.138061Z", "completed_at": "2026-02-12T22:49:47.143572Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.144163Z", "completed_at": "2026-02-12T22:49:47.144170Z"}], "thread_id": "Thread-1", "execution_time": 0.007395505905151367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_Hub_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'c12c1e50abb450d6205ea2c3fa861b3b834d13e8'\n\n      \n        AND block_timestamp >= toDateTime('2024-10-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_circles_v2_Hub_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'c12c1e50abb450d6205ea2c3fa861b3b834d13e8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_Hub_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.147117Z", "completed_at": "2026-02-12T22:49:47.152763Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.153353Z", "completed_at": "2026-02-12T22:49:47.153360Z"}], "thread_id": "Thread-1", "execution_time": 0.007723808288574219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_NameRegistry_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'a27566fd89162cc3d40cb59c87aaaa49b85f3474'\n\n      \n        AND block_timestamp >= toDateTime('2024-10-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_circles_v2_NameRegistry_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a27566fd89162cc3d40cb59c87aaaa49b85f3474'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_NameRegistry_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.156106Z", "completed_at": "2026-02-12T22:49:47.161671Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.162266Z", "completed_at": "2026-02-12T22:49:47.162274Z"}], "thread_id": "Thread-1", "execution_time": 0.007445096969604492, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_sdai_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'af204776c7245bf4147c2612bf6e5972ee483701'\n\n      \n        AND block_timestamp >= toDateTime('2023-09-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_sdai_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'af204776c7245bf4147c2612bf6e5972ee483701'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_sdai_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.165084Z", "completed_at": "2026-02-12T22:49:47.171969Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.172572Z", "completed_at": "2026-02-12T22:49:47.172580Z"}], "thread_id": "Thread-1", "execution_time": 0.008787870407104492, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_spark_Pool_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = '2dae5307c5e3fd1cf5a72cb6f698f915860607e0'\n\n      \n        AND block_timestamp >= toDateTime('2023-09-05')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_spark_Pool_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '2dae5307c5e3fd1cf5a72cb6f698f915860607e0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_spark_Pool_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.175270Z", "completed_at": "2026-02-12T22:49:47.180602Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.181190Z", "completed_at": "2026-02-12T22:49:47.181198Z"}], "thread_id": "Thread-1", "execution_time": 0.007208108901977539, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_wxdai_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n  \n  \n  \n    \n  \n\n  \n  \n  \n    \n    \n  \n\n  \n  \n    \n    \n    \n    \n  \n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT * FROM (\n    SELECT *,\n      row_number() OVER (\n        PARTITION BY block_number, transaction_index, log_index\n        ORDER BY insert_version DESC\n      ) AS _dedup_rn\n    FROM `execution`.`logs`\n    WHERE address = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n\n      \n        AND block_timestamp >= toDateTime('2020-07-01')\n      \n\n      \n      \n\n      \n        AND block_timestamp >\n          (SELECT coalesce(max(block_timestamp),'1970-01-01')\n           FROM `dbt`.`contracts_wxdai_events`)\n      \n  )\n  WHERE _dedup_rn = 1\n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_wxdai_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.184045Z", "completed_at": "2026-02-12T22:49:47.189358Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.189972Z", "completed_at": "2026-02-12T22:49:47.189980Z"}], "thread_id": "Thread-1", "execution_time": 0.007231712341308594, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_AgentResultMapping_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT * FROM (\n      SELECT *,\n        row_number() OVER (\n          PARTITION BY block_number, transaction_index\n          ORDER BY insert_version DESC\n        ) AS _dedup_rn\n      FROM `execution`.`transactions`\n      WHERE replaceAll(lower(to_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n        \n          AND block_timestamp >= toDateTime('2025-06-30')\n        \n\n        \n        \n\n        \n          AND block_timestamp >\n              (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_AgentResultMapping_calls`)\n        \n        AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n    )\n    WHERE _dedup_rn = 1\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_AgentResultMapping_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.192696Z", "completed_at": "2026-02-12T22:49:47.197999Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.198615Z", "completed_at": "2026-02-12T22:49:47.198622Z"}], "thread_id": "Thread-1", "execution_time": 0.007209300994873047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_ConditionalTokens_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT * FROM (\n      SELECT *,\n        row_number() OVER (\n          PARTITION BY block_number, transaction_index\n          ORDER BY insert_version DESC\n        ) AS _dedup_rn\n      FROM `execution`.`transactions`\n      WHERE replaceAll(lower(to_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n        \n          AND block_timestamp >= toDateTime('2020-09-01')\n        \n\n        \n        \n\n        \n          AND block_timestamp >\n              (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_ConditionalTokens_calls`)\n        \n        AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n    )\n    WHERE _dedup_rn = 1\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_ConditionalTokens_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.201341Z", "completed_at": "2026-02-12T22:49:47.206730Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.207324Z", "completed_at": "2026-02-12T22:49:47.207331Z"}], "thread_id": "Thread-1", "execution_time": 0.007295370101928711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_FPMMDeterministicFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT * FROM (\n      SELECT *,\n        row_number() OVER (\n          PARTITION BY block_number, transaction_index\n          ORDER BY insert_version DESC\n        ) AS _dedup_rn\n      FROM `execution`.`transactions`\n      WHERE replaceAll(lower(to_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n        \n          AND block_timestamp >= toDateTime('2020-09-04')\n        \n\n        \n        \n\n        \n          AND block_timestamp >\n              (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_FPMMDeterministicFactory_calls`)\n        \n        AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n    )\n    WHERE _dedup_rn = 1\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_FPMMDeterministicFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.210061Z", "completed_at": "2026-02-12T22:49:47.216580Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.217174Z", "completed_at": "2026-02-12T22:49:47.217181Z"}], "thread_id": "Thread-1", "execution_time": 0.008387088775634766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_GBCDeposit_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT * FROM (\n      SELECT *,\n        row_number() OVER (\n          PARTITION BY block_number, transaction_index\n          ORDER BY insert_version DESC\n        ) AS _dedup_rn\n      FROM `execution`.`transactions`\n      WHERE replaceAll(lower(to_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n        \n          AND block_timestamp >= toDateTime('2021-12-01')\n        \n\n        \n        \n\n        \n          AND block_timestamp >\n              (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_GBCDeposit_calls`)\n        \n        AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n    )\n    WHERE _dedup_rn = 1\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_GBCDeposit_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.220055Z", "completed_at": "2026-02-12T22:49:47.225484Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.226081Z", "completed_at": "2026-02-12T22:49:47.226089Z"}], "thread_id": "Thread-1", "execution_time": 0.0073697566986083984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_OmenAgentResultMapping_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT * FROM (\n      SELECT *,\n        row_number() OVER (\n          PARTITION BY block_number, transaction_index\n          ORDER BY insert_version DESC\n        ) AS _dedup_rn\n      FROM `execution`.`transactions`\n      WHERE replaceAll(lower(to_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n        \n          AND block_timestamp >= toDateTime('2024-09-30')\n        \n\n        \n        \n\n        \n          AND block_timestamp >\n              (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_OmenAgentResultMapping_calls`)\n        \n        AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n    )\n    WHERE _dedup_rn = 1\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_OmenAgentResultMapping_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.228839Z", "completed_at": "2026-02-12T22:49:47.234121Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.234743Z", "completed_at": "2026-02-12T22:49:47.234751Z"}], "thread_id": "Thread-1", "execution_time": 0.007253885269165039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Realitio_v2_1_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT * FROM (\n      SELECT *,\n        row_number() OVER (\n          PARTITION BY block_number, transaction_index\n          ORDER BY insert_version DESC\n        ) AS _dedup_rn\n      FROM `execution`.`transactions`\n      WHERE replaceAll(lower(to_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n        \n          AND block_timestamp >= toDateTime('2021-01-13')\n        \n\n        \n        \n\n        \n          AND block_timestamp >\n              (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Realitio_v2_1_calls`)\n        \n        AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n    )\n    WHERE _dedup_rn = 1\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Realitio_v2_1_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.237454Z", "completed_at": "2026-02-12T22:49:47.242765Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.243362Z", "completed_at": "2026-02-12T22:49:47.243369Z"}], "thread_id": "Thread-1", "execution_time": 0.007223844528198242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_MarketFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT * FROM (\n      SELECT *,\n        row_number() OVER (\n          PARTITION BY block_number, transaction_index\n          ORDER BY insert_version DESC\n        ) AS _dedup_rn\n      FROM `execution`.`transactions`\n      WHERE replaceAll(lower(to_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n        \n          AND block_timestamp >= toDateTime('2024-10-08')\n        \n\n        \n        \n\n        \n          AND block_timestamp >\n              (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Seer_MarketFactory_calls`)\n        \n        AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n    )\n    WHERE _dedup_rn = 1\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_MarketFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.246043Z", "completed_at": "2026-02-12T22:49:47.251546Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.252141Z", "completed_at": "2026-02-12T22:49:47.252149Z"}], "thread_id": "Thread-1", "execution_time": 0.007376909255981445, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_Wrapped1155Factory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT * FROM (\n      SELECT *,\n        row_number() OVER (\n          PARTITION BY block_number, transaction_index\n          ORDER BY insert_version DESC\n        ) AS _dedup_rn\n      FROM `execution`.`transactions`\n      WHERE replaceAll(lower(to_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n        \n          AND block_timestamp >= toDateTime('2024-02-07')\n        \n\n        \n        \n\n        \n          AND block_timestamp >\n              (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Seer_Wrapped1155Factory_calls`)\n        \n        AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n    )\n    WHERE _dedup_rn = 1\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_Wrapped1155Factory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.254881Z", "completed_at": "2026-02-12T22:49:47.260406Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.261014Z", "completed_at": "2026-02-12T22:49:47.261022Z"}], "thread_id": "Thread-1", "execution_time": 0.007465839385986328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT * FROM (\n      SELECT *,\n        row_number() OVER (\n          PARTITION BY block_number, transaction_index\n          ORDER BY insert_version DESC\n        ) AS _dedup_rn\n      FROM `execution`.`transactions`\n      WHERE replaceAll(lower(to_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n        \n          AND block_timestamp >= toDateTime('2022-03-01')\n        \n\n        \n        \n\n        \n          AND block_timestamp >\n              (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_calls`)\n        \n        AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n    )\n    WHERE _dedup_rn = 1\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.263766Z", "completed_at": "2026-02-12T22:49:47.270353Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.270969Z", "completed_at": "2026-02-12T22:49:47.270976Z"}], "thread_id": "Thread-1", "execution_time": 0.008494377136230469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraPool_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT * FROM (\n      SELECT *,\n        row_number() OVER (\n          PARTITION BY block_number, transaction_index\n          ORDER BY insert_version DESC\n        ) AS _dedup_rn\n      FROM `execution`.`transactions`\n      WHERE replaceAll(lower(to_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n        \n          AND block_timestamp >= toDateTime('2022-03-01')\n        \n\n        \n        \n\n        \n          AND block_timestamp >\n              (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_calls`)\n        \n        AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n    )\n    WHERE _dedup_rn = 1\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraPool_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.273725Z", "completed_at": "2026-02-12T22:49:47.279130Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.279744Z", "completed_at": "2026-02-12T22:49:47.279751Z"}], "thread_id": "Thread-1", "execution_time": 0.007364988327026367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_wxdai_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT * FROM (\n      SELECT *,\n        row_number() OVER (\n          PARTITION BY block_number, transaction_index\n          ORDER BY insert_version DESC\n        ) AS _dedup_rn\n      FROM `execution`.`transactions`\n      WHERE replaceAll(lower(to_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n        \n          AND block_timestamp >= toDateTime('2020-07-01')\n        \n\n        \n        \n\n        \n          AND block_timestamp >\n              (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_wxdai_calls`)\n        \n        AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n    )\n    WHERE _dedup_rn = 1\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_wxdai_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.282553Z", "completed_at": "2026-02-12T22:49:47.287798Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.288390Z", "completed_at": "2026-02-12T22:49:47.288397Z"}], "thread_id": "Thread-1", "execution_time": 0.00722813606262207, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_labels", "compiled": true, "compiled_code": "\n\n\nWITH latest AS (\n  SELECT\n    lower(address) AS address,\n    (label, introduced_at) AS agg\n  FROM `crawlers_data`.`dune_labels`\n),\n\nclean AS (\n  SELECT\n    address,\n    tupleElement(agg, 1) AS label_raw,\n    tupleElement(agg, 2) AS introduced_at,\n\n    trim(replaceRegexpAll(tupleElement(agg, 1), '\\\\s*([:/|>])\\\\s*', '\\\\1'))                           AS s1,\n\n    replaceRegexpAll(\n      replaceRegexpAll(s1, '_0x[0-9a-fA-F]{40}$', ''),\n      '_0x[0-9a-fA-F]{1,}\u2026[0-9a-fA-F]{1,}$',\n      ''\n    )                                                                                                AS s2,\n\n    trim(extract(s2, '^([^:/|>]+)'))                                                                 AS s3,\n\n    trim(replaceRegexpAll(s3, '(?:\\\\s*[-_ ]?[Vv]\\\\d+(?:[._-]\\\\d+)*)\\\\b', ''))                        AS s4,\n\n    lowerUTF8(s4)                                                                                    AS s4_l,\n\n    (\n      match(s1, '_0x[0-9a-fA-F]{40}$')\n      OR match(s1, '_0x[0-9a-fA-F]{1,}\u2026[0-9a-fA-F]{1,}$')\n    )                                                                                                AS looks_like_token_tail\n  FROM latest\n),\n\nwl AS (\n  SELECT\n    lower(address) AS address,\n    symbol\n  FROM `dbt`.`tokens_whitelist`\n),\n\nbucketed AS (\n \n  SELECT\n    c.address,\n    c.label_raw,\n    c.introduced_at,\n    c.s4,\n    c.s4_l,\n    c.looks_like_token_tail,\n    w.symbol AS wl_symbol,\n\n    coalesce(\n      if(c.looks_like_token_tail,\n         if(w.symbol IS NOT NULL, w.symbol, 'ERC20'),\n         NULL\n      ),\n\n      multiIf(\n        match(c.s4_l, '^(realtoken|realtokens)\\\\b'),              'REALTOKEN',\n        match(lowerUTF8(c.label_raw), '(^|[^a-z0-9])gnosis[\\\\s_-]*safe(?:l2)?([^a-z0-9]|$)') OR match(c.s4_l, '^(safe(?:l2)?)\\\\b'), 'Safe',\n\n        match(c.s4_l, '(^|[^a-z])balancer([^a-z]|$)'),            'Balancer',\n        match(c.s4_l, '(^|[-_])gaug(e)?(\\\\b|_)'),                 'Balancer',\n        match(c.s4_l, '\\\\b\\\\d{1,3}%[a-z0-9._-]+'),                'Balancer',\n        match(c.s4_l, '\\\\b(w?moo)[a-z0-9]*balancer'),             'Balancer',\n\n        match(c.s4_l, '(^|[^a-z])curve([^a-z]|$)'),               'Curve',\n        match(c.s4_l, '^(yv\\\\s*curve|yvcurve|y\\\\s*curve|ycurve)'), 'Curve',\n        match(c.s4_l, '^curvefi\\\\b'),                             'Curve',\n\n        match(c.s4_l, '\\\\buniswap\\\\b'),                           'Uniswap',\n        match(c.s4_l, '\\\\buni[- _]?v?3\\\\b'),                      'Uniswap',\n        match(c.s4_l, '\\\\buni[- _]?v?2\\\\b'),                      'Uniswap',\n        match(c.s4_l, '\\\\bnonfungiblepositionmanager\\\\b'),        'Uniswap',\n        match(c.s4_l, '\\\\bpositions?\\\\s*nft\\\\b'),                 'Uniswap',\n        match(c.s4_l, '\\\\b(rcow|cow|moo\\\\w*)\\\\s*uniswap'),        'Uniswap',\n\n        match(c.s4_l, 'sushi'),                                   'Sushi',\n\n        match(c.s4_l, '\\\\bswapr\\\\b'),                             'Swapr',\n        match(c.s4_l, '^swaprv?3\\\\b'),                            'Swapr',\n        match(c.s4_l, '\\\\bswpr\\\\b'),                              'Swapr',\n\n        match(c.s4_l, '\\\\bcow\\\\s*swap\\\\b|\\\\bcow[_\\\\s-]?protocol\\\\b|^b_cow_amm\\\\b'), 'CowSwap',\n        match(c.s4_l, '^aave\\\\b'),                                'Aave',\n        match(c.s4_l, '\\\\baave\\\\s*v?2\\\\b|\\\\baave\\\\s*v?3\\\\b'),     'Aave',\n        match(c.s4_l, '^aavepool\\\\b'),                            'Aave',\n\n        c.s4\n      )\n    ) AS s5\n  FROM clean c\n  LEFT JOIN wl w\n    ON c.address = w.address\n),\n\ntidy AS (\n  SELECT\n    address,\n    label_raw,\n    introduced_at,\n    trim(\n      replaceRegexpAll(\n        replaceRegexpAll(\n          replaceRegexpAll(\n            left(s5, length(\n              replaceRegexpAll(\n                lowerUTF8(s5),\n                '\\\\b(factory|router|vault|pool|implementation|proxy|token|bridge|aggregator|registry|controller|manager|oracle|staking|treasury|multisig|gnosis\\\\s*safe|deployer|fee\\\\s*collector|minter|burner|timelock|governor|council|rewards?|distributor|airdrop)s?\\\\s*$',\n                ''\n              )\n            )),\n            '\\\\s*\\\\([^)]*\\\\)\\\\s*$', ''\n          ),\n          '\\\\?+$', ''\n        ),\n        '[_\\\\s-]+', ' '\n      )\n    ) AS s7\n  FROM bucketed\n),\n\ncanon AS (\n  SELECT\n    address,\n    label_raw,\n    introduced_at,\n    s7,\n    multiIf(\n      match(lowerUTF8(s7), '^unlock(\\\\s*protocol)?$'),                        'Unlock Protocol',\n      match(lowerUTF8(s7), '^(eth\\\\s*swarm|ethereum\\\\s*swarm|swarm)$'),       'Swarm',\n      match(lowerUTF8(s7), '^symmetric(\\\\s*finance)?$'),                      'Symmetric',\n      match(lowerUTF8(s7), '^elk(\\\\s*finance)?$'),                            'Elk Finance',\n      match(lowerUTF8(s7), '^monerium(\\\\s*(usde|iske|blacklist))?$'),         'Monerium',\n      match(lowerUTF8(s7), '^gnosis\\\\s*pay(\\\\s*(vip|spender|eiffel))?$|^gnosispay$'), 'Gnosis Pay',\n      match(lowerUTF8(s7), '^hopr(\\\\s*(protocol|network|token|boost\\\\s*nft))?$'),    'HOPR',\n      match(lowerUTF8(s7), '^kleros(\\\\s*curate)?$'),                          'Kleros',\n      match(lowerUTF8(s7), '^sismo(\\\\s*(badges|roots))?$'),                   'Sismo',\n      match(lowerUTF8(s7), '^request(\\\\s*network)?$'),                        'Request Network',\n      match(lowerUTF8(s7), '^event\\\\s*sbt(\\\\s*\\\\(esbt\\\\)\\\\s*test)?$'),        'EventSBT',\n      match(lowerUTF8(s7), '^polkamarkets(\\\\s*aa)?$'),                        'Polkamarkets',\n      match(lowerUTF8(s7), '^everclear.*$'),                                  'Everclear',\n      match(lowerUTF8(s7), '^merkly(\\\\s*farmer)?$'),                          'Merkly',\n      match(lowerUTF8(s7), '^zerion(\\\\s*premium\\\\s*purchaser\\\\s*l2)?$'),      'Zerion',\n      match(lowerUTF8(s7), '^aura(\\\\s*finance)?$'),                           'Aura Finance',\n      match(lowerUTF8(s7), '^open\\\\s*ocean(exchange)?$|^openoceanexchange$'), 'OpenOcean',\n      match(lowerUTF8(s7), '^(amb|.*\\\\sxdai\\\\s*amb)$'),                       'AMB',\n      match(lowerUTF8(s7), '^cow\\\\s*swap$'),                                  'CowSwap',\n      match(lowerUTF8(s7), '^(rmm|real\\\\s*rmm|rmm\\\\s*ecosystem\\\\s*reserve)$'), 'RMM',\n      match(lowerUTF8(s7), '^erc\\\\s*-?\\\\s*4337(\\\\s*entry\\\\s*point)?$'), 'ERC-4337 Entry Point',\n      match(lowerUTF8(s7), '^(aa\\\\s*entrypoint|erc-?4337\\\\s*entry\\\\s*point|entrypointsimulations|pimlicoentrypointsimulations)$'), 'ERC-4337 Entry Point',\n      match(lowerUTF8(s7), '^(uni|uni\\\\s*v?3\\\\s*swaprouter02)$'),                                      'Uniswap',\n      match(lowerUTF8(s7), '^(oneinch)$'),                                                             '1inch',\n      match(lowerUTF8(s7), '^layerzero$'),                                                             'LayerZero',\n      match(lowerUTF8(s7), '^(cowswap|b_cow_amm)$'),                                                   'CowSwap',\n      match(lowerUTF8(s7), '^angle(\\\\s+ageur)?$'),                                                     'Angle',\n      match(lowerUTF8(s7), '^sablier(\\\\s+.*)?$|^sablier\\\\s*flow\\\\b|^sablier\\\\s*lockup\\\\b'),            'Sablier',\n      match(lowerUTF8(s7), '^hats[_\\\\s-]?protocol'),                                                   'Hats Protocol',\n      match(lowerUTF8(s7), '^seaport\\\\??$'),                                                           'Seaport',\n      match(lowerUTF8(s7), '^poap(\\\\s+top)?$'),                                                        'POAP',\n      match(lowerUTF8(s7), '^merkly(\\\\s+onft)?$'),                                                     'Merkly',\n      match(lowerUTF8(s7), '^circles(\\\\s*ubi)?$'),                                                     'Circles',\n      match(lowerUTF8(s7), '^(hop|hop\\\\s*protocol)$'),                                                 'Hop Protocol',\n      match(lowerUTF8(s7), '^opensea$'),                                                               'OpenSea',\n      match(lowerUTF8(s7), '^paraswap$'),                                                              'ParaSwap',\n      match(lowerUTF8(s7), '^realt(oken)?(\\\\s*money\\\\s*market)?$|^realtoken\\\\s*dao$|^realtyam$|^real_rmm$'), 'REALTOKEN',\n      match(lowerUTF8(s7), '^nulladdress$|^burn\\\\s*address$'),                                         'Null/Burn',\n      match(lowerUTF8(s7), '^eoa$'),                                                                   'EOA',\n      match(lowerUTF8(s7), '^proxyadmin$|^transparentupgradeableproxy$|^upgradeablecommunitytoken$|^contractaddressfeehelper$|^controllermodule$'), 'Infrastructure',\n      match(lowerUTF8(s7), '^unnamed$|^oracle\\\\?$|^dex\\\\s*aggregator\\\\?$|^\\\\?$'),                      'Unknown',\n      s7\n    ) AS project_canon\n  FROM tidy\n)\n\nSELECT\n  address,\n  if(\n    lengthUTF8(project_canon) = 0\n    OR positionCaseInsensitive(project_canon, '0x') > 0\n    OR match(label_raw, '_0x[0-9a-fA-F]{40}$')\n    OR match(label_raw, '_0x[0-9a-fA-F]{1,}\u2026[0-9a-fA-F]{1,}$'),\n    'ERC20',\n    project_canon\n  ) AS project,\n  label_raw AS project_raw,\n  introduced_at\nFROM canon", "relation_name": "`dbt`.`stg_crawlers_data__dune_labels`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.291275Z", "completed_at": "2026-02-12T22:49:47.295301Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.295949Z", "completed_at": "2026-02-12T22:49:47.295957Z"}], "thread_id": "Thread-1", "execution_time": 0.0060482025146484375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_clients_cnt_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,client\n    ,cnt AS value\nFROM `dbt`.`fct_execution_blocks_clients_daily`\nORDER BY date, client", "relation_name": "`dbt`.`api_execution_blocks_clients_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.298782Z", "completed_at": "2026-02-12T22:49:47.302679Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.303271Z", "completed_at": "2026-02-12T22:49:47.303278Z"}], "thread_id": "Thread-1", "execution_time": 0.0057773590087890625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_clients_pct_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,client\n    ,ROUND(fraq * 100, 2) AS value\nFROM `dbt`.`fct_execution_blocks_clients_daily`\nORDER BY date, client", "relation_name": "`dbt`.`api_execution_blocks_clients_pct_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.305876Z", "completed_at": "2026-02-12T22:49:47.310694Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.311262Z", "completed_at": "2026-02-12T22:49:47.311269Z"}], "thread_id": "Thread-1", "execution_time": 0.006630659103393555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_blocks_clients_daily_date.ba453188e6", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_execution_blocks_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.313896Z", "completed_at": "2026-02-12T22:49:47.319716Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.320278Z", "completed_at": "2026-02-12T22:49:47.320286Z"}], "thread_id": "Thread-1", "execution_time": 0.007633686065673828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_blocks_gas_usage_pct_daily_date.a4e57a886a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_blocks_gas_usage_pct_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.323004Z", "completed_at": "2026-02-12T22:49:47.326962Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.327578Z", "completed_at": "2026-02-12T22:49:47.327586Z"}], "thread_id": "Thread-1", "execution_time": 0.005863666534423828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_gas_usage_pct_monthly", "compiled": true, "compiled_code": "\n\nSELECT\n  month AS date,\n  ROUND(used * 100, 2) AS value\nFROM `dbt`.`fct_execution_blocks_gas_usage_monthly`\nORDER BY date", "relation_name": "`dbt`.`api_execution_blocks_gas_usage_pct_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.330398Z", "completed_at": "2026-02-12T22:49:47.334353Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.334962Z", "completed_at": "2026-02-12T22:49:47.334969Z"}], "thread_id": "Thread-1", "execution_time": 0.005857944488525391, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_attestations_daily", "compiled": true, "compiled_code": "\nSELECT\n    date\n    ,inclusion_delay\n    ,cnt\nFROM `dbt`.`int_consensus_attestations_daily`\nORDER BY date, inclusion_delay", "relation_name": "`dbt`.`api_consensus_attestations_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.337861Z", "completed_at": "2026-02-12T22:49:47.342346Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.342929Z", "completed_at": "2026-02-12T22:49:47.342936Z"}], "thread_id": "Thread-1", "execution_time": 0.006573677062988281, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_attestations_daily_date.3762d44128", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_attestations_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.345594Z", "completed_at": "2026-02-12T22:49:47.350095Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.350685Z", "completed_at": "2026-02-12T22:49:47.350692Z"}], "thread_id": "Thread-1", "execution_time": 0.0064296722412109375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_blob_commitments_daily_date.3327c6b9f7", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_blob_commitments_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.353384Z", "completed_at": "2026-02-12T22:49:47.358545Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.359139Z", "completed_at": "2026-02-12T22:49:47.359147Z"}], "thread_id": "Thread-1", "execution_time": 0.00704646110534668, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_graffiti_label_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,SUM(cnt) AS value\nFROM `dbt`.`int_consensus_graffiti_daily`\nGROUP BY date, label\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_graffiti_label_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.361987Z", "completed_at": "2026-02-12T22:49:47.365907Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.366523Z", "completed_at": "2026-02-12T22:49:47.366542Z"}], "thread_id": "Thread-1", "execution_time": 0.0058476924896240234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_graffiti_cloud", "compiled": true, "compiled_code": "\n\n\nWITH base AS (\n  SELECT\n      graffiti,\n      sumIf(cnt, date >= today() - 7)  AS v_7d,\n      sumIf(cnt, date >= today() - 30) AS v_30d,\n      sumIf(cnt, date >= today() - 90) AS v_90d,\n      sum(cnt)                         AS v_all\n  FROM `dbt`.`int_consensus_graffiti_daily`\n  WHERE graffiti != 'None'\n  GROUP BY graffiti\n)\nSELECT\n  label,\n  graffiti,\n  value\nFROM base\nARRAY JOIN\n  ['7D','30D','90D','All'] AS label,\n  [v_7d, v_30d, v_90d, v_all] AS value\nORDER BY label, value DESC\nLIMIT 50 BY label", "relation_name": "`dbt`.`fct_consensus_graffiti_cloud`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.369149Z", "completed_at": "2026-02-12T22:49:47.373819Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.374388Z", "completed_at": "2026-02-12T22:49:47.374395Z"}], "thread_id": "Thread-1", "execution_time": 0.006519794464111328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_graffiti_daily_date.428851ad09", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_graffiti_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.377123Z", "completed_at": "2026-02-12T22:49:47.381049Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.381661Z", "completed_at": "2026-02-12T22:49:47.381668Z"}], "thread_id": "Thread-1", "execution_time": 0.005824089050292969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_forks", "compiled": true, "compiled_code": "\n\nSELECT\n  fork_name\n  ,fork_version \n  ,fork_digest\n  ,fork_epoch \nFROM `dbt`.`fct_consensus_forks`\nORDER BY fork_version ASC", "relation_name": "`dbt`.`api_consensus_forks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.384403Z", "completed_at": "2026-02-12T22:49:47.388383Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.388991Z", "completed_at": "2026-02-12T22:49:47.388998Z"}], "thread_id": "Thread-1", "execution_time": 0.005875587463378906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_blob_commitments_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,total_blob_commitments AS value\nFROM `dbt`.`int_consensus_blocks_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_blob_commitments_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.391838Z", "completed_at": "2026-02-12T22:49:47.396121Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.396726Z", "completed_at": "2026-02-12T22:49:47.396733Z"}], "thread_id": "Thread-1", "execution_time": 0.0063283443450927734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_blocks_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,label\n    ,value\nFROM (\n    SELECT date, 'produced' AS label, blocks_produced AS value FROM `dbt`.`int_consensus_blocks_daily`\n    UNION ALL \n    SELECT date, 'missed' AS label, blocks_missed AS value FROM `dbt`.`int_consensus_blocks_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_blocks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.399536Z", "completed_at": "2026-02-12T22:49:47.405038Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.405660Z", "completed_at": "2026-02-12T22:49:47.405668Z"}], "thread_id": "Thread-1", "execution_time": 0.007424592971801758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_zero_blob_commitments_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,label\n    ,value\nFROM (\n    SELECT date, 'with Blobs' AS label, toInt64(blocks_produced) - toInt64(blocks_with_zero_blob_commitments) AS value FROM `dbt`.`int_consensus_blocks_daily`\n    UNION ALL \n    SELECT date, 'without Blobs' AS label, toInt64(blocks_with_zero_blob_commitments) AS value FROM `dbt`.`int_consensus_blocks_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_zero_blob_commitments_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.408474Z", "completed_at": "2026-02-12T22:49:47.412483Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.413079Z", "completed_at": "2026-02-12T22:49:47.413086Z"}], "thread_id": "Thread-1", "execution_time": 0.0059070587158203125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_credentials_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,credentials_type\n    ,cnt\n    ,ROUND(cnt/(SUM(cnt) OVER (PARTITION BY date)) * 100,2) AS pct \nFROM `dbt`.`int_consensus_credentials_daily`\nORDER BY date, credentials_type", "relation_name": "`dbt`.`api_consensus_credentials_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.415912Z", "completed_at": "2026-02-12T22:49:47.420045Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.420660Z", "completed_at": "2026-02-12T22:49:47.420667Z"}], "thread_id": "Thread-1", "execution_time": 0.0061686038970947266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_credentials_latest", "compiled": true, "compiled_code": "\n\nSELECT \n    credentials_type\n    ,cnt\nFROM `dbt`.`int_consensus_credentials_daily`\nWHERE date = (SELECT MAX(date) FROM `dbt`.`int_consensus_credentials_daily`)", "relation_name": "`dbt`.`api_consensus_credentials_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.423261Z", "completed_at": "2026-02-12T22:49:47.427872Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.428475Z", "completed_at": "2026-02-12T22:49:47.428483Z"}], "thread_id": "Thread-1", "execution_time": 0.006472110748291016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_credentials_daily_date.4d0b4560ad", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_credentials_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.431209Z", "completed_at": "2026-02-12T22:49:47.435131Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.435758Z", "completed_at": "2026-02-12T22:49:47.435766Z"}], "thread_id": "Thread-1", "execution_time": 0.0058441162109375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_entry_queue_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,validator_count\n    ,q05\n    ,q10\n    ,q25\n    ,q50\n    ,q75\n    ,q90\n    ,q95\n    ,mean\nFROM `dbt`.`int_consensus_entry_queue_daily`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_entry_queue_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.438544Z", "completed_at": "2026-02-12T22:49:47.443086Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.443663Z", "completed_at": "2026-02-12T22:49:47.443670Z"}], "thread_id": "Thread-1", "execution_time": 0.006409406661987305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_entry_queue_daily_date.15e3afea2e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_entry_queue_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.446248Z", "completed_at": "2026-02-12T22:49:47.451990Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.452573Z", "completed_at": "2026-02-12T22:49:47.452580Z"}], "thread_id": "Thread-1", "execution_time": 0.007568836212158203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_entry_queue_daily_validator_index.319160416e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect validator_index\nfrom `dbt`.`int_consensus_entry_queue_daily`\nwhere validator_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.455227Z", "completed_at": "2026-02-12T22:49:47.459758Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.460322Z", "completed_at": "2026-02-12T22:49:47.460329Z"}], "thread_id": "Thread-1", "execution_time": 0.0063745975494384766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_consensus_entry_queue_daily_validator_index.fc738c2e6c", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    validator_index as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_consensus_entry_queue_daily`\nwhere validator_index is not null\ngroup by validator_index\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.463000Z", "completed_at": "2026-02-12T22:49:47.466875Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.467477Z", "completed_at": "2026-02-12T22:49:47.467484Z"}], "thread_id": "Thread-1", "execution_time": 0.005749225616455078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_staked_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,effective_balance/32 AS value\nFROM `dbt`.`int_consensus_validators_balances_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_staked_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.470315Z", "completed_at": "2026-02-12T22:49:47.474500Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.475088Z", "completed_at": "2026-02-12T22:49:47.475095Z"}], "thread_id": "Thread-1", "execution_time": 0.00608515739440918, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_balances_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,value\nFROM (\n    SELECT\n        date\n        ,'balance' AS label\n        ,balance AS value\n    FROM `dbt`.`int_consensus_validators_balances_daily`\n\n    UNION ALL \n\n    SELECT\n        date\n        ,'eff. balance' AS label\n        ,effective_balance AS value\n    FROM `dbt`.`int_consensus_validators_balances_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_validators_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.477896Z", "completed_at": "2026-02-12T22:49:47.482324Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.482909Z", "completed_at": "2026-02-12T22:49:47.482917Z"}], "thread_id": "Thread-1", "execution_time": 0.00642848014831543, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_validators_balances_daily_date.13eaf1e79b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_validators_balances_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.485627Z", "completed_at": "2026-02-12T22:49:47.490645Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.491236Z", "completed_at": "2026-02-12T22:49:47.491243Z"}], "thread_id": "Thread-1", "execution_time": 0.0069811344146728516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_active_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,cnt\nFROM `dbt`.`int_consensus_validators_status_daily`\nWHERE status = 'active_ongoing'\nORDER BY date", "relation_name": "`dbt`.`api_consensus_validators_active_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.494065Z", "completed_at": "2026-02-12T22:49:47.497985Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.498604Z", "completed_at": "2026-02-12T22:49:47.498611Z"}], "thread_id": "Thread-1", "execution_time": 0.005975008010864258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_status_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,status\n    ,cnt\nFROM `dbt`.`int_consensus_validators_status_daily`\nWHERE status NOT IN ('active_ongoing', 'withdrawal_done')\nORDER BY date, status", "relation_name": "`dbt`.`api_consensus_validators_status_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.501329Z", "completed_at": "2026-02-12T22:49:47.505888Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.506530Z", "completed_at": "2026-02-12T22:49:47.506537Z"}], "thread_id": "Thread-1", "execution_time": 0.0065762996673583984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_validators_status_daily_date.8a3bdc4a88", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_validators_status_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.509212Z", "completed_at": "2026-02-12T22:49:47.513073Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.513683Z", "completed_at": "2026-02-12T22:49:47.513691Z"}], "thread_id": "Thread-1", "execution_time": 0.0057582855224609375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_withdrawal_credentials_freq_daily", "compiled": true, "compiled_code": "\nSELECT \n    date\n    ,CASE \n        WHEN cnt < 10 THEN '[1-10['\n        WHEN cnt >= 10 AND cnt < 50 THEN '[10-50['\n        WHEN cnt >= 50 AND cnt < 100 THEN '[50-100['\n        WHEN cnt >= 100 AND cnt < 500 THEN '[100-500['\n        WHEN cnt >= 500 AND cnt < 1000 THEN '[500-1000['\n        WHEN cnt >= 1000 AND cnt < 2000 THEN '[1000-2000['\n        ELSE '2000+'\n    END AS bin_number_validators\n    ,count() AS withdrawal_credentials_freq_cnt\nFROM `dbt`.`int_consensus_withdrawal_credentials_daily`\nGROUP BY 1, 2", "relation_name": "`dbt`.`fct_consensus_withdrawal_credentials_freq_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.516502Z", "completed_at": "2026-02-12T22:49:47.521111Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.521696Z", "completed_at": "2026-02-12T22:49:47.521704Z"}], "thread_id": "Thread-1", "execution_time": 0.006491422653198242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_withdrawal_credentials_daily_date.3c49b681c3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_withdrawal_credentials_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.524377Z", "completed_at": "2026-02-12T22:49:47.528359Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.528963Z", "completed_at": "2026-02-12T22:49:47.528970Z"}], "thread_id": "Thread-1", "execution_time": 0.005865812301635742, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_deposits_withdrawls_cnt_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,cnt AS value\nFROM \n    `dbt`.`int_consensus_deposits_withdrawals_daily`\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_deposits_withdrawls_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.531866Z", "completed_at": "2026-02-12T22:49:47.537067Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.537680Z", "completed_at": "2026-02-12T22:49:47.537687Z"}], "thread_id": "Thread-1", "execution_time": 0.007251262664794922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_deposits_withdrawls_volume_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,total_amount AS value\nFROM \n    `dbt`.`int_consensus_deposits_withdrawals_daily`\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_deposits_withdrawls_volume_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.540432Z", "completed_at": "2026-02-12T22:49:47.544833Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.545395Z", "completed_at": "2026-02-12T22:49:47.545403Z"}], "thread_id": "Thread-1", "execution_time": 0.006392478942871094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_deposits_withdrawals_daily_date.033d8e04f1", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_deposits_withdrawals_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.548199Z", "completed_at": "2026-02-12T22:49:47.552677Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.553296Z", "completed_at": "2026-02-12T22:49:47.553303Z"}], "thread_id": "Thread-1", "execution_time": 0.006420612335205078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_validators_dists_last_30_days", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q_balance[1] AS q05_balance,\n    q_balance[2] AS q10_balance,\n    q_balance[3] AS q25_balance,\n    q_balance[4] AS q50_balance,\n    q_balance[5] AS q75_balance,\n    q_balance[6] AS q90_balance,\n    q_balance[7] AS q95_balance,\n    q_apy[1] AS q05_apy,\n    q_apy[2] AS q10_apy,\n    q_apy[3] AS q25_apy,\n    q_apy[4] AS q50_apy,\n    q_apy[5] AS q75_apy,\n    q_apy[6] AS q90_apy,\n    q_apy[7] AS q95_apy\nFROM (\n    SELECT\n        (SELECT max(date) FROM  `dbt`.`int_consensus_validators_per_index_apy_daily` ) AS date\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(balance/POWER(10,9)) AS q_balance\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(apy) AS q_apy\n    FROM `dbt`.`int_consensus_validators_per_index_apy_daily` \n    WHERE date >= addDays((SELECT max(date) FROM  `dbt`.`int_consensus_validators_per_index_apy_daily` ), -30)\n)", "relation_name": "`dbt`.`fct_consensus_validators_dists_last_30_days`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.556356Z", "completed_at": "2026-02-12T22:49:47.562013Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.562677Z", "completed_at": "2026-02-12T22:49:47.562684Z"}], "thread_id": "Thread-1", "execution_time": 0.007824182510375977, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_dists_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q_balance[1] AS q05_balance,\n    q_balance[2] AS q10_balance,\n    q_balance[3] AS q25_balance,\n    q_balance[4] AS q50_balance,\n    q_balance[5] AS q75_balance,\n    q_balance[6] AS q90_balance,\n    q_balance[7] AS q95_balance,\n    avg_balance,\n    q_apy[1] AS q05_apy,\n    q_apy[2] AS q10_apy,\n    q_apy[3] AS q25_apy,\n    q_apy[4] AS q50_apy,\n    q_apy[5] AS q75_apy,\n    q_apy[6] AS q90_apy,\n    q_apy[7] AS q95_apy,\n    avg_apy\nFROM (\n    SELECT\n        date\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(balance/POWER(10,9)) AS q_balance\n        ,avg(balance/POWER(10,9)) AS avg_balance\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(apy) AS q_apy\n        ,avg(apy) AS avg_apy\n    FROM `dbt`.`int_consensus_validators_per_index_apy_daily`\n    WHERE status != 'pending_queued' AND apy < 200 --outlier filter\n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_consensus_validators_dists_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(date) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_consensus_validators_dists_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    GROUP BY date\n)", "relation_name": "`dbt`.`int_consensus_validators_dists_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.565576Z", "completed_at": "2026-02-12T22:49:47.570181Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.570769Z", "completed_at": "2026-02-12T22:49:47.570777Z"}], "thread_id": "Thread-1", "execution_time": 0.006498098373413086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_validators_per_index_apy_daily_date.d8e4f0bed2", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_validators_per_index_apy_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.573392Z", "completed_at": "2026-02-12T22:49:47.579618Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.580186Z", "completed_at": "2026-02-12T22:49:47.580195Z"}], "thread_id": "Thread-1", "execution_time": 0.008054494857788086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_validators_per_index_apy_daily_validator_index.bf0825b655", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect validator_index\nfrom `dbt`.`int_consensus_validators_per_index_apy_daily`\nwhere validator_index is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.582880Z", "completed_at": "2026-02-12T22:49:47.587669Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.588236Z", "completed_at": "2026-02-12T22:49:47.588244Z"}], "thread_id": "Thread-1", "execution_time": 0.006631612777709961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_consensus_validators_per_index_apy_daily_validator_index.d0da5cde77", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    validator_index as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_consensus_validators_per_index_apy_daily`\nwhere validator_index is not null\ngroup by validator_index\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.590977Z", "completed_at": "2026-02-12T22:49:47.597057Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.597665Z", "completed_at": "2026-02-12T22:49:47.597672Z"}], "thread_id": "Thread-1", "execution_time": 0.008037328720092773, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_bridges_kpis_snapshot", "compiled": true, "compiled_code": "\n\nWITH mx AS (\n  SELECT max(date) AS d\n  FROM `dbt`.`int_bridges_flows_daily`\n),\ncum AS (\n  SELECT\n    sum(volume_usd) AS cum_vol_usd,\n    sum(net_usd)    AS cum_net_usd,\n    sum(txs)        AS cum_txs\n  FROM `dbt`.`int_bridges_flows_daily`, mx\n  WHERE date <= mx.d\n),\ncur7 AS (\n  SELECT\n    sum(volume_usd) AS vol_7d,\n    sum(net_usd)    AS net_7d,\n    sum(txs)        AS txs_7d\n  FROM `dbt`.`int_bridges_flows_daily`, mx\n  WHERE date BETWEEN subtractDays(mx.d, 6) AND mx.d\n),\nprev7 AS (\n  SELECT\n    sum(volume_usd) AS vol_prev_7d,\n    sum(net_usd)    AS net_prev_7d,\n    sum(txs)        AS txs_prev_7d\n  FROM `dbt`.`int_bridges_flows_daily`, mx\n  WHERE date BETWEEN subtractDays(mx.d, 13) AND subtractDays(mx.d, 7)\n),\nbridges AS (\n  SELECT uniqExact(trim(lower(bridge))) AS distinct_bridges\n  FROM `dbt`.`int_bridges_flows_daily`, mx\n  WHERE date <= mx.d\n),\nchains_u AS (\n  SELECT trim(lower(source_chain)) AS chain\n  FROM `dbt`.`int_bridges_flows_daily`, mx\n  WHERE date <= mx.d AND lower(source_chain) != 'gnosis'\n  UNION ALL\n  SELECT trim(lower(dest_chain)) AS chain\n  FROM `dbt`.`int_bridges_flows_daily`, mx\n  WHERE date <= mx.d AND lower(dest_chain) != 'gnosis'\n),\nchains AS (\n  SELECT uniqExact(chain) AS distinct_chains\n  FROM chains_u\n)\nSELECT\n  mx.d AS as_of_date,\n  cum.cum_vol_usd,\n  cum.cum_net_usd,\n  cum.cum_txs,\n  cur7.vol_7d,\n  cur7.net_7d,\n  cur7.txs_7d,\n  coalesce(prev7.vol_prev_7d, 0) AS vol_prev_7d,\n  coalesce(prev7.net_prev_7d, 0) AS net_prev_7d,\n  coalesce(prev7.txs_prev_7d, 0) AS txs_prev_7d,\n  if(cur7.vol_7d = 0, NULL, cur7.net_7d / cur7.vol_7d) AS rate_7d,\n  if(coalesce(prev7.vol_prev_7d,0) = 0, NULL, coalesce(prev7.net_prev_7d,0) / prev7.vol_prev_7d) AS rate_prev_7d,\n  if(coalesce(prev7.vol_prev_7d,0) = 0, NULL, (cur7.vol_7d - coalesce(prev7.vol_prev_7d,0)) / prev7.vol_prev_7d) AS chg_vol_7d,\n  if(coalesce(prev7.net_prev_7d,0) = 0, NULL, (cur7.net_7d - coalesce(prev7.net_prev_7d,0)) / prev7.net_prev_7d) AS chg_net_7d,\n  if(\n    coalesce(prev7.vol_prev_7d,0) = 0 OR coalesce(prev7.net_prev_7d,0) = 0 OR cur7.vol_7d = 0 OR cur7.net_7d = 0,\n    NULL,\n    ( (cur7.net_7d / cur7.vol_7d) - (prev7.net_prev_7d / prev7.vol_prev_7d) ) / (prev7.net_prev_7d / prev7.vol_prev_7d)\n  ) AS chg_rate_7d,\n  bridges.distinct_bridges,\n  chains.distinct_chains\nFROM mx, cum, cur7, prev7, bridges, chains", "relation_name": "`dbt`.`fct_bridges_kpis_snapshot`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.600533Z", "completed_at": "2026-02-12T22:49:47.604914Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.605557Z", "completed_at": "2026-02-12T22:49:47.605565Z"}], "thread_id": "Thread-1", "execution_time": 0.0064144134521484375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_bridges_netflow_weekly_by_bridge", "compiled": true, "compiled_code": "\n\nWITH w AS (\n  SELECT\n    toStartOfWeek(date, 1) AS week,\n    bridge,\n    sum(net_usd)           AS netflow_usd_week\n  FROM `dbt`.`int_bridges_flows_daily`\n  WHERE date < toStartOfWeek(today(), 1)\n  GROUP BY week, bridge\n),\nbounds AS (\n  SELECT min(week) AS minw, max(week) AS maxw FROM w\n),\ncalendar AS (\n  SELECT toDate(addWeeks(minw, number)) AS week\n  FROM bounds\n  ARRAY JOIN range(dateDiff('week', minw, maxw) + 1) AS number\n),\nbridges AS (\n  SELECT DISTINCT bridge FROM w\n),\ngrid AS (\n  SELECT b.bridge, c.week\n  FROM bridges b\n  CROSS JOIN calendar c\n),\nfilled AS (\n  SELECT\n    g.week,\n    g.bridge,\n    coalesce(w.netflow_usd_week, 0) AS netflow_usd_week\n  FROM grid g\n  LEFT JOIN w\n    ON w.week = g.week\n   AND w.bridge = g.bridge\n)\nSELECT\n  week,\n  bridge,\n  netflow_usd_week,\n  sum(netflow_usd_week) OVER (\n    PARTITION BY bridge\n    ORDER BY week\n    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n  ) AS cum_netflow_usd\nFROM filled\nORDER BY week, bridge", "relation_name": "`dbt`.`fct_bridges_netflow_weekly_by_bridge`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.608372Z", "completed_at": "2026-02-12T22:49:47.612872Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.613485Z", "completed_at": "2026-02-12T22:49:47.613492Z"}], "thread_id": "Thread-1", "execution_time": 0.006407260894775391, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_bridges_sankey_edges_token_daily", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT\n    date,\n    source_chain              AS source_chain,\n    dest_chain                AS dest_chain,\n    bridge                    AS bridge,\n    token                     AS token,\n    toFloat64(volume_usd)     AS volume_usd\n  FROM `dbt`.`int_bridges_flows_daily`\n  WHERE date < today()  \n),\n\nout_left AS (\n  SELECT\n    b.date,\n    'out'         AS direction,\n    'left'        AS side,\n    'gnosis'      AS source,\n    b.bridge      AS target,\n    b.token,\n    sum(b.volume_usd) AS value\n  FROM base b\n  WHERE b.source_chain = 'gnosis'\n  GROUP BY b.date, direction, side, source, target, b.token\n),\nout_right AS (\n  SELECT\n    b.date,\n    'out'         AS direction,\n    'right'       AS side,\n    b.bridge      AS source,\n    b.dest_chain  AS target,   \n    b.token,\n    sum(b.volume_usd) AS value\n  FROM base b\n  WHERE b.source_chain = 'gnosis'\n    AND b.dest_chain  != 'gnosis'\n  GROUP BY b.date, direction, side, source, target, b.token\n),\n\nin_left AS (\n  SELECT\n    b.date,\n    'in'          AS direction,\n    'left'        AS side,\n    b.source_chain AS source,  \n    b.bridge       AS target,\n    b.token,\n    sum(b.volume_usd) AS value\n  FROM base b\n  WHERE b.dest_chain = 'gnosis'\n    AND b.source_chain != 'gnosis'\n  GROUP BY b.date, direction, side, source, target, b.token\n),\nin_right AS (\n  SELECT\n    b.date,\n    'in'          AS direction,\n    'right'       AS side,\n    b.bridge      AS source,\n    'gnosis'      AS target,\n    b.token,\n    sum(b.volume_usd) AS value\n  FROM base b\n  WHERE b.dest_chain = 'gnosis'\n  GROUP BY b.date, direction, side, source, target, b.token\n)\n\nSELECT * FROM out_left\nUNION ALL SELECT * FROM out_right\nUNION ALL SELECT * FROM in_left\nUNION ALL SELECT * FROM in_right", "relation_name": "`dbt`.`fct_bridges_sankey_edges_token_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.616281Z", "completed_at": "2026-02-12T22:49:47.620939Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.621581Z", "completed_at": "2026-02-12T22:49:47.621588Z"}], "thread_id": "Thread-1", "execution_time": 0.006716728210449219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_bridges_token_netflow_daily_by_bridge", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  bridge                 AS bridge,\n  token                  AS token,\n  sum(net_usd)           AS value\nFROM `dbt`.`int_bridges_flows_daily`\nWHERE date < today()               \nGROUP BY date, bridge, token\nORDER BY date, bridge, token", "relation_name": "`dbt`.`fct_bridges_token_netflow_daily_by_bridge`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.624472Z", "completed_at": "2026-02-12T22:49:47.630234Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.630823Z", "completed_at": "2026-02-12T22:49:47.630831Z"}], "thread_id": "Thread-1", "execution_time": 0.007745504379272461, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_bridge.22fa82ecb1", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect bridge\nfrom `dbt`.`int_bridges_flows_daily`\nwhere bridge is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.633488Z", "completed_at": "2026-02-12T22:49:47.637897Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.638476Z", "completed_at": "2026-02-12T22:49:47.638483Z"}], "thread_id": "Thread-1", "execution_time": 0.0062694549560546875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_date.d92f7bda3a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_bridges_flows_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.641127Z", "completed_at": "2026-02-12T22:49:47.645565Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.646135Z", "completed_at": "2026-02-12T22:49:47.646142Z"}], "thread_id": "Thread-1", "execution_time": 0.006326913833618164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_dest_chain.7a88b5c775", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect dest_chain\nfrom `dbt`.`int_bridges_flows_daily`\nwhere dest_chain is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.648816Z", "completed_at": "2026-02-12T22:49:47.653264Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.653842Z", "completed_at": "2026-02-12T22:49:47.653849Z"}], "thread_id": "Thread-1", "execution_time": 0.006363391876220703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_direction.d762c3bc15", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect direction\nfrom `dbt`.`int_bridges_flows_daily`\nwhere direction is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.656519Z", "completed_at": "2026-02-12T22:49:47.660984Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.661564Z", "completed_at": "2026-02-12T22:49:47.661571Z"}], "thread_id": "Thread-1", "execution_time": 0.006340503692626953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_net_usd.54a757230e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect net_usd\nfrom `dbt`.`int_bridges_flows_daily`\nwhere net_usd is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.664205Z", "completed_at": "2026-02-12T22:49:47.670014Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.670597Z", "completed_at": "2026-02-12T22:49:47.670604Z"}], "thread_id": "Thread-1", "execution_time": 0.007720470428466797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_source_chain.70f106b0e7", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect source_chain\nfrom `dbt`.`int_bridges_flows_daily`\nwhere source_chain is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.673242Z", "completed_at": "2026-02-12T22:49:47.677715Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.678276Z", "completed_at": "2026-02-12T22:49:47.678284Z"}], "thread_id": "Thread-1", "execution_time": 0.006356954574584961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_token.f1ed52e8b3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect token\nfrom `dbt`.`int_bridges_flows_daily`\nwhere token is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.680960Z", "completed_at": "2026-02-12T22:49:47.685404Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.685984Z", "completed_at": "2026-02-12T22:49:47.685992Z"}], "thread_id": "Thread-1", "execution_time": 0.006356239318847656, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_txs.dc0f757424", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect txs\nfrom `dbt`.`int_bridges_flows_daily`\nwhere txs is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.688659Z", "completed_at": "2026-02-12T22:49:47.693097Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.693679Z", "completed_at": "2026-02-12T22:49:47.693686Z"}], "thread_id": "Thread-1", "execution_time": 0.006334781646728516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_volume_token.8f5dfe2767", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect volume_token\nfrom `dbt`.`int_bridges_flows_daily`\nwhere volume_token is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.696341Z", "completed_at": "2026-02-12T22:49:47.700825Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.701387Z", "completed_at": "2026-02-12T22:49:47.701394Z"}], "thread_id": "Thread-1", "execution_time": 0.006330728530883789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_bridges_flows_daily_volume_usd.4cd92ff813", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect volume_usd\nfrom `dbt`.`int_bridges_flows_daily`\nwhere volume_usd is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.704056Z", "completed_at": "2026-02-12T22:49:47.708824Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.709387Z", "completed_at": "2026-02-12T22:49:47.709395Z"}], "thread_id": "Thread-1", "execution_time": 0.0066754817962646484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_crawlers_data_gno_supply_daily_date.c4ad37ea75", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_crawlers_data_gno_supply_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.712104Z", "completed_at": "2026-02-12T22:49:47.717490Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.718085Z", "completed_at": "2026-02-12T22:49:47.718092Z"}], "thread_id": "Thread-1", "execution_time": 0.007318735122680664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_cnt_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,n_txs AS value\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.720911Z", "completed_at": "2026-02-12T22:49:47.724826Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.725426Z", "completed_at": "2026-02-12T22:49:47.725433Z"}], "thread_id": "Thread-1", "execution_time": 0.005948305130004883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_cnt_total", "compiled": true, "compiled_code": "\n\nSELECT\n    transaction_type\n    ,SUM(n_txs) AS value\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nGROUP BY transaction_type\nORDER BY transaction_type", "relation_name": "`dbt`.`api_execution_transactions_cnt_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.728161Z", "completed_at": "2026-02-12T22:49:47.732081Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.732699Z", "completed_at": "2026-02-12T22:49:47.732707Z"}], "thread_id": "Thread-1", "execution_time": 0.00588226318359375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_gas_used_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,gas_used\n    ,gas_price_avg\n    ,gas_price_median\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_gas_used_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.735540Z", "completed_at": "2026-02-12T22:49:47.739429Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.740019Z", "completed_at": "2026-02-12T22:49:47.740026Z"}], "thread_id": "Thread-1", "execution_time": 0.005940914154052734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_gas_used_weekly", "compiled": true, "compiled_code": "\n\nSELECT\n  toStartOfWeek(date)        AS date,          \n  transaction_type           AS label,\n  sum(gas_used)              AS value\n  -- avg(gas_price_avg)         AS gas_price_avg,     \n  -- median(gas_price_median)   AS gas_price_median   \nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\n  AND date < toStartOfWeek(today())               \nGROUP BY date, label\nORDER BY date, label", "relation_name": "`dbt`.`api_execution_transactions_gas_used_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.742841Z", "completed_at": "2026-02-12T22:49:47.746739Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.747325Z", "completed_at": "2026-02-12T22:49:47.747332Z"}], "thread_id": "Thread-1", "execution_time": 0.0059146881103515625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_value_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,xdai_value \n    ,xdai_value_avg \n    ,xdai_value_median\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_value_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.750049Z", "completed_at": "2026-02-12T22:49:47.754804Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.755383Z", "completed_at": "2026-02-12T22:49:47.755390Z"}], "thread_id": "Thread-1", "execution_time": 0.006729602813720703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_info_daily_block_timestamp.1921bb7d1e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect block_timestamp\nfrom `dbt`.`int_execution_transactions_info_daily`\nwhere block_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.758110Z", "completed_at": "2026-02-12T22:49:47.763925Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.764506Z", "completed_at": "2026-02-12T22:49:47.764514Z"}], "thread_id": "Thread-1", "execution_time": 0.007711887359619141, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_info_daily_date.5c42bfc6c2", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_transactions_info_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.767160Z", "completed_at": "2026-02-12T22:49:47.771688Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.772250Z", "completed_at": "2026-02-12T22:49:47.772257Z"}], "thread_id": "Thread-1", "execution_time": 0.006409168243408203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_probelab_clients_daily_date.1689fe7ae8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_probelab_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.774897Z", "completed_at": "2026-02-12T22:49:47.779328Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.779913Z", "completed_at": "2026-02-12T22:49:47.779920Z"}], "thread_id": "Thread-1", "execution_time": 0.006315469741821289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_probelab_clients_version_daily_date.3153592556", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_probelab_clients_version_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.782664Z", "completed_at": "2026-02-12T22:49:47.787149Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.787726Z", "completed_at": "2026-02-12T22:49:47.787734Z"}], "thread_id": "Thread-1", "execution_time": 0.0064885616302490234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_probelab_clients_cloud_daily_date.85645cfc12", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_probelab_clients_cloud_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.790346Z", "completed_at": "2026-02-12T22:49:47.794810Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.795369Z", "completed_at": "2026-02-12T22:49:47.795376Z"}], "thread_id": "Thread-1", "execution_time": 0.0062978267669677734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_probelab_clients_country_daily_date.17a4b4d6fd", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_probelab_clients_country_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.798011Z", "completed_at": "2026-02-12T22:49:47.803613Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.804173Z", "completed_at": "2026-02-12T22:49:47.804181Z"}], "thread_id": "Thread-1", "execution_time": 0.007463693618774414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_probelab_clients_quic_daily_date.469721c547", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_probelab_clients_quic_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.806903Z", "completed_at": "2026-02-12T22:49:47.810902Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.811510Z", "completed_at": "2026-02-12T22:49:47.811518Z"}], "thread_id": "Thread-1", "execution_time": 0.005961179733276367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_state_full_size_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,SUM(bytes_diff) OVER (ORDER BY date ASC) AS bytes\nFROM `dbt`.`int_execution_state_size_full_diff_daily`\nWHERE date < today()", "relation_name": "`dbt`.`fct_execution_state_full_size_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.814382Z", "completed_at": "2026-02-12T22:49:47.818889Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.819474Z", "completed_at": "2026-02-12T22:49:47.819482Z"}], "thread_id": "Thread-1", "execution_time": 0.006582736968994141, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_state_size_full_diff_daily_date.d17c9483d0", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_state_size_full_diff_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.822190Z", "completed_at": "2026-02-12T22:49:47.827906Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.828520Z", "completed_at": "2026-02-12T22:49:47.828527Z"}], "thread_id": "Thread-1", "execution_time": 0.007674694061279297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_clients_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,argMax(IF(client='','Unknown',client),visit_ended_at) AS client\n        ,argMax(platform,visit_ended_at) AS platform\n        ,argMax(generic_provider,visit_ended_at) AS generic_provider\n        ,argMax(peer_country,visit_ended_at) AS peer_country\n    FROM `dbt`.`int_p2p_discv4_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(visit_ended_at)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_p2p_discv4_clients_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(visit_ended_at) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_p2p_discv4_clients_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT date , 'Clients' AS metric, client AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Platform' AS metric, platform AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Provider' AS metric, generic_provider AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Country' AS metric, peer_country AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv4_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.831297Z", "completed_at": "2026-02-12T22:49:47.837019Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.837645Z", "completed_at": "2026-02-12T22:49:47.837652Z"}], "thread_id": "Thread-1", "execution_time": 0.00774836540222168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\n-- 1) First CTE: basic peer info\ngnosis_peers AS (\n    SELECT \n        peer_id,\n        ip,\n        any(client) AS client\n    FROM `dbt`.`int_p2p_discv4_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) = today() - INTERVAL 1 DAY\n        AND empty(dial_errors) = 1\n        AND crawl_error IS NULL\n    GROUP BY\n        peer_id,\n        ip\n),\n\n-- 2) Second CTE: attach discovery_id_prefix to each peer\ngnosis_prefixes AS (\n    SELECT \n        d.discovery_id_prefix,\n        d.peer_id,\n        p.ip,\n        IF(p.client='', 'Unknown', p.client) AS client\n    FROM `dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids` AS d\n    INNER JOIN gnosis_peers AS p\n      ON p.peer_id = d.peer_id\n)\n\nSELECT\n    t1.date,\n\n    -- Peer columns from the subquery t1\n    t1.peer_ip,\n    t1.peer_discovery_id_prefix,\n    t1.peer_client,\n\n    -- Geographical info for peer (from crawlers_data.ipinfo)\n    peer_info.hostname   AS peer_hostname,\n    peer_info.city       AS peer_city,\n    peer_info.country    AS peer_country,\n    peer_info.org        AS peer_org,\n    peer_info.loc        AS peer_loc,\n\n    -- Neighbor columns from subquery t1\n    t1.neighbor_ip,\n    t1.neighbor_discovery_id_prefix,\n    t1.neighbor_client,\n\n    -- Geographical info for neighbor (from crawlers_data.ipinfo)\n    neighbor_info.city    AS neighbor_city,\n    neighbor_info.country AS neighbor_country,\n    neighbor_info.org     AS neighbor_org,\n    neighbor_info.loc     AS neighbor_loc,\n\n    -- Finally, the count of edges\n    t1.cnt\nFROM (\n    SELECT\n        toStartOfDay(n.crawl_created_at) AS date,\n\n        -- \u201cPeer\u201d side of the edge\n        peer_p.ip                      AS peer_ip,\n        peer_p.discovery_id_prefix     AS peer_discovery_id_prefix,\n        peer_p.client                  AS peer_client,\n\n        -- \u201cNeighbor\u201d side of the edge\n        neighbor_p.ip                      AS neighbor_ip,\n        neighbor_p.discovery_id_prefix     AS neighbor_discovery_id_prefix,\n        neighbor_p.client                  AS neighbor_client,\n\n        COUNT(*) AS cnt\n    FROM `dbt`.`stg_nebula_discv4__neighbors` AS n\n\n    -- join to get the discovery_prefix + client/fork info for \u201cpeer\u201d\n    INNER JOIN gnosis_prefixes AS peer_p\n      ON peer_p.discovery_id_prefix = n.peer_discovery_id_prefix\n\n    -- join to get the discovery_prefix + client/fork info for \u201cneighbor\u201d\n    INNER JOIN gnosis_prefixes AS neighbor_p\n      ON neighbor_p.discovery_id_prefix = n.neighbor_discovery_id_prefix\n\n    WHERE\n        toStartOfDay(n.crawl_created_at) = today() - INTERVAL 1 DAY\n\n    GROUP BY\n        date,\n        peer_p.ip,\n        peer_p.discovery_id_prefix,\n        peer_p.client,\n        neighbor_p.ip,\n        neighbor_p.discovery_id_prefix,\n        neighbor_p.client\n) AS t1\n\n-- LEFT JOIN to ipinfo for \u201cpeer\u201d\nLEFT JOIN  `dbt`.`stg_crawlers_data__ipinfo` AS peer_info\n  ON peer_info.ip = t1.peer_ip\n\n-- LEFT JOIN to ipinfo for \u201cneighbor\u201d\nLEFT JOIN  `dbt`.`stg_crawlers_data__ipinfo` AS neighbor_info\n  ON neighbor_info.ip = t1.neighbor_ip", "relation_name": "`dbt`.`int_p2p_discv4_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.840508Z", "completed_at": "2026-02-12T22:49:47.846288Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.846884Z", "completed_at": "2026-02-12T22:49:47.846891Z"}], "thread_id": "Thread-1", "execution_time": 0.007860422134399414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv4_peers_peer_id.85213b218b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_p2p_discv4_peers`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.849547Z", "completed_at": "2026-02-12T22:49:47.853992Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.854573Z", "completed_at": "2026-02-12T22:49:47.854581Z"}], "thread_id": "Thread-1", "execution_time": 0.006296873092651367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv4_peers_visit_ended_at.892f1eee6a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect visit_ended_at\nfrom `dbt`.`int_p2p_discv4_peers`\nwhere visit_ended_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.857198Z", "completed_at": "2026-02-12T22:49:47.861632Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.862192Z", "completed_at": "2026-02-12T22:49:47.862200Z"}], "thread_id": "Thread-1", "execution_time": 0.006255626678466797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_p2p_discv4_peers_peer_id.6c2e84dcf5", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_p2p_discv4_peers`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.864830Z", "completed_at": "2026-02-12T22:49:47.869276Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.869864Z", "completed_at": "2026-02-12T22:49:47.869872Z"}], "thread_id": "Thread-1", "execution_time": 0.006325960159301758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv4_visits_daily_date.7c3cc85976", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_p2p_discv4_visits_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.872629Z", "completed_at": "2026-02-12T22:49:47.882761Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.883360Z", "completed_at": "2026-02-12T22:49:47.883367Z"}], "thread_id": "Thread-1", "execution_time": 0.01213836669921875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_population_chao1", "compiled": true, "compiled_code": "\n\nWITH peer_connection_analysis AS (\n    SELECT\n        toDate(visit_ended_at) AS observation_date,\n        peer_id,\n        crawl_id,\n        \n        -- Categorize connection attempts\n        CASE \n            WHEN empty(dial_errors) = 1 AND crawl_error IS NULL THEN 'successful'\n            WHEN empty(dial_errors) = 0 OR crawl_error IS NOT NULL THEN 'failed'\n            ELSE 'unknown'\n        END AS connection_status,\n        \n        -- More granular failure analysis\n        CASE \n            WHEN empty(dial_errors) = 1 AND crawl_error IS NULL THEN 'successful'\n            WHEN crawl_error LIKE '%timeout%' THEN 'timeout'\n            WHEN crawl_error LIKE '%refused%' OR crawl_error LIKE '%connection refused%' THEN 'refused' \n            WHEN crawl_error LIKE '%unreachable%' THEN 'unreachable'\n            WHEN crawl_error LIKE '%protocol%' THEN 'protocol_mismatch'\n            WHEN NOT empty(dial_errors) THEN 'dial_error'\n            ELSE 'other_failure'\n        END AS failure_type\n        \n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(visit_ended_at)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.observation_date)), -0))\n      FROM `dbt`.`int_esg_node_population_chao1` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(visit_ended_at) >= (\n      SELECT addDays(max(toDate(x2.observation_date)), -0)\n      FROM `dbt`.`int_esg_node_population_chao1` AS x2\n      WHERE 1=1 \n    )\n  \n\n),\n\n-- Chao-1 for successful connections only\nsuccessful_chao1 AS (\n    SELECT\n        observation_date,\n        peer_id,\n        COUNT(DISTINCT crawl_id) AS times_observed\n    FROM peer_connection_analysis\n    WHERE connection_status = 'successful'\n    \n        AND observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nsuccessful_stats AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS s_obs_successful,\n        SUM(CASE WHEN times_observed = 1 THEN 1 ELSE 0 END) AS f1_successful,\n        SUM(CASE WHEN times_observed = 2 THEN 1 ELSE 0 END) AS f2_successful\n    FROM successful_chao1\n    GROUP BY observation_date\n),\n\n-- Chao-1 for ALL connection attempts (successful + failed)\nall_attempts_chao1 AS (\n    SELECT\n        observation_date,\n        peer_id,\n        COUNT(DISTINCT crawl_id) AS times_observed\n    FROM peer_connection_analysis\n    \n        WHERE observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nall_attempts_stats AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS s_obs_all,\n        SUM(CASE WHEN times_observed = 1 THEN 1 ELSE 0 END) AS f1_all,\n        SUM(CASE WHEN times_observed = 2 THEN 1 ELSE 0 END) AS f2_all\n    FROM all_attempts_chao1\n    GROUP BY observation_date\n),\n\n-- Additional peers known from failed connections\npeer_status_summary AS (\n    SELECT\n        observation_date,\n        peer_id,\n        MAX(CASE WHEN connection_status = 'successful' THEN 1 ELSE 0 END) AS had_success,\n        MAX(CASE WHEN connection_status = 'failed' THEN 1 ELSE 0 END) AS had_failure\n    FROM peer_connection_analysis\n    \n        WHERE observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nfailed_only_peers AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS peers_with_only_failures\n    FROM peer_status_summary\n    WHERE had_failure = 1 AND had_success = 0\n    GROUP BY observation_date\n),\n\n-- Connection success rates by failure type\nfailure_analysis AS (\n    SELECT\n        observation_date,\n        failure_type,\n        COUNT(DISTINCT peer_id) AS peer_count,\n        COUNT(*) AS attempt_count,\n        \n        -- Estimate reachability probability based on failure type\n        CASE failure_type\n            WHEN 'timeout' THEN 0.3      -- Sometimes reachable\n            WHEN 'refused' THEN 0.1      -- Rarely reachable (firewall/NAT)\n            WHEN 'unreachable' THEN 0.05 -- Very rarely reachable\n            WHEN 'protocol_mismatch' THEN 0.8  -- Likely reachable with right protocol\n            WHEN 'dial_error' THEN 0.2   -- Sometimes reachable\n            ELSE 0.1\n        END AS estimated_reachability_prob\n        \n    FROM peer_connection_analysis\n    WHERE connection_status = 'failed'\n    \n        AND observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, failure_type\n),\n\n-- Calculate enhanced estimates\nenhanced_calculations AS (\n    SELECT\n        COALESCE(s.observation_date, a.observation_date) AS observation_date,\n        \n        -- Successful connection metrics\n        COALESCE(s.s_obs_successful, 0) AS observed_successful_nodes,\n        CASE\n            WHEN COALESCE(s.f2_successful, 0) > 0 THEN \n                COALESCE(s.s_obs_successful, 0) + toFloat64(s.f1_successful * (s.f1_successful - 1)) / (2.0 * toFloat64(s.f2_successful + 1))\n            WHEN COALESCE(s.f1_successful, 0) > 0 THEN \n                COALESCE(s.s_obs_successful, 0) + toFloat64(s.f1_successful * (s.f1_successful - 1)) / 2.0\n            ELSE \n                toFloat64(COALESCE(s.s_obs_successful, 0))\n        END AS chao1_successful,\n        \n        -- All attempt metrics  \n        COALESCE(a.s_obs_all, 0) AS observed_total_peers,\n        CASE\n            WHEN COALESCE(a.f2_all, 0) > 0 THEN \n                COALESCE(a.s_obs_all, 0) + toFloat64(a.f1_all * (a.f1_all - 1)) / (2.0 * toFloat64(a.f2_all + 1))\n            WHEN COALESCE(a.f1_all, 0) > 0 THEN \n                COALESCE(a.s_obs_all, 0) + toFloat64(a.f1_all * (a.f1_all - 1)) / 2.0\n            ELSE \n                toFloat64(COALESCE(a.s_obs_all, 0))\n        END AS chao1_all_attempts,\n        \n        -- Failed connection insights\n        COALESCE(f.peers_with_only_failures, 0) AS failed_only_peers,\n        \n        COALESCE(s.f1_successful, 0) AS f1_successful,\n        COALESCE(s.f2_successful, 0) AS f2_successful,\n        COALESCE(a.f1_all, 0) AS f1_all,\n        COALESCE(a.f2_all, 0) AS f2_all\n        \n    FROM successful_stats s\n    FULL OUTER JOIN all_attempts_stats a ON s.observation_date = a.observation_date\n    LEFT JOIN failed_only_peers f ON COALESCE(s.observation_date, a.observation_date) = f.observation_date\n),\n\n-- Separate CTE for failure analysis aggregation\nfailure_reachability AS (\n    SELECT\n        observation_date,\n        SUM(toFloat64(peer_count) * estimated_reachability_prob) AS estimated_reachable_from_failures\n    FROM failure_analysis\n    GROUP BY observation_date\n),\n\n-- Combine all estimates\ncombined_estimates AS (\n    SELECT\n        e.*,\n        COALESCE(fr.estimated_reachable_from_failures, 0.0) AS estimated_reachable_from_failures\n    FROM enhanced_calculations e\n    LEFT JOIN failure_reachability fr ON e.observation_date = fr.observation_date\n),\n\nfinal_estimates AS (\n    SELECT\n        observation_date,\n        observed_successful_nodes,\n        observed_total_peers,\n        failed_only_peers,\n        \n        -- Different estimation approaches\n        toUInt64(round(chao1_successful, 0)) AS chao1_successful_only,\n        toUInt64(round(chao1_all_attempts, 0)) AS chao1_all_discovered,\n        toUInt64(round(estimated_reachable_from_failures, 0)) AS estimated_additional_reachable,\n        \n        -- Enhanced total estimate combining multiple signals\n        toUInt64(round(\n            chao1_successful +  -- Hidden successful nodes\n            estimated_reachable_from_failures  -- Additional reachable from failures\n        , 0)) AS enhanced_total_reachable,\n        \n        -- Network size estimate (includes unreachable nodes)\n        toUInt64(round(chao1_all_attempts, 0)) AS estimated_network_size,\n        \n        -- Success rates\n        CASE WHEN observed_total_peers > 0 THEN \n            round(100.0 * observed_successful_nodes / observed_total_peers, 2)\n        ELSE 0 END AS connection_success_rate_pct,\n        \n        -- Coverage estimates\n        CASE WHEN chao1_all_attempts > 0 THEN\n            round(100.0 * observed_total_peers / chao1_all_attempts, 2)\n        ELSE 100 END AS network_discovery_coverage_pct,\n        \n        CASE WHEN enhanced_total_reachable > 0 THEN\n            round(100.0 * observed_successful_nodes / enhanced_total_reachable, 2) \n        ELSE 100 END AS reachable_discovery_coverage_pct,\n        \n        -- Diagnostic info\n        f1_successful, f2_successful, f1_all, f2_all\n        \n    FROM combined_estimates\n)\n\nSELECT\n    observation_date,\n    \n    -- Core metrics\n    observed_successful_nodes,\n    observed_total_peers, \n    failed_only_peers,\n    \n    -- Population estimates\n    chao1_successful_only,\n    enhanced_total_reachable,\n    estimated_network_size,\n    estimated_additional_reachable,\n    \n    -- Success and coverage rates\n    connection_success_rate_pct,\n    network_discovery_coverage_pct,\n    reachable_discovery_coverage_pct,\n    \n    -- Hidden node estimates\n    chao1_successful_only - observed_successful_nodes AS hidden_successful_nodes,\n    enhanced_total_reachable - observed_successful_nodes AS hidden_reachable_nodes,\n    estimated_network_size - observed_total_peers AS hidden_total_nodes,\n    \n    -- Percentages\n    CASE WHEN chao1_successful_only > 0 THEN\n        round(100.0 * (chao1_successful_only - observed_successful_nodes) / chao1_successful_only, 2)\n    ELSE 0 END AS hidden_successful_pct,\n    \n    CASE WHEN estimated_network_size > 0 THEN\n        round(100.0 * (estimated_network_size - observed_total_peers) / estimated_network_size, 2) \n    ELSE 0 END AS hidden_total_pct,\n    \n    -- Diagnostic information\n    f1_successful AS successful_singletons,\n    f2_successful AS successful_doubletons,\n    f1_all AS all_singletons,\n    f2_all AS all_doubletons,\n    \n    now() AS calculated_at\n\nFROM final_estimates\nORDER BY observation_date DESC", "relation_name": "`dbt`.`int_esg_node_population_chao1`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.886266Z", "completed_at": "2026-02-12T22:49:47.891966Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.892612Z", "completed_at": "2026-02-12T22:49:47.892619Z"}], "thread_id": "Thread-1", "execution_time": 0.007729291915893555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_clients_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,argMax(IF(client='','Unknown',client),visit_ended_at) AS client\n        ,argMax(platform,visit_ended_at) AS platform\n        ,argMax(generic_provider,visit_ended_at) AS generic_provider\n        ,argMax(peer_country,visit_ended_at) AS peer_country\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(visit_ended_at)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_p2p_discv5_clients_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(visit_ended_at) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_p2p_discv5_clients_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT date , 'Clients' AS metric, client AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Platform' AS metric, platform AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Provider' AS metric, generic_provider AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Country' AS metric, peer_country AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv5_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.895440Z", "completed_at": "2026-02-12T22:49:47.902338Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.902952Z", "completed_at": "2026-02-12T22:49:47.902959Z"}], "thread_id": "Thread-1", "execution_time": 0.008935928344726562, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_forks_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,toString(any(cl_fork_name)) AS fork\n        ,toString(any(cl_next_fork_name)) AS next_fork\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(visit_ended_at)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_p2p_discv5_forks_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(visit_ended_at) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_p2p_discv5_forks_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,'Current Fork' AS label\n    ,fork AS fork\n    ,COUNT(*) AS cnt\nFROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL\n\nSELECT\n    date\n    ,'Next Fork' AS label\n    ,next_fork AS fork\n    ,COUNT(*) AS cnt\nFROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv5_forks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.905842Z", "completed_at": "2026-02-12T22:49:47.911735Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.912335Z", "completed_at": "2026-02-12T22:49:47.912343Z"}], "thread_id": "Thread-1", "execution_time": 0.007901430130004883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\n-- 1) First CTE: basic peer info\ngnosis_peers AS (\n    SELECT \n        peer_id,\n        cl_fork_name,\n        cl_next_fork_name,\n        ip,\n        any(splitByChar('/', agent_version)[1]) AS client\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) = today() - INTERVAL 1 DAY\n        AND empty(dial_errors) = 1\n        AND crawl_error IS NULL\n    GROUP BY\n        peer_id,\n        cl_fork_name,\n        cl_next_fork_name,\n        ip\n),\n\n-- 2) Second CTE: attach discovery_id_prefix to each peer\ngnosis_prefixes AS (\n    SELECT \n        d.discovery_id_prefix,\n        d.peer_id,\n        p.ip,\n        p.cl_fork_name,\n        p.cl_next_fork_name,\n        IF(p.client='', 'Unknown', p.client) AS client\n    FROM `dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids` AS d\n    INNER JOIN gnosis_peers AS p\n      ON p.peer_id = d.peer_id\n)\n\nSELECT\n    t1.date,\n\n    -- Peer columns from the subquery t1\n    t1.peer_ip,\n    t1.peer_discovery_id_prefix,\n    t1.peer_cl_fork_name,\n    t1.peer_cl_next_fork_name,\n    t1.peer_client,\n\n    -- Geographical info for peer (from crawlers_data.ipinfo)\n    peer_info.hostname   AS peer_hostname,\n    peer_info.city       AS peer_city,\n    peer_info.country    AS peer_country,\n    peer_info.org        AS peer_org,\n    peer_info.loc        AS peer_loc,\n\n    -- Neighbor columns from subquery t1\n    t1.neighbor_ip,\n    t1.neighbor_discovery_id_prefix,\n    t1.neighbor_cl_fork_name,\n    t1.neighbor_cl_next_fork_name,\n    t1.neighbor_client,\n\n    -- Geographical info for neighbor (from crawlers_data.ipinfo)\n    neighbor_info.city    AS neighbor_city,\n    neighbor_info.country AS neighbor_country,\n    neighbor_info.org     AS neighbor_org,\n    neighbor_info.loc     AS neighbor_loc,\n\n    -- Finally, the count of edges\n    t1.cnt\nFROM (\n    SELECT\n        toStartOfDay(n.crawl_created_at) AS date,\n\n        -- \u201cPeer\u201d side of the edge\n        peer_p.ip                      AS peer_ip,\n        peer_p.discovery_id_prefix     AS peer_discovery_id_prefix,\n        peer_p.cl_fork_name            AS peer_cl_fork_name,\n        peer_p.cl_next_fork_name       AS peer_cl_next_fork_name,\n        peer_p.client                  AS peer_client,\n\n        -- \u201cNeighbor\u201d side of the edge\n        neighbor_p.ip                      AS neighbor_ip,\n        neighbor_p.discovery_id_prefix     AS neighbor_discovery_id_prefix,\n        neighbor_p.cl_fork_name            AS neighbor_cl_fork_name,\n        neighbor_p.cl_next_fork_name       AS neighbor_cl_next_fork_name,\n        neighbor_p.client                  AS neighbor_client,\n\n        COUNT(*) AS cnt\n    FROM `dbt`.`stg_nebula_discv5__neighbors` AS n\n\n    -- join to get the discovery_prefix + client/fork info for \u201cpeer\u201d\n    INNER JOIN gnosis_prefixes AS peer_p\n      ON peer_p.discovery_id_prefix = n.peer_discovery_id_prefix\n\n    -- join to get the discovery_prefix + client/fork info for \u201cneighbor\u201d\n    INNER JOIN gnosis_prefixes AS neighbor_p\n      ON neighbor_p.discovery_id_prefix = n.neighbor_discovery_id_prefix\n\n    WHERE\n        toStartOfDay(n.crawl_created_at) = today() - INTERVAL 1 DAY\n\n    GROUP BY\n        date,\n        peer_p.ip,\n        peer_p.discovery_id_prefix,\n        peer_p.cl_fork_name,\n        peer_p.cl_next_fork_name,\n        peer_p.client,\n        neighbor_p.ip,\n        neighbor_p.discovery_id_prefix,\n        neighbor_p.cl_fork_name,\n        neighbor_p.cl_next_fork_name,\n        neighbor_p.client\n) AS t1\n\n-- LEFT JOIN to ipinfo for \u201cpeer\u201d\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS peer_info\n  ON peer_info.ip = t1.peer_ip\n\n-- LEFT JOIN to ipinfo for \u201cneighbor\u201d\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS neighbor_info\n  ON neighbor_info.ip = t1.neighbor_ip", "relation_name": "`dbt`.`int_p2p_discv5_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.915255Z", "completed_at": "2026-02-12T22:49:47.921311Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.921938Z", "completed_at": "2026-02-12T22:49:47.921945Z"}], "thread_id": "Thread-1", "execution_time": 0.008049726486206055, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_visits_latest", "compiled": true, "compiled_code": "\n\nWITH \n\ndiscv4_prev7D AS (\n    SELECT\n        date,\n        crawls\n    FROM `dbt`.`int_p2p_discv4_visits_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_visits_daily`), 7)\n),\n\ndiscv4 AS (\n    SELECT\n        date,\n        total_visits,\n        ROUND(COALESCE(successful_visits / NULLIF(total_visits, 0), 0) * 100, 1) AS pct_successful,\n        crawls\n    FROM `dbt`.`int_p2p_discv4_visits_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_visits_daily`)\n),\n\ndiscv5_prev7D AS (\n    SELECT\n        date,\n        crawls\n    FROM `dbt`.`int_p2p_discv5_visits_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_visits_daily`), 7)\n),\n\ndiscv5 AS (\n    SELECT\n        date,\n        total_visits,\n        ROUND(COALESCE(successful_visits / NULLIF(total_visits, 0), 0) * 100, 1) AS pct_successful,\n        crawls\n    FROM `dbt`.`int_p2p_discv5_visits_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_visits_daily`)\n)\n\nSELECT\n    t2.total_visits AS discv4_total_visits,\n    t2.pct_successful AS discv4_pct_successful,\n    t2.crawls AS discv4_crawls,\n    ROUND((COALESCE(t2.crawls / NULLIF(t1.crawls, 0), 0) - 1) * 100, 1) AS change_discv4_crawls_pct,\n    t4.total_visits AS discv5_total_visits,\n    t4.pct_successful AS discv5_pct_successful,\n    t4.crawls AS discv5_crawls,\n    ROUND((COALESCE(t4.crawls / NULLIF(t3.crawls, 0), 0) - 1) * 100, 1) AS change_discv5_crawls_pct\nFROM discv4_prev7D t1\nCROSS JOIN discv4 t2\nCROSS JOIN discv5_prev7D t3\nCROSS JOIN discv5 t4", "relation_name": "`dbt`.`api_p2p_visits_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.924697Z", "completed_at": "2026-02-12T22:49:47.929191Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.929799Z", "completed_at": "2026-02-12T22:49:47.929806Z"}], "thread_id": "Thread-1", "execution_time": 0.0064313411712646484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_pools__balancer_v2_events", "compiled": true, "compiled_code": "\n\nWITH vault_events AS (\n    SELECT\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        event_name,\n        decoded_params\n    FROM `dbt`.`contracts_BalancerV2_Vault_events`\n    WHERE event_name IN ('PoolBalanceChanged', 'PoolBalanceManaged', 'Swap', 'FlashLoan')\n      AND block_timestamp < today()\n),\n\npool_balance_changed AS (\n    SELECT\n        lower(decoded_params['poolId']) AS pool_id,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'PoolBalanceChanged' AS event_type,\n        lower(replaceAll(token_val, '\"', '')) AS token_address,\n        -- PoolBalanceChanged.deltas are int256. Sometimes negative values appear\n        -- as their uint256 two's-complement representation (e.g. ~2^256-1).\n        -- Decode by interpreting unsigned strings as Int256.\n        multiIf(\n            startsWith(replaceAll(delta_val, '\"', ''), '-'),\n            toInt256OrNull(replaceAll(delta_val, '\"', '')),\n            reinterpretAsInt256(toUInt256OrNull(replaceAll(delta_val, '\"', '')))\n        ) AS delta_amount_raw\n    FROM vault_events\n    ARRAY JOIN \n        JSONExtractArrayRaw(ifNull(decoded_params['tokens'], '[]')) AS token_val,\n        JSONExtractArrayRaw(ifNull(decoded_params['deltas'], '[]')) AS delta_val\n    WHERE event_name = 'PoolBalanceChanged'\n      AND decoded_params['poolId'] IS NOT NULL\n      AND decoded_params['tokens'] IS NOT NULL\n      AND decoded_params['deltas'] IS NOT NULL\n),\n\npool_balance_managed AS (\n    SELECT\n        lower(decoded_params['poolId']) AS pool_id,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'PoolBalanceManaged' AS event_type,\n        lower(decoded_params['token']) AS token_address,\n        -- cashDelta + managedDelta = net change (both int256; may be two's-complement encoded)\n        coalesce(\n            multiIf(\n                startsWith(toString(decoded_params['cashDelta']), '-'),\n                toInt256OrNull(toString(decoded_params['cashDelta'])),\n                reinterpretAsInt256(toUInt256OrNull(toString(decoded_params['cashDelta'])))\n            ),\n            toInt256(0)\n        )\n        +\n        coalesce(\n            multiIf(\n                startsWith(toString(decoded_params['managedDelta']), '-'),\n                toInt256OrNull(toString(decoded_params['managedDelta'])),\n                reinterpretAsInt256(toUInt256OrNull(toString(decoded_params['managedDelta'])))\n            ),\n            toInt256(0)\n        ) AS delta_amount_raw\n    FROM vault_events\n    WHERE event_name = 'PoolBalanceManaged'\n      AND decoded_params['poolId'] IS NOT NULL\n      AND decoded_params['token'] IS NOT NULL\n      AND (decoded_params['cashDelta'] IS NOT NULL OR decoded_params['managedDelta'] IS NOT NULL)\n),\n\nswap_events AS (\n    SELECT\n        lower(decoded_params['poolId']) AS pool_id,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Swap' AS event_type,\n        lower(decoded_params['tokenIn']) AS token_address,\n        toInt256OrNull(decoded_params['amountIn']) AS delta_amount_raw\n    FROM vault_events\n    WHERE event_name = 'Swap'\n      AND decoded_params['poolId'] IS NOT NULL\n      AND decoded_params['tokenIn'] IS NOT NULL\n      AND decoded_params['amountIn'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        lower(decoded_params['poolId']) AS pool_id,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Swap' AS event_type,\n        lower(decoded_params['tokenOut']) AS token_address,\n        -toInt256OrNull(decoded_params['amountOut']) AS delta_amount_raw\n    FROM vault_events\n    WHERE event_name = 'Swap'\n      AND decoded_params['poolId'] IS NOT NULL\n      AND decoded_params['tokenOut'] IS NOT NULL\n      AND decoded_params['amountOut'] IS NOT NULL\n)\n\nSELECT\n    pool_id,\n    block_timestamp,\n    transaction_hash,\n    log_index,\n    event_type,\n    token_address,\n    delta_amount_raw\nFROM (\n    SELECT * FROM pool_balance_changed\n    UNION ALL\n    SELECT * FROM pool_balance_managed\n    UNION ALL\n    SELECT * FROM swap_events\n)\nWHERE delta_amount_raw IS NOT NULL\n  AND token_address IS NOT NULL\n  AND pool_id IS NOT NULL\nORDER BY pool_id, block_timestamp, transaction_hash, log_index", "relation_name": "`dbt`.`stg_pools__balancer_v2_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.932466Z", "completed_at": "2026-02-12T22:49:47.936798Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.937364Z", "completed_at": "2026-02-12T22:49:47.937371Z"}], "thread_id": "Thread-1", "execution_time": 0.006190776824951172, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_pools__balancer_v3_events", "compiled": true, "compiled_code": "\n\nWITH vault_events AS (\n    SELECT\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        event_name,\n        decoded_params\n    FROM `dbt`.`contracts_BalancerV3_Vault_events`\n    WHERE event_name IN ('LiquidityAdded', 'LiquidityRemoved', 'Swap', 'Wrap', 'Unwrap', 'LiquidityAddedToBuffer')\n      AND block_timestamp < today()\n),\n\nliquidity_added AS (\n    SELECT\n        replaceAll(lower(decoded_params['pool']), '0x', '') AS pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'LiquidityAdded' AS event_type,\n        token_idx AS token_index,\n        toInt256OrNull(replaceAll(amount_val, '\"', '')) AS delta_amount_raw\n    FROM vault_events\n    ARRAY JOIN \n        range(length(JSONExtractArrayRaw(ifNull(decoded_params['amountsAddedRaw'], '[]')))) AS token_idx,\n        JSONExtractArrayRaw(ifNull(decoded_params['amountsAddedRaw'], '[]')) AS amount_val\n    WHERE event_name = 'LiquidityAdded'\n      AND decoded_params['pool'] IS NOT NULL\n      AND decoded_params['amountsAddedRaw'] IS NOT NULL\n),\n\nliquidity_removed AS (\n    SELECT\n        replaceAll(lower(decoded_params['pool']), '0x', '') AS pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'LiquidityRemoved' AS event_type,\n        token_idx AS token_index,\n        -toInt256OrNull(replaceAll(amount_val, '\"', '')) AS delta_amount_raw\n    FROM vault_events\n    ARRAY JOIN \n        range(length(JSONExtractArrayRaw(ifNull(decoded_params['amountsRemovedRaw'], '[]')))) AS token_idx,\n        JSONExtractArrayRaw(ifNull(decoded_params['amountsRemovedRaw'], '[]')) AS amount_val\n    WHERE event_name = 'LiquidityRemoved'\n      AND decoded_params['pool'] IS NOT NULL\n      AND decoded_params['amountsRemovedRaw'] IS NOT NULL\n),\n\nswap_events AS (\n    SELECT\n        replaceAll(lower(decoded_params['pool']), '0x', '') AS pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Swap' AS event_type,\n        lower(decoded_params['tokenIn']) AS token_address,\n        toInt256OrNull(decoded_params['amountIn']) AS delta_amount_raw\n    FROM vault_events\n    WHERE event_name = 'Swap'\n      AND decoded_params['pool'] IS NOT NULL\n      AND decoded_params['tokenIn'] IS NOT NULL\n      AND decoded_params['amountIn'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        replaceAll(lower(decoded_params['pool']), '0x', '') AS pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Swap' AS event_type,\n        lower(decoded_params['tokenOut']) AS token_address,\n        -toInt256OrNull(decoded_params['amountOut']) AS delta_amount_raw\n    FROM vault_events\n    WHERE event_name = 'Swap'\n      AND decoded_params['pool'] IS NOT NULL\n      AND decoded_params['tokenOut'] IS NOT NULL\n      AND decoded_params['amountOut'] IS NOT NULL\n),\n\nwrap_events AS (\n    SELECT\n        lower(decoded_params['wrappedToken']) AS wrapped_token_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Wrap' AS event_type,\n        NULL AS pool_address,\n        toInt256OrNull(decoded_params['depositedUnderlying']) AS delta_amount_raw\n    FROM vault_events\n    WHERE event_name = 'Wrap'\n      AND decoded_params['wrappedToken'] IS NOT NULL\n      AND decoded_params['depositedUnderlying'] IS NOT NULL\n),\n\nunwrap_events AS (\n    SELECT\n        lower(decoded_params['wrappedToken']) AS wrapped_token_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Unwrap' AS event_type,\n        NULL AS pool_address,\n        -toInt256OrNull(decoded_params['withdrawnUnderlying']) AS delta_amount_raw\n    FROM vault_events\n    WHERE event_name = 'Unwrap'\n      AND decoded_params['wrappedToken'] IS NOT NULL\n      AND decoded_params['withdrawnUnderlying'] IS NOT NULL\n),\n\nliquidity_added_to_buffer AS (\n    SELECT\n        lower(decoded_params['wrappedToken']) AS wrapped_token_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'LiquidityAddedToBuffer' AS event_type,\n        NULL AS pool_address,\n        toInt256OrNull(decoded_params['amountUnderlying']) AS delta_amount_raw\n    FROM vault_events\n    WHERE event_name = 'LiquidityAddedToBuffer'\n      AND decoded_params['wrappedToken'] IS NOT NULL\n      AND decoded_params['amountUnderlying'] IS NOT NULL\n)\n\nSELECT\n    pool_address,\n    block_timestamp,\n    transaction_hash,\n    log_index,\n    event_type,\n    token_index,\n    NULL AS wrapped_token_address,\n    NULL AS token_address,\n    delta_amount_raw\nFROM (\n    SELECT * FROM liquidity_added\n    UNION ALL\n    SELECT * FROM liquidity_removed\n)\nWHERE delta_amount_raw IS NOT NULL\n  AND pool_address IS NOT NULL\n\nUNION ALL\n\nSELECT\n    pool_address,\n    block_timestamp,\n    transaction_hash,\n    log_index,\n    event_type,\n    CAST(NULL AS Nullable(UInt64)) AS token_index,\n    NULL AS wrapped_token_address,\n    token_address,\n    delta_amount_raw\nFROM swap_events\nWHERE delta_amount_raw IS NOT NULL\n  AND pool_address IS NOT NULL\n  AND token_address IS NOT NULL\n\nUNION ALL\n\nSELECT\n    pool_address,\n    block_timestamp,\n    transaction_hash,\n    log_index,\n    event_type,\n    CAST(NULL AS Nullable(UInt64)) AS token_index,\n    wrapped_token_address,\n    NULL AS token_address,\n    delta_amount_raw\nFROM (\n    SELECT * FROM wrap_events\n    UNION ALL\n    SELECT * FROM unwrap_events\n    UNION ALL\n    SELECT * FROM liquidity_added_to_buffer\n)\nWHERE delta_amount_raw IS NOT NULL\n  AND wrapped_token_address IS NOT NULL\n\nORDER BY pool_address, block_timestamp, transaction_hash, log_index", "relation_name": "`dbt`.`stg_pools__balancer_v3_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.940071Z", "completed_at": "2026-02-12T22:49:47.946107Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:47.946727Z", "completed_at": "2026-02-12T22:49:47.946734Z"}], "thread_id": "Thread-1", "execution_time": 0.007950544357299805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_GBCDeposit_deposists_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(block_timestamp) AS date\n    ,decoded_params['withdrawal_credentials'] AS withdrawal_credentials\n    ,SUM(reinterpretAsUInt64(unhex(substring(decoded_params['amount'], 3)))) AS amount\nFROM `dbt`.`contracts_GBCDeposit_events`\nWHERE\n    event_name = 'DepositEvent'\n    \n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_GBCDeposit_deposists_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:47.949519Z", "completed_at": "2026-02-12T22:49:48.037497Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.038080Z", "completed_at": "2026-02-12T22:49:48.038093Z"}], "thread_id": "Thread-1", "execution_time": 0.09004020690917969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_pools__swapr_v3_events", "compiled": true, "compiled_code": "\n\nWITH pool_events AS (\n    SELECT\n        replaceAll(lower(contract_address), '0x', '') AS pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        event_name,\n        decoded_params\n    FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_events`\n    WHERE event_name IN ('Mint', 'Burn', 'Swap', 'Collect', 'Flash')\n      AND block_timestamp < today()\n)\n\nSELECT\n    pool_address,\n    block_timestamp,\n    transaction_hash,\n    log_index,\n    event_type,\n    token_position,\n    delta_amount_raw\nFROM (\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Mint' AS event_type,\n        'token0' AS token_position,\n        toInt256OrNull(decoded_params['amount0']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Mint'\n      AND decoded_params['amount0'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Mint' AS event_type,\n        'token1' AS token_position,\n        toInt256OrNull(decoded_params['amount1']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Mint'\n      AND decoded_params['amount1'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Burn' AS event_type,\n        'token0' AS token_position,\n        -toInt256OrNull(decoded_params['amount0']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Burn'\n      AND decoded_params['amount0'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Burn' AS event_type,\n        'token1' AS token_position,\n        -toInt256OrNull(decoded_params['amount1']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Burn'\n      AND decoded_params['amount1'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Swap' AS event_type,\n        'token0' AS token_position,\n        toInt256OrNull(decoded_params['amount0']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Swap'\n      AND decoded_params['amount0'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Swap' AS event_type,\n        'token1' AS token_position,\n        toInt256OrNull(decoded_params['amount1']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Swap'\n      AND decoded_params['amount1'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Collect' AS event_type,\n        'token0' AS token_position,\n        -toInt256OrNull(decoded_params['amount0']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Collect'\n      AND decoded_params['amount0'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Collect' AS event_type,\n        'token1' AS token_position,\n        -toInt256OrNull(decoded_params['amount1']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Collect'\n      AND decoded_params['amount1'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Flash' AS event_type,\n        'token0' AS token_position,\n        toInt256OrNull(decoded_params['paid0']) - toInt256OrNull(decoded_params['amount0']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Flash'\n      AND decoded_params['paid0'] IS NOT NULL\n      AND decoded_params['amount0'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Flash' AS event_type,\n        'token1' AS token_position,\n        toInt256OrNull(decoded_params['paid1']) - toInt256OrNull(decoded_params['amount1']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Flash'\n      AND decoded_params['paid1'] IS NOT NULL\n      AND decoded_params['amount1'] IS NOT NULL\n)\nWHERE delta_amount_raw IS NOT NULL\nORDER BY pool_address, block_timestamp, transaction_hash, log_index", "relation_name": "`dbt`.`stg_pools__swapr_v3_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.041008Z", "completed_at": "2026-02-12T22:49:48.045463Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.046026Z", "completed_at": "2026-02-12T22:49:48.046033Z"}], "thread_id": "Thread-1", "execution_time": 0.006384134292602539, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_pools__uniswap_v3_events", "compiled": true, "compiled_code": "\n\nWITH pool_events AS (\n    SELECT\n        replaceAll(lower(contract_address), '0x', '') AS pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        event_name,\n        decoded_params\n    FROM `dbt`.`contracts_UniswapV3_Pool_events`\n    WHERE event_name IN ('Mint', 'Burn', 'Swap', 'Collect', 'Flash')\n      AND block_timestamp < today()\n),\n\nmint_events AS (\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Mint' AS event_type,\n        'token0' AS token_position,\n        toInt256OrNull(decoded_params['amount0']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Mint'\n      AND decoded_params['amount0'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Mint' AS event_type,\n        'token1' AS token_position,\n        toInt256OrNull(decoded_params['amount1']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Mint'\n      AND decoded_params['amount1'] IS NOT NULL\n),\n\nburn_events AS (\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Burn' AS event_type,\n        'token0' AS token_position,\n        -toInt256OrNull(decoded_params['amount0']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Burn'\n      AND decoded_params['amount0'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Burn' AS event_type,\n        'token1' AS token_position,\n        -toInt256OrNull(decoded_params['amount1']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Burn'\n      AND decoded_params['amount1'] IS NOT NULL\n),\n\nswap_events AS (\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Swap' AS event_type,\n        'token0' AS token_position,\n        toInt256OrNull(decoded_params['amount0']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Swap'\n      AND decoded_params['amount0'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Swap' AS event_type,\n        'token1' AS token_position,\n        toInt256OrNull(decoded_params['amount1']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Swap'\n      AND decoded_params['amount1'] IS NOT NULL\n),\n\ncollect_events AS (\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Collect' AS event_type,\n        'token0' AS token_position,\n        -toInt256OrNull(decoded_params['amount0']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Collect'\n      AND decoded_params['amount0'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Collect' AS event_type,\n        'token1' AS token_position,\n        -toInt256OrNull(decoded_params['amount1']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Collect'\n      AND decoded_params['amount1'] IS NOT NULL\n),\n\nflash_events AS (\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Flash' AS event_type,\n        'token0' AS token_position,\n        toInt256OrNull(decoded_params['paid0']) - toInt256OrNull(decoded_params['amount0']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Flash'\n      AND decoded_params['paid0'] IS NOT NULL\n      AND decoded_params['amount0'] IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        pool_address,\n        block_timestamp,\n        transaction_hash,\n        log_index,\n        'Flash' AS event_type,\n        'token1' AS token_position,\n        toInt256OrNull(decoded_params['paid1']) - toInt256OrNull(decoded_params['amount1']) AS delta_amount_raw\n    FROM pool_events\n    WHERE event_name = 'Flash'\n      AND decoded_params['paid1'] IS NOT NULL\n      AND decoded_params['amount1'] IS NOT NULL\n)\n\nSELECT\n    pool_address,\n    block_timestamp,\n    transaction_hash,\n    log_index,\n    event_type,\n    token_position,\n    delta_amount_raw\nFROM (\n    SELECT * FROM mint_events\n    UNION ALL\n    SELECT * FROM burn_events\n    UNION ALL\n    SELECT * FROM swap_events\n    UNION ALL\n    SELECT * FROM collect_events\n    UNION ALL\n    SELECT * FROM flash_events\n)\nWHERE delta_amount_raw IS NOT NULL\nORDER BY pool_address, block_timestamp, transaction_hash, log_index", "relation_name": "`dbt`.`stg_pools__uniswap_v3_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.048717Z", "completed_at": "2026-02-12T22:49:48.056203Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.056791Z", "completed_at": "2026-02-12T22:49:48.056799Z"}], "thread_id": "Thread-1", "execution_time": 0.009351730346679688, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_yields_aave_daily", "compiled": true, "compiled_code": "\n\nWITH\n\n-- Extract APY rates from ReserveDataUpdated events\naave_rate_events AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date,\n        lower(decoded_params['reserve']) AS token_address,\n        block_timestamp,\n        toUInt256OrNull(decoded_params['liquidityRate']) AS liquidity_rate_ray,\n        toUInt256OrNull(decoded_params['variableBorrowRate']) AS variable_borrow_rate_ray\n    FROM `dbt`.`contracts_aaveV3_PoolInstance_events`\n    WHERE event_name = 'ReserveDataUpdated'\n      AND decoded_params['liquidityRate'] IS NOT NULL\n      AND block_timestamp < today()\n      \n  \n\n),\n\n-- Extract activity events (Supply, Borrow) for volumes and user counts\naave_activity_events AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date,\n        lower(decoded_params['reserve']) AS token_address,\n        lower(decoded_params['user']) AS user_address,\n        event_name AS event_type,\n        toUInt256OrNull(decoded_params['amount']) AS amount_raw\n    FROM `dbt`.`contracts_aaveV3_PoolInstance_events`\n    WHERE event_name IN ('Supply', 'Borrow')\n      AND decoded_params['reserve'] IS NOT NULL\n      AND decoded_params['user'] IS NOT NULL\n      AND decoded_params['amount'] IS NOT NULL\n      AND block_timestamp < today()\n      \n  \n\n),\n\nlatest_rates AS (\n    SELECT\n        date,\n        token_address,\n        argMax(liquidity_rate_ray, block_timestamp) AS liquidity_rate_ray,\n        argMax(variable_borrow_rate_ray, block_timestamp) AS variable_borrow_rate_ray\n    FROM aave_rate_events\n    GROUP BY date, token_address\n),\n\n-- Aggregate activity metrics by date and token\nactivity_agg AS (\n    SELECT\n        date,\n        token_address,\n        -- Bitmap states for unique user tracking\n        groupBitmapState(cityHash64(user_address)) FILTER (WHERE event_type = 'Supply') AS lenders_bitmap_state,\n        groupBitmapState(cityHash64(user_address)) FILTER (WHERE event_type = 'Borrow') AS borrowers_bitmap_state,\n        -- Daily counts\n        uniqExact(user_address) FILTER (WHERE event_type = 'Supply') AS lenders_count_daily,\n        uniqExact(user_address) FILTER (WHERE event_type = 'Borrow') AS borrowers_count_daily,\n        -- Volumes (will be converted from wei later)\n        sum(amount_raw) FILTER (WHERE event_type = 'Supply') AS deposits_volume_raw,\n        sum(amount_raw) FILTER (WHERE event_type = 'Borrow') AS borrows_volume_raw\n    FROM aave_activity_events\n    GROUP BY date, token_address\n),\n\nwith_symbols AS (\n    SELECT\n        lr.date,\n        lr.token_address,\n        w.symbol,\n        w.token_class,\n        w.decimals,\n        'Aave V3' AS protocol,\n        -- Convert RAY to APY: liquidityRate / 1e27 is already the APY as a decimal\n        CASE \n            WHEN lr.liquidity_rate_ray = 0 OR lr.liquidity_rate_ray IS NULL THEN 0\n            ELSE floor(\n                (toFloat64(lr.liquidity_rate_ray) / 1e27) * 100,\n                4\n            )\n        END AS apy_daily,\n        -- Convert RAY to APY for borrow rate\n        CASE \n            WHEN lr.variable_borrow_rate_ray = 0 OR lr.variable_borrow_rate_ray IS NULL THEN NULL\n            ELSE floor(\n                (toFloat64(lr.variable_borrow_rate_ray) / 1e27) * 100,\n                4\n            )\n        END AS borrow_apy_variable_daily\n    FROM latest_rates lr\n    INNER JOIN `dbt`.`tokens_whitelist` w\n        ON lower(w.address) = lr.token_address\n       AND lr.date >= toDate(w.date_start)\n       AND (w.date_end IS NULL OR lr.date < toDate(w.date_end))\n    WHERE lr.liquidity_rate_ray IS NOT NULL\n),\n\n-- Join yields with activity metrics\nyields_with_activity AS (\n    SELECT\n        ws.date,\n        ws.token_address,\n        ws.symbol,\n        ws.token_class,\n        ws.protocol,\n        ws.apy_daily,\n        ws.borrow_apy_variable_daily,\n        -- Activity metrics (may be NULL if no activity that day)\n        aa.lenders_bitmap_state,\n        aa.borrowers_bitmap_state,\n        COALESCE(aa.lenders_count_daily, 0) AS lenders_count_daily,\n        COALESCE(aa.borrowers_count_daily, 0) AS borrowers_count_daily,\n        -- Convert volumes from wei to token units\n        COALESCE(aa.deposits_volume_raw / POWER(10, COALESCE(ws.decimals, 18)), 0) AS deposits_volume_daily,\n        COALESCE(aa.borrows_volume_raw / POWER(10, COALESCE(ws.decimals, 18)), 0) AS borrows_volume_daily\n    FROM with_symbols ws\n    LEFT JOIN activity_agg aa\n        ON ws.date = aa.date\n        AND ws.token_address = aa.token_address\n),\n\n-- Get date range and unique token combinations\ndate_range AS (\n    SELECT \n        MIN(date) AS min_date,\n        MAX(date) AS max_date\n    FROM yields_with_activity\n),\n\ntoken_combinations AS (\n    SELECT DISTINCT\n        token_address,\n        symbol,\n        token_class\n    FROM yields_with_activity\n),\n\n-- Create calendar: all dates for each token combination\ncalendar AS (\n    SELECT\n        tc.token_address,\n        tc.symbol,\n        tc.token_class,\n        addDays(dr.min_date, offset) AS date\n    FROM token_combinations tc\n    CROSS JOIN date_range dr\n    ARRAY JOIN range(toUInt64(dateDiff('day', dr.min_date, dr.max_date) + 1)) AS offset\n),\n\n-- Forward fill: use last known value for missing days (only for APY rates)\n-- Activity metrics don't need forward-filling (show only days with activity)\nfilled_yields AS (\n    SELECT\n        c.date,\n        c.token_address,\n        c.symbol,\n        c.token_class,\n        'Aave V3' AS protocol,\n        -- Forward fill: get the last known apy_daily value up to this date\n        last_value(ywa.apy_daily) IGNORE NULLS OVER (\n            PARTITION BY c.token_address \n            ORDER BY c.date\n            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS apy_daily,\n        -- Forward fill: get the last known borrow_apy_variable_daily value up to this date\n        last_value(ywa.borrow_apy_variable_daily) IGNORE NULLS OVER (\n            PARTITION BY c.token_address \n            ORDER BY c.date\n            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS borrow_apy_variable_daily,\n        -- Activity metrics: use actual values (no forward fill)\n        ywa.lenders_bitmap_state,\n        ywa.borrowers_bitmap_state,\n        COALESCE(ywa.lenders_count_daily, 0) AS lenders_count_daily,\n        COALESCE(ywa.borrowers_count_daily, 0) AS borrowers_count_daily,\n        COALESCE(ywa.deposits_volume_daily, 0) AS deposits_volume_daily,\n        COALESCE(ywa.borrows_volume_daily, 0) AS borrows_volume_daily\n    FROM calendar c\n    LEFT JOIN yields_with_activity ywa\n        ON ywa.token_address = c.token_address\n        AND ywa.date = c.date\n)\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n    protocol,\n    apy_daily,\n    borrow_apy_variable_daily,\n    -- Calculate spread: borrow APY - lend APY\n    CASE \n        WHEN borrow_apy_variable_daily IS NOT NULL AND apy_daily IS NOT NULL\n        THEN ROUND(borrow_apy_variable_daily - apy_daily, 2)\n        ELSE NULL\n    END AS spread_variable,\n    lenders_bitmap_state,\n    borrowers_bitmap_state,\n    lenders_count_daily,\n    borrowers_count_daily,\n    deposits_volume_daily,\n    borrows_volume_daily\nFROM filled_yields\nWHERE apy_daily IS NOT NULL\nORDER BY date, token_address", "relation_name": "`dbt`.`int_execution_yields_aave_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.059631Z", "completed_at": "2026-02-12T22:49:48.073396Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.074083Z", "completed_at": "2026-02-12T22:49:48.074091Z"}], "thread_id": "Thread-1", "execution_time": 0.015928983688354492, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_rwa_backedfi_prices", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n\n\n        SELECT\n            'bC3M' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bC3M_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n      WHERE 1=1 \n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bCOIN' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bCOIN_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n      WHERE 1=1 \n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bCSPX' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bCSPX_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n      WHERE 1=1 \n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bHIGH' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bHIGH_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n      WHERE 1=1 \n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bIB01' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bIB01_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n      WHERE 1=1 \n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bIBTA' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bIBTA_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n      WHERE 1=1 \n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bMSTR' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bMSTR_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n      WHERE 1=1 \n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bNVDA' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bNVDA_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n      WHERE 1=1 \n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'TSLAx' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_TSLAx_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS x2\n      WHERE 1=1 \n    )\n  \n\n        GROUP BY 1, 2\n    ", "relation_name": "`dbt`.`int_execution_rwa_backedfi_prices`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.076967Z", "completed_at": "2026-02-12T22:49:48.082781Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.083383Z", "completed_at": "2026-02-12T22:49:48.083390Z"}], "thread_id": "Thread-1", "execution_time": 0.00779414176940918, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_backing", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(block_timestamp) AS date\n    ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_CirclesBackingFactory_events`\nWHERE \n    event_name = 'CirclesBackingCompleted'\n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_circles_backing` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_circles_backing` AS x2\n      WHERE 1=1 \n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_execution_circles_backing`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.086321Z", "completed_at": "2026-02-12T22:49:48.092918Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.093528Z", "completed_at": "2026-02-12T22:49:48.093535Z"}], "thread_id": "Thread-1", "execution_time": 0.008648395538330078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_transitive_transfers", "compiled": true, "compiled_code": "\n\n\nSELECT\n  toStartOfDay(block_timestamp) AS date\n  ,decoded_params['from'] AS from_avatar\n  ,decoded_params['to']   AS  to_avatar\n  ,SUM(\n    toUInt256OrZero(\n      arrayJoin(\n        JSONExtract(\n          ifNull(decoded_params['amounts'], '[]'),   -- remove Nullable\n          'Array(String)'                            -- get Array(String)\n        )\n      )\n    )\n  ) AS total_amount\n  ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE\n  event_name = 'StreamCompleted'\n  \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_circles_transitive_transfers` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_circles_transitive_transfers` AS x2\n      WHERE 1=1 \n    )\n  \n\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_execution_circles_transitive_transfers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.096304Z", "completed_at": "2026-02-12T22:49:48.101744Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.102330Z", "completed_at": "2026-02-12T22:49:48.102338Z"}], "thread_id": "Thread-1", "execution_time": 0.007328987121582031, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_v1_avatars", "compiled": true, "compiled_code": "\n\n\nSELECT\n    block_timestamp\n    ,decoded_params['avatar'] AS user_address\n    ,decoded_params['inviter'] AS inviter_address\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE \n    event_name = 'RegisterHuman'\n    \n  \n    \n    \n\n   WHERE \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_circles_v1_avatars` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_circles_v1_avatars` AS x2\n      WHERE 1=1 \n    )\n  \n", "relation_name": "`dbt`.`int_execution_circles_v1_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.105162Z", "completed_at": "2026-02-12T22:49:48.110696Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.111287Z", "completed_at": "2026-02-12T22:49:48.111295Z"}], "thread_id": "Thread-1", "execution_time": 0.0074117183685302734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_v2_avatars", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(block_timestamp) AS date\n    ,CASE  \n        WHEN event_name = 'RegisterHuman' THEN 'Human' \n        WHEN event_name = 'RegisterGroup' THEN 'Group' \n        WHEN event_name = 'RegisterOrganization' THEN 'Org'\n        ELSE 'Unknown' \n    END AS avatar_type\n    ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE \n    event_name IN ('RegisterHuman','RegisterGroup','RegisterOrganization')\n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_circles_v2_avatars` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_circles_v2_avatars` AS x2\n      WHERE 1=1 \n    )\n  \n\nGROUP BY 1,2", "relation_name": "`dbt`.`int_execution_circles_v2_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.114125Z", "completed_at": "2026-02-12T22:49:48.121837Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.122456Z", "completed_at": "2026-02-12T22:49:48.122464Z"}], "thread_id": "Thread-1", "execution_time": 0.009697914123535156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_yields_sdai_rate_daily", "compiled": true, "compiled_code": "\n\n\nWITH \n\nsdai_rate_sparse_daily AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date\n        ,argMin(\n          toUInt256OrNull(decoded_params['assets']) / toUInt256OrNull(decoded_params['shares']),\n          block_timestamp\n        ) AS sdai_conversion\n    FROM \n        `dbt`.`contracts_sdai_events`\n    WHERE \n        event_name = 'Deposit'\n        AND toUInt256OrNull(decoded_params['shares']) != 0\n        AND block_timestamp < today()\n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_yields_sdai_rate_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_yields_sdai_rate_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    GROUP BY 1\n),\n\ncalendar AS (\n    SELECT\n        arrayJoin(\n            arrayMap(\n                x -> toStartOfDay(start_date + x),\n                range(toUInt32(end_date - start_date) + 1)\n            )\n        ) AS date\n    FROM (\n        SELECT \n          min(toDate(date)) AS start_date\n          ,max(toDate(date)) AS end_date\n        FROM sdai_rate_sparse_daily\n    )\n),\n\n\nlast_partition_value AS (\n    SELECT \n        sdai_conversion\n    FROM \n        `dbt`.`int_yields_sdai_rate_daily`\n    WHERE\n        toStartOfMonth(date) = (\n            SELECT addMonths(max(toStartOfMonth(date)), -1)\n            FROM `dbt`.`int_yields_sdai_rate_daily`\n        )\n    ORDER BY date DESC\n    LIMIT 1\n),\n\n\nsdai_daily_rate AS (\n  SELECT\n      date\n      ,sdai_conversion\n      ,floor(\n          sdai_conversion \n          - (\n            \n            COALESCE(\n                lagInFrame(sdai_conversion) OVER (\n                    ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n                ),\n                (SELECT sdai_conversion FROM last_partition_value)\n            )\n            \n            )\n      ,12) AS rate\n  FROM (\n    SELECT \n      t1.date\n      ,last_value(t2.sdai_conversion) ignore nulls OVER (ORDER BY t1.date) AS sdai_conversion\n    FROM calendar t1\n    LEFT JOIN\n      sdai_rate_sparse_daily t2\n      ON t2.date = t1.date\n  )\n)\n\n\nSELECT \n  date\n  ,sdai_conversion\n  ,rate\nFROM sdai_daily_rate\nWHERE rate IS NOT NULL", "relation_name": "`dbt`.`int_yields_sdai_rate_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.125317Z", "completed_at": "2026-02-12T22:49:48.135481Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.136095Z", "completed_at": "2026-02-12T22:49:48.136102Z"}], "thread_id": "Thread-1", "execution_time": 0.012086153030395508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transfers_whitelisted_daily", "compiled": true, "compiled_code": "\n\n\n\n\n\n\nWITH tokens AS (\n    SELECT\n        lower(address)                       AS token_address,\n        decimals,\n        symbol,\n        date_start,\n        date_end\n    FROM `dbt`.`tokens_whitelist`\n    WHERE symbol != 'WxDAI'\n),\n\ndeduped_logs AS (\n    SELECT\n        CONCAT('0x', address) AS address,\n        topic1,\n        topic2,\n        data,\n        block_timestamp\n    FROM (\n        \n\nSELECT address, topic1, topic2, data, block_timestamp\nFROM (\n    SELECT\n        address, topic1, topic2, data, block_timestamp,\n        ROW_NUMBER() OVER (\n            PARTITION BY block_number, transaction_index, log_index\n            ORDER BY insert_version DESC\n        ) AS _dedup_rn\n    FROM `execution`.`logs`\n    \n    WHERE \n    topic0 = 'ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n    AND address != 'e91d153e0b41518a2ce8dd3d7944fa863463a97d' -- exclude WxDAI, handled separately\n    AND block_timestamp < today()\n    \n      \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_transfers_whitelisted_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_transfers_whitelisted_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    \n\n    \n)\nWHERE _dedup_rn = 1\n\n    )\n),\n\nraw_whitelisted_transfers AS (\n    SELECT\n        toDate(l.block_timestamp) AS date,\n        t.token_address,\n        t.symbol,\n        lower(concat('0x', substring(l.topic1, 25, 40))) AS \"from\",\n        lower(concat('0x', substring(l.topic2, 25, 40))) AS \"to\",\n        reinterpretAsInt256(\n                reverse(unhex(l.data))\n            ) AS value_raw\n    FROM deduped_logs AS l\n    INNER JOIN tokens t\n        ON lower(l.address) = t.token_address\n        AND l.block_timestamp >= t.date_start\n        AND (t.date_end IS NULL OR l.block_timestamp < t.date_end)\n    WHERE\n        toDate(l.block_timestamp) >= t.date_start\n        AND (t.date_end IS NULL OR toDate(l.block_timestamp) < t.date_end)\n),\n\ntransfers_whitelisted_daily AS (\n    SELECT\n        date,\n        token_address,\n        any(symbol)       AS symbol,\n        \"from\",\n        \"to\",\n        sum(value_raw) AS amount_raw,\n        count() AS transfer_count\n    FROM raw_whitelisted_transfers\n    GROUP BY\n        date, token_address, \"from\", \"to\"\n),\n\n\nwxdai_logs AS (\n    SELECT\n        toDate(block_timestamp) AS date\n        ,'0xe91d153e0b41518a2ce8dd3d7944fa863463a97d' AS token_address\n        ,'WxDAI' AS symbol\n        ,decoded_params\n        ,event_name\n    FROM `dbt`.`contracts_wxdai_events` \n    WHERE (event_name = 'Withdrawal' OR event_name = 'Transfer' OR event_name = 'Deposit')\n        AND block_timestamp < today()\n        \n          \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_transfers_whitelisted_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_transfers_whitelisted_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n        \n),\n\ndeposits_wxdai AS (\n    SELECT\n        date\n        ,token_address\n        ,symbol\n        ,'0x0000000000000000000000000000000000000000' AS \"from\"\n        ,decoded_params['dst'] AS \"to\"\n        ,toInt256(decoded_params['wad']) AS value_raw\n    FROM wxdai_logs\n    WHERE event_name = 'Deposit'\n),\n\nwithdrawals_wxdai AS (\n    SELECT\n        date\n        ,token_address\n        ,symbol\n        ,decoded_params['src'] AS \"from\"\n        ,'0x0000000000000000000000000000000000000000' AS \"to\"\n        ,toInt256(decoded_params['wad'])AS value_raw\n    FROM wxdai_logs\n    WHERE event_name = 'Withdrawal'\n),\n\ntransfers_wxdai AS (\n    SELECT\n        date\n        ,token_address\n        ,symbol\n        ,decoded_params['src'] AS \"from\"\n        ,decoded_params['dst']  AS \"to\"\n        ,toInt256(decoded_params['wad'])AS value_raw\n    FROM wxdai_logs\n    WHERE event_name = 'Transfer'\n),\n\ntransfers_wxdai_daily AS (\n    SELECT\n        date\n        ,token_address\n        ,symbol\n        ,\"from\"\n        ,\"to\"\n        ,SUM(value_raw) AS value_raw\n        ,count() AS transfer_count\n    FROM (\n        SELECT * FROM deposits_wxdai\n        UNION ALL \n        SELECT * FROM withdrawals_wxdai\n        UNION ALL \n        SELECT * FROM transfers_wxdai\n    )\n    GROUP BY 1, 2, 3, 4, 5\n),\n\ntransfers_daily AS (\n    SELECT * FROM transfers_whitelisted_daily\n    UNION ALL\n    SELECT * FROM transfers_wxdai_daily\n)\n\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    \"from\",\n    \"to\",\n    amount_raw,\n    transfer_count\nFROM transfers_daily", "relation_name": "`dbt`.`int_execution_transfers_whitelisted_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.138995Z", "completed_at": "2026-02-12T22:49:48.147019Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.147643Z", "completed_at": "2026-02-12T22:49:48.147650Z"}], "thread_id": "Thread-1", "execution_time": 0.009975433349609375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_crawlers_data_labels", "compiled": true, "compiled_code": "\n\n\n\n\nWITH src AS (\n  SELECT\n    lower(address) AS address,\n    project,\n    introduced_at\n  FROM `dbt`.`stg_crawlers_data__dune_labels`\n  \n    \n  \n    \n    \n\n   WHERE \n    toStartOfMonth(toDate(introduced_at)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.introduced_at)), -0))\n      FROM `dbt`.`int_crawlers_data_labels` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(introduced_at) >= (\n      SELECT addDays(max(toDate(x2.introduced_at)), -0)\n      FROM `dbt`.`int_crawlers_data_labels` AS x2\n      WHERE 1=1 \n    )\n  \n\n  \n),\n\nlabeled AS (\n  SELECT\n    address,\n    project,\n    introduced_at,\n\n    multiIf(\n\n      match(project, '(?i)^Unknown$'),           'Unknown',\n      match(project, '(?i)^EOA$'),               'EOAs',\n      match(project, '(?i)^ERC20$'),             'ERC20 Tokens',\n\n      match(project, '(?i)(uniswap|sushi|swapr|balancer|curve|honeyswap|levinswap|openocean|openoceanexchange|1inch|paraswap|cow\\\\s*swap|cowswap|gnosis\\\\s*protocol|xswap|symmetric(\\\\s*finance)?|elk\\\\s*finance|\\\\bdex\\\\b|aggregator|dex\\\\s*aggregator|zerion|kinetex\\\\s*xswap|baoswap)'),\n      'DEX',\n\n      match(project, '(?i)(\\\\baave\\\\b|spark(\\\\s*protocol)?|agave|compound|compoundadapter|\\\\bidle\\\\b|beefy|jarvis(\\\\s*network)?|gyroscope|qidao|powerpool|lending(manager)?|stakewise|aura\\\\s*finance|merkl)'),\n      'Lending & Yield',\n\n      match(project, '(?i)(\\\\bbridge\\\\b|omnibridge|hop(\\\\s*protocol)?|\\\\bbungee\\\\b|\\\\bacross\\\\b|connext|celer|stargate|lifi|li\\\\.?fi|\\\\bamb\\\\b|eth\\\\s*xdai\\\\s*amb|bsc\\\\s*xdai\\\\s*amb|\\\\brelay\\\\b|spokebridge|spokegateway|socket(\\\\b|\\\\s)|rango\\\\s*exchange|rubic(\\\\s*(onchain|crosschain))?|swaps?\\\\s*io|eywa|symbiosis|squid(\\\\s*spoke)?)'),\n      'Bridges',\n\n      match(project, '(?i)(layer\\\\s*zero|hyperlane|zk\\\\s*bridge|zkbridge|polyhedra|zk(light|client)|telepathy|messag(?:ing|e)|everclear|interop)'),\n      'Messaging / Interop',\n\n      match(project, '(?i)(safe(?:\\\\s*l2)?|gnosis\\\\s*safe|ambirewallet|biconomy|erc[- ]?4337|erc\\\\s*4337\\\\s*entry\\\\s*point|entry\\\\s*point|wethgateway|tokenbound|delegatecash|rhinestone|apex\\\\s*smart\\\\s*wallet|zeroexsettlerdeployersafemodule)'),\n      'Wallets & AA',\n\n      match(project, '(?i)(\\\\busdc\\\\b|\\\\busdt\\\\b|\\\\bsdai\\\\b|\\\\bdai\\\\b|\\\\bxdai\\\\b|ageur|angle|monerium(\\\\s*(iske|usde|blacklist))?|transmuter)'),\n      'Stablecoins & Fiat Ramps',\n\n      match(project, '(?i)(gnosis\\\\s*pay(\\\\s*(vip|spender|eiffel))?|\\\\bgpay\\\\b|request(\\\\s*network)?|payments?|invoice|smart\\\\s*invoice|superfluid|sablier|swing\\\\s*xdai\\\\s*single\\\\s*chain)'),\n      'Payments',\n\n      match(project, '(?i)(chainlink|tellor|pyth|\\\\boracle\\\\b|origin\\\\s*trail|origintrail|marketview|analytics|\\\\bdata\\\\b|\\\\bindex\\\\b|mu\\\\s*exchange\\\\s*pythoracle)'),\n      'Oracles & Data',\n\n      match(project, '(?i)(opensea|seaport|poap|nifty(ink|fair)?|\\\\bnft\\\\b|erc721|erc1155|foundation|eporio|marketplace|creator|mint|mech\\\\s*marketplace|ghost\\\\s*nft\\\\s*faucet|nfts2me|crypto\\\\s*stamp|nondescriptive\\\\s*1155|unlock(\\\\s*protocol)?)'),\n      'NFTs & Marketplaces',\n\n      match(project, '(?i)(dark\\\\s*forest|conquest\\\\.eth|mithraeum|\\\\bgame\\\\b|gaming)'),\n      'Gaming',\n\n      match(project, '(?i)(dao\\\\s*haus|daoh?a?us|daostack|\\\\bdao\\\\b|daosquare|plazadao|zodiac|snapshot|kleros(\\\\s*curate)?|reality\\\\s*eth|vocdoni|proof\\\\s*of\\\\s*humanity|sismo(\\\\s*(badges|roots|attestations\\\\s*registry))?|attestation|identity|omen|ran\\\\s*dao|circles|polkamarkets)'),\n      'DAOs & Governance',\n\n      match(project, '(?i)(tornado(?:\\\\.?\\\\s*cash)?|tornado\\\\s*cash\\\\s*nova|umbra|privacy|\\\\bmix\\\\b)'),\n      'Privacy',\n\n      match(project, '(?i)(autonolas|gnosis\\\\s*ai|autonomous|agent)'),\n      'AI & Agents',\n\n      match(project, '(?i)(real\\\\s*token|realtoken|real\\\\s*rmm|\\\\brmm\\\\b|emblem|backed)'),\n      'RWA & Tokenization',\n\n      match(project, '(?i)(^infrastructure$|gelato|opengsn|obol|ankr|shutter|infra(structure)?|registry|deployer|factory|controller|manager|router|pool|proxy|multisig|gnosis\\\\s*protocol|gnosis\\\\s*chain|xdai\\\\s*posdao|swarm|ethswarm|address\\\\s*tag\\\\s*registry|judicialassetfactory|hopr(\\\\s*(token|network|protocol))?)'),\n      'Infrastructure & DevTools',\n\n      'Others'\n    ) AS sector\n  FROM src\n)\n\nSELECT\n  address,\n  project,\n  sector,\n  introduced_at\nFROM labeled", "relation_name": "`dbt`.`int_crawlers_data_labels`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.150430Z", "completed_at": "2026-02-12T22:49:48.155084Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.155688Z", "completed_at": "2026-02-12T22:49:48.155696Z"}], "thread_id": "Thread-1", "execution_time": 0.006601810455322266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_blocks_clients_cnt_daily_date.9319e2b653", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_blocks_clients_cnt_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.158310Z", "completed_at": "2026-02-12T22:49:48.162862Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.163443Z", "completed_at": "2026-02-12T22:49:48.163450Z"}], "thread_id": "Thread-1", "execution_time": 0.006392717361450195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_blocks_clients_pct_daily_date.49d7e9d160", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_blocks_clients_pct_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.166113Z", "completed_at": "2026-02-12T22:49:48.170585Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.171152Z", "completed_at": "2026-02-12T22:49:48.171160Z"}], "thread_id": "Thread-1", "execution_time": 0.006308317184448242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_blocks_gas_usage_pct_monthly_date.b145145f73", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_blocks_gas_usage_pct_monthly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.173842Z", "completed_at": "2026-02-12T22:49:48.178429Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.178998Z", "completed_at": "2026-02-12T22:49:48.179006Z"}], "thread_id": "Thread-1", "execution_time": 0.006481170654296875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_attestations_daily_date.3207eebc80", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_attestations_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.181655Z", "completed_at": "2026-02-12T22:49:48.186104Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.186694Z", "completed_at": "2026-02-12T22:49:48.186702Z"}], "thread_id": "Thread-1", "execution_time": 0.0062978267669677734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_graffiti_label_daily_date.c8d1441f38", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_graffiti_label_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.189382Z", "completed_at": "2026-02-12T22:49:48.194540Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.195130Z", "completed_at": "2026-02-12T22:49:48.195137Z"}], "thread_id": "Thread-1", "execution_time": 0.0070269107818603516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_graffiti_cloud", "compiled": true, "compiled_code": "\n\n\nSELECT\n    label\n    ,graffiti\n    ,value\nFROM `dbt`.`fct_consensus_graffiti_cloud`\nORDER BY label DESC, value DESC", "relation_name": "`dbt`.`api_consensus_graffiti_cloud`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.197826Z", "completed_at": "2026-02-12T22:49:48.202242Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.202828Z", "completed_at": "2026-02-12T22:49:48.202836Z"}], "thread_id": "Thread-1", "execution_time": 0.006264925003051758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_blob_commitments_daily_date.ac917c94fc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_blob_commitments_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.205495Z", "completed_at": "2026-02-12T22:49:48.209981Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.210564Z", "completed_at": "2026-02-12T22:49:48.210571Z"}], "thread_id": "Thread-1", "execution_time": 0.0063512325286865234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_blocks_daily_date.e9ec9189ec", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_blocks_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.213575Z", "completed_at": "2026-02-12T22:49:48.218119Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.218761Z", "completed_at": "2026-02-12T22:49:48.218768Z"}], "thread_id": "Thread-1", "execution_time": 0.006491899490356445, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_zero_blob_commitments_daily_date.e6d21e8e11", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_zero_blob_commitments_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.221429Z", "completed_at": "2026-02-12T22:49:48.225893Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.226483Z", "completed_at": "2026-02-12T22:49:48.226491Z"}], "thread_id": "Thread-1", "execution_time": 0.00632476806640625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_credentials_daily_date.ca88cf1daa", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_credentials_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.229142Z", "completed_at": "2026-02-12T22:49:48.234627Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.235191Z", "completed_at": "2026-02-12T22:49:48.235199Z"}], "thread_id": "Thread-1", "execution_time": 0.0073244571685791016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_entry_queue_daily_date.2e8aa4a490", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_entry_queue_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.237844Z", "completed_at": "2026-02-12T22:49:48.242313Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.242902Z", "completed_at": "2026-02-12T22:49:48.242909Z"}], "thread_id": "Thread-1", "execution_time": 0.006365299224853516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_staked_daily_date.cc2cf09386", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_staked_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.245567Z", "completed_at": "2026-02-12T22:49:48.250117Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.250705Z", "completed_at": "2026-02-12T22:49:48.250713Z"}], "thread_id": "Thread-1", "execution_time": 0.006415843963623047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_balances_daily_date.c8289bba92", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_balances_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.253360Z", "completed_at": "2026-02-12T22:49:48.257849Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.258428Z", "completed_at": "2026-02-12T22:49:48.258436Z"}], "thread_id": "Thread-1", "execution_time": 0.006390810012817383, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_active_daily_date.0f0139a9c5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_active_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.261094Z", "completed_at": "2026-02-12T22:49:48.265614Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.266175Z", "completed_at": "2026-02-12T22:49:48.266182Z"}], "thread_id": "Thread-1", "execution_time": 0.006403446197509766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_status_daily_date.91f2382e0e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_status_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.268912Z", "completed_at": "2026-02-12T22:49:48.272894Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.273512Z", "completed_at": "2026-02-12T22:49:48.273519Z"}], "thread_id": "Thread-1", "execution_time": 0.005946159362792969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_withdrawal_credentials_freq_daily", "compiled": true, "compiled_code": "\nSELECT \n    date\n    ,bin_number_validators AS label\n    ,withdrawal_credentials_freq_cnt AS value\nFROM `dbt`.`fct_consensus_withdrawal_credentials_freq_daily`\nORDER BY 1, 2", "relation_name": "`dbt`.`api_consensus_withdrawal_credentials_freq_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.276316Z", "completed_at": "2026-02-12T22:49:48.282010Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.282677Z", "completed_at": "2026-02-12T22:49:48.282684Z"}], "thread_id": "Thread-1", "execution_time": 0.007781505584716797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_consensus_withdrawal_credentials_freq_daily_date.f213289ea4", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_consensus_withdrawal_credentials_freq_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.285356Z", "completed_at": "2026-02-12T22:49:48.289822Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.290382Z", "completed_at": "2026-02-12T22:49:48.290390Z"}], "thread_id": "Thread-1", "execution_time": 0.00630950927734375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_deposits_withdrawls_cnt_daily_date.d17bc34ba0", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_deposits_withdrawls_cnt_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.293059Z", "completed_at": "2026-02-12T22:49:48.297635Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.298201Z", "completed_at": "2026-02-12T22:49:48.298209Z"}], "thread_id": "Thread-1", "execution_time": 0.006470680236816406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_deposits_withdrawls_volume_daily_date.8c82141e3f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_deposits_withdrawls_volume_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.300982Z", "completed_at": "2026-02-12T22:49:48.305029Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.305698Z", "completed_at": "2026-02-12T22:49:48.305706Z"}], "thread_id": "Thread-1", "execution_time": 0.006084918975830078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_apy_dist_last_30_days", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q05_apy AS q05,\n    q10_apy AS q10,\n    q25_apy AS q25,\n    q50_apy AS q50,\n    q75_apy AS q75,\n    q90_apy AS q90,\n    q95_apy AS q95\nFROM `dbt`.`fct_consensus_validators_dists_last_30_days`", "relation_name": "`dbt`.`api_consensus_validators_apy_dist_last_30_days`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.308585Z", "completed_at": "2026-02-12T22:49:48.312543Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.313148Z", "completed_at": "2026-02-12T22:49:48.313156Z"}], "thread_id": "Thread-1", "execution_time": 0.0058786869049072266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_balance_dist_last_30_days", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q05_balance AS q05,\n    q10_balance AS q10,\n    q25_balance AS q25,\n    q50_balance AS q50,\n    q75_balance AS q75,\n    q90_balance AS q90,\n    q95_balance AS q95\nFROM `dbt`.`fct_consensus_validators_dists_last_30_days`", "relation_name": "`dbt`.`api_consensus_validators_balance_dist_last_30_days`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.315945Z", "completed_at": "2026-02-12T22:49:48.321731Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.322297Z", "completed_at": "2026-02-12T22:49:48.322304Z"}], "thread_id": "Thread-1", "execution_time": 0.0077555179595947266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_consensus_validators_dists_last_30_days_date.220d93c4f9", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_consensus_validators_dists_last_30_days`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.325062Z", "completed_at": "2026-02-12T22:49:48.329068Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.329756Z", "completed_at": "2026-02-12T22:49:48.329764Z"}], "thread_id": "Thread-1", "execution_time": 0.006055355072021484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_apy_dist_daily", "compiled": true, "compiled_code": "\n\n-- in GNO\nSELECT\n    date,\n    q05_apy AS q05,\n    q10_apy AS q10,\n    q25_apy AS q25,\n    q50_apy AS q50,\n    q75_apy AS q75,\n    q90_apy AS q90,\n    q95_apy AS q95,\n    avg_apy AS average\nFROM `dbt`.`int_consensus_validators_dists_daily`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_validators_apy_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.332642Z", "completed_at": "2026-02-12T22:49:48.336572Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.337177Z", "completed_at": "2026-02-12T22:49:48.337184Z"}], "thread_id": "Thread-1", "execution_time": 0.0058782100677490234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_balances_dist_daily", "compiled": true, "compiled_code": "\n\n-- in GNO\nSELECT\n    date,\n    q05_balance/32 AS q05,\n    q10_balance/32 AS q10,\n    q25_balance/32 AS q25,\n    q50_balance/32 AS q50,\n    q75_balance/32 AS q75,\n    q90_balance/32 AS q90,\n    q95_balance/32 AS q95\nFROM `dbt`.`int_consensus_validators_dists_daily`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_validators_balances_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.340097Z", "completed_at": "2026-02-12T22:49:48.347905Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.348519Z", "completed_at": "2026-02-12T22:49:48.348526Z"}], "thread_id": "Thread-1", "execution_time": 0.009856224060058594, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_info_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ndeposits_withdrawls_latest AS (\n    SELECT\n        label\n        ,cnt\n        ,total_amount\n    FROM \n        `dbt`.`int_consensus_deposits_withdrawals_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_deposits_withdrawals_daily`)\n),\n\ndeposits_withdrawls_7d AS (\n    SELECT\n        label\n        ,cnt\n        ,total_amount\n    FROM \n        `dbt`.`int_consensus_deposits_withdrawals_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_deposits_withdrawals_daily`), 7)\n),\n\napy_latest AS (\n    SELECT\n        avg_apy AS apy\n    FROM \n        `dbt`.`int_consensus_validators_dists_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_validators_dists_daily`)\n),\n\napy_7d AS (\n    SELECT\n       avg_apy AS apy\n    FROM \n        `dbt`.`int_consensus_validators_dists_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_validators_dists_daily`), 7)\n),\n\nstatus_latest AS (\n    SELECT\n        status AS label\n        ,CAST(COALESCE(cnt,0) AS Float64) AS value\n    FROM \n        `dbt`.`int_consensus_validators_status_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_validators_status_daily`)\n),\n\nstatus_7d AS (\n    SELECT\n        status AS label\n        ,CAST(COALESCE(cnt,0) AS Float64) AS value\n    FROM \n        `dbt`.`int_consensus_validators_status_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_validators_status_daily`), 7)\n),\n\n\nstaked_latest AS (\n    SELECT\n        'Staked' AS label\n        ,effective_balance/32 AS value\n    FROM \n        `dbt`.`int_consensus_validators_balances_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_validators_balances_daily`)\n),\n\nstaked_7d AS (\n    SELECT\n        'Staked' AS label\n        ,effective_balance/32 AS value\n    FROM \n        `dbt`.`int_consensus_validators_balances_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_validators_balances_daily`), 7)\n),\n\n\ninfo_latest AS ( \n    SELECT\n        'deposits_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_latest WHERE label = 'Deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_latest WHERE label = 'Withdrawals'), 0) AS value\n    UNION ALL\n    SELECT\n        'deposits_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'Deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'Withdrawals'), 0) AS value\n    UNION ALL\n    SELECT\n        'APY' AS label \n    ,COALESCE((SELECT ROUND(apy,2) FROM apy_latest),0) AS value\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM status_latest\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM staked_latest\n),\n\ninfo_7d AS ( \n    SELECT\n        'deposits_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_7d WHERE label = 'Deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_7d WHERE label = 'Withdrawals'), 0) AS value\n    UNION ALL\n    SELECT\n        'deposits_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_7d WHERE label = 'Deposits'), 0) AS value\n    UNION ALL\n     SELECT\n        'withdrawls_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_7d WHERE label = 'Withdrawals'), 0) AS value\n    UNION ALL\n    SELECT\n        'APY' AS label \n    ,COALESCE((SELECT ROUND(apy,2) FROM apy_7d),0) AS value\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM status_7d\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM staked_7d\n)\n\nSELECT\n    t1.label\n    ,t1.value AS value\n    ,IF(t1.value=0 AND t2.value=0, 0, ROUND(( COALESCE(t1.value / NULLIF(t2.value, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM info_latest t1\nINNER JOIN info_7d t2\nON t2.label = t1.label", "relation_name": "`dbt`.`fct_consensus_info_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.351468Z", "completed_at": "2026-02-12T22:49:48.356072Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.356656Z", "completed_at": "2026-02-12T22:49:48.356663Z"}], "thread_id": "Thread-1", "execution_time": 0.006537914276123047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_consensus_validators_dists_daily_date.09c3cbe00c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_consensus_validators_dists_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.359357Z", "completed_at": "2026-02-12T22:49:48.363300Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.363905Z", "completed_at": "2026-02-12T22:49:48.363912Z"}], "thread_id": "Thread-1", "execution_time": 0.0058324337005615234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_kpi_distinct_bridges_all_time", "compiled": true, "compiled_code": "\n\nSELECT \n    distinct_bridges AS value\nFROM `dbt`.`fct_bridges_kpis_snapshot`\nORDER BY as_of_date DESC\nLIMIT 1", "relation_name": "`dbt`.`api_bridges_kpi_distinct_bridges_all_time`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.366645Z", "completed_at": "2026-02-12T22:49:48.371881Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.372493Z", "completed_at": "2026-02-12T22:49:48.372501Z"}], "thread_id": "Thread-1", "execution_time": 0.007217884063720703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_kpi_distinct_chains_all_time", "compiled": true, "compiled_code": "\n\nSELECT distinct_chains AS value\nFROM `dbt`.`fct_bridges_kpis_snapshot`\nORDER BY as_of_date DESC\nLIMIT 1", "relation_name": "`dbt`.`api_bridges_kpi_distinct_chains_all_time`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.375205Z", "completed_at": "2026-02-12T22:49:48.379089Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.379690Z", "completed_at": "2026-02-12T22:49:48.379698Z"}], "thread_id": "Thread-1", "execution_time": 0.005819082260131836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_kpi_netflow_7d", "compiled": true, "compiled_code": "\n\nSELECT\n  round(net_7d, 2)        AS value,\n  round(net_prev_7d, 2)   AS prev_value,\n  chg_net_7d              AS change_pct\nFROM `dbt`.`fct_bridges_kpis_snapshot`\nORDER BY as_of_date DESC\nLIMIT 1", "relation_name": "`dbt`.`api_bridges_kpi_netflow_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.382394Z", "completed_at": "2026-02-12T22:49:48.386260Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.386867Z", "completed_at": "2026-02-12T22:49:48.386874Z"}], "thread_id": "Thread-1", "execution_time": 0.0057599544525146484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_kpi_total_netflow_all_time", "compiled": true, "compiled_code": "\n\nSELECT \n    round(cum_net_usd, 2) AS value\nFROM `dbt`.`fct_bridges_kpis_snapshot`\nORDER BY as_of_date DESC\nLIMIT 1", "relation_name": "`dbt`.`api_bridges_kpi_total_netflow_all_time`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.389594Z", "completed_at": "2026-02-12T22:49:48.393396Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.393997Z", "completed_at": "2026-02-12T22:49:48.394004Z"}], "thread_id": "Thread-1", "execution_time": 0.005692720413208008, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_kpi_total_volume_all_time", "compiled": true, "compiled_code": "\n\nSELECT \n    round(cum_vol_usd, 2) AS value\nFROM `dbt`.`fct_bridges_kpis_snapshot`\nORDER BY as_of_date DESC\nLIMIT 1", "relation_name": "`dbt`.`api_bridges_kpi_total_volume_all_time`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.396724Z", "completed_at": "2026-02-12T22:49:48.400584Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.401169Z", "completed_at": "2026-02-12T22:49:48.401177Z"}], "thread_id": "Thread-1", "execution_time": 0.0057315826416015625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_kpi_volume_7d", "compiled": true, "compiled_code": "\n\nSELECT\n  round(vol_7d, 2)        AS value,\n  round(vol_prev_7d, 2)   AS prev_value,\n  chg_vol_7d              AS change_pct\nFROM `dbt`.`fct_bridges_kpis_snapshot`\nORDER BY as_of_date DESC\nLIMIT 1", "relation_name": "`dbt`.`api_bridges_kpi_volume_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.403897Z", "completed_at": "2026-02-12T22:49:48.407826Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.408433Z", "completed_at": "2026-02-12T22:49:48.408441Z"}], "thread_id": "Thread-1", "execution_time": 0.005821704864501953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_cum_netflow_weekly_by_bridge", "compiled": true, "compiled_code": "\n\nSELECT\n  week  AS date,\n  bridge AS series,\n  cum_netflow_usd AS value\nFROM `dbt`.`fct_bridges_netflow_weekly_by_bridge`\nORDER BY date, series", "relation_name": "`dbt`.`api_bridges_cum_netflow_weekly_by_bridge`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.411205Z", "completed_at": "2026-02-12T22:49:48.416679Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.417272Z", "completed_at": "2026-02-12T22:49:48.417279Z"}], "thread_id": "Thread-1", "execution_time": 0.007464408874511719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_sankey_gnosis_in_by_token_7d", "compiled": true, "compiled_code": "\n\nWITH mx AS (SELECT max(date) AS d FROM `dbt`.`fct_bridges_sankey_edges_token_daily`)\n\nSELECT token, source, target, sum(value) AS value\nFROM `dbt`.`fct_bridges_sankey_edges_token_daily`, mx\nWHERE direction = 'in'\n  AND date BETWEEN subtractDays(mx.d, 6) AND mx.d\nGROUP BY token, source, target\nHAVING value > 0\nORDER BY token, value DESC, source ASC, target ASC", "relation_name": "`dbt`.`api_bridges_sankey_gnosis_in_by_token_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.420047Z", "completed_at": "2026-02-12T22:49:48.424517Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.425105Z", "completed_at": "2026-02-12T22:49:48.425113Z"}], "thread_id": "Thread-1", "execution_time": 0.006398200988769531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_sankey_gnosis_in_ranges", "compiled": true, "compiled_code": "\n\nWITH mx AS (SELECT max(date) AS d FROM `dbt`.`fct_bridges_sankey_edges_token_daily`),\nmn AS (SELECT min(date) AS m FROM `dbt`.`fct_bridges_sankey_edges_token_daily`),\nranges AS (\n  SELECT '1D'  AS range, mx.d                       AS start_d, mx.d AS end_d, 1 AS range_order FROM mx\n  UNION ALL SELECT '7D',  subtractDays(mx.d,  6), mx.d, 2 FROM mx\n  UNION ALL SELECT '30D', subtractDays(mx.d, 29), mx.d, 3 FROM mx\n  UNION ALL SELECT '90D', subtractDays(mx.d, 89), mx.d, 4 FROM mx\n  UNION ALL SELECT 'All', mn.m, mx.d, 5 FROM mn, mx\n)\n\nSELECT\n  r.range,\n  e.source,\n  e.target,\n  sum(e.value) AS value\nFROM `dbt`.`fct_bridges_sankey_edges_token_daily` e\nJOIN ranges r ON e.date BETWEEN r.start_d AND r.end_d\nWHERE e.direction = 'in'\nGROUP BY r.range, e.source, e.target, r.range_order\nHAVING value > 0\nORDER BY r.range_order, value DESC, e.source ASC, e.target ASC", "relation_name": "`dbt`.`api_bridges_sankey_gnosis_in_ranges`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.427826Z", "completed_at": "2026-02-12T22:49:48.432029Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.432644Z", "completed_at": "2026-02-12T22:49:48.432651Z"}], "thread_id": "Thread-1", "execution_time": 0.006099700927734375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_sankey_gnosis_out_by_token_7d", "compiled": true, "compiled_code": "\n\nWITH mx AS (SELECT max(date) AS d FROM `dbt`.`fct_bridges_sankey_edges_token_daily`)\n\nSELECT token, source, target, sum(value) AS value\nFROM `dbt`.`fct_bridges_sankey_edges_token_daily`, mx\nWHERE direction = 'out'\n  AND date BETWEEN subtractDays(mx.d, 6) AND mx.d\nGROUP BY token, source, target\nHAVING value > 0\nORDER BY token, value DESC, source ASC, target ASC", "relation_name": "`dbt`.`api_bridges_sankey_gnosis_out_by_token_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.435307Z", "completed_at": "2026-02-12T22:49:48.439745Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.440336Z", "completed_at": "2026-02-12T22:49:48.440343Z"}], "thread_id": "Thread-1", "execution_time": 0.0063629150390625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_sankey_gnosis_out_ranges", "compiled": true, "compiled_code": "\n\nWITH mx AS (SELECT max(date) AS d FROM `dbt`.`fct_bridges_sankey_edges_token_daily`),\nmn AS (SELECT min(date) AS m FROM `dbt`.`fct_bridges_sankey_edges_token_daily`),\nranges AS (\n  SELECT '1D'  AS range, mx.d                       AS start_d, mx.d AS end_d, 1 AS range_order FROM mx\n  UNION ALL SELECT '7D',  subtractDays(mx.d,  6), mx.d, 2 FROM mx\n  UNION ALL SELECT '30D', subtractDays(mx.d, 29), mx.d, 3 FROM mx\n  UNION ALL SELECT '90D', subtractDays(mx.d, 89), mx.d, 4 FROM mx\n  UNION ALL SELECT 'All', mn.m, mx.d, 5 FROM mn, mx\n)\n\nSELECT\n  r.range,\n  e.source,\n  e.target,\n  sum(e.value) AS value\nFROM `dbt`.`fct_bridges_sankey_edges_token_daily` e\nJOIN ranges r ON e.date BETWEEN r.start_d AND r.end_d\nWHERE e.direction = 'out'\nGROUP BY r.range, e.source, e.target, r.range_order\nHAVING value > 0\nORDER BY r.range_order, value DESC, e.source ASC, e.target ASC", "relation_name": "`dbt`.`api_bridges_sankey_gnosis_out_ranges`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.443019Z", "completed_at": "2026-02-12T22:49:48.447656Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.448226Z", "completed_at": "2026-02-12T22:49:48.448233Z"}], "thread_id": "Thread-1", "execution_time": 0.006461381912231445, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_bridges_sankey_edges_token_daily_date.f4408c8d4c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_bridges_sankey_edges_token_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.451058Z", "completed_at": "2026-02-12T22:49:48.456204Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.456828Z", "completed_at": "2026-02-12T22:49:48.456836Z"}], "thread_id": "Thread-1", "execution_time": 0.007142782211303711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_bridges_token_netflow_daily_by_bridge", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT date, bridge, token, value\n  FROM `dbt`.`fct_bridges_token_netflow_daily_by_bridge`\n),\nall_rows AS (\n  SELECT\n    date,\n    'All'   AS bridge,\n    token,\n    sum(value) AS value\n  FROM base\n  GROUP BY date, token\n),\nunioned AS (\n  SELECT date, bridge, token, value FROM base\n  UNION ALL\n  SELECT date, bridge, token, value FROM all_rows\n)\nSELECT\n  date,\n  bridge,\n  token,\n  value,\n  multiIf(bridge = 'All', 0, 1) AS bridge_order\nFROM unioned\nORDER BY date, bridge_order, bridge, token", "relation_name": "`dbt`.`api_bridges_token_netflow_daily_by_bridge`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.459708Z", "completed_at": "2026-02-12T22:49:48.464138Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.464719Z", "completed_at": "2026-02-12T22:49:48.464726Z"}], "thread_id": "Thread-1", "execution_time": 0.006428956985473633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_bridges_token_netflow_daily_by_bridge_date.b9e44b725f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_bridges_token_netflow_daily_by_bridge`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.467324Z", "completed_at": "2026-02-12T22:49:48.471836Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.472396Z", "completed_at": "2026-02-12T22:49:48.472404Z"}], "thread_id": "Thread-1", "execution_time": 0.006383419036865234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_cnt_daily_date.f29b9945e6", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_cnt_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.475061Z", "completed_at": "2026-02-12T22:49:48.479474Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.480041Z", "completed_at": "2026-02-12T22:49:48.480048Z"}], "thread_id": "Thread-1", "execution_time": 0.0062389373779296875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_gas_used_daily_date.1f6b125a22", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_gas_used_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.482731Z", "completed_at": "2026-02-12T22:49:48.487234Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.487816Z", "completed_at": "2026-02-12T22:49:48.487824Z"}], "thread_id": "Thread-1", "execution_time": 0.006428241729736328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_gas_used_weekly_date.4d15d1e638", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_gas_used_weekly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.490503Z", "completed_at": "2026-02-12T22:49:48.495126Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.495711Z", "completed_at": "2026-02-12T22:49:48.495719Z"}], "thread_id": "Thread-1", "execution_time": 0.006554841995239258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_value_daily_date.9495d891e5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_value_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.498475Z", "completed_at": "2026-02-12T22:49:48.503631Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.504218Z", "completed_at": "2026-02-12T22:49:48.504226Z"}], "thread_id": "Thread-1", "execution_time": 0.007134675979614258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_state_full_size_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,bytes/POWER(10,9) AS value\nFROM `dbt`.`fct_execution_state_full_size_daily`", "relation_name": "`dbt`.`api_execution_state_full_size_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.506987Z", "completed_at": "2026-02-12T22:49:48.511521Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.512085Z", "completed_at": "2026-02-12T22:49:48.512092Z"}], "thread_id": "Thread-1", "execution_time": 0.006494998931884766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_state_full_size_daily_date.d76bb8ce85", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_execution_state_full_size_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.514816Z", "completed_at": "2026-02-12T22:49:48.518716Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.519307Z", "completed_at": "2026-02-12T22:49:48.519315Z"}], "thread_id": "Thread-1", "execution_time": 0.00584101676940918, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv4_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv4_clients_daily`\nWHERE date < today()\nORDER BY date, metric, label", "relation_name": "`dbt`.`api_p2p_discv4_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.522116Z", "completed_at": "2026-02-12T22:49:48.526231Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.526840Z", "completed_at": "2026-02-12T22:49:48.526847Z"}], "thread_id": "Thread-1", "execution_time": 0.006005764007568359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv4_clients_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv4_clients_daily`\nWHERE date = (SELECT MAX(date) FROM  `dbt`.`int_p2p_discv4_clients_daily` )\nORDER BY metric, label", "relation_name": "`dbt`.`api_p2p_discv4_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.529530Z", "completed_at": "2026-02-12T22:49:48.534013Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.534592Z", "completed_at": "2026-02-12T22:49:48.534600Z"}], "thread_id": "Thread-1", "execution_time": 0.006339550018310547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv4_clients_daily_date.db7cce1925", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_p2p_discv4_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.537208Z", "completed_at": "2026-02-12T22:49:48.541781Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.542344Z", "completed_at": "2026-02-12T22:49:48.542351Z"}], "thread_id": "Thread-1", "execution_time": 0.006451845169067383, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv4_clients_daily_peer_id.373111a0c3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_p2p_discv4_clients_daily`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.544990Z", "completed_at": "2026-02-12T22:49:48.550830Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.551393Z", "completed_at": "2026-02-12T22:49:48.551401Z"}], "thread_id": "Thread-1", "execution_time": 0.0077207088470458984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_p2p_discv4_clients_daily_peer_id.cadec56725", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_p2p_discv4_clients_daily`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.554121Z", "completed_at": "2026-02-12T22:49:48.558568Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.559136Z", "completed_at": "2026-02-12T22:49:48.559143Z"}], "thread_id": "Thread-1", "execution_time": 0.006268978118896484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv4_topology_latest_peer_id.78ef9f3a69", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_p2p_discv4_topology_latest`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.561819Z", "completed_at": "2026-02-12T22:49:48.566221Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.566807Z", "completed_at": "2026-02-12T22:49:48.566815Z"}], "thread_id": "Thread-1", "execution_time": 0.0062754154205322266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_p2p_discv4_topology_latest_peer_id.ecfe315c77", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_p2p_discv4_topology_latest`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.569584Z", "completed_at": "2026-02-12T22:49:48.576915Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.577548Z", "completed_at": "2026-02-12T22:49:48.577555Z"}], "thread_id": "Thread-1", "execution_time": 0.009356021881103516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_classification", "compiled": true, "compiled_code": "\n\n\nWITH latest_observations AS (\n    SELECT \n        toDate(visit_ended_at) as observation_date,\n        peer_id,\n        argMax(ip, visit_ended_at) AS ip_address,\n        argMax(client, visit_ended_at) AS client_type,\n        argMax(peer_country, visit_ended_at) AS country_code,\n        argMax(generic_provider, visit_ended_at) AS generic_provider,\n        argMax(peer_org, visit_ended_at) AS peer_org,\n        MAX(visit_ended_at) AS last_seen_that_day\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE \n        empty(dial_errors) = 1 \n        AND crawl_error IS NULL\n        AND toStartOfDay(visit_ended_at) < today()\n        \n            AND toDate(visit_ended_at) > (SELECT MAX(date) FROM `dbt`.`int_esg_node_classification`)\n        \n    GROUP BY observation_date, peer_id\n),\n\nnode_categories AS (\n    SELECT\n        observation_date,\n        peer_id,\n        ip_address,\n        client_type,\n        country_code,\n        generic_provider,\n        peer_org,\n        \n        -- Classify nodes into operational archetypes based on generic_provider\n        CASE\n            WHEN generic_provider IN ('AWS', 'Google', 'Azure', 'Oracle Cloud', 'Alibaba Cloud') \n                THEN 'cloud_hosted'\n            WHEN generic_provider IN ('DigitalOcean', 'OVHcloud', 'Hetzner', 'Scaleway', 'Linode', 'Vultr', \n                                    'Equinix Metal', 'Hosting/CDN (Other)') \n                THEN 'cloud_hosted'\n            WHEN generic_provider = 'Carrier/Transit' \n                THEN 'professional_operator'\n            WHEN lower(peer_org) LIKE '%datacenter%' \n                OR lower(peer_org) LIKE '%data center%'\n                OR lower(peer_org) LIKE '%hosting%'\n                OR lower(peer_org) LIKE '%server%'\n                THEN 'professional_operator'\n            WHEN generic_provider = 'Public ISP (Home/Office)' \n                THEN 'home_staker'\n            WHEN lower(peer_org) LIKE '%telecom%'\n                OR lower(peer_org) LIKE '%broadband%'\n                OR lower(peer_org) LIKE '%cable%'\n                OR lower(peer_org) LIKE '%fiber%'\n                OR lower(peer_org) LIKE '%residential%'\n                THEN 'home_staker'\n            ELSE 'unknown'\n        END AS node_category,\n        \n        CASE\n            WHEN generic_provider IN ('AWS', 'Google', 'Azure', 'Oracle Cloud', 'Alibaba Cloud') THEN 0.95\n            WHEN generic_provider IN ('DigitalOcean', 'OVHcloud', 'Hetzner', 'Scaleway', 'Linode', 'Vultr') THEN 0.90\n            WHEN generic_provider = 'Public ISP (Home/Office)' THEN 0.80\n            WHEN generic_provider = 'Hosting/CDN (Other)' THEN 0.75\n            WHEN generic_provider = 'Carrier/Transit' THEN 0.70\n            WHEN generic_provider = 'Unknown' THEN 0.30\n            ELSE 0.50\n        END AS classification_confidence\n        \n    FROM latest_observations\n),\n\ndaily_distribution AS (\n    SELECT\n        observation_date AS date,\n        node_category,\n        COUNT(DISTINCT peer_id) AS observed_nodes,\n        AVG(classification_confidence) AS avg_confidence\n    FROM node_categories\n    GROUP BY observation_date, node_category\n),\n\nchao1_data AS (\n    SELECT\n        p.observation_date,\n        p.observed_successful_nodes,\n        p.enhanced_total_reachable,\n        p.connection_success_rate_pct\n    FROM `dbt`.`int_esg_node_population_chao1` p\n    WHERE 1=1\n        \n            AND p.observation_date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_classification`)\n        \n),\n\nscaled_distribution AS (\n    SELECT\n        d.date,\n        d.node_category,\n        d.observed_nodes,\n        d.avg_confidence,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(greatest(toFloat64(d.observed_nodes), \n                    toFloat64(d.observed_nodes) * c.enhanced_total_reachable / c.observed_successful_nodes))\n            ELSE d.observed_nodes\n        END AS estimated_total_nodes,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(greatest(toFloat64(d.observed_nodes), \n                    toFloat64(d.observed_nodes) * c.enhanced_total_reachable * 0.85 / c.observed_successful_nodes))\n            ELSE toUInt64(d.observed_nodes * 0.85)\n        END AS nodes_lower_95,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(toFloat64(d.observed_nodes) * c.enhanced_total_reachable * 1.15 / c.observed_successful_nodes)\n            ELSE toUInt64(d.observed_nodes * 1.15)\n        END AS nodes_upper_95,\n        \n        COALESCE(c.connection_success_rate_pct / 100.0, 0.75) AS sample_coverage,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                round(toFloat64(c.enhanced_total_reachable) / c.observed_successful_nodes, 3)\n            ELSE 1.0\n        END AS scaling_factor\n        \n    FROM daily_distribution d\n    LEFT JOIN chao1_data c ON d.date = c.observation_date\n),\n\ngeographic_distribution AS (\n    SELECT\n        observation_date AS date,\n        node_category,\n        country_code,\n        COUNT(DISTINCT peer_id) AS country_observed_nodes\n    FROM node_categories\n    WHERE country_code IS NOT NULL AND country_code != '' AND country_code != 'Unknown'\n    GROUP BY observation_date, node_category, country_code\n),\n\ngeographic_scaled AS (\n    SELECT\n        g.date,\n        g.node_category,\n        g.country_code,\n        g.country_observed_nodes,\n        \n        CASE \n            WHEN s.scaling_factor > 0 THEN\n                toUInt64(toFloat64(g.country_observed_nodes) * s.scaling_factor)\n            ELSE g.country_observed_nodes\n        END AS country_estimated_nodes\n        \n    FROM geographic_distribution g\n    JOIN scaled_distribution s\n        ON g.date = s.date AND g.node_category = s.node_category\n)\n\nSELECT\n    s.date,\n    s.node_category,\n    s.observed_nodes,\n    s.estimated_total_nodes,\n    s.nodes_lower_95,\n    s.nodes_upper_95,\n    s.avg_confidence,\n    s.sample_coverage,\n    s.scaling_factor,\n    \n    round(100.0 * s.estimated_total_nodes / \n          SUM(s.estimated_total_nodes) OVER (PARTITION BY s.date), 2) AS category_percentage,\n    \n    s.estimated_total_nodes - s.observed_nodes AS hidden_nodes_estimated,\n    round(100.0 * (s.estimated_total_nodes - s.observed_nodes) / s.estimated_total_nodes, 2) AS hidden_nodes_percentage,\n    \n    CASE \n        WHEN COUNT(g.country_code) > 0 THEN\n            toJSONString(groupArray((g.country_code, g.country_estimated_nodes)))\n        ELSE '[]'\n    END AS geographic_distribution,\n    \n    CASE \n        WHEN COUNT(g.country_code) > 0 THEN\n            arrayStringConcat(\n                arraySlice(\n                    arrayMap(x -> tupleElement(x, 1),\n                        arraySort(x -> -tupleElement(x, 2),\n                            groupArray((g.country_code, g.country_estimated_nodes))\n                        )\n                    ), 1, 5\n                ), ', '\n            )\n        ELSE 'No geographic data'\n    END AS top_countries,\n    \n    now() AS calculated_at\n    \nFROM scaled_distribution s\nLEFT JOIN geographic_scaled g\n    ON s.date = g.date AND s.node_category = g.node_category\n\nGROUP BY \n    s.date, s.node_category, s.observed_nodes, s.estimated_total_nodes,\n    s.nodes_lower_95, s.nodes_upper_95, s.avg_confidence, s.sample_coverage, s.scaling_factor\n\nORDER BY s.date, s.estimated_total_nodes DESC", "relation_name": "`dbt`.`int_esg_node_classification`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.580353Z", "completed_at": "2026-02-12T22:49:48.585029Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.585646Z", "completed_at": "2026-02-12T22:49:48.585654Z"}], "thread_id": "Thread-1", "execution_time": 0.006643533706665039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_esg_node_population_chao1_crawl_id.8287fd921b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect crawl_id\nfrom `dbt`.`int_esg_node_population_chao1`\nwhere crawl_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.588376Z", "completed_at": "2026-02-12T22:49:48.594013Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.594595Z", "completed_at": "2026-02-12T22:49:48.594602Z"}], "thread_id": "Thread-1", "execution_time": 0.007629871368408203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_esg_node_population_chao1_peer_id.3bd40dc3d4", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_esg_node_population_chao1`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.597240Z", "completed_at": "2026-02-12T22:49:48.601623Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.602183Z", "completed_at": "2026-02-12T22:49:48.602190Z"}], "thread_id": "Thread-1", "execution_time": 0.006209850311279297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_esg_node_population_chao1_crawl_id.bfb9073510", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    crawl_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_esg_node_population_chao1`\nwhere crawl_id is not null\ngroup by crawl_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.604865Z", "completed_at": "2026-02-12T22:49:48.609220Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.609798Z", "completed_at": "2026-02-12T22:49:48.609805Z"}], "thread_id": "Thread-1", "execution_time": 0.006192207336425781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_esg_node_population_chao1_peer_id.8374b515b0", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_esg_node_population_chao1`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.612487Z", "completed_at": "2026-02-12T22:49:48.618227Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.618840Z", "completed_at": "2026-02-12T22:49:48.618847Z"}], "thread_id": "Thread-1", "execution_time": 0.007691621780395508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_clients_latest", "compiled": true, "compiled_code": "\n\nWITH \n\ndiscv4_prev7D AS (\n    SELECT\n        date,\n        SUM(value) AS discv4_count\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`), 7)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv4 AS (\n    SELECT\n        date,\n        SUM(value) AS discv4_count\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv5_prev7D AS (\n    SELECT\n        date,\n        SUM(value) AS discv5_count\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_clients_daily`), 7)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv5 AS (\n    SELECT\n        date,\n        SUM(value) AS discv5_count\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_clients_daily`)\n        AND metric = 'Clients'\n    GROUP BY date\n)\n\nSELECT\n    t2.discv4_count AS discv4_count,\n    ROUND((COALESCE(t2.discv4_count / NULLIF(t1.discv4_count, 0), 0) - 1) * 100, 1) AS change_discv4_pct,\n    t4.discv5_count AS discv5_count,\n    ROUND((COALESCE(t4.discv5_count / NULLIF(t3.discv5_count, 0), 0) - 1) * 100, 1) AS change_discv5_pct\nFROM discv4_prev7D t1\nCROSS JOIN discv4 t2\nCROSS JOIN discv5_prev7D t3\nCROSS JOIN discv5 t4", "relation_name": "`dbt`.`api_p2p_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.621659Z", "completed_at": "2026-02-12T22:49:48.625572Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.626165Z", "completed_at": "2026-02-12T22:49:48.626172Z"}], "thread_id": "Thread-1", "execution_time": 0.005936622619628906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv5_clients_daily`\nWHERE date < today()\nORDER BY date, metric, label", "relation_name": "`dbt`.`api_p2p_discv5_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.628984Z", "completed_at": "2026-02-12T22:49:48.633164Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.633772Z", "completed_at": "2026-02-12T22:49:48.633780Z"}], "thread_id": "Thread-1", "execution_time": 0.0062122344970703125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_clients_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv5_clients_daily`\nWHERE date = (SELECT MAX(date) FROM  `dbt`.`int_p2p_discv5_clients_daily` )\nORDER BY metric, label", "relation_name": "`dbt`.`api_p2p_discv5_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.636444Z", "completed_at": "2026-02-12T22:49:48.642158Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.642742Z", "completed_at": "2026-02-12T22:49:48.642750Z"}], "thread_id": "Thread-1", "execution_time": 0.007621049880981445, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv5_clients_daily_date.5fbdde7245", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_p2p_discv5_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.645381Z", "completed_at": "2026-02-12T22:49:48.649949Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.650538Z", "completed_at": "2026-02-12T22:49:48.650545Z"}], "thread_id": "Thread-1", "execution_time": 0.006417274475097656, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv5_clients_daily_peer_id.dbdc25d7e1", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_p2p_discv5_clients_daily`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.653200Z", "completed_at": "2026-02-12T22:49:48.657630Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.658192Z", "completed_at": "2026-02-12T22:49:48.658199Z"}], "thread_id": "Thread-1", "execution_time": 0.0063190460205078125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_p2p_discv5_clients_daily_peer_id.2414407777", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_p2p_discv5_clients_daily`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.660938Z", "completed_at": "2026-02-12T22:49:48.664807Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.665395Z", "completed_at": "2026-02-12T22:49:48.665402Z"}], "thread_id": "Thread-1", "execution_time": 0.0058307647705078125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_current_fork_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`\nWHERE label = 'Current Fork' \nORDER BY date ASC, fork ASC", "relation_name": "`dbt`.`api_p2p_discv5_current_fork_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.668230Z", "completed_at": "2026-02-12T22:49:48.672126Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.672732Z", "completed_at": "2026-02-12T22:49:48.672739Z"}], "thread_id": "Thread-1", "execution_time": 0.0059282779693603516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_next_fork_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`\nWHERE label = 'Next Fork' \nORDER BY date ASC, fork ASC", "relation_name": "`dbt`.`api_p2p_discv5_next_fork_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.675529Z", "completed_at": "2026-02-12T22:49:48.679989Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.680598Z", "completed_at": "2026-02-12T22:49:48.680605Z"}], "thread_id": "Thread-1", "execution_time": 0.0063741207122802734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_p2p_discv5_forks_daily", "compiled": true, "compiled_code": "SELECT\n    date\n    ,label\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`", "relation_name": "`dbt`.`fct_p2p_discv5_forks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.683349Z", "completed_at": "2026-02-12T22:49:48.687807Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.688367Z", "completed_at": "2026-02-12T22:49:48.688374Z"}], "thread_id": "Thread-1", "execution_time": 0.006428956985473633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv5_forks_daily_date.8e990ae415", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_p2p_discv5_forks_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.691071Z", "completed_at": "2026-02-12T22:49:48.695539Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.696098Z", "completed_at": "2026-02-12T22:49:48.696106Z"}], "thread_id": "Thread-1", "execution_time": 0.006335735321044922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv5_forks_daily_peer_id.7e2ec92420", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_p2p_discv5_forks_daily`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.698762Z", "completed_at": "2026-02-12T22:49:48.703176Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.703758Z", "completed_at": "2026-02-12T22:49:48.703765Z"}], "thread_id": "Thread-1", "execution_time": 0.006322622299194336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_p2p_discv5_forks_daily_peer_id.31fc691e37", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_p2p_discv5_forks_daily`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.706545Z", "completed_at": "2026-02-12T22:49:48.711056Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.711715Z", "completed_at": "2026-02-12T22:49:48.711722Z"}], "thread_id": "Thread-1", "execution_time": 0.006503105163574219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_p2p_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ndiscv4_topology AS (\n    SELECT\n        date,\n        peer_ip,\n        peer_discovery_id_prefix,\n        peer_client,\n        peer_hostname,\n        peer_city,\n        peer_country,\n        peer_org,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(peer_loc, '')), 1)) AS peer_lat,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(peer_loc, '')), 2)) AS peer_lon,\n        neighbor_ip,\n        neighbor_discovery_id_prefix,\n        neighbor_client,\n        neighbor_city,\n        neighbor_country,\n        neighbor_org,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(neighbor_loc, '')), 1)) AS neighbor_lat,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(neighbor_loc, '')), 2)) AS neighbor_lon,\n        cnt\n    FROM `dbt`.`int_p2p_discv4_topology_latest`\n),\n\ndiscv5_topology AS (\n    SELECT\n        date,\n        peer_ip,\n        peer_discovery_id_prefix,\n        peer_client,\n        peer_hostname,\n        peer_city,\n        peer_country,\n        peer_org,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(peer_loc, '')), 1)) AS peer_lat,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(peer_loc, '')), 2)) AS peer_lon,\n        neighbor_ip,\n        neighbor_discovery_id_prefix,\n        neighbor_client,\n        neighbor_city,\n        neighbor_country,\n        neighbor_org,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(neighbor_loc, '')), 1)) AS neighbor_lat,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(neighbor_loc, '')), 2)) AS neighbor_lon,\n        cnt\n    FROM `dbt`.`int_p2p_discv5_topology_latest`\n)\n\nSELECT 'DiscV4' AS protocol, * FROM discv4_topology\nUNION ALL\nSELECT 'DiscV5' AS protocol, * FROM discv5_topology", "relation_name": "`dbt`.`fct_p2p_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.714531Z", "completed_at": "2026-02-12T22:49:48.719196Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.719800Z", "completed_at": "2026-02-12T22:49:48.719807Z"}], "thread_id": "Thread-1", "execution_time": 0.0066242218017578125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_p2p_discv5_topology_latest_peer_id.a2433c6a9f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_p2p_discv5_topology_latest`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.722463Z", "completed_at": "2026-02-12T22:49:48.728161Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.728739Z", "completed_at": "2026-02-12T22:49:48.728746Z"}], "thread_id": "Thread-1", "execution_time": 0.007556915283203125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_p2p_discv5_topology_latest_peer_id.72fec1dadd", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_p2p_discv5_topology_latest`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.731356Z", "completed_at": "2026-02-12T22:49:48.735842Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.736405Z", "completed_at": "2026-02-12T22:49:48.736429Z"}], "thread_id": "Thread-1", "execution_time": 0.006361484527587891, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_visits_latest_date.05d6acdde5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_visits_latest`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.739055Z", "completed_at": "2026-02-12T22:49:48.743547Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.744109Z", "completed_at": "2026-02-12T22:49:48.744117Z"}], "thread_id": "Thread-1", "execution_time": 0.0063664913177490234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_GBCDeposit_deposists_daily_date.38d3333b70", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_GBCDeposit_deposists_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.746857Z", "completed_at": "2026-02-12T22:49:48.751041Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.751627Z", "completed_at": "2026-02-12T22:49:48.751635Z"}], "thread_id": "Thread-1", "execution_time": 0.006101846694946289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_lending_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    symbol AS token,\n    token_class,\n    protocol AS label,\n    'Lending APY' AS apy_type,\n    apy_daily AS value\nFROM `dbt`.`int_execution_yields_aave_daily`\nWHERE apy_daily IS NOT NULL\n\nUNION ALL\n\nSELECT\n    date,\n    symbol AS token,\n    token_class,\n    protocol AS label,\n    'Borrow APY' AS apy_type,\n    borrow_apy_variable_daily AS value\nFROM `dbt`.`int_execution_yields_aave_daily`\nWHERE borrow_apy_variable_daily IS NOT NULL\n\nORDER BY date DESC, token, label, apy_type", "relation_name": "`dbt`.`api_execution_yields_lending_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.754386Z", "completed_at": "2026-02-12T22:49:48.759637Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.760195Z", "completed_at": "2026-02-12T22:49:48.760203Z"}], "thread_id": "Thread-1", "execution_time": 0.0072362422943115234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_yields_lending_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nlatest_date AS (\n    SELECT MAX(date) AS max_date\n    FROM `dbt`.`int_execution_yields_aave_daily`\n    WHERE date < today()\n),\n\n-- Define time windows (currently only 7D, but structure allows for 30D, 90D later)\nrng AS (\n    SELECT '7D' AS window, 7 AS days\n    -- UNION ALL\n    -- SELECT '30D' AS window, 30 AS days\n    -- UNION ALL\n    -- SELECT '90D' AS window, 90 AS days\n),\n\nbounds AS (\n    SELECT\n        r.window,\n        r.days,\n        w.max_date,\n        subtractDays(w.max_date, r.days)        AS curr_start,\n        w.max_date                              AS curr_end,\n        subtractDays(w.max_date, 2 * r.days)    AS prev_start,\n        subtractDays(w.max_date, r.days)        AS prev_end\n    FROM rng r\n    CROSS JOIN latest_date w\n),\n\ncurr_lenders AS (\n    SELECT\n        b.window,\n        d.symbol AS token,\n        toUInt64(groupBitmapMerge(d.lenders_bitmap_state)) AS value\n    FROM `dbt`.`int_execution_yields_aave_daily` d\n    INNER JOIN bounds b\n        ON d.date > b.curr_start\n        AND d.date <= b.curr_end\n        AND d.lenders_bitmap_state IS NOT NULL\n    GROUP BY b.window, d.symbol\n),\n\nprev_lenders AS (\n    SELECT\n        b.window,\n        d.symbol AS token,\n        toUInt64(groupBitmapMerge(d.lenders_bitmap_state)) AS value\n    FROM `dbt`.`int_execution_yields_aave_daily` d\n    INNER JOIN bounds b\n        ON d.date > b.prev_start\n        AND d.date <= b.prev_end\n        AND d.lenders_bitmap_state IS NOT NULL\n    GROUP BY b.window, d.symbol\n),\n\ncurr_borrowers AS (\n    SELECT\n        b.window,\n        d.symbol AS token,\n        toUInt64(groupBitmapMerge(d.borrowers_bitmap_state)) AS value\n    FROM `dbt`.`int_execution_yields_aave_daily` d\n    INNER JOIN bounds b\n        ON d.date > b.curr_start\n        AND d.date <= b.curr_end\n        AND d.borrowers_bitmap_state IS NOT NULL\n    GROUP BY b.window, d.symbol\n),\n\nprev_borrowers AS (\n    SELECT\n        b.window,\n        d.symbol AS token,\n        toUInt64(groupBitmapMerge(d.borrowers_bitmap_state)) AS value\n    FROM `dbt`.`int_execution_yields_aave_daily` d\n    INNER JOIN bounds b\n        ON d.date > b.prev_start\n        AND d.date <= b.prev_end\n        AND d.borrowers_bitmap_state IS NOT NULL\n    GROUP BY b.window, d.symbol\n)\n\nSELECT\n    'Lenders' AS label,\n    c.window,\n    c.token,\n    toFloat64(COALESCE(c.value, 0)) AS value,\n    ROUND((COALESCE(c.value / NULLIF(p.value, 0), 0) - 1) * 100, 1) AS change_pct\nFROM curr_lenders c\nLEFT JOIN prev_lenders p ON p.window = c.window AND p.token = c.token\n\nUNION ALL\n\nSELECT\n    'Borrowers' AS label,\n    c.window,\n    c.token,\n    toFloat64(COALESCE(c.value, 0)) AS value,\n    ROUND((COALESCE(c.value / NULLIF(p.value, 0), 0) - 1) * 100, 1) AS change_pct\nFROM curr_borrowers c\nLEFT JOIN prev_borrowers p ON p.window = c.window AND p.token = c.token", "relation_name": "`dbt`.`fct_execution_yields_lending_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.763023Z", "completed_at": "2026-02-12T22:49:48.768496Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.769062Z", "completed_at": "2026-02-12T22:49:48.769070Z"}], "thread_id": "Thread-1", "execution_time": 0.0075228214263916016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_yields_lending_weekly", "compiled": true, "compiled_code": "\n\nWITH weekly_agg AS (\n    SELECT\n        toStartOfWeek(date) AS week,\n        token_address,\n        symbol,\n        token_class,\n        protocol,\n        -- APY: use last value of the week\n        argMax(apy_daily, date) AS apy_weekly,\n        argMax(borrow_apy_variable_daily, date) AS borrow_apy_weekly,\n        groupBitmapMerge(lenders_bitmap_state) AS lenders_bitmap_state,\n        groupBitmapMerge(borrowers_bitmap_state) AS borrowers_bitmap_state,\n        sum(deposits_volume_daily) AS deposits_volume_weekly,\n        sum(borrows_volume_daily) AS borrows_volume_weekly\n    FROM `dbt`.`int_execution_yields_aave_daily`\n    WHERE date < toStartOfWeek(today())\n    GROUP BY week, token_address, symbol, token_class, protocol\n)\n\nSELECT\n    week,\n    token_address,\n    symbol,\n    token_class,\n    protocol,\n    apy_weekly,\n    borrow_apy_weekly,\n    lenders_bitmap_state,\n    borrowers_bitmap_state,\n    toUInt64(lenders_bitmap_state) AS lenders_count_weekly,\n    toUInt64(borrowers_bitmap_state) AS borrowers_count_weekly,\n    deposits_volume_weekly,\n    borrows_volume_weekly\nFROM weekly_agg", "relation_name": "`dbt`.`fct_execution_yields_lending_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.771836Z", "completed_at": "2026-02-12T22:49:48.779102Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.779747Z", "completed_at": "2026-02-12T22:49:48.779755Z"}], "thread_id": "Thread-1", "execution_time": 0.009284734725952148, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_rwa_backedfi_prices_daily", "compiled": true, "compiled_code": "\n\n\n\n   -- safely before any token was listed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bC3M'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bC3M'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bCOIN'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bCOIN'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bCSPX'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bCSPX'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bHIGH'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bHIGH'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bIB01'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bIB01'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bIBTA'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bIBTA'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bMSTR'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bMSTR'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bNVDA'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bNVDA'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'TSLAx'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'TSLAx'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nORDER BY bticker, date", "relation_name": "`dbt`.`fct_execution_rwa_backedfi_prices_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.782706Z", "completed_at": "2026-02-12T22:49:48.787313Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.787900Z", "completed_at": "2026-02-12T22:49:48.787907Z"}], "thread_id": "Thread-1", "execution_time": 0.006712675094604492, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_rwa_backedfi_prices_date.10510ec5d3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_rwa_backedfi_prices`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.790602Z", "completed_at": "2026-02-12T22:49:48.794796Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.795383Z", "completed_at": "2026-02-12T22:49:48.795390Z"}], "thread_id": "Thread-1", "execution_time": 0.0060694217681884766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_circles_backing", "compiled": true, "compiled_code": "\n\nWITH dates AS (\n    -- get min/max date \n    SELECT\n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM `dbt`.`int_execution_circles_backing`\n),\ndate_series AS (\n    -- generate dense series of dates\n    SELECT\n        toDate(min_date) + number AS date\n    FROM dates\n    ARRAY JOIN range(dateDiff('day', min_date, max_date) + 1) AS number\n),\n\nfilled AS (\n    SELECT\n        g.date,\n        coalesce(t.cnt, 0) AS cnt\n    FROM date_series g\n    LEFT JOIN `dbt`.`int_execution_circles_backing` t\n        ON g.date = t.date\n)\n\nSELECT\n    date,\n    cnt,\n    SUM(cnt) OVER (ORDER BY date) AS total\nFROM filled\nWHERE date < today()", "relation_name": "`dbt`.`fct_execution_circles_backing`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.798140Z", "completed_at": "2026-02-12T22:49:48.802668Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.803243Z", "completed_at": "2026-02-12T22:49:48.803250Z"}], "thread_id": "Thread-1", "execution_time": 0.00637364387512207, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_circles_backing_date.f1014374da", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_circles_backing`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.805908Z", "completed_at": "2026-02-12T22:49:48.810481Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.811049Z", "completed_at": "2026-02-12T22:49:48.811057Z"}], "thread_id": "Thread-1", "execution_time": 0.0064051151275634766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_circles_transitive_transfers_date.3c0b3c4d11", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_circles_transitive_transfers`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.813735Z", "completed_at": "2026-02-12T22:49:48.819544Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.820110Z", "completed_at": "2026-02-12T22:49:48.820118Z"}], "thread_id": "Thread-1", "execution_time": 0.007647514343261719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_circles_v1_avatars_block_timestamp.59705b6705", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect block_timestamp\nfrom `dbt`.`int_execution_circles_v1_avatars`\nwhere block_timestamp is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.822839Z", "completed_at": "2026-02-12T22:49:48.827273Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.827881Z", "completed_at": "2026-02-12T22:49:48.827888Z"}], "thread_id": "Thread-1", "execution_time": 0.006373405456542969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_circles_avatars", "compiled": true, "compiled_code": "\n\nWITH dates AS (\n    -- get min/max date \n    SELECT\n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM `dbt`.`int_execution_circles_v2_avatars`\n),\ndate_series AS (\n    -- generate dense series of dates\n    SELECT\n        toDate(min_date) + number AS date\n    FROM dates\n    ARRAY JOIN range(dateDiff('day', min_date, max_date) + 1) AS number\n),\navatar_types AS (\n    SELECT DISTINCT avatar_type\n    FROM `dbt`.`int_execution_circles_v2_avatars`\n),\ndense_grid AS (\n    SELECT\n        d.date,\n        a.avatar_type\n    FROM date_series d\n    CROSS JOIN avatar_types a\n),\nfilled AS (\n    SELECT\n        g.date,\n        g.avatar_type,\n        coalesce(t.cnt, 0) AS cnt\n    FROM dense_grid g\n    LEFT JOIN `dbt`.`int_execution_circles_v2_avatars` t\n        ON g.date = t.date\n       AND g.avatar_type = t.avatar_type\n)\n\nSELECT\n    date,\n    avatar_type,\n    cnt,\n    SUM(cnt) OVER (PARTITION BY avatar_type ORDER BY date) AS total\nFROM filled", "relation_name": "`dbt`.`fct_execution_circles_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.830686Z", "completed_at": "2026-02-12T22:49:48.835269Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.835887Z", "completed_at": "2026-02-12T22:49:48.835895Z"}], "thread_id": "Thread-1", "execution_time": 0.006545066833496094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_circles_v2_avatars_date.d60ea61f19", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_circles_v2_avatars`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.838607Z", "completed_at": "2026-02-12T22:49:48.842566Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.843168Z", "completed_at": "2026-02-12T22:49:48.843175Z"}], "thread_id": "Thread-1", "execution_time": 0.005861520767211914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_yields_sdai_apy_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nsdai_apy_daily AS (\n    SELECT\n        date,\n        floor(POWER((1+rate),365) - 1,4) * 100 AS apy,\n        floor(\n            avg(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 6  PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_7DMA,\n        floor(\n            avg(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_30DMA,\n         floor(\n            median(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 6  PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_7DMM,\n        floor(\n            median(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_30DMM\n    FROM `dbt`.`int_yields_sdai_rate_daily`\n)\n\nSELECT date, apy, 'Daily' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_7DMA, '7DMA' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_30DMA, '30DMA' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_7DMM, '7DMM' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_30DMM, '30DMM' AS label FROM sdai_apy_daily", "relation_name": "`dbt`.`fct_yields_sdai_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.846005Z", "completed_at": "2026-02-12T22:49:48.856255Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.856890Z", "completed_at": "2026-02-12T22:49:48.856897Z"}], "thread_id": "Thread-1", "execution_time": 0.012273311614990234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_tokens_address_diffs_daily", "compiled": true, "compiled_code": "\n\n-- depends_on: `dbt`.`int_execution_transfers_whitelisted_daily`\n\n\n\n\n\n\n\n\nWITH base AS (\n    SELECT\n        date,\n        lower(token_address) AS token_address,\n        symbol,\n        lower(\"from\")        AS from_address,\n        lower(\"to\")          AS to_address,\n        amount_raw               AS amount_raw\n    FROM `dbt`.`int_execution_transfers_whitelisted_daily`\n    WHERE date < today()\n      \n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_tokens_address_diffs_daily` AS x1\n      WHERE 1=1 \n  \n  \n\n  \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n\n    )\n    AND toDate(date) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_tokens_address_diffs_daily` AS x2\n      WHERE 1=1 \n  \n  \n\n  \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n\n    )\n  \n\n      \n      \n  \n\n      \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n),\n\nwith_class AS (\n    SELECT\n        b.date,\n        b.token_address,\n        b.symbol,\n        coalesce(w.token_class, 'OTHER') AS token_class,\n        b.from_address,\n        b.to_address,\n        b.amount_raw\n    FROM base b\n    INNER JOIN `dbt`.`tokens_whitelist` w\n      ON lower(w.address) = b.token_address\n     AND b.date >= toDate(w.date_start)\n     AND (w.date_end IS NULL OR b.date < toDate(w.date_end))\n),\n\ndeltas AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        from_address AS address,\n        -amount_raw      AS delta_raw\n    FROM with_class\n\n    UNION ALL\n\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        to_address   AS address,\n        amount_raw       AS delta_raw\n    FROM with_class\n),\n\nagg AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        lower(address) AS address,\n        sum(delta_raw)     AS net_delta_raw\n    FROM deltas\n    GROUP BY date, token_address, symbol, token_class, address\n)\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n    address,\n    net_delta_raw\nFROM agg\nWHERE net_delta_raw != 0", "relation_name": "`dbt`.`int_execution_tokens_address_diffs_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.859827Z", "completed_at": "2026-02-12T22:49:48.870397Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.871025Z", "completed_at": "2026-02-12T22:49:48.871033Z"}], "thread_id": "Thread-1", "execution_time": 0.012665748596191406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_tokens_transfers_daily", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\nWITH base AS (\n    SELECT\n        date,\n        lower(token_address) AS token_address,\n        symbol,\n        lower(\"from\")        AS from_address,\n        lower(\"to\")          AS to_address,\n        amount_raw,\n        transfer_count\n    FROM `dbt`.`int_execution_transfers_whitelisted_daily`\n    WHERE date < today()\n      \n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_tokens_transfers_daily` AS x1\n      WHERE 1=1 \n  \n  \n\n  \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n\n    )\n    AND toDate(date) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_tokens_transfers_daily` AS x2\n      WHERE 1=1 \n  \n  \n\n  \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n\n    )\n  \n\n      \n      \n  \n\n      \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n),\n\nwith_class AS (\n    SELECT\n        b.date,\n        b.token_address,\n        b.symbol,\n        coalesce(w.token_class, 'OTHER') AS token_class,\n        w.decimals,\n        b.from_address,\n        b.to_address,\n        b.amount_raw,\n        b.transfer_count\n    FROM base b\n    INNER JOIN `dbt`.`tokens_whitelist` w\n      ON lower(w.address) = b.token_address\n     AND b.date >= toDate(w.date_start)\n     AND (w.date_end IS NULL OR b.date < toDate(w.date_end))\n),\n\nagg AS (\n    SELECT\n        date,\n        token_address,\n        any(symbol)      AS symbol,\n        any(token_class) AS token_class,\n        sum(amount_raw / POWER(10, COALESCE(decimals, 18))) AS volume_token,\n        sum(transfer_count) AS transfer_count,\n        groupBitmapState(cityHash64(from_address)) AS ua_bitmap_state,\n        uniqExact(from_address)                    AS active_senders,\n        uniqExact(to_address)                      AS unique_receivers\n    FROM with_class\n    GROUP BY date, token_address\n)\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n    volume_token,\n    transfer_count,\n    ua_bitmap_state,\n    active_senders,\n    unique_receivers\nFROM agg\nORDER BY date, token_address", "relation_name": "`dbt`.`int_execution_tokens_transfers_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.873900Z", "completed_at": "2026-02-12T22:49:48.877844Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.878453Z", "completed_at": "2026-02-12T22:49:48.878461Z"}], "thread_id": "Thread-1", "execution_time": 0.005866527557373047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_crawlers_data_distinct_projects_sectors", "compiled": true, "compiled_code": "\n\nSELECT DISTINCT\n  project,\n  sector\nFROM `dbt`.`int_crawlers_data_labels`\nWHERE project IS NOT NULL\n  AND sector  IS NOT NULL", "relation_name": "`dbt`.`fct_crawlers_data_distinct_projects_sectors`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.881365Z", "completed_at": "2026-02-12T22:49:48.889895Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.890512Z", "completed_at": "2026-02-12T22:49:48.890519Z"}], "thread_id": "Thread-1", "execution_time": 0.01066136360168457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_by_project_daily", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\nWITH lbl AS (\n  SELECT address, project, sector\n  FROM `dbt`.`int_crawlers_data_labels`\n),\n\ndeduped_transactions AS (\n    SELECT\n        block_timestamp,\n        CONCAT('0x', from_address) AS from_address,\n        IF(to_address IS NULL, NULL, CONCAT('0x', to_address)) AS to_address,\n        gas_used,\n        gas_price\n    FROM (\n        \n\nSELECT block_timestamp, from_address, to_address, gas_used, gas_price\nFROM (\n    SELECT\n        block_timestamp, from_address, to_address, gas_used, gas_price,\n        ROW_NUMBER() OVER (\n            PARTITION BY block_number, transaction_index\n            ORDER BY insert_version DESC\n        ) AS _dedup_rn\n    FROM `execution`.`transactions`\n    \n    WHERE \n    block_timestamp < today()\n    AND from_address IS NOT NULL\n    AND success = 1\n    \n      \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(block_timestamp)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_transactions_by_project_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(block_timestamp) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_transactions_by_project_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n    \n\n    \n)\nWHERE _dedup_rn = 1\n\n    )\n),\n\ntx_labeled AS (\n  SELECT\n    toDate(t.block_timestamp)                        AS date,\n    coalesce(nullIf(trim(l.project), ''), 'Unknown') AS project,\n    lower(t.from_address)                            AS from_address,\n    toFloat64(coalesce(t.gas_used, 0))               AS gas_used,\n    toFloat64(coalesce(t.gas_price, 0))              AS gas_price\n  FROM deduped_transactions t\n  ANY LEFT JOIN lbl l ON lower(t.to_address) = l.address\n),\n\nagg AS (\n  SELECT\n    date,\n    project,\n    count()                                    AS tx_count,\n    groupBitmapState(cityHash64(from_address)) AS ua_bitmap_state,\n    sum(gas_used)                              AS gas_used_sum,\n    sum(gas_used * gas_price) / 1e18           AS fee_native_sum\n  FROM tx_labeled\n  GROUP BY date, project\n),\n\nproj_sector AS (\n  SELECT\n    project,\n    coalesce(nullIf(trim(sector), ''), 'Unknown') AS sector\n  FROM (\n    SELECT project, anyHeavy(sector) AS sector\n    FROM `dbt`.`int_crawlers_data_labels`\n    GROUP BY project\n  )\n)\n\nSELECT\n  a.date                AS date,\n  a.project             AS project,\n  ps.sector             AS sector,\n  a.tx_count            AS tx_count,\n  a.ua_bitmap_state     AS ua_bitmap_state,\n  a.gas_used_sum        AS gas_used_sum,\n  a.fee_native_sum      AS fee_native_sum\nFROM agg a\nLEFT JOIN proj_sector ps ON ps.project = a.project", "relation_name": "`dbt`.`int_execution_transactions_by_project_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.893361Z", "completed_at": "2026-02-12T22:49:48.899189Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.899832Z", "completed_at": "2026-02-12T22:49:48.899840Z"}], "thread_id": "Thread-1", "execution_time": 0.007914066314697266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_by_project_hourly_recent", "compiled": true, "compiled_code": "\n\n\n\nWITH lbl AS (\n  SELECT address, project, sector\n  FROM `dbt`.`int_crawlers_data_labels`\n),\n\ndeduped_transactions AS (\n    SELECT\n        block_timestamp,\n        CONCAT('0x', from_address) AS from_address,\n        IF(to_address IS NULL, NULL, CONCAT('0x', to_address)) AS to_address,\n        gas_used,\n        gas_price\n    FROM (\n        \n\nSELECT block_timestamp, from_address, to_address, gas_used, gas_price\nFROM (\n    SELECT\n        block_timestamp, from_address, to_address, gas_used, gas_price,\n        ROW_NUMBER() OVER (\n            PARTITION BY block_number, transaction_index\n            ORDER BY insert_version DESC\n        ) AS _dedup_rn\n    FROM `execution`.`transactions`\n    \n    WHERE \n    toStartOfMonth(block_timestamp) >= toStartOfMonth(today() - INTERVAL 1 MONTH)\n    AND from_address IS NOT NULL\n    AND success = 1\n\n    \n)\nWHERE _dedup_rn = 1\n\n    )\n),\n\nwm AS (\n  SELECT toStartOfDay(max(block_timestamp), 'UTC') AS max_day\n  FROM deduped_transactions\n),\n\ntx AS (\n  SELECT\n    toStartOfHour(t.block_timestamp, 'UTC') AS hour,\n    lower(t.from_address)                 AS from_address,\n    lower(t.to_address)                   AS to_address,\n    toFloat64(coalesce(t.gas_used, 0))    AS gas_used,\n    toFloat64(coalesce(t.gas_price, 0))   AS gas_price\n  FROM deduped_transactions t\n  CROSS JOIN wm\n  WHERE\n    toStartOfDay(t.block_timestamp, 'UTC') >= subtractDays(max_day, 2)\n    AND toStartOfDay(t.block_timestamp, 'UTC') < max_day\n),\n\nclassified AS (\n  SELECT\n    tx.hour,\n    coalesce(nullIf(trim(l.project), ''), 'Unknown') AS project,\n    count()                                          AS tx_count,\n    countDistinct(tx.from_address)                   AS active_accounts,\n    groupBitmapState(cityHash64(tx.from_address))    AS ua_bitmap_state,\n    sum(tx.gas_used * tx.gas_price) / 1e18           AS fee_native_sum\n  FROM tx\n  ANY LEFT JOIN lbl l ON tx.to_address = l.address\n  GROUP BY tx.hour, project\n),\n\nproj_sector AS (\n  SELECT\n    project,\n    coalesce(nullIf(trim(sector), ''), 'Unknown') AS sector\n  FROM (\n    SELECT project, anyHeavy(sector) AS sector\n    FROM `dbt`.`int_crawlers_data_labels`\n    GROUP BY project\n  )\n)\n\nSELECT\n  c.hour,\n  c.project,\n  ps.sector,\n  c.tx_count,\n  c.active_accounts,\n  c.ua_bitmap_state,\n  c.fee_native_sum\nFROM classified c\nLEFT JOIN proj_sector ps ON ps.project = c.project", "relation_name": "`dbt`.`int_execution_transactions_by_project_hourly_recent`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.902746Z", "completed_at": "2026-02-12T22:49:48.907379Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.907990Z", "completed_at": "2026-02-12T22:49:48.907998Z"}], "thread_id": "Thread-1", "execution_time": 0.006715536117553711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_crawlers_data_labels_introduced_at.caa2cba0cf", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect introduced_at\nfrom `dbt`.`int_crawlers_data_labels`\nwhere introduced_at is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.910659Z", "completed_at": "2026-02-12T22:49:48.915105Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.915689Z", "completed_at": "2026-02-12T22:49:48.915696Z"}], "thread_id": "Thread-1", "execution_time": 0.006306648254394531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_withdrawal_credentials_freq_daily_date.b55d46aedc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_withdrawal_credentials_freq_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.918349Z", "completed_at": "2026-02-12T22:49:48.924125Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.924715Z", "completed_at": "2026-02-12T22:49:48.924723Z"}], "thread_id": "Thread-1", "execution_time": 0.007695436477661133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_apy_dist_last_30_days_date.640e008a97", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_apy_dist_last_30_days`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.927376Z", "completed_at": "2026-02-12T22:49:48.932123Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.932707Z", "completed_at": "2026-02-12T22:49:48.932714Z"}], "thread_id": "Thread-1", "execution_time": 0.0066525936126708984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_balance_dist_last_30_days_date.da42d3977a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_balance_dist_last_30_days`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.935358Z", "completed_at": "2026-02-12T22:49:48.939904Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.940487Z", "completed_at": "2026-02-12T22:49:48.940494Z"}], "thread_id": "Thread-1", "execution_time": 0.006447553634643555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_apy_dist_daily_date.a70bc6aaff", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_apy_dist_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.943122Z", "completed_at": "2026-02-12T22:49:48.947580Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.948146Z", "completed_at": "2026-02-12T22:49:48.948153Z"}], "thread_id": "Thread-1", "execution_time": 0.006327629089355469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_consensus_validators_balances_dist_daily_date.41eb9fe9cd", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_consensus_validators_balances_dist_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.950882Z", "completed_at": "2026-02-12T22:49:48.954844Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.955459Z", "completed_at": "2026-02-12T22:49:48.955466Z"}], "thread_id": "Thread-1", "execution_time": 0.0058765411376953125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_active_ongoing_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'active_ongoing'", "relation_name": "`dbt`.`api_consensus_info_active_ongoing_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.958183Z", "completed_at": "2026-02-12T22:49:48.963222Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.963833Z", "completed_at": "2026-02-12T22:49:48.963840Z"}], "thread_id": "Thread-1", "execution_time": 0.006986141204833984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_apy_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'APY'", "relation_name": "`dbt`.`api_consensus_info_apy_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.966585Z", "completed_at": "2026-02-12T22:49:48.970479Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.971072Z", "completed_at": "2026-02-12T22:49:48.971079Z"}], "thread_id": "Thread-1", "execution_time": 0.005864381790161133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_deposits_cnt_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'deposits_cnt'", "relation_name": "`dbt`.`api_consensus_info_deposits_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.973852Z", "completed_at": "2026-02-12T22:49:48.977734Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.978315Z", "completed_at": "2026-02-12T22:49:48.978323Z"}], "thread_id": "Thread-1", "execution_time": 0.00583958625793457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_staked_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    toUInt32(value) AS value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'Staked'", "relation_name": "`dbt`.`api_consensus_info_staked_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.981074Z", "completed_at": "2026-02-12T22:49:48.984919Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.985521Z", "completed_at": "2026-02-12T22:49:48.985529Z"}], "thread_id": "Thread-1", "execution_time": 0.005741119384765625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_withdrawls_cnt_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'withdrawls_cnt'", "relation_name": "`dbt`.`api_consensus_info_withdrawls_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.988208Z", "completed_at": "2026-02-12T22:49:48.992695Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:48.993264Z", "completed_at": "2026-02-12T22:49:48.993272Z"}], "thread_id": "Thread-1", "execution_time": 0.006375551223754883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_bridges_cum_netflow_weekly_by_bridge_date.73f6426d30", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_bridges_cum_netflow_weekly_by_bridge`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:48.995966Z", "completed_at": "2026-02-12T22:49:49.000529Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.001086Z", "completed_at": "2026-02-12T22:49:49.001094Z"}], "thread_id": "Thread-1", "execution_time": 0.0064508914947509766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_bridges_token_netflow_daily_by_bridge_date.5058311fee", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_bridges_token_netflow_daily_by_bridge`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.003758Z", "completed_at": "2026-02-12T22:49:49.009590Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.010159Z", "completed_at": "2026-02-12T22:49:49.010167Z"}], "thread_id": "Thread-1", "execution_time": 0.0077207088470458984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_state_full_size_daily_date.453c8c3223", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_state_full_size_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.012836Z", "completed_at": "2026-02-12T22:49:49.017221Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.017801Z", "completed_at": "2026-02-12T22:49:49.017809Z"}], "thread_id": "Thread-1", "execution_time": 0.0062940120697021484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_discv4_clients_daily_date.48ee0389eb", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_discv4_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.020578Z", "completed_at": "2026-02-12T22:49:49.028812Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.029427Z", "completed_at": "2026-02-12T22:49:49.029435Z"}], "thread_id": "Thread-1", "execution_time": 0.01024484634399414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_client_distribution", "compiled": true, "compiled_code": "\n\nWITH node_classification AS (\n    -- Get total nodes per category from classification model\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        scaling_factor\n    FROM `dbt`.`int_esg_node_classification`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`)\n    \n),\n\n-- Combine client data from both DiscV4 (execution) and DiscV5 (consensus)\ncombined_client_data AS (\n    -- DiscV5 Consensus clients\n    SELECT\n        date,\n        'consensus_' || label AS client_type,\n        value AS observed_client_nodes\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE metric = 'Clients' \n        AND value > 0\n        AND label NOT IN ('Unknown', '')\n        \n            AND date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`) - INTERVAL 1 DAY\n        \n    \n    UNION ALL\n    \n    -- DiscV4 Execution clients  \n    SELECT\n        date,\n        'execution_' || label AS client_type,\n        value AS observed_client_nodes\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE metric = 'Clients'\n        AND value > 0  \n        AND label NOT IN ('Unknown', '')\n        \n            AND date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`) - INTERVAL 1 DAY\n        \n),\n\n-- Calculate client distribution percentages\nobserved_client_distribution AS (\n    SELECT\n        date,\n        client_type,\n        observed_client_nodes,\n        round(100.0 * observed_client_nodes / SUM(observed_client_nodes) OVER (PARTITION BY date), 3) AS observed_client_percentage\n    FROM combined_client_data\n),\n\n-- Apply client distribution to each node category\nclient_distribution_by_category AS (\n    SELECT\n        nc.date,\n        nc.node_category, \n        ocd.client_type,\n        ocd.observed_client_nodes,\n        ocd.observed_client_percentage,\n        \n        -- Calculate client nodes for this category\n        -- Each client gets same percentage of each category\n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.estimated_total_nodes\n        )) AS estimated_client_nodes,\n        \n        -- Proportional bounds\n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.nodes_lower_95\n        )) AS client_nodes_lower_95,\n        \n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.nodes_upper_95\n        )) AS client_nodes_upper_95,\n        \n        -- Client efficiency factors\n        CASE \n            -- Consensus client efficiency (relative to baseline)\n            WHEN ocd.client_type = 'consensus_Lighthouse' THEN 0.95\n            WHEN ocd.client_type = 'consensus_Nimbus' THEN 0.85  \n            WHEN ocd.client_type = 'consensus_Teku' THEN 1.15\n            WHEN ocd.client_type = 'consensus_Prysm' THEN 1.05\n            WHEN ocd.client_type = 'consensus_Lodestar' THEN 1.10\n            \n            -- Execution client efficiency (relative to baseline)\n            WHEN ocd.client_type = 'execution_Erigon' THEN 0.95\n            WHEN ocd.client_type = 'execution_Nethermind' THEN 1.00\n            WHEN ocd.client_type = 'execution_Besu' THEN 1.02\n            WHEN ocd.client_type = 'execution_Geth' THEN 0.98\n            \n            -- Default for other/unknown clients\n            ELSE 1.0\n        END AS client_efficiency_factor,\n        \n        nc.scaling_factor\n        \n    FROM node_classification nc\n    JOIN observed_client_distribution ocd ON nc.date = ocd.date\n    WHERE nc.estimated_total_nodes > 0\n),\n\n-- Calculate final metrics with rankings\nfinal_client_distribution AS (\n    SELECT\n        date,\n        node_category,\n        client_type,\n        estimated_client_nodes,\n        client_nodes_lower_95,\n        client_nodes_upper_95,\n        client_efficiency_factor,\n        \n        -- Percentage within this node category\n        round(100.0 * estimated_client_nodes / \n              NULLIF(SUM(estimated_client_nodes) OVER (PARTITION BY date, node_category), 0), 2\n        ) AS category_client_percentage,\n        \n        -- Global percentage across all categories  \n        round(100.0 * estimated_client_nodes /\n              NULLIF(SUM(estimated_client_nodes) OVER (PARTITION BY date), 0), 2\n        ) AS global_client_percentage,\n        \n        -- Ranking within category\n        ROW_NUMBER() OVER (\n            PARTITION BY date, node_category \n            ORDER BY estimated_client_nodes DESC, client_type\n        ) AS rank_in_category,\n        \n        -- Global ranking\n        ROW_NUMBER() OVER (\n            PARTITION BY date \n            ORDER BY estimated_client_nodes DESC, node_category, client_type\n        ) AS global_rank\n        \n    FROM client_distribution_by_category\n    WHERE estimated_client_nodes > 0\n)\n\nSELECT\n    date,\n    node_category,\n    client_type,\n    estimated_client_nodes,\n    client_nodes_lower_95,\n    client_nodes_upper_95,\n    client_efficiency_factor,\n    category_client_percentage,\n    global_client_percentage,\n    rank_in_category,\n    global_rank,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM final_client_distribution\nORDER BY date, node_category, estimated_client_nodes DESC", "relation_name": "`dbt`.`int_esg_node_client_distribution`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.032353Z", "completed_at": "2026-02-12T22:49:49.038042Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.038660Z", "completed_at": "2026-02-12T22:49:49.038667Z"}], "thread_id": "Thread-1", "execution_time": 0.007688045501708984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_geographic_distribution", "compiled": true, "compiled_code": "\n\nWITH node_classification AS (\n    -- Get node classification data\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        geographic_distribution\n    FROM `dbt`.`int_esg_node_classification`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_geographic_distribution`)\n    \n),\n\n-- Parse geographic distribution JSON\ngeographic_parsed AS (\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        \n        -- Parse JSON array of country distributions\n        JSONExtract(geographic_distribution, 'Array(Tuple(String, UInt32))') AS country_array\n    FROM node_classification\n),\n\ngeographic_expanded AS (\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95, \n        nodes_upper_95,\n        \n        -- Unpack country data\n        arrayJoin(country_array) AS country_tuple,\n        tupleElement(country_tuple, 1) AS country_code,\n        tupleElement(country_tuple, 2) AS estimated_nodes\n        \n    FROM geographic_parsed\n    WHERE length(country_array) > 0\n),\n\n-- Add country metadata from country_codes table\ncountry_enriched AS (\n    SELECT\n        g.date,\n        g.node_category,\n        g.country_code,\n        g.estimated_nodes,\n        \n        -- Calculate bounds proportionally\n        round(toFloat64(g.estimated_nodes) * g.nodes_lower_95 / g.estimated_total_nodes) AS nodes_lower_95,\n        round(toFloat64(g.estimated_nodes) * g.nodes_upper_95 / g.estimated_total_nodes) AS nodes_upper_95,\n        \n        -- Country percentage within this category\n        round(100.0 * g.estimated_nodes / g.estimated_total_nodes, 2) AS category_percentage,\n        \n        -- Get country metadata from reference table\n        COALESCE(cc.name, 'Unknown') AS country_name,\n        COALESCE(cc.region, 'Other') AS region,\n        cc.`sub-region` AS sub_region,\n        cc.`alpha-3` AS country_code_alpha3\n        \n    FROM geographic_expanded g\n    LEFT JOIN `dbt`.`stg_crawlers_data__country_codes` cc\n        ON g.country_code = cc.`alpha-2`\n    WHERE g.estimated_nodes > 0  -- Only include countries with nodes\n)\n\nSELECT\n    date,\n    node_category,\n    country_code,\n    country_name,\n    region,\n    sub_region,\n    country_code_alpha3,\n    estimated_nodes AS estimated_total_nodes,\n    nodes_lower_95,\n    nodes_upper_95,\n    category_percentage,\n    \n    -- Overall percentage across all categories\n    round(100.0 * estimated_nodes / SUM(estimated_nodes) OVER (PARTITION BY date), 2) AS global_percentage,\n    \n    -- Ranking within category\n    ROW_NUMBER() OVER (PARTITION BY date, node_category ORDER BY estimated_nodes DESC) AS rank_in_category,\n    \n    -- Ranking globally\n    ROW_NUMBER() OVER (PARTITION BY date ORDER BY estimated_nodes DESC) AS global_rank,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM country_enriched\nORDER BY date, node_category, estimated_nodes DESC", "relation_name": "`dbt`.`int_esg_node_geographic_distribution`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.041298Z", "completed_at": "2026-02-12T22:49:49.046080Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.046695Z", "completed_at": "2026-02-12T22:49:49.046702Z"}], "thread_id": "Thread-1", "execution_time": 0.006668567657470703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_esg_node_classification_peer_id.08efd9bad7", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect peer_id\nfrom `dbt`.`int_esg_node_classification`\nwhere peer_id is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.049335Z", "completed_at": "2026-02-12T22:49:49.054938Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.055520Z", "completed_at": "2026-02-12T22:49:49.055527Z"}], "thread_id": "Thread-1", "execution_time": 0.007494926452636719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.unique_int_esg_node_classification_peer_id.d2c6a70b0b", "compiled": true, "compiled_code": "\n    \n    \n\nselect\n    peer_id as unique_field,\n    count(*) as n_records\n\nfrom `dbt`.`int_esg_node_classification`\nwhere peer_id is not null\ngroup by peer_id\nhaving count(*) > 1\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.058173Z", "completed_at": "2026-02-12T22:49:49.062631Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.063189Z", "completed_at": "2026-02-12T22:49:49.063196Z"}], "thread_id": "Thread-1", "execution_time": 0.00627899169921875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_clients_latest_date.79522e2cdc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_clients_latest`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.065839Z", "completed_at": "2026-02-12T22:49:49.070256Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.070840Z", "completed_at": "2026-02-12T22:49:49.070848Z"}], "thread_id": "Thread-1", "execution_time": 0.006324052810668945, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_discv5_clients_daily_date.1187b1bb2f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_discv5_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.073524Z", "completed_at": "2026-02-12T22:49:49.078374Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.078957Z", "completed_at": "2026-02-12T22:49:49.078964Z"}], "thread_id": "Thread-1", "execution_time": 0.006785392761230469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_discv5_current_fork_daily_date.81d71f6217", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_discv5_current_fork_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.081644Z", "completed_at": "2026-02-12T22:49:49.086118Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.086700Z", "completed_at": "2026-02-12T22:49:49.086708Z"}], "thread_id": "Thread-1", "execution_time": 0.0063991546630859375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_discv5_next_fork_daily_date.617d796abf", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_discv5_next_fork_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.089320Z", "completed_at": "2026-02-12T22:49:49.093902Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.094484Z", "completed_at": "2026-02-12T22:49:49.094492Z"}], "thread_id": "Thread-1", "execution_time": 0.006418704986572266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_p2p_discv5_forks_daily_date.71a6724bfb", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_p2p_discv5_forks_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.097235Z", "completed_at": "2026-02-12T22:49:49.102529Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.103153Z", "completed_at": "2026-02-12T22:49:49.103160Z"}], "thread_id": "Thread-1", "execution_time": 0.007234811782836914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_topology_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    protocol,\n    date,\n    peer_discovery_id_prefix,\n    peer_client,\n    peer_city,\n    peer_country,\n    peer_org,\n    peer_lat,\n    peer_lon,\n    neighbor_discovery_id_prefix,\n    neighbor_client,\n    neighbor_city,\n    neighbor_country,\n    neighbor_org,\n    neighbor_lat,\n    neighbor_lon,\n    cnt\nFROM `dbt`.`fct_p2p_topology_latest`\nWHERE peer_lat IS NOT NULL AND neighbor_lat IS NOT NULL\nORDER BY protocol DESC", "relation_name": "`dbt`.`api_p2p_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.105938Z", "completed_at": "2026-02-12T22:49:49.110363Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.110940Z", "completed_at": "2026-02-12T22:49:49.110947Z"}], "thread_id": "Thread-1", "execution_time": 0.006265163421630859, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_p2p_topology_latest_date.561982df18", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_p2p_topology_latest`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.113570Z", "completed_at": "2026-02-12T22:49:49.117430Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.117999Z", "completed_at": "2026-02-12T22:49:49.118006Z"}], "thread_id": "Thread-1", "execution_time": 0.005666494369506836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_lending_borrowers_count_7d", "compiled": true, "compiled_code": "\n\nSELECT\n    token,\n    value,\n    change_pct\nFROM `dbt`.`fct_execution_yields_lending_latest`\nWHERE label = 'Borrowers' AND window = '7D'\nORDER BY token", "relation_name": "`dbt`.`api_execution_yields_lending_borrowers_count_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.120791Z", "completed_at": "2026-02-12T22:49:49.124712Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.125278Z", "completed_at": "2026-02-12T22:49:49.125285Z"}], "thread_id": "Thread-1", "execution_time": 0.005765199661254883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_lending_lenders_count_7d", "compiled": true, "compiled_code": "\n\nSELECT\n    token,\n    value,\n    change_pct\nFROM `dbt`.`fct_execution_yields_lending_latest`\nWHERE label = 'Lenders' AND window = '7D'\nORDER BY token", "relation_name": "`dbt`.`api_execution_yields_lending_lenders_count_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.128017Z", "completed_at": "2026-02-12T22:49:49.132225Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.132809Z", "completed_at": "2026-02-12T22:49:49.132816Z"}], "thread_id": "Thread-1", "execution_time": 0.006165981292724609, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_lending_activity_counts_weekly", "compiled": true, "compiled_code": "\n\nSELECT\n    week AS date,\n    symbol AS token,\n    token_class,\n    protocol AS label,\n    'Lenders' AS activity_type,\n    lenders_count_weekly AS value\nFROM `dbt`.`fct_execution_yields_lending_weekly`\nWHERE lenders_count_weekly > 0\n\nUNION ALL\n\nSELECT\n    week AS date,\n    symbol AS token,\n    token_class,\n    protocol AS label,\n    'Borrowers' AS activity_type,\n    borrowers_count_weekly AS value\nFROM `dbt`.`fct_execution_yields_lending_weekly`\nWHERE borrowers_count_weekly > 0\n\nORDER BY date DESC, token, label, activity_type", "relation_name": "`dbt`.`api_execution_yields_lending_activity_counts_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.135458Z", "completed_at": "2026-02-12T22:49:49.139623Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.140183Z", "completed_at": "2026-02-12T22:49:49.140190Z"}], "thread_id": "Thread-1", "execution_time": 0.0059986114501953125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_lending_activity_volumes_weekly", "compiled": true, "compiled_code": "\n\nSELECT\n    week AS date,\n    symbol AS token,\n    token_class,\n    protocol AS label,\n    'Deposits' AS volume_type,\n    deposits_volume_weekly AS value\nFROM `dbt`.`fct_execution_yields_lending_weekly`\nWHERE deposits_volume_weekly > 0\n\nUNION ALL\n\nSELECT\n    week AS date,\n    symbol AS token,\n    token_class,\n    protocol AS label,\n    'Borrows' AS volume_type,\n    borrows_volume_weekly AS value\nFROM `dbt`.`fct_execution_yields_lending_weekly`\nWHERE borrows_volume_weekly > 0\n\nORDER BY date DESC, token, label, volume_type", "relation_name": "`dbt`.`api_execution_yields_lending_activity_volumes_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.142931Z", "completed_at": "2026-02-12T22:49:49.148114Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.148735Z", "completed_at": "2026-02-12T22:49:49.148742Z"}], "thread_id": "Thread-1", "execution_time": 0.007099151611328125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_rwa_backedfi_prices_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  bticker,\n  date,\n  price         \nFROM `dbt`.`fct_execution_rwa_backedfi_prices_daily`\nORDER BY\n  bticker,\n  date", "relation_name": "`dbt`.`api_execution_rwa_backedfi_prices_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.151557Z", "completed_at": "2026-02-12T22:49:49.156352Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.156991Z", "completed_at": "2026-02-12T22:49:49.156999Z"}], "thread_id": "Thread-1", "execution_time": 0.006870746612548828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_token_prices_daily", "compiled": true, "compiled_code": "\n\nWITH dune AS (\n    SELECT\n        toDate(date)        AS date,\n        upper(symbol)       AS symbol,\n        toFloat64(price)    AS price\n    FROM `dbt`.`stg_crawlers_data__dune_prices`\n    WHERE date < today()\n),\n\nbackedfi AS (\n    SELECT\n        toDate(date)        AS date,\n        upper(bticker)      AS symbol,\n        toFloat64(price)    AS price\n    FROM `dbt`.`fct_execution_rwa_backedfi_prices_daily`\n    WHERE date < today()\n),\n\nwxdai_from_xdai AS (\n    SELECT\n        date,\n        'WXDAI' AS symbol,\n        price\n    FROM dune\n    WHERE symbol = 'XDAI'\n),\n\nagnosdai_from_sdai AS (\n    SELECT\n        date,\n        'AGNOSDAI' AS symbol,\n        price\n    FROM dune\n    WHERE symbol = 'SDAI'\n),\n\nusd_pegs AS (\n    SELECT\n        date,\n        symbol,\n        1.0 AS price\n    FROM (\n        SELECT DISTINCT date FROM dune\n    )\n    ARRAY JOIN ['USDC','USDC.E','USDT'] AS symbol\n),\n\nall_prices AS (\n    SELECT date, symbol, price, 1 AS priority FROM dune\n    UNION ALL\n    SELECT date, symbol, price, 2 AS priority FROM backedfi\n    UNION ALL\n    SELECT date, symbol, price, 1 AS priority FROM wxdai_from_xdai\n    UNION ALL\n    SELECT date, symbol, price, 1 AS priority FROM agnosdai_from_sdai\n    UNION ALL\n    SELECT date, symbol, 1.0 AS price, 3 AS priority FROM usd_pegs\n),\n\ndeduplicated AS (\n    SELECT\n        date,\n        symbol,\n        price\n    FROM (\n        SELECT\n            date,\n            symbol,\n            price,\n            row_number() OVER (PARTITION BY date, symbol ORDER BY priority) AS rn\n        FROM all_prices\n    )\n    WHERE rn = 1\n),\n\nwhitelist_symbols AS (\n    SELECT\n        upper(w.symbol) AS symbol_upper,\n        argMax(w.symbol, w.date_start) AS symbol_display\n    FROM `dbt`.`tokens_whitelist` w\n    GROUP BY symbol_upper\n)\n\nSELECT\n    d.date,\n    coalesce(nullIf(w.symbol_display, ''), d.symbol) AS symbol,\n    d.price\nFROM deduplicated d\nLEFT JOIN whitelist_symbols w\n  ON upper(d.symbol) = w.symbol_upper\nORDER BY d.date, symbol", "relation_name": "`dbt`.`int_execution_token_prices_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.159800Z", "completed_at": "2026-02-12T22:49:49.164522Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.165097Z", "completed_at": "2026-02-12T22:49:49.165105Z"}], "thread_id": "Thread-1", "execution_time": 0.006585121154785156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_rwa_backedfi_prices_daily_date.99116a3e90", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_execution_rwa_backedfi_prices_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.167847Z", "completed_at": "2026-02-12T22:49:49.172714Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.173304Z", "completed_at": "2026-02-12T22:49:49.173312Z"}], "thread_id": "Thread-1", "execution_time": 0.006758213043212891, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_backers_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nbackers_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_backing`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_backing`)\n),\n\nbackers_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_backing`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_backing`), 7)\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM backers_latest t1\nCROSS JOIN backers_7d t2", "relation_name": "`dbt`.`api_execution_circles_backers_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.176088Z", "completed_at": "2026-02-12T22:49:49.180098Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.180711Z", "completed_at": "2026-02-12T22:49:49.180718Z"}], "thread_id": "Thread-1", "execution_time": 0.005930185317993164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_avatars", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,avatar_type\n    ,cnt\n    ,total\nFROM `dbt`.`fct_execution_circles_avatars`\nORDER BY date, avatar_type", "relation_name": "`dbt`.`api_execution_circles_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.183575Z", "completed_at": "2026-02-12T22:49:49.189853Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.190470Z", "completed_at": "2026-02-12T22:49:49.190478Z"}], "thread_id": "Thread-1", "execution_time": 0.008186817169189453, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_groups_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ngroups_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Group'\n),\n\ngroups_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Group'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM groups_latest t1\nCROSS JOIN groups_7d t2", "relation_name": "`dbt`.`api_execution_circles_groups_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.193179Z", "completed_at": "2026-02-12T22:49:49.197936Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.198544Z", "completed_at": "2026-02-12T22:49:49.198551Z"}], "thread_id": "Thread-1", "execution_time": 0.0066471099853515625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_humans_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nhumans_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Human'\n),\n\nhumans_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Human'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM humans_latest t1\nCROSS JOIN humans_7d t2", "relation_name": "`dbt`.`api_execution_circles_humans_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.201266Z", "completed_at": "2026-02-12T22:49:49.206028Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.206651Z", "completed_at": "2026-02-12T22:49:49.206659Z"}], "thread_id": "Thread-1", "execution_time": 0.006670713424682617, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_orgs_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\norgs_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Org'\n),\n\norgs_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Org'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM orgs_latest t1\nCROSS JOIN orgs_7d t2", "relation_name": "`dbt`.`api_execution_circles_orgs_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.209356Z", "completed_at": "2026-02-12T22:49:49.213954Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.214546Z", "completed_at": "2026-02-12T22:49:49.214553Z"}], "thread_id": "Thread-1", "execution_time": 0.00645899772644043, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_tokens_address_diffs_daily_date.42826529da", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_tokens_address_diffs_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.217203Z", "completed_at": "2026-02-12T22:49:49.221786Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.222359Z", "completed_at": "2026-02-12T22:49:49.222366Z"}], "thread_id": "Thread-1", "execution_time": 0.006503105163574219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_tokens_transfers_daily_date.f914da64d3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_tokens_transfers_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.225109Z", "completed_at": "2026-02-12T22:49:49.229052Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.229660Z", "completed_at": "2026-02-12T22:49:49.229667Z"}], "thread_id": "Thread-1", "execution_time": 0.005899190902709961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_crawlers_data_distinct_projects_sectors_totals", "compiled": true, "compiled_code": "\n\nSELECT\n  toFloat64(countDistinct(project)) AS value1,  \n  toFloat64(countDistinct(sector))  AS value2    \nFROM `dbt`.`fct_crawlers_data_distinct_projects_sectors`", "relation_name": "`dbt`.`api_crawlers_data_distinct_projects_sectors_totals`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.232480Z", "completed_at": "2026-02-12T22:49:49.238356Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.238956Z", "completed_at": "2026-02-12T22:49:49.238964Z"}], "thread_id": "Thread-1", "execution_time": 0.007853507995605469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_crawlers_data_distinct_projects_sectors_project.4a7e81c7b3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect project\nfrom `dbt`.`fct_crawlers_data_distinct_projects_sectors`\nwhere project is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.241727Z", "completed_at": "2026-02-12T22:49:49.246146Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.246734Z", "completed_at": "2026-02-12T22:49:49.246741Z"}], "thread_id": "Thread-1", "execution_time": 0.006387472152709961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_crawlers_data_distinct_projects_sectors_sector.d1a0f36858", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect sector\nfrom `dbt`.`fct_crawlers_data_distinct_projects_sectors`\nwhere sector is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.249488Z", "completed_at": "2026-02-12T22:49:49.253692Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.254292Z", "completed_at": "2026-02-12T22:49:49.254300Z"}], "thread_id": "Thread-1", "execution_time": 0.0061342716217041016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_gas_share_by_project_daily", "compiled": true, "compiled_code": "\n\nWITH tot AS (\n  SELECT\n    date,\n    SUM(gas_used_sum) AS day_gas_used\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  WHERE date < today()     \n  GROUP BY date\n)\nSELECT\n  p.date,\n  p.project AS label,\n  ROUND(p.gas_used_sum / NULLIF(t.day_gas_used, 0) * 100, 2) AS value\nFROM `dbt`.`int_execution_transactions_by_project_daily` p\nJOIN tot t USING (date)\nWHERE p.date < today()\nORDER BY p.date DESC, label", "relation_name": "`dbt`.`api_execution_transactions_gas_share_by_project_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.257173Z", "completed_at": "2026-02-12T22:49:49.264509Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.265125Z", "completed_at": "2026-02-12T22:49:49.265136Z"}], "thread_id": "Thread-1", "execution_time": 0.009428262710571289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_project_monthly_top5", "compiled": true, "compiled_code": "\n\n\n\n\nWITH base AS (\n  SELECT\n    toStartOfMonth(date)                    AS month,\n    project,\n    sum(tx_count)                           AS txs,\n    sum(fee_native_sum)                     AS fee_native,\n    sum(gas_used_sum)                       AS gas_used,\n    groupBitmapMergeState(ua_bitmap_state)  AS active_state\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  WHERE date < toStartOfMonth(today())\n  \n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -1))\n      FROM `dbt`.`fct_execution_transactions_by_project_monthly_top5` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(date) >= (\n      SELECT addDays(max(toDate(x2.date)), -1)\n      FROM `dbt`.`fct_execution_transactions_by_project_monthly_top5` AS x2\n      WHERE 1=1 \n    )\n  \n\n  \n  GROUP BY month, project\n),\nranked AS (\n  SELECT\n    month, project, txs, fee_native, gas_used, active_state,\n    row_number() OVER (PARTITION BY month ORDER BY txs DESC, fee_native DESC, project ASC) AS rk\n  FROM base\n),\nbucketed AS (\n  SELECT\n    month,\n    if(rk <= 5, project, 'Others') AS project_label,\n    txs, fee_native, gas_used, active_state\n  FROM ranked\n),\nmonthly AS (\n  SELECT\n    month,\n    project_label AS project,\n    sum(txs)                            AS txs,\n    sum(fee_native)                     AS fee_native,\n    sum(gas_used)                       AS gas_used,\n    groupBitmapMergeState(active_state) AS active_state\n  FROM bucketed\n  GROUP BY month, project_label\n)\n\nSELECT * FROM (\n  SELECT month AS date, project AS label, 'Transactions'  AS metric, toFloat64(txs)                  AS value FROM monthly\n  UNION ALL\n  SELECT month AS date, project AS label, 'FeesNative'    AS metric, round(toFloat64(fee_native), 6) AS value FROM monthly\n  UNION ALL\n  SELECT month AS date, project AS label, 'GasUsed'       AS metric, toFloat64(gas_used)             AS value FROM monthly\n  UNION ALL\n  SELECT\n    month AS date,\n    project AS label,\n    'ActiveAccounts' AS metric,\n    toFloat64(finalizeAggregation(active_state)) AS value\n  FROM monthly\n)\nORDER BY date ASC, label ASC, metric ASC", "relation_name": "`dbt`.`fct_execution_transactions_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.268196Z", "completed_at": "2026-02-12T22:49:49.274980Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.275608Z", "completed_at": "2026-02-12T22:49:49.275616Z"}], "thread_id": "Thread-1", "execution_time": 0.008901119232177734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_sector_daily", "compiled": true, "compiled_code": "\n\n\n\n\nWITH base AS (\n  SELECT *\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  WHERE 1=1\n  \n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -1))\n      FROM `dbt`.`fct_execution_transactions_by_sector_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(date) >= (\n      SELECT addDays(max(toDate(x2.date)), -1)\n      FROM `dbt`.`fct_execution_transactions_by_sector_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n  \n)\n\nSELECT\n    date,\n    sector,\n    groupBitmapMerge(ua_bitmap_state)        AS active_accounts,\n    sum(tx_count)                            AS txs,\n    sum(gas_used_sum)                        AS gas_used_sum,\n    round(toFloat64(sum(fee_native_sum)), 6) AS fee_native_sum\nFROM base\nGROUP BY date, sector", "relation_name": "`dbt`.`fct_execution_transactions_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.278556Z", "completed_at": "2026-02-12T22:49:49.286598Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.287205Z", "completed_at": "2026-02-12T22:49:49.287213Z"}], "thread_id": "Thread-1", "execution_time": 0.010189056396484375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_sector_weekly", "compiled": true, "compiled_code": "\n\n\n\n\nWITH base AS (\n  SELECT *\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  WHERE date < toStartOfWeek(today())\n  \n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.week)), -1))\n      FROM `dbt`.`fct_execution_transactions_by_sector_weekly` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(date) >= (\n      SELECT addDays(max(toDate(x2.week)), -1)\n      FROM `dbt`.`fct_execution_transactions_by_sector_weekly` AS x2\n      WHERE 1=1 \n    )\n  \n\n  \n)\n\nSELECT\n  toStartOfWeek(date)                          AS week,\n  sector,\n  toUInt64(groupBitmapMerge(ua_bitmap_state))  AS active_accounts,  \n  sum(tx_count)                                AS txs,\n  sum(gas_used_sum)                            AS gas_used_sum,\n  round(toFloat64(sum(fee_native_sum)), 2)     AS fee_native_sum\nFROM base\nGROUP BY week, sector", "relation_name": "`dbt`.`fct_execution_transactions_by_sector_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.290124Z", "completed_at": "2026-02-12T22:49:49.296745Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.297345Z", "completed_at": "2026-02-12T22:49:49.297353Z"}], "thread_id": "Thread-1", "execution_time": 0.008610248565673828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_by_project_alltime_state", "compiled": true, "compiled_code": "\n\n\n\n\nWITH src AS (\n  SELECT\n    toStartOfMonth(date)                   AS month,\n    project,\n    sumState(tx_count)                     AS txs_state,\n    sumState(fee_native_sum)               AS fee_state,\n    groupBitmapMergeState(ua_bitmap_state) AS aa_state\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  WHERE 1=1\n    \n      \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.month)), -0))\n      FROM `dbt`.`int_execution_transactions_by_project_alltime_state` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(date) >= (\n      SELECT addDays(max(toDate(x2.month)), -0)\n      FROM `dbt`.`int_execution_transactions_by_project_alltime_state` AS x2\n      WHERE 1=1 \n    )\n  \n\n    \n  GROUP BY month, project\n)\n\nSELECT project, month, txs_state, fee_state, aa_state\nFROM src", "relation_name": "`dbt`.`int_execution_transactions_by_project_alltime_state`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.300270Z", "completed_at": "2026-02-12T22:49:49.304159Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.304770Z", "completed_at": "2026-02-12T22:49:49.304777Z"}], "thread_id": "Thread-1", "execution_time": 0.0058248043060302734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_sector_hourly", "compiled": true, "compiled_code": "\n\nSELECT\n  hour AS date,\n  sector AS label,\n  groupBitmapMerge(ua_bitmap_state) AS value\nFROM `dbt`.`int_execution_transactions_by_project_hourly_recent`\nGROUP BY date, label\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_sector_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.307583Z", "completed_at": "2026-02-12T22:49:49.311472Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.312066Z", "completed_at": "2026-02-12T22:49:49.312074Z"}], "thread_id": "Thread-1", "execution_time": 0.005789756774902344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_sector_hourly", "compiled": true, "compiled_code": "\n\nSELECT\n  hour AS date,\n  sector AS label,\n  sum(tx_count) AS value\nFROM `dbt`.`int_execution_transactions_by_project_hourly_recent`\nGROUP BY date, label\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_sector_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.314886Z", "completed_at": "2026-02-12T22:49:49.318807Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.319400Z", "completed_at": "2026-02-12T22:49:49.319424Z"}], "thread_id": "Thread-1", "execution_time": 0.005824565887451172, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_sector_hourly", "compiled": true, "compiled_code": "\n\nSELECT\n  hour AS date,\n  sector AS label,\n  round(toFloat64(sum(fee_native_sum)), 2) AS value\nFROM `dbt`.`int_execution_transactions_by_project_hourly_recent`\nGROUP BY date, label\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_sector_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.322168Z", "completed_at": "2026-02-12T22:49:49.326716Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.327283Z", "completed_at": "2026-02-12T22:49:49.327291Z"}], "thread_id": "Thread-1", "execution_time": 0.0063741207122802734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_esg_node_client_distribution_date.7f21d27537", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_esg_node_client_distribution`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.330033Z", "completed_at": "2026-02-12T22:49:49.339539Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.340153Z", "completed_at": "2026-02-12T22:49:49.340161Z"}], "thread_id": "Thread-1", "execution_time": 0.011422395706176758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_dynamic_power_consumption", "compiled": true, "compiled_code": "\n\nWITH node_distribution AS (\n    SELECT\n        date,\n        node_category,\n        country_code,\n        country_name,\n        region,\n        sub_region,\n        country_code_alpha3,\n        estimated_total_nodes,  \n        nodes_lower_95,           \n        nodes_upper_95          \n    FROM `dbt`.`int_esg_node_geographic_distribution` n\n    \n        WHERE n.date > (SELECT MAX(date) FROM `dbt`.`int_esg_dynamic_power_consumption`)\n    \n),\n\n-- Get client efficiency from upstream client distribution model\nclient_efficiency_by_category AS (\n    SELECT\n        date,\n        node_category,\n        \n        -- Weighted average client efficiency for this category\n        SUM(category_client_percentage / 100.0 * client_efficiency_factor) AS avg_client_efficiency,\n        \n        -- Client diversity count for resilience bonus\n        COUNT(DISTINCT client_type) AS client_diversity,\n        \n        -- Total estimated client nodes for validation\n        SUM(estimated_client_nodes) AS total_client_nodes,\n        \n        -- Client breakdown for diagnostics\n        groupArray((client_type, category_client_percentage, estimated_client_nodes)) AS client_breakdown\n        \n    FROM `dbt`.`int_esg_node_client_distribution` ncd\n    \n        WHERE ncd.date > (SELECT MAX(date) FROM `dbt`.`int_esg_dynamic_power_consumption`) - INTERVAL 1 DAY\n    \n    GROUP BY date, node_category\n),\n\n-- Base power calculations by hardware tier with CCRI empirical values\npower_per_category AS (\n    SELECT\n        nd.date,\n        nd.node_category,\n        nd.country_code,\n        nd.country_name,\n        nd.region,\n        nd.sub_region,\n        nd.country_code_alpha3,\n        nd.estimated_total_nodes,\n        nd.nodes_lower_95,\n        nd.nodes_upper_95,\n        \n        -- CCRI empirical power consumption (Watts per node)\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 22.0        -- CCRI Tier 4: mean of 16.56-25.97W\n            WHEN 'professional_operator' THEN 48.0  -- CCRI Tier 5: mean of 36.82-59.95W\n            WHEN 'cloud_hosted' THEN 155.0      -- CCRI Tier 6: mean of 139.90-186.76W\n            ELSE 50.0\n        END AS base_power_watts,\n        \n        -- Standard deviation based on CCRI measurement ranges\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 3.3        -- ~15% of 22W (conservative uncertainty)\n            WHEN 'professional_operator' THEN 7.2  -- ~15% of 48W\n            WHEN 'cloud_hosted' THEN 23.0       -- ~15% of 155W\n            ELSE 7.5\n        END AS power_std_watts,\n        \n        -- Data source for traceability\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 'CCRI_Tier4_Empirical'\n            WHEN 'professional_operator' THEN 'CCRI_Tier5_Empirical'\n            WHEN 'cloud_hosted' THEN 'CCRI_Tier6_Empirical'\n            ELSE 'CCRI_Default'\n        END AS power_source,\n        \n        -- Measurement confidence (CCRI empirical data is high quality)\n        0.85 AS measurement_confidence,\n        \n        -- PUE by category  \n        CASE nd.node_category\n            WHEN 'home_staker' THEN 1.0         -- No datacenter overhead\n            WHEN 'professional_operator' THEN 1.58  -- Traditional datacenter\n            WHEN 'cloud_hosted' THEN 1.15       -- Efficient cloud datacenter\n            ELSE 1.1\n        END AS pue_factor,\n        \n        -- Client efficiency from upstream model\n        COALESCE(ce.avg_client_efficiency, 1.0) AS client_efficiency_multiplier,\n        \n        -- Diversity bonus (more client types = better resilience)\n        CASE \n            WHEN ce.client_diversity > 0 THEN 0.95 + 0.05 * least(4, ce.client_diversity) / 4.0\n            ELSE 1.0\n        END AS diversity_bonus,\n        \n        ce.client_breakdown,\n        ce.total_client_nodes\n        \n    FROM node_distribution nd\n    LEFT JOIN client_efficiency_by_category ce ON nd.date = ce.date AND nd.node_category = ce.node_category\n),\n\n-- Apply all efficiency factors\nfinal_power_calculations AS (\n    SELECT\n        p.*,\n        \n        -- Final power per node with all efficiency factors\n        p.base_power_watts * p.client_efficiency_multiplier * p.diversity_bonus AS avg_power_watts_per_node,\n        p.power_std_watts * p.client_efficiency_multiplier * p.diversity_bonus AS power_std_dev_per_node,\n        \n        -- Daily energy consumption (kWh)\n        p.estimated_total_nodes * \n        p.base_power_watts * \n        p.client_efficiency_multiplier * \n        p.diversity_bonus * \n        24.0 / 1000.0 AS daily_energy_kwh_mean\n\n    FROM power_per_category p\n),\n\n-- Carbon intensity lookup with robust fallback\ncarbon_intensity_lookup AS (\n    SELECT DISTINCT\n        p.date,\n        p.country_code_alpha3,\n        \n        -- Robust fallback hierarchy\n        COALESCE(\n            ci_country.carbon_intensity_mean,\n            ci_world.carbon_intensity_mean,\n            450.0\n        ) AS carbon_intensity_gco2_kwh,\n        \n        COALESCE(\n            ci_country.carbon_intensity_std,\n            ci_world.carbon_intensity_std, \n            45.0\n        ) AS carbon_intensity_std_gco2_kwh,\n        \n        CASE \n            WHEN ci_country.carbon_intensity_mean IS NOT NULL THEN 'country_specific'\n            WHEN ci_world.carbon_intensity_mean IS NOT NULL THEN 'world_average'\n            ELSE 'conservative_default'\n        END AS carbon_intensity_source\n        \n    FROM final_power_calculations p\n    LEFT JOIN `dbt`.`int_esg_carbon_intensity_ensemble` ci_country\n        ON p.country_code_alpha3 = ci_country.country_code\n        AND ci_country.month_date = toStartOfMonth(p.date)\n        AND p.country_code_alpha3 IS NOT NULL\n        AND p.country_code_alpha3 != ''\n    LEFT JOIN `dbt`.`int_esg_carbon_intensity_ensemble` ci_world\n        ON ci_world.country_code = 'WORLD'\n        AND ci_world.month_date = toStartOfMonth(p.date)\n    WHERE ci_country.month_date != DATE '1970-01-01' OR ci_world.month_date != DATE '1970-01-01' -- nu;;s ghet repl;ace by date...\n),\n\n-- Final calculations with carbon emissions\nfinal_calculations AS (\n    SELECT\n        p.date AS date,\n        p.node_category AS node_category,\n        p.country_code AS country_code,\n        p.country_code_alpha3 AS country_code_alpha3,\n        p.country_name AS country_name,\n        p.region AS region,\n        p.sub_region AS sub_region,\n        p.estimated_total_nodes AS estimated_total_nodes,\n        p.nodes_lower_95 AS nodes_lower_95,\n        p.nodes_upper_95 AS nodes_upper_95,\n        p.avg_power_watts_per_node AS avg_power_watts_per_node,\n        p.power_std_dev_per_node AS power_std_dev_per_node,\n        p.daily_energy_kwh_mean AS daily_energy_kwh_mean,\n        p.pue_factor AS pue_factor,\n        p.client_efficiency_multiplier AS client_efficiency,\n        p.diversity_bonus,\n        \n        -- CCRI source tracking\n        p.power_source,\n        p.measurement_confidence,\n        p.base_power_watts AS ccri_base_power_watts,\n        \n        -- Carbon intensity from lookup\n        ci.carbon_intensity_gco2_kwh,\n        ci.carbon_intensity_std_gco2_kwh,\n        ci.carbon_intensity_source,\n        \n        -- CO2 calculations\n        p.daily_energy_kwh_mean * p.pue_factor * ci.carbon_intensity_gco2_kwh / 1000.0 AS daily_co2_kg_mean,\n        \n        -- CO2 standard deviation\n        sqrt(\n            pow(p.daily_energy_kwh_mean * p.pue_factor * ci.carbon_intensity_std_gco2_kwh / 1000.0, 2) +\n            pow(p.power_std_dev_per_node * 24 / 1000.0 * p.pue_factor * ci.carbon_intensity_gco2_kwh / 1000.0, 2)\n        ) AS daily_co2_kg_std,\n        \n        -- Diagnostics\n        p.client_breakdown,\n        p.total_client_nodes\n        \n    FROM final_power_calculations p\n    INNER JOIN carbon_intensity_lookup ci\n        ON p.date = ci.date\n        AND COALESCE(p.country_code_alpha3, '') = COALESCE(ci.country_code_alpha3, '')\n)\n\nSELECT\n    date,\n    node_category,\n    country_code,\n    country_name,\n    region,\n    estimated_total_nodes,\n    nodes_lower_95,\n    nodes_upper_95,\n    \n    -- Power consumption metrics\n    round(avg_power_watts_per_node, 2) AS avg_power_watts_per_node,\n    round(power_std_dev_per_node, 2) AS power_std_dev_per_node,\n    round(daily_energy_kwh_mean, 2) AS daily_energy_kwh_mean,\n    round(pue_factor, 3) AS pue_mean,\n    round(client_efficiency, 3) AS client_efficiency_factor,\n    round(diversity_bonus, 3) AS diversity_bonus,\n    \n    -- Carbon emissions\n    round(daily_co2_kg_mean, 4) AS daily_co2_kg_mean,\n    round(daily_co2_kg_std, 4) AS daily_co2_kg_std,\n    round(carbon_intensity_gco2_kwh, 2) AS carbon_intensity_gco2_kwh,\n    round(carbon_intensity_std_gco2_kwh, 2) AS carbon_intensity_std_gco2_kwh,\n    \n    -- Confidence intervals\n    round(greatest(0, daily_co2_kg_mean - 1.96 * daily_co2_kg_std), 4) AS daily_co2_kg_lower_95,\n    round(daily_co2_kg_mean + 1.96 * daily_co2_kg_std, 4) AS daily_co2_kg_upper_95,\n    \n    -- CCRI data quality and source tracking\n    carbon_intensity_source,\n    round(ccri_base_power_watts, 2) AS ccri_base_power_watts,\n    power_source,\n    round(measurement_confidence, 3) AS measurement_confidence,\n    \n    -- Performance comparison with previous estimates\n    round(\n        100.0 * (avg_power_watts_per_node - CASE node_category\n            WHEN 'home_staker' THEN 75.0\n            WHEN 'professional_operator' THEN 200.0  \n            WHEN 'cloud_hosted' THEN 110.0\n            ELSE 100.0\n        END) / CASE node_category\n            WHEN 'home_staker' THEN 75.0\n            WHEN 'professional_operator' THEN 200.0\n            WHEN 'cloud_hosted' THEN 110.0  \n            ELSE 100.0\n        END, 1\n    ) AS power_reduction_vs_previous_pct,\n    \n    -- Diagnostics\n    toJSONString(client_breakdown) AS client_breakdown_json,\n    total_client_nodes AS debug_total_clients,\n    \n    -- Metadata\n    now() AS calculated_at\n\nFROM final_calculations\nWHERE estimated_total_nodes > 0", "relation_name": "`dbt`.`int_esg_dynamic_power_consumption`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.342913Z", "completed_at": "2026-02-12T22:49:49.347550Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.348123Z", "completed_at": "2026-02-12T22:49:49.348130Z"}], "thread_id": "Thread-1", "execution_time": 0.006562232971191406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_esg_node_geographic_distribution_date.d2db5e6651", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_esg_node_geographic_distribution`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.350816Z", "completed_at": "2026-02-12T22:49:49.355216Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.355797Z", "completed_at": "2026-02-12T22:49:49.355804Z"}], "thread_id": "Thread-1", "execution_time": 0.006242990493774414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_p2p_topology_latest_date.dd73c240aa", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_p2p_topology_latest`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.358551Z", "completed_at": "2026-02-12T22:49:49.368365Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.368998Z", "completed_at": "2026-02-12T22:49:49.369006Z"}], "thread_id": "Thread-1", "execution_time": 0.011828899383544922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transfers_whitelisted_raw", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\nWITH tokens AS (\n    SELECT\n        lower(address)                           AS token_address,\n        lower(replaceAll(address, '0x', ''))     AS token_address_raw,\n        decimals,\n        symbol,\n        upper(symbol)                            AS symbol_upper,\n        date_start,\n        date_end\n    FROM `dbt`.`tokens_whitelist`\n),\n\ndeduped_logs AS (\n    SELECT\n        block_number,\n        transaction_index,\n        log_index,\n        CONCAT('0x', transaction_hash) AS transaction_hash,\n        CONCAT('0x', address) AS address,\n        topic1,\n        topic2,\n        data,\n        block_timestamp\n    FROM (\n        \n\nSELECT block_number, transaction_index, log_index, transaction_hash, address, topic1, topic2, data, block_timestamp\nFROM (\n    SELECT\n        block_number, transaction_index, log_index, transaction_hash, address, topic1, topic2, data, block_timestamp,\n        ROW_NUMBER() OVER (\n            PARTITION BY block_number, transaction_index, log_index\n            ORDER BY insert_version DESC\n        ) AS _dedup_rn\n    FROM `execution`.`logs`\n    \n    WHERE \n    topic0 = 'ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n    AND block_timestamp < today()\n    \n      \n  \n\n    \n    \n\n    \n)\nWHERE _dedup_rn = 1\n\n    )\n),\n\nraw_whitelisted_logs AS (\n    SELECT\n        l.block_number,\n        l.block_timestamp,\n        l.transaction_index,\n        l.log_index,\n        lower(l.transaction_hash) AS transaction_hash,\n        t.token_address,\n        t.symbol,\n        t.symbol_upper,\n        t.decimals,\n        t.date_start,\n        t.date_end,\n        lower(concat('0x', substring(l.topic1, 25, 40))) AS \"from\",\n        lower(concat('0x', substring(l.topic2, 25, 40))) AS \"to\",\n        toString(\n            reinterpretAsUInt256(\n                reverse(unhex(replaceAll(l.data, '0x', '')))\n            )\n        ) AS value_raw\n    FROM deduped_logs AS l\n    INNER JOIN tokens t\n        ON lower(l.address) = t.token_address\n       AND toDate(l.block_timestamp) >= t.date_start\n       AND (t.date_end IS NULL OR toDate(l.block_timestamp) < t.date_end)\n),\n\nprices_rwa AS (\n    SELECT\n        toDate(date)             AS date,\n        upper(bticker)           AS symbol_upper,\n        price\n    FROM `dbt`.`api_execution_rwa_backedfi_prices_daily`\n),\n\nprices_dune_raw AS (\n    SELECT\n        date,\n        upper(symbol)            AS symbol_upper,\n        price\n    FROM `dbt`.`stg_crawlers_data__dune_prices`\n),\n\nprices_dune AS (\n    SELECT date, symbol_upper, price\n    FROM prices_dune_raw\n    UNION ALL\n    SELECT date, 'WXDAI' AS symbol_upper, price\n    FROM prices_dune_raw\n    WHERE symbol_upper = 'XDAI'\n),\n\nprices AS (\n    SELECT date, symbol_upper, price FROM prices_rwa\n    UNION ALL\n    SELECT date, symbol_upper, price FROM prices_dune\n),\n\nenriched AS (\n    SELECT\n        r.block_number,\n        r.block_timestamp,\n        r.transaction_index,\n        r.log_index,\n        r.transaction_hash,\n        r.\"from\",\n        r.\"to\",\n        r.token_address,\n        r.symbol,\n        r.symbol_upper,\n        r.decimals,\n        r.value_raw,\n        r.date_start,\n        r.date_end,\n        toFloat64OrZero(r.value_raw) / pow(10, r.decimals) AS amount,\n        coalesce(\n            p.price,\n            case\n              when r.symbol_upper IN ('USDC','USDC.E','USDT') then 1.0\n              when r.symbol_upper = 'WXDAI'                   then 1.0   \n              else null\n            end\n        ) AS price\n    FROM raw_whitelisted_logs r\n    LEFT JOIN prices p\n      ON p.date = toDate(r.block_timestamp)\n     AND p.symbol_upper = r.symbol_upper\n)\n\nSELECT\n    block_number,\n    block_timestamp,\n    transaction_index,\n    log_index,\n    transaction_hash,\n    \"from\",\n    \"to\",\n    token_address,\n    symbol,\n    decimals,\n    amount,\n    price,\n    amount * price AS amount_usd,\n    value_raw\nFROM enriched", "relation_name": "`dbt`.`int_execution_transfers_whitelisted_raw`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.371797Z", "completed_at": "2026-02-12T22:49:49.376238Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.376822Z", "completed_at": "2026-02-12T22:49:49.376830Z"}], "thread_id": "Thread-1", "execution_time": 0.006311178207397461, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_rwa_backedfi_prices_daily_date.1d033684e5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_rwa_backedfi_prices_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.379752Z", "completed_at": "2026-02-12T22:49:49.398787Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.399482Z", "completed_at": "2026-02-12T22:49:49.399490Z"}], "thread_id": "Thread-1", "execution_time": 0.021198272705078125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_tokens_balances_daily", "compiled": true, "compiled_code": "\n\n-- depends_on: `dbt`.`int_execution_tokens_address_diffs_daily`\n\n\n\n\n\n\n\n\nWITH deltas AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        address,\n        net_delta_raw\n    FROM `dbt`.`int_execution_tokens_address_diffs_daily`\n    WHERE date < today()\n      \n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -1))\n      FROM `dbt`.`int_execution_tokens_balances_daily` AS x1\n      WHERE 1=1 \n  \n  \n\n  \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n\n    )\n    AND toDate(date) >= (\n      SELECT addDays(max(toDate(x2.date)), -1)\n      FROM `dbt`.`int_execution_tokens_balances_daily` AS x2\n      WHERE 1=1 \n  \n  \n\n  \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n\n    )\n  \n\n      \n      \n  \n\n      \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n\n),\n\noverall_max_date AS (\n    SELECT\n        least(\n            \n                today(),\n            \n            yesterday(),\n            (\n                SELECT max(toDate(date))\n                FROM `dbt`.`int_execution_tokens_address_diffs_daily`\n                \n            )\n        ) AS max_date\n),\n\n\ncurrent_partition AS (\n    SELECT \n        max(toStartOfMonth(date)) AS month\n        ,max(date)  AS max_date\n    FROM `dbt`.`int_execution_tokens_balances_daily`\n    WHERE date < yesterday()\n      \n  \n\n      \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n),\nprev_balances AS (\n    SELECT \n        t1.token_address,\n        t1.symbol,\n        t1.token_class,\n        t1.address,\n        t1.balance_raw\n    FROM `dbt`.`int_execution_tokens_balances_daily` t1\n    CROSS JOIN current_partition t2\n    WHERE \n        t1.date = t2.max_date\n        \n  \n\n        \n  \n    \n    \n      AND t1.symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n),\n\nkeys AS (\n    SELECT DISTINCT \n        token_address,\n        symbol,\n        token_class,\n        address\n    FROM (\n        SELECT\n            token_address,\n            symbol,\n            token_class,\n            address\n        FROM prev_balances\n\n        UNION ALL\n\n        SELECT\n            token_address,\n            symbol,\n            token_class,\n            address\n        FROM deltas\n    )\n),\n\ncalendar AS (\n    SELECT\n        k.token_address,\n        k.symbol,\n        k.token_class,\n        k.address,\n        addDays(cp.max_date + 1, offset) AS date\n    FROM keys k\n    CROSS JOIN current_partition cp\n    CROSS JOIN overall_max_date o\n    ARRAY JOIN range(\n        dateDiff('day', cp.max_date, o.max_date)\n    ) AS offset\n),\n\n\n\n\nbalances AS (\n    SELECT\n        c.date AS date,\n        c.token_address AS token_address,\n        c.symbol AS symbol,\n        c.token_class AS token_class,\n        c.address AS address,\n\n        sum(COALESCE(d.net_delta_raw,toInt256(0))) OVER (\n            PARTITION BY c.token_address, c.address\n            ORDER BY c.date\n            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        )\n        \n            + coalesce(p.balance_raw, toInt256(0)) \n        \n        AS balance_raw\n    FROM calendar c\n    LEFT JOIN deltas d\n      ON d.token_address = c.token_address\n     AND d.address       = c.address\n     AND d.date          = c.date\n    \n    LEFT JOIN prev_balances p\n      ON p.token_address = c.token_address\n     AND p.address       = c.address\n    \n),\n\nprices AS (\n    SELECT\n        p.date,\n        p.symbol,\n        p.price\n    FROM `dbt`.`int_execution_token_prices_daily` p\n    WHERE date < today()\n      \n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -1))\n      FROM `dbt`.`int_execution_tokens_balances_daily` AS x1\n      WHERE 1=1 \n  \n  \n\n  \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n\n    )\n    AND toDate(date) >= (\n      SELECT addDays(max(toDate(x2.date)), -1)\n      FROM `dbt`.`int_execution_tokens_balances_daily` AS x2\n      WHERE 1=1 \n  \n  \n\n  \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n\n    )\n  \n\n      \n      \n  \n\n      \n  \n    \n    \n      AND symbol NOT IN (\n        \n          'aGnoGNO', \n        \n          'aGnoWXDAI', \n        \n          'aGnosDAI', \n        \n          'aGnoUSDC', \n        \n          'spGNO', \n        \n          'spUSDT', \n        \n          'spUSDC', \n        \n          'spUSDC.e'\n        \n      )\n    \n  \n\n),\n\nfinal AS (\n    SELECT\n        b.date AS date,\n        b.token_address AS token_address,\n        b.symbol AS symbol,\n        b.token_class AS token_class,\n        b.address AS address,\n        b.balance_raw AS balance_raw,\n        b.balance_raw/POWER(10, t.decimals) AS balance,\n        (b.balance_raw/POWER(10, t.decimals)) * p.price AS balance_usd\n    FROM balances b\n    INNER JOIN `dbt`.`tokens_whitelist` t\n      ON lower(t.address) = b.token_address\n     AND b.date >= toDate(t.date_start)\n     AND (t.date_end IS NULL OR b.date < toDate(t.date_end))\n    LEFT JOIN prices p\n      ON p.date = b.date\n     AND upper(p.symbol) = upper(b.symbol)\n    WHERE b.balance_raw != 0\n)\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n    address,\n    balance_raw,\n    balance,\n    balance_usd\nFROM final", "relation_name": "`dbt`.`int_execution_tokens_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.402291Z", "completed_at": "2026-02-12T22:49:49.422633Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.423198Z", "completed_at": "2026-02-12T22:49:49.423208Z"}], "thread_id": "Thread-1", "execution_time": 0.02226877212524414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_yields_pools_fees_daily", "compiled": true, "compiled_code": "\n\n\nWITH\nconstants AS (\n    SELECT\n        toUInt256('57896044618658097711785492504343953926634992332820282019728792003956564819967') AS max_int256,\n        toUInt256('115792089237316195423570985008687907853269984665640564039457584007913129639936') AS two_256,\n        toUInt64(4294967296) AS log_index_factor, -- 2^32\n        toUInt64(1000000) AS fee_denom\n),\n\ntoken_meta AS (\n    SELECT\n        lower(address) AS token_address,\n        nullIf(upper(trimBoth(symbol)), '') AS token,\n        decimals,\n        date_start,\n        date_end\n    FROM `dbt`.`tokens_whitelist`\n),\n\nprices AS (\n    SELECT\n        toDate(date) AS date,\n        nullIf(upper(trimBoth(symbol)), '') AS token,\n        toFloat64(price) AS price_usd\n    FROM `dbt`.`int_execution_token_prices_daily`\n    WHERE date < today()\n      \n        \n  \n\n      \n),\n\n/* -----------------------------\n   Uniswap V3: pool meta + fee tier\n------------------------------ */\nuniswap_v3_pools AS (\n    SELECT DISTINCT\n        replaceAll(lower(decoded_params['pool']), '0x', '') AS pool_address_no0x,\n        lower(decoded_params['token0']) AS token0_address,\n        lower(decoded_params['token1']) AS token1_address,\n        toUInt32OrNull(decoded_params['fee']) AS fee_ppm\n    FROM `dbt`.`contracts_UniswapV3_Factory_events`\n    WHERE event_name = 'PoolCreated'\n      AND decoded_params['pool'] IS NOT NULL\n      AND decoded_params['token0'] IS NOT NULL\n      AND decoded_params['token1'] IS NOT NULL\n      AND decoded_params['fee'] IS NOT NULL\n),\n\nuniswap_v3_swaps_raw AS (\n    SELECT\n        toDate(toStartOfDay(e.block_timestamp)) AS date,\n        replaceAll(lower(e.contract_address), '0x', '') AS pool_address_no0x,\n        e.block_timestamp,\n        e.log_index,\n        (toUInt64(toUnixTimestamp(e.block_timestamp)) * (SELECT log_index_factor FROM constants) + toUInt64(e.log_index)) AS event_order,\n        toUInt256OrNull(e.decoded_params['amount0']) AS amount0_u,\n        toUInt256OrNull(e.decoded_params['amount1']) AS amount1_u\n    FROM `dbt`.`contracts_UniswapV3_Pool_events` e\n    WHERE e.event_name = 'Swap'\n      AND e.block_timestamp < today()\n      AND e.decoded_params['amount0'] IS NOT NULL\n      AND e.decoded_params['amount1'] IS NOT NULL\n      \n        \n  \n\n      \n),\n\nuniswap_v3_swaps AS (\n    SELECT\n        s.date,\n        s.pool_address_no0x,\n        if(\n            s.amount0_u > (SELECT max_int256 FROM constants),\n            -toInt256((SELECT two_256 FROM constants) - s.amount0_u),\n            toInt256(s.amount0_u)\n        ) AS amount0,\n        if(\n            s.amount1_u > (SELECT max_int256 FROM constants),\n            -toInt256((SELECT two_256 FROM constants) - s.amount1_u),\n            toInt256(s.amount1_u)\n        ) AS amount1,\n        p.fee_ppm AS fee_ppm\n    FROM uniswap_v3_swaps_raw s\n    INNER JOIN uniswap_v3_pools p\n        ON p.pool_address_no0x = s.pool_address_no0x\n    WHERE s.amount0_u IS NOT NULL\n      AND s.amount1_u IS NOT NULL\n      AND p.fee_ppm IS NOT NULL\n),\n\nuniswap_v3_swap_fees_token AS (\n    SELECT\n        date,\n        'Uniswap V3' AS protocol,\n        pool_address_no0x,\n        'token0' AS token_position,\n        toUInt256(intDiv(greatest(amount0, toInt256(0)) * toInt256(fee_ppm), toInt256((SELECT fee_denom FROM constants)))) AS fee_raw\n    FROM uniswap_v3_swaps\n\n    UNION ALL\n\n    SELECT\n        date,\n        'Uniswap V3' AS protocol,\n        pool_address_no0x,\n        'token1' AS token_position,\n        toUInt256(intDiv(greatest(amount1, toInt256(0)) * toInt256(fee_ppm), toInt256((SELECT fee_denom FROM constants)))) AS fee_raw\n    FROM uniswap_v3_swaps\n),\n\nuniswap_v3_flash_fees_token AS (\n    SELECT\n        toDate(toStartOfDay(e.block_timestamp)) AS date,\n        'Uniswap V3' AS protocol,\n        replaceAll(lower(e.contract_address), '0x', '') AS pool_address_no0x,\n        'token0' AS token_position,\n        toUInt256(\n            toUInt256OrNull(e.decoded_params['paid0']) - toUInt256OrNull(e.decoded_params['amount0'])\n        ) AS fee_raw\n    FROM `dbt`.`contracts_UniswapV3_Pool_events` e\n    WHERE e.event_name = 'Flash'\n      AND e.block_timestamp < today()\n      AND e.decoded_params['paid0'] IS NOT NULL\n      AND e.decoded_params['amount0'] IS NOT NULL\n      \n        \n  \n\n      \n\n    UNION ALL\n\n    SELECT\n        toDate(toStartOfDay(e.block_timestamp)) AS date,\n        'Uniswap V3' AS protocol,\n        replaceAll(lower(e.contract_address), '0x', '') AS pool_address_no0x,\n        'token1' AS token_position,\n        toUInt256(\n            toUInt256OrNull(e.decoded_params['paid1']) - toUInt256OrNull(e.decoded_params['amount1'])\n        ) AS fee_raw\n    FROM `dbt`.`contracts_UniswapV3_Pool_events` e\n    WHERE e.event_name = 'Flash'\n      AND e.block_timestamp < today()\n      AND e.decoded_params['paid1'] IS NOT NULL\n      AND e.decoded_params['amount1'] IS NOT NULL\n      \n        \n  \n\n      \n),\n\nuniswap_v3_fees_token AS (\n    SELECT * FROM uniswap_v3_swap_fees_token\n    UNION ALL\n    SELECT * FROM uniswap_v3_flash_fees_token\n),\n\n/* -----------------------------\n   Swapr V3 (Algebra): pool meta + dynamic fee schedule\n------------------------------ */\nswapr_v3_pools AS (\n    SELECT DISTINCT\n        replaceAll(lower(decoded_params['pool']), '0x', '') AS pool_address_no0x,\n        lower(decoded_params['token0']) AS token0_address,\n        lower(decoded_params['token1']) AS token1_address\n    FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_events`\n    WHERE event_name = 'Pool'\n      AND decoded_params['pool'] IS NOT NULL\n      AND decoded_params['token0'] IS NOT NULL\n      AND decoded_params['token1'] IS NOT NULL\n),\n\nswapr_v3_fee_events AS (\n    SELECT\n        replaceAll(lower(e.contract_address), '0x', '') AS pool_address_no0x,\n        e.block_timestamp,\n        e.log_index,\n        (toUInt64(toUnixTimestamp(e.block_timestamp)) * (SELECT log_index_factor FROM constants) + toUInt64(e.log_index)) AS event_order,\n        toUInt32OrNull(e.decoded_params['fee']) AS fee_ppm\n    FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_events` e\n    WHERE e.event_name = 'Fee'\n      AND e.block_timestamp < today()\n      AND e.decoded_params['fee'] IS NOT NULL\n      \n        \n  \n\n      \n),\n\nswapr_v3_first_fee AS (\n    SELECT\n        pool_address_no0x,\n        argMin(fee_ppm, event_order) AS first_fee_ppm\n    FROM swapr_v3_fee_events\n    WHERE fee_ppm IS NOT NULL\n    GROUP BY pool_address_no0x\n),\n\nswapr_v3_swaps_raw AS (\n    SELECT\n        toDate(toStartOfDay(e.block_timestamp)) AS date,\n        replaceAll(lower(e.contract_address), '0x', '') AS pool_address_no0x,\n        e.block_timestamp,\n        e.log_index,\n        (toUInt64(toUnixTimestamp(e.block_timestamp)) * (SELECT log_index_factor FROM constants) + toUInt64(e.log_index)) AS event_order,\n        toUInt256OrNull(e.decoded_params['amount0']) AS amount0_u,\n        toUInt256OrNull(e.decoded_params['amount1']) AS amount1_u\n    FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_events` e\n    WHERE e.event_name = 'Swap'\n      AND e.block_timestamp < today()\n      AND e.decoded_params['amount0'] IS NOT NULL\n      AND e.decoded_params['amount1'] IS NOT NULL\n      \n        \n  \n\n      \n),\n\nswapr_v3_swaps_with_fee AS (\n    SELECT\n        s.date,\n        s.pool_address_no0x,\n        if(\n            s.amount0_u > (SELECT max_int256 FROM constants),\n            -toInt256((SELECT two_256 FROM constants) - s.amount0_u),\n            toInt256(s.amount0_u)\n        ) AS amount0,\n        if(\n            s.amount1_u > (SELECT max_int256 FROM constants),\n            -toInt256((SELECT two_256 FROM constants) - s.amount1_u),\n            toInt256(s.amount1_u)\n        ) AS amount1,\n        coalesce(f.fee_ppm, ff.first_fee_ppm) AS fee_ppm\n    FROM (\n        SELECT * FROM swapr_v3_swaps_raw\n        ORDER BY pool_address_no0x, event_order\n    ) s\n    ASOF LEFT JOIN (\n        SELECT * FROM swapr_v3_fee_events\n        ORDER BY pool_address_no0x, event_order\n    ) f\n      ON s.pool_address_no0x = f.pool_address_no0x\n     AND s.event_order >= f.event_order\n    LEFT JOIN swapr_v3_first_fee ff\n      ON ff.pool_address_no0x = s.pool_address_no0x\n    WHERE coalesce(f.fee_ppm, ff.first_fee_ppm) IS NOT NULL\n),\n\nswapr_v3_swap_fees_token AS (\n    SELECT\n        date,\n        'Swapr V3' AS protocol,\n        s.pool_address_no0x,\n        'token0' AS token_position,\n        toUInt256(intDiv(greatest(amount0, toInt256(0)) * toInt256(fee_ppm), toInt256((SELECT fee_denom FROM constants)))) AS fee_raw\n    FROM swapr_v3_swaps_with_fee s\n\n    UNION ALL\n\n    SELECT\n        date,\n        'Swapr V3' AS protocol,\n        s.pool_address_no0x,\n        'token1' AS token_position,\n        toUInt256(intDiv(greatest(amount1, toInt256(0)) * toInt256(fee_ppm), toInt256((SELECT fee_denom FROM constants)))) AS fee_raw\n    FROM swapr_v3_swaps_with_fee s\n),\n\nswapr_v3_flash_fees_token AS (\n    SELECT\n        toDate(toStartOfDay(e.block_timestamp)) AS date,\n        'Swapr V3' AS protocol,\n        replaceAll(lower(e.contract_address), '0x', '') AS pool_address_no0x,\n        'token0' AS token_position,\n        toUInt256(\n            toUInt256OrNull(e.decoded_params['paid0']) - toUInt256OrNull(e.decoded_params['amount0'])\n        ) AS fee_raw\n    FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_events` e\n    WHERE e.event_name = 'Flash'\n      AND e.block_timestamp < today()\n      AND e.decoded_params['paid0'] IS NOT NULL\n      AND e.decoded_params['amount0'] IS NOT NULL\n      \n        \n  \n\n      \n\n    UNION ALL\n\n    SELECT\n        toDate(toStartOfDay(e.block_timestamp)) AS date,\n        'Swapr V3' AS protocol,\n        replaceAll(lower(e.contract_address), '0x', '') AS pool_address_no0x,\n        'token1' AS token_position,\n        toUInt256(\n            toUInt256OrNull(e.decoded_params['paid1']) - toUInt256OrNull(e.decoded_params['amount1'])\n        ) AS fee_raw\n    FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_events` e\n    WHERE e.event_name = 'Flash'\n      AND e.block_timestamp < today()\n      AND e.decoded_params['paid1'] IS NOT NULL\n      AND e.decoded_params['amount1'] IS NOT NULL\n      \n        \n  \n\n      \n),\n\nswapr_v3_fees_token AS (\n    SELECT * FROM swapr_v3_swap_fees_token\n    UNION ALL\n    SELECT * FROM swapr_v3_flash_fees_token\n),\n\n/* -----------------------------\n   Token mapping + aggregation\n------------------------------ */\nv3_pool_meta AS (\n    SELECT\n        'Uniswap V3' AS protocol,\n        pool_address_no0x,\n        token0_address,\n        token1_address\n    FROM uniswap_v3_pools\n\n    UNION ALL\n\n    SELECT\n        'Swapr V3' AS protocol,\n        pool_address_no0x,\n        token0_address,\n        token1_address\n    FROM swapr_v3_pools\n),\n\nall_fees_token AS (\n    SELECT * FROM uniswap_v3_fees_token\n    UNION ALL\n    SELECT * FROM swapr_v3_fees_token\n),\n\nfees_with_token AS (\n    SELECT\n        f.date,\n        f.protocol,\n        f.pool_address_no0x,\n        concat('0x', f.pool_address_no0x) AS pool_address,\n        multiIf(\n            f.token_position = 'token0', m.token0_address,\n            f.token_position = 'token1', m.token1_address,\n            NULL\n        ) AS token_address,\n        f.fee_raw\n    FROM all_fees_token f\n    INNER JOIN v3_pool_meta m\n      ON m.protocol = f.protocol\n     AND m.pool_address_no0x = f.pool_address_no0x\n    WHERE f.fee_raw IS NOT NULL\n),\n\nfees_token_amounts AS (\n    SELECT\n        f.date,\n        f.protocol,\n        f.pool_address,\n        f.token_address,\n        tm.token,\n        (toFloat64(f.fee_raw) / pow(10, coalesce(tm.decimals, 18))) AS fee_amount\n    FROM fees_with_token f\n    LEFT JOIN token_meta tm\n      ON tm.token_address = f.token_address\n     AND f.date >= toDate(tm.date_start)\n     AND (tm.date_end IS NULL OR f.date < toDate(tm.date_end))\n    WHERE f.token_address IS NOT NULL\n      AND tm.token IS NOT NULL\n      AND tm.token != ''\n),\n\nfees_daily AS (\n    SELECT\n        f.date,\n        f.protocol,\n        f.pool_address,\n        f.token_address,\n        f.token,\n        sum(f.fee_amount) AS fee_amount,\n        sum(f.fee_amount * coalesce(p.price_usd, 0)) AS fees_usd\n    FROM fees_token_amounts f\n    LEFT JOIN prices p\n      ON p.date = f.date\n     AND p.token = f.token\n    GROUP BY f.date, f.protocol, f.pool_address, f.token_address, f.token\n)\n\nSELECT\n    date,\n    protocol,\n    pool_address,\n    token_address,\n    token,\n    fee_amount,\n    fees_usd\nFROM fees_daily\nWHERE date < today()", "relation_name": "`dbt`.`int_execution_yields_pools_fees_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.425924Z", "completed_at": "2026-02-12T22:49:49.430670Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.431248Z", "completed_at": "2026-02-12T22:49:49.431255Z"}], "thread_id": "Thread-1", "execution_time": 0.0066640377044677734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_circles_avatars_date.458ccb6f09", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_circles_avatars`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.434020Z", "completed_at": "2026-02-12T22:49:49.438814Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.439381Z", "completed_at": "2026-02-12T22:49:49.439388Z"}], "thread_id": "Thread-1", "execution_time": 0.0067136287689208984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_crawlers_data_distinct_projects_sectors_totals_value1.058dcfb0ef", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect value1\nfrom `dbt`.`api_crawlers_data_distinct_projects_sectors_totals`\nwhere value1 is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.442091Z", "completed_at": "2026-02-12T22:49:49.446954Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.447548Z", "completed_at": "2026-02-12T22:49:49.447555Z"}], "thread_id": "Thread-1", "execution_time": 0.006815671920776367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_crawlers_data_distinct_projects_sectors_totals_value2.08f4d1c65b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect value2\nfrom `dbt`.`api_crawlers_data_distinct_projects_sectors_totals`\nwhere value2 is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.450223Z", "completed_at": "2026-02-12T22:49:49.456177Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.456768Z", "completed_at": "2026-02-12T22:49:49.456775Z"}], "thread_id": "Thread-1", "execution_time": 0.00787210464477539, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_gas_share_by_project_daily_date.9a0f9c0df3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_gas_share_by_project_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.459553Z", "completed_at": "2026-02-12T22:49:49.463590Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.464185Z", "completed_at": "2026-02-12T22:49:49.464193Z"}], "thread_id": "Thread-1", "execution_time": 0.006026744842529297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_project_monthly_top5", "compiled": true, "compiled_code": "\nSELECT\n  date,\n  label,\n  value\nFROM `dbt`.`fct_execution_transactions_by_project_monthly_top5`\nWHERE metric = 'ActiveAccounts'\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.467103Z", "completed_at": "2026-02-12T22:49:49.471014Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.471633Z", "completed_at": "2026-02-12T22:49:49.471641Z"}], "thread_id": "Thread-1", "execution_time": 0.005841732025146484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_project_monthly_top5", "compiled": true, "compiled_code": "\nSELECT\n  date,\n  label,\n  value\nFROM `dbt`.`fct_execution_transactions_by_project_monthly_top5`\nWHERE metric = 'Transactions'\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.474478Z", "completed_at": "2026-02-12T22:49:49.478327Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.478966Z", "completed_at": "2026-02-12T22:49:49.478973Z"}], "thread_id": "Thread-1", "execution_time": 0.005947113037109375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_project_monthly_top5", "compiled": true, "compiled_code": "\nSELECT\n  date,\n  label,\n  value\nFROM `dbt`.`fct_execution_transactions_by_project_monthly_top5`\nWHERE metric = 'FeesNative'\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.481817Z", "completed_at": "2026-02-12T22:49:49.485711Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.486309Z", "completed_at": "2026-02-12T22:49:49.486317Z"}], "thread_id": "Thread-1", "execution_time": 0.005947113037109375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_sector_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  sector AS label,\n  active_accounts AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_daily`\nWHERE date < today()\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.489002Z", "completed_at": "2026-02-12T22:49:49.493063Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.493696Z", "completed_at": "2026-02-12T22:49:49.493703Z"}], "thread_id": "Thread-1", "execution_time": 0.0059773921966552734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_sector_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  sector AS label,\n  txs AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_daily`\nWHERE date < today()\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.496497Z", "completed_at": "2026-02-12T22:49:49.501680Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.502275Z", "completed_at": "2026-02-12T22:49:49.502282Z"}], "thread_id": "Thread-1", "execution_time": 0.007080078125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_sector_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  sector AS label,\n  fee_native_sum AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_daily`\nWHERE date < today()\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.505048Z", "completed_at": "2026-02-12T22:49:49.509560Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.510123Z", "completed_at": "2026-02-12T22:49:49.510130Z"}], "thread_id": "Thread-1", "execution_time": 0.006337165832519531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_transactions_by_sector_daily_date.cf19023a9f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_execution_transactions_by_sector_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.512876Z", "completed_at": "2026-02-12T22:49:49.518118Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.518735Z", "completed_at": "2026-02-12T22:49:49.518742Z"}], "thread_id": "Thread-1", "execution_time": 0.0071563720703125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_sector_weekly", "compiled": true, "compiled_code": "\n\nSELECT\n  week AS date,\n  sector AS label,\n  active_accounts AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_weekly`\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_sector_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.522247Z", "completed_at": "2026-02-12T22:49:49.526589Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.527193Z", "completed_at": "2026-02-12T22:49:49.527201Z"}], "thread_id": "Thread-1", "execution_time": 0.0069539546966552734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_sector_weekly", "compiled": true, "compiled_code": "\n\nSELECT\n  week AS date,\n  sector AS label,\n  txs AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_weekly`\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_sector_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.530131Z", "completed_at": "2026-02-12T22:49:49.534064Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.534672Z", "completed_at": "2026-02-12T22:49:49.534679Z"}], "thread_id": "Thread-1", "execution_time": 0.005929231643676758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_sector_weekly", "compiled": true, "compiled_code": "\n\nSELECT\n  week AS date,\n  sector AS label,\n  fee_native_sum AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_weekly`\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_sector_weekly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.537468Z", "completed_at": "2026-02-12T22:49:49.543613Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.544205Z", "completed_at": "2026-02-12T22:49:49.544212Z"}], "thread_id": "Thread-1", "execution_time": 0.00803065299987793, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_project_snapshots", "compiled": true, "compiled_code": "\n\nWITH wd AS (\n  SELECT max(date) AS max_date\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n),\nrng AS (\n  SELECT '1D'  AS window,  1  AS days UNION ALL\n  SELECT '7D'  AS window,  7  AS days UNION ALL\n  SELECT '30D' AS window,  30 AS days UNION ALL\n  SELECT '90D' AS window,  90 AS days\n),\nbounds AS (\n  SELECT\n    r.window,\n    r.days,\n    w.max_date,\n    subtractDays(w.max_date, r.days)        AS curr_start,\n    w.max_date                              AS curr_end,\n    subtractDays(w.max_date, 2 * r.days)    AS prev_start,\n    subtractDays(w.max_date, r.days)        AS prev_end\n  FROM rng r\n  CROSS JOIN wd w\n),\n\ncurr_win AS (\n  SELECT\n    b.window,\n    d.project,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.curr_start\n   AND d.date <= b.curr_end\n  GROUP BY b.window, d.project\n),\nprev_win AS (\n  SELECT\n    b.window,\n    d.project,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.prev_start\n   AND d.date <= b.prev_end\n  GROUP BY b.window, d.project\n),\n\n/* all-time from AMT */\ncurr_all AS (\n  SELECT\n    'All' AS window,\n    a.project,\n    sumMerge(a.txs_state)             AS txs,\n    sumMerge(a.fee_state)             AS fee_native,\n    groupBitmapMerge(a.aa_state)      AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_alltime_state` a\n  GROUP BY a.project\n),\n\njoined AS (\n  SELECT\n    c.window,\n    c.project,\n    c.txs        AS txs_curr,\n    p.txs        AS txs_prev,\n    c.fee_native AS fee_curr,\n    p.fee_native AS fee_prev,\n    c.aa_uniques AS aa_curr,\n    p.aa_uniques AS aa_prev\n  FROM curr_win c\n  LEFT JOIN prev_win p\n    ON p.window = c.window AND p.project = c.project\n),\n\nall_windows AS (\n  SELECT window, project, txs, fee_native, aa_uniques FROM curr_win\n  UNION ALL\n  SELECT window, project, txs, fee_native, aa_uniques FROM curr_all\n)\n\nSELECT\n  'Transactions'            AS label,\n  w.window                  AS window,\n  w.project                 AS bucket,\n  toFloat64(w.txs)          AS value,\n  multiIf(\n    w.window = 'All', NULL,\n    round((coalesce(j.txs_curr / nullIf(j.txs_prev, 0), 0) - 1) * 100, 1)\n  )                         AS change_pct\nFROM all_windows w\nLEFT JOIN joined j\n  ON j.window = w.window AND j.project = w.project\n\nUNION ALL\nSELECT\n  'FeesNative',\n  w.window,\n  w.project,\n  round(toFloat64(w.fee_native), 6),\n  multiIf(\n    w.window = 'All', NULL,\n    round((coalesce(j.fee_curr / nullIf(j.fee_prev, 0), 0) - 1) * 100, 1)\n  )\nFROM all_windows w\nLEFT JOIN joined j\n  ON j.window = w.window AND j.project = w.project\n\nUNION ALL\nSELECT\n  'ActiveAccounts',\n  w.window,\n  w.project,\n  toFloat64(w.aa_uniques),\n  multiIf(\n    w.window = 'All', NULL,\n    round((coalesce(j.aa_curr / nullIf(j.aa_prev, 0), 0) - 1) * 100, 1)\n  )\nFROM all_windows w\nLEFT JOIN joined j\n  ON j.window = w.window AND j.project = w.project", "relation_name": "`dbt`.`fct_execution_transactions_by_project_snapshots`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.547017Z", "completed_at": "2026-02-12T22:49:49.552173Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.552798Z", "completed_at": "2026-02-12T22:49:49.552805Z"}], "thread_id": "Thread-1", "execution_time": 0.007194995880126953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_snapshots", "compiled": true, "compiled_code": "\n\nWITH wd AS (\n  SELECT max(date) AS max_date\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n),\nrng AS (\n  SELECT '1D'  AS window,  1  AS days UNION ALL\n  SELECT '7D'  AS window,  7  AS days UNION ALL\n  SELECT '30D' AS window,  30 AS days UNION ALL\n  SELECT '90D' AS window,  90 AS days\n),\nbounds AS (\n  SELECT\n    r.window,\n    r.days,\n    w.max_date,\n    subtractDays(w.max_date, r.days)        AS curr_start,\n    w.max_date                              AS curr_end,\n    subtractDays(w.max_date, 2 * r.days)    AS prev_start,\n    subtractDays(w.max_date, r.days)        AS prev_end\n  FROM rng r\n  CROSS JOIN wd w\n),\n\ncurr_win AS (\n  SELECT\n    b.window,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.curr_start\n   AND d.date <= b.curr_end\n  GROUP BY b.window\n),\nprev_win AS (\n  SELECT\n    b.window,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.prev_start\n   AND d.date <= b.prev_end\n  GROUP BY b.window\n),\n\ncurr_all AS (\n  SELECT\n    'All' AS window,\n    sumMerge(a.txs_state)           AS txs,\n    sumMerge(a.fee_state)           AS fee_native,\n    groupBitmapMerge(a.aa_state)    AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_alltime_state` a\n),\n\ncurr AS (\n  SELECT * FROM curr_win\n  UNION ALL\n  SELECT * FROM curr_all\n)\n\nSELECT\n  'Transactions'            AS label,\n  c.window                  AS window,\n  toFloat64(c.txs)          AS value,\n  CASE\n    WHEN c.window = 'All' THEN NULL\n    ELSE round((coalesce(c.txs / nullIf(p.txs, 0), 0) - 1) * 100, 1)\n  END AS change_pct\nFROM curr c\nLEFT JOIN prev_win p ON p.window = c.window\n\nUNION ALL\nSELECT\n  'FeesNative',\n  c.window,\n  round(toFloat64(c.fee_native), 6),\n  CASE\n    WHEN c.window = 'All' THEN NULL\n    ELSE round((coalesce(c.fee_native / nullIf(p.fee_native, 0), 0) - 1) * 100, 1)\n  END\nFROM curr c\nLEFT JOIN prev_win p ON p.window = c.window\n\nUNION ALL\nSELECT\n  'ActiveAccounts',\n  c.window,\n  toFloat64(c.aa_uniques),\n  CASE\n    WHEN c.window = 'All' THEN NULL\n    ELSE round((coalesce(c.aa_uniques / nullIf(p.aa_uniques, 0), 0) - 1) * 100, 1)\n  END\nFROM curr c\nLEFT JOIN prev_win p ON p.window = c.window", "relation_name": "`dbt`.`fct_execution_transactions_snapshots`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.555579Z", "completed_at": "2026-02-12T22:49:49.560464Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.561041Z", "completed_at": "2026-02-12T22:49:49.561048Z"}], "thread_id": "Thread-1", "execution_time": 0.006813526153564453, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_sector_hourly_date.e77654a051", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_active_accounts_by_sector_hourly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.563833Z", "completed_at": "2026-02-12T22:49:49.568260Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.568843Z", "completed_at": "2026-02-12T22:49:49.568851Z"}], "thread_id": "Thread-1", "execution_time": 0.006277561187744141, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_sector_hourly_date.d5137ceba4", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_by_sector_hourly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.571498Z", "completed_at": "2026-02-12T22:49:49.576297Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.576903Z", "completed_at": "2026-02-12T22:49:49.576911Z"}], "thread_id": "Thread-1", "execution_time": 0.006688117980957031, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_fees_native_by_sector_hourly_date.6d9e2316bf", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_fees_native_by_sector_hourly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.579755Z", "completed_at": "2026-02-12T22:49:49.588250Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.588885Z", "completed_at": "2026-02-12T22:49:49.588893Z"}], "thread_id": "Thread-1", "execution_time": 0.010472297668457031, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_esg_carbon_footprint_uncertainty", "compiled": true, "compiled_code": "\n\nWITH node_country_distribution AS (\n    -- Get node distribution by country and category with their carbon intensities\n    SELECT\n        date,\n        node_category,\n        country_code,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        carbon_intensity_gco2_kwh,\n        daily_energy_kwh_mean,\n        avg_power_watts_per_node,\n        power_std_dev_per_node,\n        daily_co2_kg_mean,\n        daily_co2_kg_std\n    FROM `dbt`.`int_esg_dynamic_power_consumption`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`)\n    \n),\n\n-- Calculate network effective CIF from geographic distribution\nnetwork_effective_cif AS (\n    SELECT\n        date,\n        -- Network Effective CIF = \u03a3(nodes_in_country \u00d7 country_CIF) / total_nodes\n        SUM(estimated_total_nodes * carbon_intensity_gco2_kwh) / \n        NULLIF(SUM(estimated_total_nodes), 0) AS network_weighted_cif,\n        \n        -- Weighted standard deviation of network CIF\n        -- Using variance formula: Var = \u03a3(w_i * (x_i - mean)\u00b2) / \u03a3(w_i)\n        -- Then std = sqrt(var)\n        SQRT(\n            SUM(estimated_total_nodes * pow(carbon_intensity_gco2_kwh, 2)) / NULLIF(SUM(estimated_total_nodes), 0) -\n            pow(SUM(estimated_total_nodes * carbon_intensity_gco2_kwh) / NULLIF(SUM(estimated_total_nodes), 0), 2)\n        ) AS network_cif_std\n    FROM node_country_distribution\n    GROUP BY date\n),\n\ndaily_power_data AS (\n    -- Aggregate power consumption across all categories and countries\n    SELECT\n        date,\n        node_category,\n        \n        -- Node counts with uncertainty\n        SUM(estimated_total_nodes) AS category_nodes,\n        SUM(nodes_lower_95) AS category_nodes_lower_95,\n        SUM(nodes_upper_95) AS category_nodes_upper_95,\n        \n        -- Energy totals with uncertainty calculation\n        SUM(daily_energy_kwh_mean) AS category_energy_kwh_mean,\n        \n        -- Energy standard deviation (propagate uncertainty from power and node count)\n        SQRT(SUM(\n            pow(power_std_dev_per_node * estimated_total_nodes * 24 / 1000.0, 2) + \n            pow(avg_power_watts_per_node * (nodes_upper_95 - nodes_lower_95) / 3.92 * 24 / 1000.0, 2)\n        )) AS category_energy_kwh_std,\n        \n        -- Carbon totals\n        SUM(daily_co2_kg_mean) AS category_co2_kg,\n        SQRT(SUM(pow(daily_co2_kg_std, 2))) AS category_co2_kg_std,\n        \n        -- Weighted averages\n        SUM(daily_energy_kwh_mean * estimated_total_nodes) / NULLIF(SUM(estimated_total_nodes), 0) AS weighted_avg_energy_per_node,\n        SUM(daily_co2_kg_mean * estimated_total_nodes) / NULLIF(SUM(estimated_total_nodes), 0) AS weighted_avg_co2_per_node,\n        \n        -- Country count for this category\n        COUNT(DISTINCT country_code) AS countries_represented\n        \n    FROM node_country_distribution\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`)\n    \n    GROUP BY date, node_category\n),\n\nnetwork_totals AS (\n    -- Calculate network-wide totals with full uncertainty propagation\n    SELECT\n        date,\n        \n        -- Total network size with bounds\n        SUM(category_nodes) AS total_estimated_nodes,\n        SUM(category_nodes_lower_95) AS total_nodes_lower_95,\n        SUM(category_nodes_upper_95) AS total_nodes_upper_95,\n        \n        -- Total energy consumption with uncertainty\n        SUM(category_energy_kwh_mean) AS total_energy_kwh_mean,\n        SQRT(SUM(pow(category_energy_kwh_std, 2))) AS total_energy_kwh_std,\n        \n        -- Total emissions with error propagation\n        SUM(category_co2_kg) AS total_co2_kg_mean,\n        SQRT(SUM(pow(category_co2_kg_std, 2))) AS total_co2_kg_std,\n        \n        -- Category breakdown for energy\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_energy_kwh_mean ELSE 0 END) AS home_staker_energy_kwh,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_energy_kwh_mean ELSE 0 END) AS professional_energy_kwh,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_energy_kwh_mean ELSE 0 END) AS cloud_energy_kwh,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_energy_kwh_mean ELSE 0 END) AS unknown_energy_kwh,\n        \n        -- Category breakdown for carbon\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_co2_kg ELSE 0 END) AS home_staker_co2_kg,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_co2_kg ELSE 0 END) AS professional_co2_kg,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_co2_kg ELSE 0 END) AS cloud_co2_kg,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_co2_kg ELSE 0 END) AS unknown_co2_kg,\n        \n        -- Node breakdown\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_nodes ELSE 0 END) AS home_staker_nodes,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_nodes ELSE 0 END) AS professional_nodes,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_nodes ELSE 0 END) AS cloud_nodes,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_nodes ELSE 0 END) AS unknown_nodes,\n        \n        -- Quality metrics\n        COUNT(DISTINCT CASE WHEN category_nodes > 0 THEN node_category END) AS active_categories,\n        MAX(countries_represented) AS max_countries_in_category\n        \n    FROM daily_power_data\n    GROUP BY date\n),\n\n-- Add Chao-1 population estimates for comparison\nchao1_comparison AS (\n    SELECT\n        nt.date AS date,\n        nt.*,\n        necif.network_weighted_cif,\n        necif.network_cif_std,\n        \n        -- Link to Chao-1 estimates\n        c.observed_successful_nodes AS chao1_observed,\n        c.enhanced_total_reachable AS chao1_estimated,\n        c.connection_success_rate_pct AS chao1_success_rate,\n        c.reachable_discovery_coverage_pct AS chao1_coverage,\n        \n        -- Compare our estimates to Chao-1\n        round(100.0 * nt.total_estimated_nodes / NULLIF(c.enhanced_total_reachable, 0), 1) AS node_estimate_vs_chao1_pct,\n        \n        -- Calculate scaling factor applied\n        round(toFloat64(nt.total_estimated_nodes) / NULLIF(c.observed_successful_nodes, 0), 2) AS applied_scaling_factor\n        \n    FROM network_totals nt\n    JOIN network_effective_cif necif ON nt.date = necif.date\n    LEFT JOIN `dbt`.`int_esg_node_population_chao1` c\n        ON c.observation_date = nt.date\n),\n\nenhanced_statistics AS (\n    SELECT\n        date,\n        \n        -- Node population metrics with bounds\n        total_estimated_nodes,\n        total_nodes_lower_95,\n        total_nodes_upper_95,\n        chao1_observed,\n        chao1_estimated,\n        chao1_success_rate,\n        chao1_coverage,\n        node_estimate_vs_chao1_pct,\n        applied_scaling_factor,\n        \n        -- Network carbon intensity with uncertainty\n        round(network_weighted_cif, 2) AS network_carbon_intensity_gco2_kwh,\n        round(network_cif_std, 2) AS network_carbon_intensity_std,\n        \n        -- Daily energy metrics with full uncertainty bands\n        round(total_energy_kwh_mean, 2) AS daily_energy_kwh_mean,\n        round(total_energy_kwh_std, 2) AS daily_energy_kwh_std,\n        \n        -- Daily energy confidence intervals (95%)\n        round(greatest(0, total_energy_kwh_mean - 1.96 * total_energy_kwh_std), 2) AS daily_energy_kwh_lower_95,\n        round(total_energy_kwh_mean + 1.96 * total_energy_kwh_std, 2) AS daily_energy_kwh_upper_95,\n        \n        -- Daily energy confidence intervals (90%)\n        round(greatest(0, total_energy_kwh_mean - 1.645 * total_energy_kwh_std), 2) AS daily_energy_kwh_lower_90,\n        round(total_energy_kwh_mean + 1.645 * total_energy_kwh_std, 2) AS daily_energy_kwh_upper_90,\n        \n        -- Annual energy projections with uncertainty\n        round(total_energy_kwh_mean * 365 / 1000, 2) AS annual_energy_mwh_mean,\n        round(total_energy_kwh_std * sqrt(365) / 1000, 2) AS annual_energy_mwh_std,\n        \n        -- Annual energy confidence intervals (95%)\n        round(greatest(0, (total_energy_kwh_mean * 365 / 1000) - 1.96 * (total_energy_kwh_std * sqrt(365) / 1000)), 2) AS annual_energy_mwh_lower_95,\n        round((total_energy_kwh_mean * 365 / 1000) + 1.96 * (total_energy_kwh_std * sqrt(365) / 1000), 2) AS annual_energy_mwh_upper_95,\n        \n        -- Annual energy confidence intervals (90%)\n        round(greatest(0, (total_energy_kwh_mean * 365 / 1000) - 1.645 * (total_energy_kwh_std * sqrt(365) / 1000)), 2) AS annual_energy_mwh_lower_90,\n        round((total_energy_kwh_mean * 365 / 1000) + 1.645 * (total_energy_kwh_std * sqrt(365) / 1000), 2) AS annual_energy_mwh_upper_90,\n        \n        -- Carbon emissions (primary metrics)\n        round(total_co2_kg_mean, 2) AS daily_co2_kg_mean,\n        round(total_co2_kg_std, 2) AS daily_co2_kg_std,\n        \n        -- Daily CO2 confidence intervals (95%)\n        round(greatest(0, total_co2_kg_mean - 1.96 * total_co2_kg_std), 2) AS daily_co2_kg_lower_95,\n        round(total_co2_kg_mean + 1.96 * total_co2_kg_std, 2) AS daily_co2_kg_upper_95,\n        \n        -- Daily CO2 confidence intervals (90%)\n        round(greatest(0, total_co2_kg_mean - 1.645 * total_co2_kg_std), 2) AS daily_co2_kg_lower_90,\n        round(total_co2_kg_mean + 1.645 * total_co2_kg_std, 2) AS daily_co2_kg_upper_90,\n        \n        -- Annual CO2 projections\n        round(total_co2_kg_mean * 365 / 1000, 2) AS annual_co2_tonnes_mean,\n        round(total_co2_kg_std * sqrt(365) / 1000, 2) AS annual_co2_tonnes_std,\n        \n        -- Category breakdowns for energy\n        round(home_staker_energy_kwh, 2) AS home_staker_energy_kwh_daily,\n        round(professional_energy_kwh, 2) AS professional_energy_kwh_daily,\n        round(cloud_energy_kwh, 2) AS cloud_energy_kwh_daily,\n        round(unknown_energy_kwh, 2) AS unknown_energy_kwh_daily,\n        \n        -- Category breakdowns for carbon\n        round(home_staker_co2_kg, 2) AS home_staker_co2_kg_daily,\n        round(professional_co2_kg, 2) AS professional_co2_kg_daily,\n        round(cloud_co2_kg, 2) AS cloud_co2_kg_daily,\n        round(unknown_co2_kg, 2) AS unknown_co2_kg_daily,\n        \n        -- Category percentages\n        round(100.0 * home_staker_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS home_staker_pct,\n        round(100.0 * professional_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS professional_pct,\n        round(100.0 * cloud_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS cloud_pct,\n        \n        -- Node distribution\n        home_staker_nodes,\n        professional_nodes,\n        cloud_nodes,\n        unknown_nodes,\n        \n        -- Relative uncertainties\n        round(100.0 * total_energy_kwh_std / NULLIF(total_energy_kwh_mean, 0), 1) AS energy_relative_uncertainty_pct,\n        round(100.0 * total_co2_kg_std / NULLIF(total_co2_kg_mean, 0), 1) AS carbon_relative_uncertainty_pct,\n        \n        -- Quality metrics\n        active_categories,\n        max_countries_in_category AS countries_with_nodes\n        \n    FROM chao1_comparison\n)\n\nSELECT\n    date,\n    \n    -- PRIMARY CARBON FOOTPRINT METRICS WITH BANDS\n    daily_co2_kg_mean,\n    daily_co2_kg_std,\n    daily_co2_kg_lower_95,\n    daily_co2_kg_upper_95,\n    daily_co2_kg_lower_90,\n    daily_co2_kg_upper_90,\n    \n    -- Annual CO2 projections with uncertainty bands\n    annual_co2_tonnes_mean AS annual_co2_tonnes_projected,\n    annual_co2_tonnes_std,\n    round(greatest(0, annual_co2_tonnes_mean - 1.96 * annual_co2_tonnes_std), 2) AS annual_co2_tonnes_lower_95,\n    round(annual_co2_tonnes_mean + 1.96 * annual_co2_tonnes_std, 2) AS annual_co2_tonnes_upper_95,\n    round(greatest(0, annual_co2_tonnes_mean - 1.645 * annual_co2_tonnes_std), 2) AS annual_co2_tonnes_lower_90,\n    round(annual_co2_tonnes_mean + 1.645 * annual_co2_tonnes_std, 2) AS annual_co2_tonnes_upper_90,\n    \n    -- PRIMARY ENERGY METRICS WITH BANDS\n    daily_energy_kwh_mean AS daily_energy_kwh_total,\n    daily_energy_kwh_std,\n    daily_energy_kwh_lower_95,\n    daily_energy_kwh_upper_95,\n    daily_energy_kwh_lower_90,\n    daily_energy_kwh_upper_90,\n    \n    -- Annual energy projections with uncertainty bands\n    annual_energy_mwh_mean AS annual_energy_Mwh_projected,\n    annual_energy_mwh_std,\n    annual_energy_mwh_lower_95,\n    annual_energy_mwh_upper_95,\n    annual_energy_mwh_lower_90,\n    annual_energy_mwh_upper_90,\n    \n    -- NETWORK CARBON INTENSITY WITH UNCERTAINTY\n    network_carbon_intensity_gco2_kwh AS effective_carbon_intensity,\n    network_carbon_intensity_std AS effective_carbon_intensity_std,\n    round(greatest(0, network_carbon_intensity_gco2_kwh - 1.96 * network_carbon_intensity_std), 2) AS effective_carbon_intensity_lower_95,\n    round(network_carbon_intensity_gco2_kwh + 1.96 * network_carbon_intensity_std, 2) AS effective_carbon_intensity_upper_95,\n    \n    -- NODE POPULATION WITH BOUNDS\n    total_estimated_nodes AS estimated_nodes,\n    total_nodes_lower_95 AS nodes_lower_95,\n    total_nodes_upper_95 AS nodes_upper_95,\n    \n    -- Category breakdown for energy (daily)\n    home_staker_energy_kwh_daily,\n    professional_energy_kwh_daily,\n    cloud_energy_kwh_daily,\n    unknown_energy_kwh_daily,\n    \n    -- Category breakdown for emissions (daily)\n    home_staker_co2_kg_daily,\n    professional_co2_kg_daily,\n    cloud_co2_kg_daily,\n    unknown_co2_kg_daily,\n    \n    -- Category percentages\n    home_staker_pct,\n    professional_pct,\n    cloud_pct,\n    \n    -- Node distribution by category\n    home_staker_nodes,\n    professional_nodes,\n    cloud_nodes,\n    unknown_nodes,\n    \n    -- UNCERTAINTY METRICS\n    energy_relative_uncertainty_pct,\n    carbon_relative_uncertainty_pct,\n    \n    -- Quality metrics\n    active_categories AS node_categories_active,\n    countries_with_nodes,\n    \n    -- Comparison with Chao-1 estimates\n    chao1_observed AS baseline_observed_nodes,\n    chao1_estimated AS chao1_total_estimated,\n    node_estimate_vs_chao1_pct,\n    applied_scaling_factor,\n    round(chao1_success_rate, 1) AS network_reachability_pct,\n    round(chao1_coverage, 1) AS discovery_completeness_pct,\n    \n    -- PER-NODE METRICS WITH BOUNDS\n    round(daily_co2_kg_mean / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS grams_co2_per_node_daily,\n    round(daily_energy_kwh_mean / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS wh_per_node_daily,\n    \n    -- Per-node uncertainty bands\n    round(greatest(0, (daily_co2_kg_mean - 1.96 * daily_co2_kg_std) / NULLIF(total_estimated_nodes, 0) * 1000), 1) AS grams_co2_per_node_lower_95,\n    round((daily_co2_kg_mean + 1.96 * daily_co2_kg_std) / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS grams_co2_per_node_upper_95,\n    \n    round(greatest(0, (daily_energy_kwh_mean - 1.96 * daily_energy_kwh_std) / NULLIF(total_estimated_nodes, 0) * 1000), 1) AS wh_per_node_lower_95,\n    round((daily_energy_kwh_mean + 1.96 * daily_energy_kwh_std) / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS wh_per_node_upper_95\n    \nFROM enhanced_statistics\nORDER BY date DESC", "relation_name": "`dbt`.`fct_esg_carbon_footprint_uncertainty`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.591784Z", "completed_at": "2026-02-12T22:49:49.598094Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.598698Z", "completed_at": "2026-02-12T22:49:49.598705Z"}], "thread_id": "Thread-1", "execution_time": 0.008261442184448242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_esg_dynamic_power_consumption_date.d15537ff08", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_esg_dynamic_power_consumption`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.601356Z", "completed_at": "2026-02-12T22:49:49.616032Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.616622Z", "completed_at": "2026-02-12T22:49:49.616630Z"}], "thread_id": "Thread-1", "execution_time": 0.016528606414794922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_pools_balances_daily", "compiled": true, "compiled_code": "\n\n\n\n\nWITH\ncontracts_whitelist AS (\n    SELECT\n        lower(address) AS pool_address,\n        contract_type\n    FROM `dbt`.`contracts_whitelist`\n),\n\nuniswap_v3_pools AS (\n    SELECT DISTINCT\n        multiIf(\n            startsWith(lower(decoded_params['pool']), '0x'),\n            lower(decoded_params['pool']),\n            concat('0x', replaceAll(lower(decoded_params['pool']), '0x', ''))\n        ) AS pool_address,\n        lower(decoded_params['token0']) AS token0,\n        lower(decoded_params['token1']) AS token1,\n        'Uniswap V3' AS protocol\n    FROM `dbt`.`contracts_UniswapV3_Factory_events` f\n    INNER JOIN contracts_whitelist w\n      ON w.pool_address = multiIf(\n          startsWith(lower(f.decoded_params['pool']), '0x'),\n          lower(f.decoded_params['pool']),\n          concat('0x', replaceAll(lower(f.decoded_params['pool']), '0x', ''))\n      )\n     AND w.contract_type = 'UniswapV3Pool'\n    WHERE event_name = 'PoolCreated'\n      AND decoded_params['pool'] IS NOT NULL\n      AND decoded_params['token0'] IS NOT NULL\n      AND decoded_params['token1'] IS NOT NULL\n),\n\nswapr_v3_pools AS (\n    SELECT DISTINCT\n        multiIf(\n            startsWith(lower(decoded_params['pool']), '0x'),\n            lower(decoded_params['pool']),\n            concat('0x', replaceAll(lower(decoded_params['pool']), '0x', ''))\n        ) AS pool_address,\n        lower(decoded_params['token0']) AS token0,\n        lower(decoded_params['token1']) AS token1,\n        'Swapr V3' AS protocol\n    FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_events` f\n    INNER JOIN contracts_whitelist w\n      ON w.pool_address = multiIf(\n          startsWith(lower(f.decoded_params['pool']), '0x'),\n          lower(f.decoded_params['pool']),\n          concat('0x', replaceAll(lower(f.decoded_params['pool']), '0x', ''))\n      )\n     AND w.contract_type = 'SwaprPool'\n    WHERE event_name = 'Pool'\n      AND decoded_params['pool'] IS NOT NULL\n      AND decoded_params['token0'] IS NOT NULL\n      AND decoded_params['token1'] IS NOT NULL\n),\n\npool_tokens AS (\n    SELECT\n        protocol,\n        pool_address,\n        token0 AS token_address\n    FROM uniswap_v3_pools\n\n    UNION ALL\n\n    SELECT\n        protocol,\n        pool_address,\n        token1 AS token_address\n    FROM uniswap_v3_pools\n\n    UNION ALL\n\n    SELECT\n        protocol,\n        pool_address,\n        token0 AS token_address\n    FROM swapr_v3_pools\n\n    UNION ALL\n\n    SELECT\n        protocol,\n        pool_address,\n        token1 AS token_address\n    FROM swapr_v3_pools\n),\n\nbalances_daily AS (\n    SELECT\n        date,\n        lower(token_address) AS token_address,\n        lower(address) AS address,\n        balance_raw,\n        balance AS token_amount\n    FROM `dbt`.`int_execution_tokens_balances_daily`\n    WHERE date < today()\n      \n        \n  \n\n      \n),\n\ntransfer_based_balances AS (\n    SELECT\n        b.date AS date,\n        p.protocol AS protocol,\n        p.pool_address AS pool_address,\n        p.token_address AS token_address,\n        b.balance_raw AS token_amount_raw,\n        b.token_amount AS token_amount\n    FROM balances_daily b\n    INNER JOIN pool_tokens p\n        ON b.address = p.pool_address\n       AND b.token_address = p.token_address\n),\n\nbalancer_v2_pool_registry AS (\n    SELECT\n        lower(decoded_params['poolId']) AS pool_id,\n        lower(decoded_params['poolAddress']) AS pool_address\n    FROM `dbt`.`contracts_BalancerV2_Vault_events`\n    WHERE event_name = 'PoolRegistered'\n      AND decoded_params['poolId'] IS NOT NULL\n      AND decoded_params['poolAddress'] IS NOT NULL\n),\n\nbalancer_v3_swap_tokens AS (\n    SELECT\n        pool_address,\n        arraySort(groupUniqArray(token_address)) AS swap_tokens\n    FROM `dbt`.`stg_pools__balancer_v3_events`\n    WHERE event_type = 'Swap'\n      AND pool_address IS NOT NULL\n      AND token_address IS NOT NULL\n    GROUP BY pool_address\n),\n\nbalancer_v3_tokenconfig_raw AS (\n    SELECT\n        replaceAll(lower(decoded_params['pool']), '0x', '') AS pool_address,\n        token_idx AS token_index,\n        lower(concat('0x', right(replaceAll(replaceAll(token_val, '\"', ''), '0x', ''), 40))) AS token_address,\n        token_address IN (\n            '0x0000000000000000000000000000000000000000',\n            '0x0000000000000000000000000000000000000001'\n        ) AS is_sentinel,\n        block_timestamp,\n        log_index\n    FROM `dbt`.`contracts_BalancerV3_Vault_events`\n    ARRAY JOIN\n        range(length(JSONExtractArrayRaw(ifNull(decoded_params['tokenConfig'], '[]')))) AS token_idx,\n        JSONExtractArrayRaw(ifNull(decoded_params['tokenConfig'], '[]')) AS token_val\n    WHERE event_name = 'PoolRegistered'\n      AND decoded_params['pool'] IS NOT NULL\n      AND decoded_params['tokenConfig'] IS NOT NULL\n),\n\nbalancer_v3_tokenconfig AS (\n    SELECT\n        pool_address,\n        token_index,\n        token_address,\n        is_sentinel\n    FROM (\n        SELECT\n            pool_address,\n            token_index,\n            token_address,\n            is_sentinel,\n            row_number() OVER (\n                PARTITION BY pool_address, token_index\n                ORDER BY block_timestamp DESC, log_index DESC\n            ) AS rn\n        FROM balancer_v3_tokenconfig_raw\n    )\n    WHERE rn = 1\n),\n\nbalancer_v3_tokenconfig_stats AS (\n    SELECT\n        pool_address,\n        countIf(not is_sentinel) AS valid_cnt,\n        anyIf(token_address, not is_sentinel) AS any_valid_token\n    FROM balancer_v3_tokenconfig\n    GROUP BY pool_address\n),\n\nbalancer_v3_pool_tokens AS (\n    SELECT\n        pool_address,\n        token_index,\n        protocol,\n        token_address\n    FROM (\n        SELECT\n            c.pool_address AS pool_address,\n            c.token_index AS token_index,\n            'Balancer V3' AS protocol,\n            multiIf(\n                not c.is_sentinel,\n                c.token_address,\n                -- If the config contains a sentinel slot, infer it from swap tokens (2-token pools).\n                length(ifNull(s.swap_tokens, [])) = 2 AND st.valid_cnt = 1,\n                if(st.any_valid_token = s.swap_tokens[1], s.swap_tokens[2], s.swap_tokens[1]),\n                -- If both slots are sentinel (rare), fall back to swap token ordering by index.\n                length(ifNull(s.swap_tokens, [])) = 2 AND st.valid_cnt = 0,\n                s.swap_tokens[toInt32(c.token_index) + 1],\n                NULL\n            ) AS token_address\n        FROM balancer_v3_tokenconfig c\n        LEFT JOIN balancer_v3_swap_tokens s\n            ON s.pool_address = c.pool_address\n        LEFT JOIN balancer_v3_tokenconfig_stats st\n            ON st.pool_address = c.pool_address\n    )\n    WHERE token_address IS NOT NULL\n),\n\nbalancer_v2_deltas AS (\n    SELECT\n        e.block_timestamp,\n        e.transaction_hash,\n        e.log_index,\n        'Balancer V2' AS protocol,\n        lower(e.token_address) AS token_address,\n        e.delta_amount_raw,\n        coalesce(r.pool_address, e.pool_id) AS pool_address\n    FROM `dbt`.`stg_pools__balancer_v2_events` e\n    LEFT JOIN balancer_v2_pool_registry r\n        ON r.pool_id = e.pool_id\n    WHERE e.delta_amount_raw IS NOT NULL\n      AND e.token_address IS NOT NULL\n      AND e.pool_id IS NOT NULL\n),\n\nbalancer_v3_deltas_pool AS (\n    SELECT\n        e.block_timestamp AS block_timestamp,\n        e.transaction_hash AS transaction_hash,\n        e.log_index AS log_index,\n        p.protocol AS protocol,\n        p.token_address AS token_address,\n        e.delta_amount_raw AS delta_amount_raw,\n        p.pool_address AS pool_address\n    FROM `dbt`.`stg_pools__balancer_v3_events` e\n    INNER JOIN balancer_v3_pool_tokens p\n        ON e.pool_address = p.pool_address\n       AND e.token_index = p.token_index\n    WHERE e.delta_amount_raw IS NOT NULL\n      AND e.token_index IS NOT NULL\n      AND e.pool_address IS NOT NULL\n),\n\nbalancer_v3_deltas_swap AS (\n    SELECT\n        e.block_timestamp AS block_timestamp,\n        e.transaction_hash AS transaction_hash,\n        e.log_index AS log_index,\n        'Balancer V3' AS protocol,\n        lower(e.token_address) AS token_address,\n        e.delta_amount_raw AS delta_amount_raw,\n        e.pool_address AS pool_address\n    FROM `dbt`.`stg_pools__balancer_v3_events` e\n    WHERE e.event_type = 'Swap'\n      AND e.delta_amount_raw IS NOT NULL\n      AND e.token_address IS NOT NULL\n      AND e.pool_address IS NOT NULL\n),\n\nbalancer_deltas AS (\n    SELECT\n        pool_address,\n        toStartOfDay(block_timestamp) AS date,\n        block_timestamp,\n        protocol,\n        token_address,\n        delta_amount_raw\n    FROM (\n        SELECT * FROM balancer_v2_deltas\n        UNION ALL\n        SELECT * FROM balancer_v3_deltas_pool\n        UNION ALL\n        SELECT * FROM balancer_v3_deltas_swap\n    )\n    WHERE delta_amount_raw IS NOT NULL\n      AND token_address IS NOT NULL\n      AND pool_address IS NOT NULL\n      AND block_timestamp < today()\n      \n        \n  \n\n      \n),\n\nbalancer_daily_deltas AS (\n    SELECT\n        date,\n        protocol,\n        pool_address,\n        token_address,\n        sum(delta_amount_raw) AS daily_delta_raw\n    FROM balancer_deltas\n    GROUP BY date, protocol, pool_address, token_address\n),\n\n\n\nbalancer_balances AS (\n    SELECT\n        date,\n        protocol,\n        pool_address,\n        token_address,\n        sum(daily_delta_raw) OVER (\n            PARTITION BY protocol, pool_address, token_address\n            ORDER BY date\n            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        )\n        \n        AS balance_raw\n    FROM balancer_daily_deltas d\n    \n),\n\nbalancer_balances_final AS (\n    SELECT\n        b.date AS date,\n        b.protocol AS protocol,\n        b.pool_address AS pool_address,\n        b.token_address AS token_address,\n        b.balance_raw AS token_amount_raw,\n        b.balance_raw / POWER(10, COALESCE(t.decimals, 18)) AS token_amount\n    FROM balancer_balances b\n    LEFT JOIN `dbt`.`tokens_whitelist` t\n        ON lower(t.address) = b.token_address\n       AND b.date >= toDate(t.date_start)\n       AND (t.date_end IS NULL OR b.date < toDate(t.date_end))\n    WHERE b.balance_raw != 0\n),\n\nall_balances AS (\n    SELECT\n        date,\n        protocol,\n        pool_address,\n        token_address,\n        token_amount_raw,\n        token_amount\n    FROM transfer_based_balances\n\n    UNION ALL\n\n    SELECT\n        date,\n        protocol,\n        pool_address,\n        token_address,\n        token_amount_raw,\n        token_amount\n    FROM balancer_balances_final\n),\n\nfinal AS (\n    SELECT\n        *\n    FROM all_balances\n    WHERE NOT (\n        protocol IN ('Balancer V2', 'Balancer V3')\n        AND (\n            -- Balancer V2 pool_address is a normal 0x address\n            (protocol = 'Balancer V2' AND lower(token_address) = lower(pool_address))\n            -- Balancer V3 pool_address is stored without 0x in this project\n            OR (protocol = 'Balancer V3' AND lower(token_address) = concat('0x', lower(pool_address)))\n        )\n    )\n      AND lower(token_address) NOT IN (\n        '0x0000000000000000000000000000000000000000',\n        '0x0000000000000000000000000000000000000001'\n      )\n)\n\nSELECT\n    date,\n    protocol,\n    pool_address,\n    token_address,\n    token_amount_raw,\n    token_amount\nFROM final", "relation_name": "`dbt`.`int_execution_pools_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.619477Z", "completed_at": "2026-02-12T22:49:49.626352Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.626952Z", "completed_at": "2026-02-12T22:49:49.626960Z"}], "thread_id": "Thread-1", "execution_time": 0.008790731430053711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_tokens_balance_cohorts_daily", "compiled": true, "compiled_code": "\n\n\n\n\nWITH\n\nbalances_base AS (\n    SELECT\n        b.date,\n        lower(b.token_address) AS token_address,\n        b.symbol AS symbol,\n        b.token_class,\n        lower(b.address) AS address,\n        b.balance,\n        b.balance_usd\n    FROM `dbt`.`int_execution_tokens_balances_daily` b\n    WHERE b.date < today()\n      AND lower(b.address) != '0x0000000000000000000000000000000000000000'\n      \n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(b.date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_tokens_balance_cohorts_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(b.date) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_tokens_balance_cohorts_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n      \n),\n\nbucketed_usd AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        address,\n        balance,\n        balance_usd,\n        'usd' AS cohort_unit,\n        CASE\n            WHEN balance_usd <     0.01       THEN '0-0.01'\n            WHEN balance_usd <      0.1       THEN '0.01-0.1'\n            WHEN balance_usd <        1       THEN '0.1-1'\n            WHEN balance_usd <       10       THEN '1-10'\n            WHEN balance_usd <      100       THEN '10-100'\n            WHEN balance_usd <     1000       THEN '100-1k'\n            WHEN balance_usd <    10000       THEN '1k-10k'\n            WHEN balance_usd <   100000       THEN '10k-100k'\n            WHEN balance_usd <  1000000       THEN '100k-1M'\n            ELSE                                  '1M+'\n        END AS balance_bucket\n    FROM balances_base\n    WHERE balance_usd IS NOT NULL\n      AND balance_usd > 0\n),\n\nbucketed_native AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        address,\n        balance,\n        balance_usd,\n        'native' AS cohort_unit,\n        CASE\n            WHEN balance <     0.01       THEN '0-0.01'\n            WHEN balance <      0.1       THEN '0.01-0.1'\n            WHEN balance <        1       THEN '0.1-1'\n            WHEN balance <       10       THEN '1-10'\n            WHEN balance <      100       THEN '10-100'\n            WHEN balance <     1000       THEN '100-1k'\n            WHEN balance <    10000       THEN '1k-10k'\n            WHEN balance <   100000       THEN '10k-100k'\n            WHEN balance <  1000000       THEN '100k-1M'\n            ELSE                                  '1M+'\n        END AS balance_bucket\n    FROM balances_base\n    WHERE balance > 0\n),\n\nbucketed AS (\n    SELECT * FROM bucketed_usd\n    UNION ALL\n    SELECT * FROM bucketed_native\n),\n\nagg AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        cohort_unit,\n        balance_bucket,\n        countDistinct(address) AS holders_in_bucket,\n        sum(balance) AS value_native_in_bucket,\n        sum(balance_usd) AS value_usd_in_bucket\n    FROM bucketed\n    GROUP BY\n        date,\n        token_address,\n        symbol,\n        token_class,\n        cohort_unit,\n        balance_bucket\n)\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n    cohort_unit,\n    balance_bucket,\n    holders_in_bucket,\n    value_native_in_bucket,\n    value_usd_in_bucket\nFROM agg\nWHERE date < today()\nORDER BY date, token_address, cohort_unit, balance_bucket", "relation_name": "`dbt`.`int_execution_tokens_balance_cohorts_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.629776Z", "completed_at": "2026-02-12T22:49:49.637034Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.637640Z", "completed_at": "2026-02-12T22:49:49.637648Z"}], "thread_id": "Thread-1", "execution_time": 0.009298324584960938, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_tokens_balances_by_sector_daily", "compiled": true, "compiled_code": "\n\n\n\n\nWITH\n\nbalances_filtered AS (\n    SELECT\n        b.date,\n        lower(b.token_address) AS token_address,\n        b.symbol AS symbol,\n        b.token_class,\n        lower(b.address) AS address,\n        b.balance,\n        b.balance_usd\n    FROM `dbt`.`int_execution_tokens_balances_daily` b\n    WHERE b.date < today()\n      AND b.balance > 0\n      AND lower(b.address) != '0x0000000000000000000000000000000000000000'\n      \n        \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(b.date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_tokens_balances_by_sector_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(b.date) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_tokens_balances_by_sector_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n      \n),\n\nlabels AS (\n    SELECT\n        lower(address) AS address,\n        sector\n    FROM `dbt`.`int_crawlers_data_labels`\n),\n\njoined AS (\n    SELECT\n        b.date,\n        b.token_address,\n        b.symbol,\n        b.token_class,\n        b.address,\n        b.balance,\n        b.balance_usd,\n        COALESCE(nullIf(trim(l.sector), ''), 'Unknown') AS sector\n    FROM balances_filtered b\n    LEFT JOIN labels l ON b.address = l.address\n),\n\nagg AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        sector,\n        SUM(balance) AS supply,\n        SUM(balance_usd) AS supply_usd\n    FROM joined\n    GROUP BY\n        date,\n        token_address,\n        symbol,\n        token_class,\n        sector\n)\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n    sector,\n    supply,\n    supply_usd\nFROM agg\nWHERE date < today()\nORDER BY date, token_address, sector, token_class", "relation_name": "`dbt`.`int_execution_tokens_balances_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.640403Z", "completed_at": "2026-02-12T22:49:49.647153Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.647753Z", "completed_at": "2026-02-12T22:49:49.647761Z"}], "thread_id": "Thread-1", "execution_time": 0.008752822875976562, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_tokens_supply_holders_daily", "compiled": true, "compiled_code": "\n\n\n\n\nSELECT\n    b.date,\n    b.token_address,\n    any(b.symbol) AS symbol,\n    any(b.token_class) AS token_class,\n\n    sumIf(\n        b.balance,\n        lower(b.address) != '0x0000000000000000000000000000000000000000'\n    ) AS supply,\n\n    toUInt64(\n      countDistinctIf(\n          b.address,\n          b.balance > 0\n          AND lower(b.address) != '0x0000000000000000000000000000000000000000'\n      )\n    ) AS holders\nFROM `dbt`.`int_execution_tokens_balances_daily` b\nWHERE b.date < today()\n  \n    \n  \n    \n    \n\n   AND \n    toStartOfMonth(toDate(b.date)) >= (\n      SELECT toStartOfMonth(addDays(max(toDate(x1.date)), -0))\n      FROM `dbt`.`int_execution_tokens_supply_holders_daily` AS x1\n      WHERE 1=1 \n    )\n    AND toDate(b.date) >= (\n      SELECT addDays(max(toDate(x2.date)), -0)\n      FROM `dbt`.`int_execution_tokens_supply_holders_daily` AS x2\n      WHERE 1=1 \n    )\n  \n\n  \nGROUP BY b.date, b.token_address\nORDER BY b.date, b.token_address", "relation_name": "`dbt`.`int_execution_tokens_supply_holders_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.650540Z", "completed_at": "2026-02-12T22:49:49.756325Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.756935Z", "completed_at": "2026-02-12T22:49:49.756946Z"}], "thread_id": "Thread-1", "execution_time": 0.10787177085876465, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_tokens_balances_daily_date.a8a2d84af0", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_tokens_balances_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.759775Z", "completed_at": "2026-02-12T22:49:49.764775Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.765336Z", "completed_at": "2026-02-12T22:49:49.765344Z"}], "thread_id": "Thread-1", "execution_time": 0.0070018768310546875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_project_monthly_top5_date.52939ba037", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_active_accounts_by_project_monthly_top5`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.767990Z", "completed_at": "2026-02-12T22:49:49.772893Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.773474Z", "completed_at": "2026-02-12T22:49:49.773482Z"}], "thread_id": "Thread-1", "execution_time": 0.006738185882568359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_project_monthly_top5_date.3e677f077f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_by_project_monthly_top5`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.776158Z", "completed_at": "2026-02-12T22:49:49.780904Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.781491Z", "completed_at": "2026-02-12T22:49:49.781499Z"}], "thread_id": "Thread-1", "execution_time": 0.006661653518676758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_fees_native_by_project_monthly_top5_date.32ac91a2c0", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_fees_native_by_project_monthly_top5`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.784249Z", "completed_at": "2026-02-12T22:49:49.789029Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.789612Z", "completed_at": "2026-02-12T22:49:49.789619Z"}], "thread_id": "Thread-1", "execution_time": 0.006680011749267578, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_sector_daily_date.2ce83bd86d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_active_accounts_by_sector_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.792271Z", "completed_at": "2026-02-12T22:49:49.796823Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.797387Z", "completed_at": "2026-02-12T22:49:49.797394Z"}], "thread_id": "Thread-1", "execution_time": 0.006460428237915039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_sector_daily_date.7d6d9bbca5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_by_sector_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.800056Z", "completed_at": "2026-02-12T22:49:49.805951Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.806553Z", "completed_at": "2026-02-12T22:49:49.806561Z"}], "thread_id": "Thread-1", "execution_time": 0.007809638977050781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_fees_native_by_sector_daily_date.848e5f723c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_fees_native_by_sector_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.809210Z", "completed_at": "2026-02-12T22:49:49.813975Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.814558Z", "completed_at": "2026-02-12T22:49:49.814565Z"}], "thread_id": "Thread-1", "execution_time": 0.006616830825805664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_sector_weekly_date.e42928d899", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_active_accounts_by_sector_weekly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.817195Z", "completed_at": "2026-02-12T22:49:49.821668Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.822236Z", "completed_at": "2026-02-12T22:49:49.822243Z"}], "thread_id": "Thread-1", "execution_time": 0.006351947784423828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_sector_weekly_date.4bd3931428", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_by_sector_weekly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.824933Z", "completed_at": "2026-02-12T22:49:49.829620Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.830182Z", "completed_at": "2026-02-12T22:49:49.830189Z"}], "thread_id": "Thread-1", "execution_time": 0.0065937042236328125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_fees_native_by_sector_weekly_date.fde4f7e3e7", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_fees_native_by_sector_weekly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.832951Z", "completed_at": "2026-02-12T22:49:49.836953Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.837570Z", "completed_at": "2026-02-12T22:49:49.837578Z"}], "thread_id": "Thread-1", "execution_time": 0.005995988845825195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_project_ranges_top20", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT\n    t.window,\n    t.bucket,\n    toFloat64(t.value) AS value\n  FROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\n  WHERE t.label = 'ActiveAccounts'\n    AND t.window IN ('All','7D','30D','90D')\n    AND t.bucket IS NOT NULL\n),\nranked AS (\n  SELECT\n    window,\n    bucket,\n    value,\n    row_number() OVER (PARTITION BY window ORDER BY value DESC, bucket ASC) AS rn\n  FROM base\n)\nSELECT\n  window AS range,\n  if(rn <= 20, bucket, 'Others') AS label,\n  sum(value) AS value\nFROM ranked\nGROUP BY range, label\nHAVING value > 0\nORDER BY\n  multiIf(range = 'All', 1, range = '90D', 2, range = '30D', 3, range = '7D', 4, 5),\n  value DESC,\n  label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_project_ranges_top20`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.840320Z", "completed_at": "2026-02-12T22:49:49.845254Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.845865Z", "completed_at": "2026-02-12T22:49:49.845872Z"}], "thread_id": "Thread-1", "execution_time": 0.006901264190673828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_project_total", "compiled": true, "compiled_code": "\n\nSELECT bucket AS label, value\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` t\nWHERE t.label = 'ActiveAccounts' AND window = 'All'\nORDER BY value DESC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_project_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.848609Z", "completed_at": "2026-02-12T22:49:49.852597Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.853183Z", "completed_at": "2026-02-12T22:49:49.853190Z"}], "thread_id": "Thread-1", "execution_time": 0.005880117416381836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_project_ranges_top20", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT\n    t.window,\n    t.bucket,\n    toFloat64(t.value) AS value\n  FROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\n  WHERE t.label = 'Transactions'\n    AND t.window IN ('All','7D','30D','90D')\n    AND t.bucket IS NOT NULL\n),\nranked AS (\n  SELECT\n    window,\n    bucket,\n    value,\n    row_number() OVER (PARTITION BY window ORDER BY value DESC, bucket ASC) AS rn\n  FROM base\n)\nSELECT\n  window AS range,\n  if(rn <= 20, bucket, 'Others') AS label,\n  sum(value) AS value\nFROM ranked\nGROUP BY range, label\nHAVING value > 0\nORDER BY\n  multiIf(range = 'All', 1, range = '90D', 2, range = '30D', 3, range = '7D', 4, 5),\n  value DESC,\n  label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_project_ranges_top20`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.855852Z", "completed_at": "2026-02-12T22:49:49.859815Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.860404Z", "completed_at": "2026-02-12T22:49:49.860439Z"}], "thread_id": "Thread-1", "execution_time": 0.005860090255737305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_project_total", "compiled": true, "compiled_code": "\n\nSELECT t.bucket AS label, t.value\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'Transactions' AND t.window = 'All'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_by_project_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.863159Z", "completed_at": "2026-02-12T22:49:49.867119Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.867734Z", "completed_at": "2026-02-12T22:49:49.867741Z"}], "thread_id": "Thread-1", "execution_time": 0.005910396575927734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_project_ranges_top20", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT\n    t.window,\n    t.bucket,\n    toFloat64(t.value) AS value\n  FROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\n  WHERE t.label = 'FeesNative'\n    AND t.window IN ('All','7D','30D','90D')\n    AND t.bucket IS NOT NULL\n),\nranked AS (\n  SELECT\n    window,\n    bucket,\n    value,\n    row_number() OVER (PARTITION BY window ORDER BY value DESC, bucket ASC) AS rn\n  FROM base\n)\nSELECT\n  window AS range,\n  if(rn <= 20, bucket, 'Others') AS label,\n  sum(value) AS value\nFROM ranked\nGROUP BY range, label\nHAVING value > 0\nORDER BY\n  multiIf(range = 'All', 1, range = '90D', 2, range = '30D', 3, range = '7D', 4, 5),\n  value DESC,\n  label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_project_ranges_top20`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.870495Z", "completed_at": "2026-02-12T22:49:49.874468Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.875057Z", "completed_at": "2026-02-12T22:49:49.875064Z"}], "thread_id": "Thread-1", "execution_time": 0.005937337875366211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_project_total", "compiled": true, "compiled_code": "\n\nSELECT t.bucket AS label, t.value\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'FeesNative' AND t.window = 'All'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_project_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.877804Z", "completed_at": "2026-02-12T22:49:49.881788Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.882383Z", "completed_at": "2026-02-12T22:49:49.882391Z"}], "thread_id": "Thread-1", "execution_time": 0.005935192108154297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_7d", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'Transactions' AND window = '7D'", "relation_name": "`dbt`.`api_execution_transactions_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.885215Z", "completed_at": "2026-02-12T22:49:49.890456Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.891041Z", "completed_at": "2026-02-12T22:49:49.891048Z"}], "thread_id": "Thread-1", "execution_time": 0.007266044616699219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_7d", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'ActiveAccounts' AND window = '7D'", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.893861Z", "completed_at": "2026-02-12T22:49:49.897744Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.898332Z", "completed_at": "2026-02-12T22:49:49.898340Z"}], "thread_id": "Thread-1", "execution_time": 0.0058650970458984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_total", "compiled": true, "compiled_code": "\nSELECT value\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'ActiveAccounts' AND window = 'All'", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.901084Z", "completed_at": "2026-02-12T22:49:49.904986Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.905595Z", "completed_at": "2026-02-12T22:49:49.905603Z"}], "thread_id": "Thread-1", "execution_time": 0.005844831466674805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_7d", "compiled": true, "compiled_code": "\n\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'FeesNative' AND window = '7D'", "relation_name": "`dbt`.`api_execution_transactions_fees_native_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.908313Z", "completed_at": "2026-02-12T22:49:49.912170Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.912779Z", "completed_at": "2026-02-12T22:49:49.912786Z"}], "thread_id": "Thread-1", "execution_time": 0.005749702453613281, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_total", "compiled": true, "compiled_code": "\n\nSELECT value\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'FeesNative' AND window = 'All'", "relation_name": "`dbt`.`api_execution_transactions_fees_native_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.915523Z", "completed_at": "2026-02-12T22:49:49.919431Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.920019Z", "completed_at": "2026-02-12T22:49:49.920026Z"}], "thread_id": "Thread-1", "execution_time": 0.005867481231689453, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_total", "compiled": true, "compiled_code": "\n\nSELECT value\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'Transactions' AND window = 'All'", "relation_name": "`dbt`.`api_execution_transactions_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.922771Z", "completed_at": "2026-02-12T22:49:49.926923Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.927526Z", "completed_at": "2026-02-12T22:49:49.927534Z"}], "thread_id": "Thread-1", "execution_time": 0.006048917770385742, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_emissions_annualised_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    annual_co2_tonnes_projected\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date DESC \nLIMIT 1", "relation_name": "`dbt`.`api_esg_carbon_emissions_annualised_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.930253Z", "completed_at": "2026-02-12T22:49:49.935870Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.936486Z", "completed_at": "2026-02-12T22:49:49.936493Z"}], "thread_id": "Thread-1", "execution_time": 0.00757598876953125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_emissions_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    AVG(daily_co2_kg_mean) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_value,\n    AVG(daily_co2_kg_lower_90) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_90,\n    AVG(daily_co2_kg_upper_90) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_90,\n    AVG(daily_co2_kg_lower_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_95,\n    AVG(daily_co2_kg_upper_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_95\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date", "relation_name": "`dbt`.`api_esg_carbon_emissions_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.939344Z", "completed_at": "2026-02-12T22:49:49.943294Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.943921Z", "completed_at": "2026-02-12T22:49:49.943929Z"}], "thread_id": "Thread-1", "execution_time": 0.006036520004272461, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_timeseries_bands", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    daily_co2_kg_mean AS value,\n    daily_co2_kg_lower_95 AS lower_95,\n    daily_co2_kg_upper_95 AS upper_95,\n    daily_co2_kg_lower_90 AS lower_90,\n    daily_co2_kg_upper_90 AS upper_90,\n    \n    -- Moving averages for smoothing\n    AVG(daily_co2_kg_mean) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_value,\n    AVG(daily_co2_kg_lower_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_95,\n    AVG(daily_co2_kg_upper_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_95,\n    \n    -- Month-to-date statistics\n    AVG(daily_co2_kg_mean) OVER (PARTITION BY toStartOfMonth(date) ORDER BY date) AS mtd_avg,\n    SUM(daily_co2_kg_mean) OVER (PARTITION BY toStartOfMonth(date) ORDER BY date) AS mtd_total\n    \nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`", "relation_name": "`dbt`.`api_esg_carbon_timeseries_bands`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.946771Z", "completed_at": "2026-02-12T22:49:49.951069Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.951673Z", "completed_at": "2026-02-12T22:49:49.951681Z"}], "thread_id": "Thread-1", "execution_time": 0.006192922592163086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_cif_network_vs_countries_daily", "compiled": true, "compiled_code": "\n\n\nWITH network_daily_cif AS (\n    -- Get network's daily effective carbon intensity\n    SELECT\n        date,\n        effective_carbon_intensity AS carbon_intensity,\n        'GNOSIS' AS entity_code\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE effective_carbon_intensity IS NOT NULL\n        AND effective_carbon_intensity > 0\n),\n\ncountry_monthly_cif AS (\n    -- Get all monthly country carbon intensities \n    SELECT\n        ci.country_code,\n        ci.carbon_intensity_mean AS carbon_intensity,\n        ci.month_date\n    FROM `dbt`.`int_esg_carbon_intensity_ensemble` ci\n    WHERE ci.country_code != 'WORLD'\n        AND ci.carbon_intensity_mean IS NOT NULL\n        AND ci.carbon_intensity_mean > 0\n        AND ci.country_code IN (\n            'USA',  -- United States\n            'DEU',  -- Germany  \n            'CHN',  -- China\n            'FRA',  -- France\n            'SWE',  -- Sweden \n            'AUS',  -- Australia\n            'BRA',  -- Brazil\n            'ISL'   -- Iceland\n        )\n),\n\ncountry_timeseries AS (\n    -- Join countries to dates using the correct month's CIF\n    SELECT\n        nd.date,\n        cm.carbon_intensity,\n        cm.country_code AS entity_code\n    FROM network_daily_cif nd\n    JOIN country_monthly_cif cm \n        ON cm.month_date = toStartOfMonth(nd.date)  -- Match date to its month\n),\n\n-- Combine network and country data\ncombined_data AS (\n    SELECT * FROM network_daily_cif\n    UNION ALL\n    SELECT * FROM country_timeseries\n),\n\n-- Add comparison metrics\nwith_comparisons AS (\n    SELECT\n        cd.*,\n        nd.carbon_intensity AS network_cif\n    FROM combined_data cd\n    LEFT JOIN network_daily_cif nd ON cd.date = nd.date\n)\n\nSELECT\n    date,\n    entity_code,\n    round(carbon_intensity, 1) AS carbon_intensity_gco2_kwh\nFROM with_comparisons\nORDER BY date, entity_code, carbon_intensity_gco2_kwh DESC", "relation_name": "`dbt`.`api_esg_cif_network_vs_countries_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.954483Z", "completed_at": "2026-02-12T22:49:49.958315Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.958917Z", "completed_at": "2026-02-12T22:49:49.958924Z"}], "thread_id": "Thread-1", "execution_time": 0.005872011184692383, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_energy_consumption_annualised_latest", "compiled": true, "compiled_code": "\n\n\nSELECT\n    annual_energy_Mwh_projected\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nORDER BY date DESC \nLIMIT 1", "relation_name": "`dbt`.`api_esg_energy_consumption_annualised_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.961662Z", "completed_at": "2026-02-12T22:49:49.965527Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.966112Z", "completed_at": "2026-02-12T22:49:49.966120Z"}], "thread_id": "Thread-1", "execution_time": 0.005828857421875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_energy_monthly", "compiled": true, "compiled_code": "\n\n\nSELECT toStartOfMonth(date) AS date, SUM(daily_energy_kwh_total) AS value\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nGROUP BY 1\nORDER BY date", "relation_name": "`dbt`.`api_esg_energy_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.968948Z", "completed_at": "2026-02-12T22:49:49.972914Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.973522Z", "completed_at": "2026-02-12T22:49:49.973529Z"}], "thread_id": "Thread-1", "execution_time": 0.0058727264404296875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_estimated_nodes_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT \n    date\n    ,baseline_observed_nodes\n    ,estimated_nodes\n    ,nodes_lower_95\n    ,nodes_upper_95\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date", "relation_name": "`dbt`.`api_esg_estimated_nodes_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.976196Z", "completed_at": "2026-02-12T22:49:49.981933Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.982584Z", "completed_at": "2026-02-12T22:49:49.982592Z"}], "thread_id": "Thread-1", "execution_time": 0.007676601409912109, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_info_annual_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,label\n    ,mean_val\n    ,lower_95\n    ,upper_95\n    ,lower_90\n    ,upper_90\nFROM (\n    SELECT \n        date\n        ,'Energy (MWh)' AS label\n        ,annual_energy_Mwh_projected AS mean_val\n        ,annual_energy_mwh_lower_95 AS lower_95\n        ,annual_energy_mwh_upper_95 AS upper_95\n        ,annual_energy_mwh_lower_90 AS lower_90\n        ,annual_energy_mwh_upper_90 AS upper_90\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT \n        date\n        ,'CO2e (tonnes)' AS label\n        ,annual_co2_tonnes_projected AS mean_val\n        ,annual_co2_tonnes_lower_95 AS lower_95\n        ,annual_co2_tonnes_upper_95 AS upper_95\n        ,annual_co2_tonnes_lower_90 AS lower_90\n        ,annual_co2_tonnes_upper_90 AS upper_90\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_esg_info_annual_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.985378Z", "completed_at": "2026-02-12T22:49:49.992167Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:49.992797Z", "completed_at": "2026-02-12T22:49:49.992804Z"}], "thread_id": "Thread-1", "execution_time": 0.008825302124023438, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_info_category_daily", "compiled": true, "compiled_code": "\n\n\n\n\nSELECT \n    date\n    ,label\n    ,category\n    ,value\nFROM (\n    SELECT date, 'Home Staker' AS label, 'CO2e (kg)' AS category, home_staker_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'CO2e (kg)' AS category, professional_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'CO2e (kg)' AS category, cloud_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'CO2e (kg)' AS category, unknown_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n\n    UNION ALL \n\n    SELECT date, 'Home Staker' AS label, 'Energy (kWh)' AS category, home_staker_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'Energy (kWh)' AS category, professional_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'Energy (kWh)' AS category, cloud_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'Energy (kWh)' AS category, unknown_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n\n    UNION ALL \n\n    SELECT date, 'Home Staker' AS label, 'Nodes' AS category, CAST(home_staker_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'Nodes' AS category, CAST(professional_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'Nodes' AS category, CAST(cloud_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'Nodes' AS category, CAST(unknown_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n)\nORDER BY date, label, category", "relation_name": "`dbt`.`api_esg_info_category_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:49.995687Z", "completed_at": "2026-02-12T22:49:50.000226Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.000814Z", "completed_at": "2026-02-12T22:49:50.000822Z"}], "thread_id": "Thread-1", "execution_time": 0.006444215774536133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_esg_carbon_footprint_uncertainty_date.7d5415c9ba", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_esg_carbon_footprint_uncertainty`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.003445Z", "completed_at": "2026-02-12T22:49:50.010096Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.010680Z", "completed_at": "2026-02-12T22:49:50.010687Z"}], "thread_id": "Thread-1", "execution_time": 0.008494853973388672, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_yields_pools_daily", "compiled": true, "compiled_code": "\n\nWITH\nbalances_base AS (\n    SELECT\n        toDate(b.date) AS date,\n        b.protocol AS protocol,\n        lower(b.pool_address) AS pool_address_raw,\n        lower(b.token_address) AS token_address,\n        b.token_amount AS token_amount\n    FROM `dbt`.`int_execution_pools_balances_daily` b\n    WHERE b.date < today()\n),\n\nbalances_canon AS (\n    SELECT\n        date,\n        protocol,\n        multiIf(\n            startsWith(pool_address_raw, '0x'),\n            pool_address_raw,\n            concat('0x', pool_address_raw)\n        ) AS pool_address,\n        replaceAll(\n            multiIf(\n                startsWith(pool_address_raw, '0x'),\n                pool_address_raw,\n                concat('0x', pool_address_raw)\n            ),\n            '0x',\n            ''\n        ) AS pool_address_no0x,\n        token_address,\n        token_amount\n    FROM balances_base\n),\n\ntoken_meta AS (\n    SELECT\n        lower(address) AS token_address,\n        nullIf(upper(trimBoth(symbol)), '') AS token,\n        decimals,\n        date_start,\n        date_end\n    FROM `dbt`.`tokens_whitelist`\n),\n\nprices AS (\n    SELECT\n        toDate(date) AS date,\n        nullIf(upper(trimBoth(symbol)), '') AS token,\n        toFloat64(price) AS price_usd\n    FROM `dbt`.`int_execution_token_prices_daily`\n    WHERE date < today()\n),\n\nbalances_enriched AS (\n    SELECT\n        b.date AS date,\n        b.protocol AS protocol,\n        b.pool_address AS pool_address,\n        b.pool_address_no0x AS pool_address_no0x,\n        b.token_address AS token_address,\n        tm.token AS token,\n        b.token_amount AS token_amount,\n        p.price_usd AS price_usd,\n        b.token_amount * coalesce(p.price_usd, 0) AS tvl_component_usd\n    FROM balances_canon b\n    LEFT JOIN token_meta tm\n      ON tm.token_address = b.token_address\n     AND b.date >= toDate(tm.date_start)\n     AND (tm.date_end IS NULL OR b.date < toDate(tm.date_end))\n    LEFT JOIN prices p\n      ON p.date = b.date\n     AND p.token = tm.token\n),\n\ntoken_pool_tvl_daily AS (\n    SELECT\n        date,\n        protocol,\n        pool_address,\n        token_address,\n        token,\n        sum(tvl_component_usd) AS token_tvl_usd\n    FROM balances_enriched\n    WHERE protocol IN ('Uniswap V3', 'Swapr V3')\n      AND token IS NOT NULL\n      AND token != ''\n    GROUP BY date, protocol, pool_address, token_address, token\n),\n\ntoken_pool_tvl_scored AS (\n    SELECT\n        date,\n        protocol,\n        pool_address,\n        token_address,\n        token,\n        token_tvl_usd,\n        avg(token_tvl_usd) OVER (\n            PARTITION BY protocol, pool_address, token_address\n            ORDER BY date\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS token_tvl_usd_30d_avg\n    FROM token_pool_tvl_daily\n),\n\ntop_pools_by_token AS (\n    SELECT\n        token,\n        protocol,\n        pool_address,\n        token_address\n    FROM (\n        SELECT\n            token,\n            protocol,\n            pool_address,\n            token_address,\n            token_tvl_usd_30d_avg,\n            row_number() OVER (\n                PARTITION BY token\n                ORDER BY token_tvl_usd_30d_avg DESC, protocol, pool_address\n            ) AS pool_rank\n        FROM (\n            SELECT\n                *,\n                max(date) OVER (PARTITION BY token) AS latest_date_for_token\n            FROM token_pool_tvl_scored\n        )\n        WHERE date = latest_date_for_token\n          AND token_tvl_usd_30d_avg >= 1000\n    )\n    WHERE pool_rank <= 5\n),\n\npool_tvl_daily AS (\n    SELECT\n        date,\n        protocol,\n        pool_address,\n        any(pool_address_no0x) AS pool_address_no0x,\n        sum(tvl_component_usd) AS tvl_usd\n    FROM balances_enriched\n    GROUP BY date, protocol, pool_address\n),\n\nuniswap_v3_pools AS (\n    SELECT DISTINCT\n        replaceAll(lower(decoded_params['pool']), '0x', '') AS pool_address_no0x,\n        lower(decoded_params['token0']) AS token0_address,\n        lower(decoded_params['token1']) AS token1_address,\n        'Uniswap V3' AS protocol\n    FROM `dbt`.`contracts_UniswapV3_Factory_events`\n    WHERE event_name = 'PoolCreated'\n      AND decoded_params['pool'] IS NOT NULL\n      AND decoded_params['token0'] IS NOT NULL\n      AND decoded_params['token1'] IS NOT NULL\n),\n\nswapr_v3_pools AS (\n    SELECT DISTINCT\n        replaceAll(lower(decoded_params['pool']), '0x', '') AS pool_address_no0x,\n        lower(decoded_params['token0']) AS token0_address,\n        lower(decoded_params['token1']) AS token1_address,\n        'Swapr V3' AS protocol\n    FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_events`\n    WHERE event_name = 'Pool'\n      AND decoded_params['pool'] IS NOT NULL\n      AND decoded_params['token0'] IS NOT NULL\n      AND decoded_params['token1'] IS NOT NULL\n),\n\nv3_pool_meta AS (\n    SELECT * FROM uniswap_v3_pools\n    UNION ALL\n    SELECT * FROM swapr_v3_pools\n),\n\npool_symbol_lists AS (\n    SELECT\n        protocol,\n        pool_address,\n        arraySort(groupUniqArray(token)) AS tokens_sorted,\n        countDistinct(token) AS tokens_cnt\n    FROM (\n        SELECT\n            protocol,\n            pool_address,\n            token\n        FROM balances_enriched\n        WHERE token IS NOT NULL\n          AND token != ''\n    )\n    GROUP BY protocol, pool_address\n),\n\npool_labels AS (\n    SELECT\n        p.protocol AS protocol,\n        p.pool_address AS pool_address,\n        -- Default label for Balancer or unknown: sym1/sym2/sym3(+N) \u2022 protocol \u2022 0x\u2026suffix\n        multiIf(\n            p.protocol IN ('Uniswap V3', 'Swapr V3'),\n            concat(\n                coalesce(t0.token, 'UNK'),\n                '/',\n                coalesce(t1.token, 'UNK'),\n                ' \u2022 ',\n                p.protocol,\n                ' \u2022 ',\n                right(p.pool_address, 6)\n            ),\n            concat(\n                arrayStringConcat(arraySlice(sl.tokens_sorted, 1, 3), '/'),\n                if(sl.tokens_cnt > 3, concat('(+', toString(sl.tokens_cnt - 3), ')'), ''),\n                ' \u2022 ',\n                p.protocol,\n                ' \u2022 ',\n                right(p.pool_address, 6)\n            )\n        ) AS pool\n    FROM (\n        SELECT DISTINCT protocol, pool_address FROM balances_canon\n    ) p\n    LEFT JOIN v3_pool_meta m\n      ON m.protocol = p.protocol\n     AND m.pool_address_no0x = replaceAll(lower(p.pool_address), '0x', '')\n    LEFT JOIN token_meta t0\n      ON t0.token_address = m.token0_address\n    LEFT JOIN token_meta t1\n      ON t1.token_address = m.token1_address\n    LEFT JOIN pool_symbol_lists sl\n      ON sl.protocol = p.protocol\n     AND sl.pool_address = p.pool_address\n),\n\n-- Accrued fees (gross) from Swap + Flash events (Uniswap V3 + Swapr V3 only)\nfees_usd_daily AS (\n    SELECT\n        date,\n        protocol,\n        pool_address,\n        sum(fees_usd) AS fees_usd_daily\n    FROM `dbt`.`int_execution_yields_pools_fees_daily`\n    WHERE date < today()\n    GROUP BY date, protocol, pool_address\n),\n\npool_metrics_daily AS (\n    SELECT\n        t.date,\n        t.protocol,\n        t.pool_address,\n        t.tvl_usd,\n        coalesce(f.fees_usd_daily, 0) AS fees_usd_daily,\n        sum(coalesce(f.fees_usd_daily, 0)) OVER (\n            PARTITION BY t.protocol, t.pool_address\n            ORDER BY t.date\n            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW\n        ) AS fees_usd_7d,\n        avg(t.tvl_usd) OVER (\n            PARTITION BY t.protocol, t.pool_address\n            ORDER BY t.date\n            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW\n        ) AS tvl_usd_7d_avg\n    FROM pool_tvl_daily t\n    LEFT JOIN fees_usd_daily f\n      ON f.date = t.date\n     AND f.protocol = t.protocol\n     AND f.pool_address = t.pool_address\n),\n\npool_metrics_final AS (\n    SELECT\n        date,\n        protocol,\n        pool_address,\n        tvl_usd,\n        fees_usd_daily,\n        multiIf(\n            protocol IN ('Uniswap V3', 'Swapr V3') AND tvl_usd_7d_avg > 0,\n            (fees_usd_7d / tvl_usd_7d_avg) * (365.0 / 7.0) * 100.0,\n            NULL\n        ) AS fee_apr_7d\n    FROM pool_metrics_daily\n),\n\nfinal AS (\n    SELECT\n        b.date AS date,\n        b.protocol AS protocol,\n        b.pool_address AS pool_address,\n        pl.pool AS pool,\n        b.token_address AS token_address,\n        b.token AS token,\n        pm.tvl_usd AS tvl_usd,\n        pm.fees_usd_daily AS fees_usd_daily,\n        pm.fee_apr_7d AS fee_apr_7d\n    FROM (\n        SELECT DISTINCT\n            date,\n            protocol,\n            pool_address,\n            token_address,\n            token\n        FROM balances_enriched\n        WHERE token IS NOT NULL\n          AND token != ''\n    ) b\n    INNER JOIN top_pools_by_token tp\n      ON tp.token = b.token\n     AND tp.protocol = b.protocol\n     AND tp.pool_address = b.pool_address\n     AND tp.token_address = b.token_address\n    LEFT JOIN pool_labels pl\n      ON pl.protocol = b.protocol\n     AND pl.pool_address = b.pool_address\n    LEFT JOIN pool_metrics_final pm\n      ON pm.date = b.date\n     AND pm.protocol = b.protocol\n     AND pm.pool_address = b.pool_address\n    WHERE b.protocol IN ('Uniswap V3', 'Swapr V3')\n)\n\nSELECT\n    date,\n    protocol,\n    pool_address,\n    pool,\n    token_address,\n    token,\n    tvl_usd,\n    fees_usd_daily,\n    fee_apr_7d\nFROM final\nWHERE date < today()", "relation_name": "`dbt`.`fct_execution_yields_pools_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.013484Z", "completed_at": "2026-02-12T22:49:50.017688Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.018297Z", "completed_at": "2026-02-12T22:49:50.018304Z"}], "thread_id": "Thread-1", "execution_time": 0.00624394416809082, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_balance_cohorts_holders_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  symbol                         AS token,   \n  cohort_unit,\n  balance_bucket                 AS label,   \n  holders_in_bucket              AS value    \nFROM `dbt`.`int_execution_tokens_balance_cohorts_daily`\nWHERE date < today()\nORDER BY\n  date,\n  token,\n  cohort_unit,\n  label", "relation_name": "`dbt`.`api_execution_tokens_balance_cohorts_holders_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.021129Z", "completed_at": "2026-02-12T22:49:50.026224Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.026833Z", "completed_at": "2026-02-12T22:49:50.026841Z"}], "thread_id": "Thread-1", "execution_time": 0.0069849491119384766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_balance_cohorts_value_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  symbol                         AS token,   \n  cohort_unit,\n  balance_bucket                 AS label,   \n  value_native_in_bucket         AS value_native,\n  value_usd_in_bucket            AS value_usd\nFROM `dbt`.`int_execution_tokens_balance_cohorts_daily`\nWHERE date < today()\nORDER BY\n  date,\n  token,\n  cohort_unit,\n  label", "relation_name": "`dbt`.`api_execution_tokens_balance_cohorts_value_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.029575Z", "completed_at": "2026-02-12T22:49:50.034756Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.035320Z", "completed_at": "2026-02-12T22:49:50.035328Z"}], "thread_id": "Thread-1", "execution_time": 0.007008075714111328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.accepted_values_int_execution_tokens_balance_cohorts_daily_cohort_unit__usd__native.214140e418", "compiled": true, "compiled_code": "\n    \n    \n\nwith all_values as (\n\n    select\n        cohort_unit as value_field,\n        count(*) as n_records\n\n    from `dbt`.`int_execution_tokens_balance_cohorts_daily`\n    group by cohort_unit\n\n)\n\nselect *\nfrom all_values\nwhere value_field not in (\n    'usd','native'\n)\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.037968Z", "completed_at": "2026-02-12T22:49:50.042557Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.043129Z", "completed_at": "2026-02-12T22:49:50.043137Z"}], "thread_id": "Thread-1", "execution_time": 0.00641942024230957, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_tokens_balance_cohorts_daily_cohort_unit.143e351ede", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect cohort_unit\nfrom `dbt`.`int_execution_tokens_balance_cohorts_daily`\nwhere cohort_unit is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.045775Z", "completed_at": "2026-02-12T22:49:50.050339Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.050944Z", "completed_at": "2026-02-12T22:49:50.050952Z"}], "thread_id": "Thread-1", "execution_time": 0.0064220428466796875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_tokens_balance_cohorts_daily_date.b1a8f01b8d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_tokens_balance_cohorts_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.053597Z", "completed_at": "2026-02-12T22:49:50.058146Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.058733Z", "completed_at": "2026-02-12T22:49:50.058741Z"}], "thread_id": "Thread-1", "execution_time": 0.006386756896972656, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_tokens_balances_by_sector_daily_date.2d3da0b35e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_tokens_balances_by_sector_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.061380Z", "completed_at": "2026-02-12T22:49:50.066441Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.067009Z", "completed_at": "2026-02-12T22:49:50.067017Z"}], "thread_id": "Thread-1", "execution_time": 0.006887912750244141, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_tokens_metrics_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nsupply_holders AS (\n    SELECT\n        date,\n        token_address,\n        symbol,\n        token_class,\n        supply,\n        holders\n    FROM `dbt`.`int_execution_tokens_supply_holders_daily`\n    WHERE date < today()\n),\n\ntransfers AS (\n    SELECT\n        t.date,\n        t.token_address,\n        t.symbol,\n        t.token_class,\n        t.volume_token,\n        t.transfer_count,\n        t.ua_bitmap_state,\n        t.active_senders,\n        t.unique_receivers\n    FROM `dbt`.`int_execution_tokens_transfers_daily` t\n    WHERE t.date < today()\n),\n\nprices AS (\n    SELECT\n        date,\n        symbol,\n        price AS price_usd\n    FROM `dbt`.`int_execution_token_prices_daily`\n    WHERE date < today()\n),\n\njoined AS (\n    SELECT\n        coalesce(sh.date, t.date) AS date,\n        coalesce(sh.token_address, t.token_address) AS token_address,\n        coalesce(sh.symbol, t.symbol) AS symbol,\n        coalesce(sh.token_class, t.token_class) AS token_class,\n\n        sh.supply,\n        sh.supply * COALESCE(p.price_usd, 0) AS supply_usd,\n        sh.holders,\n\n        t.volume_token,\n        t.volume_token * COALESCE(p.price_usd, 0) AS volume_usd,\n        t.transfer_count,\n        t.ua_bitmap_state,\n        t.active_senders,\n        t.unique_receivers\n    FROM supply_holders sh\n    FULL OUTER JOIN transfers t\n      ON sh.date = t.date\n     AND sh.token_address = t.token_address\n\n    LEFT JOIN prices p\n      ON p.date = coalesce(sh.date, t.date)\n     AND upper(p.symbol) = upper(coalesce(sh.symbol, t.symbol))\n)\n\nSELECT\n    date,\n    token_address,\n    symbol,\n    token_class,\n\n    supply,\n    supply_usd,\n    holders,\n\n    volume_token,\n    volume_usd,\n    transfer_count,\n    ua_bitmap_state,\n    active_senders,\n    unique_receivers\nFROM joined\nWHERE date < today()\nORDER BY date, token_address", "relation_name": "`dbt`.`fct_execution_tokens_metrics_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.070039Z", "completed_at": "2026-02-12T22:49:50.076149Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.076741Z", "completed_at": "2026-02-12T22:49:50.076749Z"}], "thread_id": "Thread-1", "execution_time": 0.0082550048828125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_tokens_supply_holders_daily_date.170bf063e0", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_tokens_supply_holders_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.079385Z", "completed_at": "2026-02-12T22:49:50.083965Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.084548Z", "completed_at": "2026-02-12T22:49:50.084555Z"}], "thread_id": "Thread-1", "execution_time": 0.006426572799682617, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_carbon_emissions_daily_date.51296759dc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_carbon_emissions_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.087186Z", "completed_at": "2026-02-12T22:49:50.091624Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.092188Z", "completed_at": "2026-02-12T22:49:50.092195Z"}], "thread_id": "Thread-1", "execution_time": 0.0062601566314697266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_carbon_timeseries_bands_date.bd7a9a51aa", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_carbon_timeseries_bands`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.094852Z", "completed_at": "2026-02-12T22:49:50.099268Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.099853Z", "completed_at": "2026-02-12T22:49:50.099860Z"}], "thread_id": "Thread-1", "execution_time": 0.0062754154205322266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_cif_network_vs_countries_daily_date.efb633caf8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_cif_network_vs_countries_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.102490Z", "completed_at": "2026-02-12T22:49:50.106910Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.107488Z", "completed_at": "2026-02-12T22:49:50.107496Z"}], "thread_id": "Thread-1", "execution_time": 0.006262779235839844, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_energy_monthly_date.8745f6e20b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_energy_monthly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.110105Z", "completed_at": "2026-02-12T22:49:50.115687Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.116250Z", "completed_at": "2026-02-12T22:49:50.116258Z"}], "thread_id": "Thread-1", "execution_time": 0.0074045658111572266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_estimated_nodes_daily_date.2276da231f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_estimated_nodes_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.118984Z", "completed_at": "2026-02-12T22:49:50.123441Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.124003Z", "completed_at": "2026-02-12T22:49:50.124010Z"}], "thread_id": "Thread-1", "execution_time": 0.006355762481689453, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_info_annual_daily_date.506342e106", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_info_annual_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.126654Z", "completed_at": "2026-02-12T22:49:50.131267Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.131856Z", "completed_at": "2026-02-12T22:49:50.131864Z"}], "thread_id": "Thread-1", "execution_time": 0.0064623355865478516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_esg_info_category_daily_date.26de97e343", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_esg_info_category_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.134509Z", "completed_at": "2026-02-12T22:49:50.138457Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.139022Z", "completed_at": "2026-02-12T22:49:50.139029Z"}], "thread_id": "Thread-1", "execution_time": 0.005835294723510742, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_pools_fee_apr_7d_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    token,\n    pool AS label,\n    'Fee APR (7D trailing)' AS apy_type,\n    fee_apr_7d AS value\nFROM `dbt`.`fct_execution_yields_pools_daily`\nWHERE fee_apr_7d IS NOT NULL\n  AND token IS NOT NULL\n  AND token != ''\n  AND date < today()\nORDER BY date DESC, token, label", "relation_name": "`dbt`.`api_execution_yields_pools_fee_apr_7d_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.142024Z", "completed_at": "2026-02-12T22:49:50.146290Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.146868Z", "completed_at": "2026-02-12T22:49:50.146875Z"}], "thread_id": "Thread-1", "execution_time": 0.006154775619506836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_pools_tvl_by_pool_latest", "compiled": true, "compiled_code": "\n\nWITH latest_date AS (\n    SELECT max(date) AS max_date\n    FROM `dbt`.`fct_execution_yields_pools_daily`\n    WHERE date < today()\n)\n\nSELECT\n    f.token,\n    f.pool AS label,\n    f.tvl_usd AS value\nFROM `dbt`.`fct_execution_yields_pools_daily` f\nCROSS JOIN latest_date d\nWHERE f.date = d.max_date\n  AND f.token IS NOT NULL\n  AND f.token != ''\n  AND f.tvl_usd IS NOT NULL\n  AND f.tvl_usd > 0\nORDER BY f.token, f.tvl_usd DESC", "relation_name": "`dbt`.`api_execution_yields_pools_tvl_by_pool_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.149486Z", "completed_at": "2026-02-12T22:49:50.153487Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.154052Z", "completed_at": "2026-02-12T22:49:50.154059Z"}], "thread_id": "Thread-1", "execution_time": 0.005828380584716797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_pools_tvl_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    token,\n    pool AS label,\n    'TVL (USD)' AS tvl_type,\n    tvl_usd AS value\nFROM `dbt`.`fct_execution_yields_pools_daily`\nWHERE tvl_usd IS NOT NULL\n  AND token IS NOT NULL\n  AND token != ''\n  AND date < today()\nORDER BY date DESC, token, label", "relation_name": "`dbt`.`api_execution_yields_pools_tvl_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.156696Z", "completed_at": "2026-02-12T22:49:50.163144Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.163727Z", "completed_at": "2026-02-12T22:49:50.163734Z"}], "thread_id": "Thread-1", "execution_time": 0.008283853530883789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_yields_opportunities_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    type,\n    name,\n    yield_pct,\n    borrow_apy,\n    tvl,\n    protocol\nFROM (\n    WITH\n    \n    pools_latest_date AS (\n        SELECT max(date) AS max_date\n        FROM `dbt`.`fct_execution_yields_pools_daily`\n        WHERE date < today()\n    ),\n    \n    lp_pools AS (\n        SELECT\n            'LP' AS type,\n            f.pool AS name,\n            f.fee_apr_7d AS yield_pct,\n            NULL AS borrow_apy,\n            f.tvl_usd AS tvl,\n            f.protocol AS protocol\n        FROM `dbt`.`fct_execution_yields_pools_daily` f\n        CROSS JOIN pools_latest_date d\n        WHERE f.date = d.max_date\n          AND f.fee_apr_7d IS NOT NULL\n          AND f.pool IS NOT NULL\n    ),\n    \n    lp_pools_dedup AS (\n        SELECT\n            type,\n            name,\n            yield_pct,\n            borrow_apy,\n            tvl,\n            protocol\n        FROM (\n            SELECT\n                *,\n                row_number() OVER (PARTITION BY name ORDER BY tvl DESC) AS rn\n            FROM lp_pools\n        )\n        WHERE rn = 1\n    ),\n    \n    \n    lending_latest_date AS (\n        SELECT max(date) AS max_date\n        FROM `dbt`.`int_execution_yields_aave_daily`\n        WHERE date < today()\n    ),\n    \n    lending_markets AS (\n        SELECT\n            'Lending' AS type,\n            a.symbol AS name,\n            a.apy_daily AS yield_pct,\n            a.borrow_apy_variable_daily AS borrow_apy,\n            NULL AS tvl,\n            a.protocol AS protocol\n        FROM `dbt`.`int_execution_yields_aave_daily` a\n        CROSS JOIN lending_latest_date d\n        WHERE a.date = d.max_date\n          AND a.apy_daily IS NOT NULL\n          AND a.apy_daily > 0\n    )\n    \n    \n    SELECT type, name, yield_pct, borrow_apy, tvl, protocol\n    FROM lp_pools_dedup\n    \n    UNION ALL\n    \n    SELECT type, name, yield_pct, borrow_apy, tvl, protocol\n    FROM lending_markets\n)\nORDER BY yield_pct DESC", "relation_name": "`dbt`.`fct_execution_yields_opportunities_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.166490Z", "completed_at": "2026-02-12T22:49:50.171941Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.172519Z", "completed_at": "2026-02-12T22:49:50.172527Z"}], "thread_id": "Thread-1", "execution_time": 0.007461071014404297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_yields_pools_snapshots", "compiled": true, "compiled_code": "\n\n\nSELECT\n    token,\n    metric,\n    value,\n    change_pct\nFROM (\n    WITH\n    token_latest_dates AS (\n        SELECT\n            token,\n            max(date) AS token_max_date\n        FROM `dbt`.`fct_execution_yields_pools_daily`\n        WHERE date < today()\n          AND token IS NOT NULL\n          AND token != ''\n        GROUP BY token\n    ),\n\n    tvl_latest AS (\n        SELECT\n            f.token,\n            sum(f.tvl_usd) AS tvl_usd\n        FROM `dbt`.`fct_execution_yields_pools_daily` f\n        INNER JOIN token_latest_dates tld ON tld.token = f.token AND f.date = tld.token_max_date\n        WHERE f.token IS NOT NULL\n          AND f.token != ''\n        GROUP BY f.token\n    ),\n\n    tvl_7d_ago AS (\n        SELECT\n            f.token,\n            sum(f.tvl_usd) AS tvl_usd\n        FROM `dbt`.`fct_execution_yields_pools_daily` f\n        INNER JOIN token_latest_dates tld ON tld.token = f.token AND f.date = tld.token_max_date - INTERVAL 7 DAY\n        WHERE f.token IS NOT NULL\n          AND f.token != ''\n        GROUP BY f.token\n    ),\n\n    fees_7d AS (\n        SELECT\n            f.token,\n            sum(f.fees_usd_daily) AS fees_usd\n        FROM `dbt`.`fct_execution_yields_pools_daily` f\n        INNER JOIN token_latest_dates tld ON tld.token = f.token\n        WHERE f.date > tld.token_max_date - INTERVAL 7 DAY\n          AND f.date <= tld.token_max_date\n          AND f.token IS NOT NULL\n          AND f.token != ''\n        GROUP BY f.token\n    ),\n\n    fees_prior_7d AS (\n        SELECT\n            f.token,\n            sum(f.fees_usd_daily) AS fees_usd\n        FROM `dbt`.`fct_execution_yields_pools_daily` f\n        INNER JOIN token_latest_dates tld ON tld.token = f.token\n        WHERE f.date > tld.token_max_date - INTERVAL 14 DAY\n          AND f.date <= tld.token_max_date - INTERVAL 7 DAY\n          AND f.token IS NOT NULL\n          AND f.token != ''\n        GROUP BY f.token\n    ),\n\n    combined AS (\n        SELECT\n            tld.token AS token,\n            tl.tvl_usd AS tvl_latest,\n            t7.tvl_usd AS tvl_7d_ago,\n            f7.fees_usd AS fees_7d,\n            fp.fees_usd AS fees_prior_7d\n        FROM token_latest_dates tld\n        LEFT JOIN tvl_latest tl ON tl.token = tld.token\n        LEFT JOIN tvl_7d_ago t7 ON t7.token = tld.token\n        LEFT JOIN fees_7d f7 ON f7.token = tld.token\n        LEFT JOIN fees_prior_7d fp ON fp.token = tld.token\n    )\n\n    SELECT\n        token,\n        'TVL_Latest' AS metric,\n        tvl_latest AS value,\n        round(\n            CASE\n                WHEN tvl_7d_ago IS NULL OR tvl_7d_ago = 0 THEN NULL\n                ELSE ((tvl_latest / tvl_7d_ago) - 1) * 100\n            END,\n            2\n        ) AS change_pct\n    FROM combined\n    WHERE tvl_latest IS NOT NULL\n\n    UNION ALL\n\n    SELECT\n        token,\n        'Fees_7D' AS metric,\n        fees_7d AS value,\n        round(\n            CASE\n                WHEN fees_prior_7d IS NULL OR fees_prior_7d = 0 THEN NULL\n                ELSE ((fees_7d / fees_prior_7d) - 1) * 100\n            END,\n            2\n        ) AS change_pct\n    FROM combined\n    WHERE fees_7d IS NOT NULL\n)", "relation_name": "`dbt`.`fct_execution_yields_pools_snapshots`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.175301Z", "completed_at": "2026-02-12T22:49:50.180194Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.180804Z", "completed_at": "2026-02-12T22:49:50.180812Z"}], "thread_id": "Thread-1", "execution_time": 0.006841421127319336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_tokens_balance_cohorts_holders_daily_date.d7138b9b9d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_tokens_balance_cohorts_holders_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.183448Z", "completed_at": "2026-02-12T22:49:50.187918Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.188497Z", "completed_at": "2026-02-12T22:49:50.188505Z"}], "thread_id": "Thread-1", "execution_time": 0.006315946578979492, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_tokens_balance_cohorts_value_daily_date.e54ff2f979", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_tokens_balance_cohorts_value_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.191182Z", "completed_at": "2026-02-12T22:49:50.195195Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.195804Z", "completed_at": "2026-02-12T22:49:50.195812Z"}], "thread_id": "Thread-1", "execution_time": 0.005898714065551758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_active_senders_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  symbol          AS token,\n  token_class,\n  active_senders  AS value\nFROM `dbt`.`fct_execution_tokens_metrics_daily`\nWHERE date < today()\nORDER BY\n  date,\n  token", "relation_name": "`dbt`.`api_execution_tokens_active_senders_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.198474Z", "completed_at": "2026-02-12T22:49:50.203787Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.204386Z", "completed_at": "2026-02-12T22:49:50.204394Z"}], "thread_id": "Thread-1", "execution_time": 0.007231712341308594, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_holders_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  symbol      AS token,\n  token_class,\n  holders     AS value\nFROM `dbt`.`fct_execution_tokens_metrics_daily`\nWHERE date < today()\nORDER BY\n  date,\n  token", "relation_name": "`dbt`.`api_execution_tokens_holders_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.207221Z", "completed_at": "2026-02-12T22:49:50.211117Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.211727Z", "completed_at": "2026-02-12T22:49:50.211734Z"}], "thread_id": "Thread-1", "execution_time": 0.00578761100769043, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_holders_latest_by_token", "compiled": true, "compiled_code": "\n\nSELECT\n  symbol      AS token,\n  toUInt64(argMax(holders, date)) AS value\nFROM `dbt`.`fct_execution_tokens_metrics_daily`\nWHERE date < today()\nGROUP BY token_address, symbol\nORDER BY token", "relation_name": "`dbt`.`api_execution_tokens_holders_latest_by_token`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.214427Z", "completed_at": "2026-02-12T22:49:50.218353Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.218974Z", "completed_at": "2026-02-12T22:49:50.218981Z"}], "thread_id": "Thread-1", "execution_time": 0.005836009979248047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_supply_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  symbol      AS token,\n  token_class,\n  supply      AS value_native,\n  supply_usd  AS value_usd\nFROM `dbt`.`fct_execution_tokens_metrics_daily`\nWHERE date < today()\nORDER BY\n  date,\n  token", "relation_name": "`dbt`.`api_execution_tokens_supply_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.221811Z", "completed_at": "2026-02-12T22:49:50.225739Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.226325Z", "completed_at": "2026-02-12T22:49:50.226332Z"}], "thread_id": "Thread-1", "execution_time": 0.00597071647644043, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_supply_latest_by_token", "compiled": true, "compiled_code": "\n\nSELECT\n  symbol      AS token,\n  argMax(supply, date) AS value_native,\n  argMax(supply_usd, date) AS value_usd\nFROM `dbt`.`fct_execution_tokens_metrics_daily`\nWHERE date < today()\nGROUP BY symbol\nORDER BY token", "relation_name": "`dbt`.`api_execution_tokens_supply_latest_by_token`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.229031Z", "completed_at": "2026-02-12T22:49:50.232946Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.233558Z", "completed_at": "2026-02-12T22:49:50.233565Z"}], "thread_id": "Thread-1", "execution_time": 0.005797863006591797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_volume_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  symbol      AS token,\n  token_class,\n  volume_token AS value_native,\n  volume_usd   AS value_usd\nFROM `dbt`.`fct_execution_tokens_metrics_daily`\nWHERE date < today()\nORDER BY\n  date,\n  token", "relation_name": "`dbt`.`api_execution_tokens_volume_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.236272Z", "completed_at": "2026-02-12T22:49:50.241346Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.241940Z", "completed_at": "2026-02-12T22:49:50.241947Z"}], "thread_id": "Thread-1", "execution_time": 0.007031679153442383, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_tokens_overview_by_class_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nlatest_date AS (\n    SELECT MAX(date) AS max_date\n    FROM `dbt`.`fct_execution_tokens_metrics_daily`\n    WHERE date < today()\n),\n\nsupply_latest AS (\n    SELECT\n        token_class,\n        SUM(supply) AS value\n    FROM `dbt`.`fct_execution_tokens_metrics_daily`\n    CROSS JOIN latest_date\n    WHERE date = latest_date.max_date\n    GROUP BY token_class\n),\n\nsupply_7d AS (\n    SELECT\n        token_class,\n        SUM(supply) AS value\n    FROM `dbt`.`fct_execution_tokens_metrics_daily`\n    CROSS JOIN latest_date\n    WHERE date = subtractDays(latest_date.max_date, 7)\n    GROUP BY token_class\n),\n\nholders_latest AS (\n    SELECT\n        token_class,\n        CAST(COUNT(DISTINCT address) AS Float64) AS value\n    FROM `dbt`.`int_execution_tokens_balances_daily`\n    CROSS JOIN latest_date\n    WHERE date = latest_date.max_date\n      AND balance_raw > 0\n    GROUP BY token_class\n),\n\nholders_7d AS (\n    SELECT\n        token_class,\n        CAST(COUNT(DISTINCT address) AS Float64) AS value\n    FROM `dbt`.`int_execution_tokens_balances_daily`\n    CROSS JOIN latest_date\n    WHERE date = subtractDays(latest_date.max_date, 7)\n      AND balance_raw > 0\n    GROUP BY token_class\n),\n\ninfo_latest AS (\n    SELECT \n        token_class,\n        'supply_total' AS label, \n        value\n    FROM supply_latest\n    UNION ALL\n    SELECT \n        token_class,\n        'holders_total' AS label, \n        value\n    FROM holders_latest\n),\n\ninfo_7d AS (\n    SELECT \n        token_class,\n        'supply_total' AS label, \n        value\n    FROM supply_7d\n    UNION ALL\n    SELECT \n        token_class,\n        'holders_total' AS label, \n        value\n    FROM holders_7d\n)\n\nSELECT\n    t1.token_class,\n    t1.label,\n    t1.value AS value,\n    IF(t1.value = 0 AND t2.value = 0, 0, \n       ROUND((COALESCE(t1.value / NULLIF(t2.value, 0), 0) - 1) * 100, 1)\n    ) AS change_pct\nFROM info_latest t1\nINNER JOIN info_7d t2\n    ON t1.token_class = t2.token_class\n    AND t1.label = t2.label\nORDER BY t1.token_class, t1.label", "relation_name": "`dbt`.`fct_execution_tokens_overview_by_class_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.244705Z", "completed_at": "2026-02-12T22:49:50.250342Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.250942Z", "completed_at": "2026-02-12T22:49:50.250949Z"}], "thread_id": "Thread-1", "execution_time": 0.007580757141113281, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_tokens_supply_by_sector_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nlatest_date AS (\n    SELECT MAX(date) AS max_date\n    FROM `dbt`.`fct_execution_tokens_metrics_daily`\n    WHERE date < today()\n),\n\nsector_supply AS (\n    SELECT\n        token_class,\n        sector,\n        SUM(supply) AS value,\n        SUM(supply_usd) AS value_usd\n    FROM `dbt`.`int_execution_tokens_balances_by_sector_daily`\n    CROSS JOIN latest_date\n    WHERE date = latest_date.max_date\n    GROUP BY token_class, sector\n),\n\ntotal_supply AS (\n    SELECT \n        token_class,\n        SUM(value) AS total,\n        SUM(value_usd) AS total_usd\n    FROM sector_supply\n    GROUP BY token_class\n)\n\nSELECT\n    ss.token_class,\n    ss.sector,\n    ss.value,\n    ss.value_usd,\n    ROUND(ss.value_usd / NULLIF(ts.total_usd, 0) * 100, 2) AS percentage\nFROM sector_supply ss\nINNER JOIN total_supply ts\n    ON ss.token_class = ts.token_class\nORDER BY ss.token_class, ss.value_usd DESC", "relation_name": "`dbt`.`fct_execution_tokens_supply_by_sector_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.253664Z", "completed_at": "2026-02-12T22:49:50.257799Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.258365Z", "completed_at": "2026-02-12T22:49:50.258372Z"}], "thread_id": "Thread-1", "execution_time": 0.005973100662231445, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_tokens_supply_distribution_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nlatest_date AS (\n    SELECT MAX(date) AS max_date\n    FROM `dbt`.`fct_execution_tokens_metrics_daily`\n    WHERE date < today()\n),\n\ntokens_supply AS (\n    SELECT\n        token_class,\n        symbol AS token,\n        supply AS value,\n        supply_usd AS value_usd\n    FROM `dbt`.`fct_execution_tokens_metrics_daily`\n    CROSS JOIN latest_date\n    WHERE date = latest_date.max_date\n),\n\ntotal_supply AS (\n    SELECT \n        token_class,\n        SUM(value) AS total,\n        SUM(value_usd) AS total_usd\n    FROM tokens_supply\n    GROUP BY token_class\n)\n\nSELECT\n    ts.token_class,\n    ts.token,\n    ts.value,\n    ts.value_usd,\n    ROUND(ts.value_usd / NULLIF(tot.total_usd, 0) * 100, 2) AS percentage\nFROM tokens_supply ts\nINNER JOIN total_supply tot\n    ON ts.token_class = tot.token_class\nORDER BY ts.token_class, ts.value_usd DESC", "relation_name": "`dbt`.`fct_execution_tokens_supply_distribution_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.261133Z", "completed_at": "2026-02-12T22:49:50.269842Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.270406Z", "completed_at": "2026-02-12T22:49:50.270431Z"}], "thread_id": "Thread-1", "execution_time": 0.010560274124145508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_yields_overview_snapshot", "compiled": true, "compiled_code": "\n\nSELECT\n    metric,\n    value,\n    change_pct,\n    label\nFROM (\n    WITH\n    \n    pools_latest_date AS (\n        SELECT max(date) AS max_date\n        FROM `dbt`.`fct_execution_yields_pools_daily`\n        WHERE date < today()\n    ),\n    \n    -- LP Total TVL (latest)\n    lp_tvl_latest AS (\n        SELECT sum(tvl_usd) AS tvl\n        FROM `dbt`.`fct_execution_yields_pools_daily` f\n        CROSS JOIN pools_latest_date d\n        WHERE f.date = d.max_date\n    ),\n    \n    -- LP Total TVL (7 days ago)\n    lp_tvl_7d_ago AS (\n        SELECT sum(tvl_usd) AS tvl\n        FROM `dbt`.`fct_execution_yields_pools_daily` f\n        CROSS JOIN pools_latest_date d\n        WHERE f.date = d.max_date - INTERVAL 7 DAY\n    ),\n    \n    -- LP Best APR (latest) with pool name\n    lp_best_apr_latest AS (\n        SELECT\n            f.fee_apr_7d AS apr,\n            f.pool AS pool_name\n        FROM `dbt`.`fct_execution_yields_pools_daily` f\n        CROSS JOIN pools_latest_date d\n        WHERE f.date = d.max_date\n          AND f.fee_apr_7d IS NOT NULL\n        ORDER BY f.fee_apr_7d DESC\n        LIMIT 1\n    ),\n    \n    -- LP Best APR (7 days ago)\n    lp_best_apr_7d_ago AS (\n        SELECT max(fee_apr_7d) AS apr\n        FROM `dbt`.`fct_execution_yields_pools_daily` f\n        CROSS JOIN pools_latest_date d\n        WHERE f.date = d.max_date - INTERVAL 7 DAY\n          AND f.fee_apr_7d IS NOT NULL\n    ),\n    \n    \n    lending_latest_date AS (\n        SELECT max(date) AS max_date\n        FROM `dbt`.`int_execution_yields_aave_daily`\n        WHERE date < today()\n    ),\n    \n    -- Best Lending APY (latest) with token name\n    lending_best_apy_latest AS (\n        SELECT\n            a.apy_daily AS apy,\n            a.symbol AS token_name\n        FROM `dbt`.`int_execution_yields_aave_daily` a\n        CROSS JOIN lending_latest_date d\n        WHERE a.date = d.max_date\n          AND a.apy_daily IS NOT NULL\n          AND a.apy_daily > 0\n        ORDER BY a.apy_daily DESC\n        LIMIT 1\n    ),\n    \n    -- Best Lending APY (7 days ago)\n    lending_best_apy_7d_ago AS (\n        SELECT max(apy_daily) AS apy\n        FROM `dbt`.`int_execution_yields_aave_daily` a\n        CROSS JOIN lending_latest_date d\n        WHERE a.date = d.max_date - INTERVAL 7 DAY\n          AND a.apy_daily IS NOT NULL\n    ),\n    \n    -- Total unique lenders (all-time) using bitmap merge\n    lending_lenders_total AS (\n        SELECT toUInt64(groupBitmapMerge(lenders_bitmap_state)) AS total_lenders\n        FROM `dbt`.`int_execution_yields_aave_daily`\n        WHERE lenders_bitmap_state IS NOT NULL\n    ),\n    \n    -- Lenders (7D window for change calculation)\n    lending_lenders_7d AS (\n        SELECT toUInt64(groupBitmapMerge(lenders_bitmap_state)) AS lenders\n        FROM `dbt`.`int_execution_yields_aave_daily` a\n        CROSS JOIN lending_latest_date d\n        WHERE a.date > d.max_date - INTERVAL 7 DAY\n          AND a.date <= d.max_date\n          AND a.lenders_bitmap_state IS NOT NULL\n    ),\n    \n    lending_lenders_prior_7d AS (\n        SELECT toUInt64(groupBitmapMerge(lenders_bitmap_state)) AS lenders\n        FROM `dbt`.`int_execution_yields_aave_daily` a\n        CROSS JOIN lending_latest_date d\n        WHERE a.date > d.max_date - INTERVAL 14 DAY\n          AND a.date <= d.max_date - INTERVAL 7 DAY\n          AND a.lenders_bitmap_state IS NOT NULL\n    ),\n    \n    \n    sdai_latest_date AS (\n        SELECT max(date) AS max_date\n        FROM `dbt`.`fct_yields_sdai_apy_daily`\n        WHERE date < today()\n          AND label = 'Daily'\n    ),\n    \n    -- sDAI APY (latest)\n    sdai_apy_latest AS (\n        SELECT apy\n        FROM `dbt`.`fct_yields_sdai_apy_daily` s\n        CROSS JOIN sdai_latest_date d\n        WHERE s.date = d.max_date\n          AND s.label = 'Daily'\n    ),\n    \n    -- sDAI APY (7 days ago)\n    sdai_apy_7d_ago AS (\n        SELECT apy\n        FROM `dbt`.`fct_yields_sdai_apy_daily` s\n        CROSS JOIN sdai_latest_date d\n        WHERE s.date = d.max_date - INTERVAL 7 DAY\n          AND s.label = 'Daily'\n    ),\n    \n    -- sDAI Supply (latest)\n    sdai_supply_latest AS (\n        SELECT argMax(supply, date) AS supply\n        FROM `dbt`.`fct_execution_tokens_metrics_daily`\n        WHERE upper(symbol) = 'SDAI'\n          AND date < today()\n    ),\n    \n    -- sDAI Supply (7 days ago)\n    sdai_supply_7d_ago AS (\n        SELECT supply\n        FROM `dbt`.`fct_execution_tokens_metrics_daily`\n        WHERE upper(symbol) = 'SDAI'\n          AND date = (SELECT max(date) - INTERVAL 7 DAY FROM `dbt`.`fct_execution_tokens_metrics_daily` WHERE upper(symbol) = 'SDAI' AND date < today())\n    )\n\n    \n    -- 1. LP Total TVL\n    SELECT\n        'lp_tvl_total' AS metric,\n        l.tvl AS value,\n        round(\n            CASE\n                WHEN p.tvl IS NULL OR p.tvl = 0 THEN NULL\n                ELSE ((l.tvl / p.tvl) - 1) * 100\n            END,\n            2\n        ) AS change_pct,\n        NULL AS label\n    FROM lp_tvl_latest l\n    CROSS JOIN lp_tvl_7d_ago p\n    \n    UNION ALL\n    \n    -- 2. LP Best APR\n    SELECT\n        'lp_best_apr' AS metric,\n        l.apr AS value,\n        round(\n            CASE\n                WHEN p.apr IS NULL OR p.apr = 0 THEN NULL\n                ELSE ((l.apr / p.apr) - 1) * 100\n            END,\n            2\n        ) AS change_pct,\n        l.pool_name AS label\n    FROM lp_best_apr_latest l\n    CROSS JOIN lp_best_apr_7d_ago p\n    \n    UNION ALL\n    \n    -- 3. Lending Best APY\n    SELECT\n        'lending_best_apy' AS metric,\n        l.apy AS value,\n        round(\n            CASE\n                WHEN p.apy IS NULL OR p.apy = 0 THEN NULL\n                ELSE ((l.apy / p.apy) - 1) * 100\n            END,\n            2\n        ) AS change_pct,\n        l.token_name AS label\n    FROM lending_best_apy_latest l\n    CROSS JOIN lending_best_apy_7d_ago p\n    \n    UNION ALL\n    \n    -- 4. Total Lenders (all-time)\n    SELECT\n        'lending_lenders_total' AS metric,\n        toFloat64(t.total_lenders) AS value,\n        round(\n            CASE\n                WHEN p.lenders IS NULL OR p.lenders = 0 THEN NULL\n                ELSE ((toFloat64(c.lenders) / toFloat64(p.lenders)) - 1) * 100\n            END,\n            2\n        ) AS change_pct,\n        NULL AS label\n    FROM lending_lenders_total t\n    CROSS JOIN lending_lenders_7d c\n    CROSS JOIN lending_lenders_prior_7d p\n    \n    UNION ALL\n    \n    -- 5. sDAI APY\n    SELECT\n        'sdai_apy' AS metric,\n        l.apy AS value,\n        round(\n            CASE\n                WHEN p.apy IS NULL OR p.apy = 0 THEN NULL\n                ELSE ((l.apy / p.apy) - 1) * 100\n            END,\n            2\n        ) AS change_pct,\n        NULL AS label\n    FROM sdai_apy_latest l\n    CROSS JOIN sdai_apy_7d_ago p\n    \n    UNION ALL\n    \n    -- 6. sDAI Total Supply\n    SELECT\n        'sdai_supply_total' AS metric,\n        l.supply AS value,\n        round(\n            CASE\n                WHEN p.supply IS NULL OR p.supply = 0 THEN NULL\n                ELSE ((l.supply / p.supply) - 1) * 100\n            END,\n            2\n        ) AS change_pct,\n        NULL AS label\n    FROM sdai_supply_latest l\n    CROSS JOIN sdai_supply_7d_ago p\n)", "relation_name": "`dbt`.`fct_execution_yields_overview_snapshot`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.273319Z", "completed_at": "2026-02-12T22:49:50.277191Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.277772Z", "completed_at": "2026-02-12T22:49:50.277779Z"}], "thread_id": "Thread-1", "execution_time": 0.005944728851318359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_opportunities_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    type,\n    name,\n    yield_pct,\n    borrow_apy,\n    tvl,\n    protocol\nFROM `dbt`.`fct_execution_yields_opportunities_latest`\nORDER BY yield_pct DESC", "relation_name": "`dbt`.`api_execution_yields_opportunities_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.280379Z", "completed_at": "2026-02-12T22:49:50.284339Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.284923Z", "completed_at": "2026-02-12T22:49:50.284931Z"}], "thread_id": "Thread-1", "execution_time": 0.005795001983642578, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_pools_fees_7d", "compiled": true, "compiled_code": "\n\nSELECT\n    token,\n    value,\n    change_pct\nFROM `dbt`.`fct_execution_yields_pools_snapshots`\nWHERE metric = 'Fees_7D'\nORDER BY value DESC", "relation_name": "`dbt`.`api_execution_yields_pools_fees_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.287546Z", "completed_at": "2026-02-12T22:49:50.291516Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.292066Z", "completed_at": "2026-02-12T22:49:50.292074Z"}], "thread_id": "Thread-1", "execution_time": 0.005782365798950195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_pools_tvl_latest", "compiled": true, "compiled_code": "\n\n\nSELECT\n    token,\n    value,\n    change_pct\nFROM `dbt`.`fct_execution_yields_pools_snapshots`\nWHERE metric = 'TVL_Latest'\nORDER BY value DESC", "relation_name": "`dbt`.`api_execution_yields_pools_tvl_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.294737Z", "completed_at": "2026-02-12T22:49:50.300751Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.301311Z", "completed_at": "2026-02-12T22:49:50.301318Z"}], "thread_id": "Thread-1", "execution_time": 0.00784754753112793, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_tokens_active_senders_daily_date.6606045079", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_tokens_active_senders_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.303951Z", "completed_at": "2026-02-12T22:49:50.308356Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.308942Z", "completed_at": "2026-02-12T22:49:50.308949Z"}], "thread_id": "Thread-1", "execution_time": 0.006249189376831055, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_tokens_holders_daily_date.366662102e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_tokens_holders_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.311577Z", "completed_at": "2026-02-12T22:49:50.315993Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.316577Z", "completed_at": "2026-02-12T22:49:50.316584Z"}], "thread_id": "Thread-1", "execution_time": 0.0062716007232666016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_tokens_supply_daily_date.cbf90243fc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_tokens_supply_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.319221Z", "completed_at": "2026-02-12T22:49:50.323716Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.324291Z", "completed_at": "2026-02-12T22:49:50.324299Z"}], "thread_id": "Thread-1", "execution_time": 0.00638890266418457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_tokens_volume_daily_date.60fbe0b93c", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_tokens_volume_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.326974Z", "completed_at": "2026-02-12T22:49:50.330823Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.331383Z", "completed_at": "2026-02-12T22:49:50.331391Z"}], "thread_id": "Thread-1", "execution_time": 0.005752086639404297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_overview_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    token_class,\n    label,\n    value,\n    change_pct\nFROM `dbt`.`fct_execution_tokens_overview_by_class_latest`\nORDER BY token_class, label", "relation_name": "`dbt`.`api_execution_tokens_overview_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.334048Z", "completed_at": "2026-02-12T22:49:50.337958Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.338544Z", "completed_at": "2026-02-12T22:49:50.338552Z"}], "thread_id": "Thread-1", "execution_time": 0.005808353424072266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_supply_by_sector_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    token_class,\n    sector AS label,\n    value,\n    value_usd,\n    percentage\nFROM `dbt`.`fct_execution_tokens_supply_by_sector_latest`\nORDER BY token_class, value_usd DESC", "relation_name": "`dbt`.`api_execution_tokens_supply_by_sector_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.341219Z", "completed_at": "2026-02-12T22:49:50.346454Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.347024Z", "completed_at": "2026-02-12T22:49:50.347032Z"}], "thread_id": "Thread-1", "execution_time": 0.007130861282348633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_tokens_supply_distribution_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    token_class,\n    token,\n    value,\n    value_usd,\n    percentage\nFROM `dbt`.`fct_execution_tokens_supply_distribution_latest`\nORDER BY token_class, value_usd DESC", "relation_name": "`dbt`.`api_execution_tokens_supply_distribution_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.349682Z", "completed_at": "2026-02-12T22:49:50.353562Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.354134Z", "completed_at": "2026-02-12T22:49:50.354141Z"}], "thread_id": "Thread-1", "execution_time": 0.0057561397552490234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_overview_lending_best_apy", "compiled": true, "compiled_code": "\n\nSELECT\n    value,\n    change_pct,\n    label\nFROM `dbt`.`fct_execution_yields_overview_snapshot`\nWHERE metric = 'lending_best_apy'", "relation_name": "`dbt`.`api_execution_yields_overview_lending_best_apy`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.356843Z", "completed_at": "2026-02-12T22:49:50.360677Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.361240Z", "completed_at": "2026-02-12T22:49:50.361248Z"}], "thread_id": "Thread-1", "execution_time": 0.005721092224121094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_overview_lending_lenders", "compiled": true, "compiled_code": "\n\nSELECT\n    value,\n    change_pct,\n    label\nFROM `dbt`.`fct_execution_yields_overview_snapshot`\nWHERE metric = 'lending_lenders_total'", "relation_name": "`dbt`.`api_execution_yields_overview_lending_lenders`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.363916Z", "completed_at": "2026-02-12T22:49:50.367750Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.368309Z", "completed_at": "2026-02-12T22:49:50.368316Z"}], "thread_id": "Thread-1", "execution_time": 0.005740642547607422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_overview_lp_best_apr", "compiled": true, "compiled_code": "\n\nSELECT\n    value,\n    change_pct,\n    label\nFROM `dbt`.`fct_execution_yields_overview_snapshot`\nWHERE metric = 'lp_best_apr'", "relation_name": "`dbt`.`api_execution_yields_overview_lp_best_apr`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.370974Z", "completed_at": "2026-02-12T22:49:50.374821Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.375385Z", "completed_at": "2026-02-12T22:49:50.375392Z"}], "thread_id": "Thread-1", "execution_time": 0.0056896209716796875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_overview_lp_tvl", "compiled": true, "compiled_code": "\n\nSELECT\n    value,\n    change_pct,\n    label\nFROM `dbt`.`fct_execution_yields_overview_snapshot`\nWHERE metric = 'lp_tvl_total'", "relation_name": "`dbt`.`api_execution_yields_overview_lp_tvl`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.378054Z", "completed_at": "2026-02-12T22:49:50.381959Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.382542Z", "completed_at": "2026-02-12T22:49:50.382549Z"}], "thread_id": "Thread-1", "execution_time": 0.005763530731201172, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_overview_sdai_apy", "compiled": true, "compiled_code": "\n\nSELECT\n    value,\n    change_pct,\n    label\nFROM `dbt`.`fct_execution_yields_overview_snapshot`\nWHERE metric = 'sdai_apy'", "relation_name": "`dbt`.`api_execution_yields_overview_sdai_apy`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-02-12T22:49:50.385204Z", "completed_at": "2026-02-12T22:49:50.390384Z"}, {"name": "execute", "started_at": "2026-02-12T22:49:50.390971Z", "completed_at": "2026-02-12T22:49:50.390978Z"}], "thread_id": "Thread-1", "execution_time": 0.007086038589477539, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_yields_overview_sdai_supply", "compiled": true, "compiled_code": "\n\nSELECT\n    value,\n    change_pct,\n    label\nFROM `dbt`.`fct_execution_yields_overview_snapshot`\nWHERE metric = 'sdai_supply_total'", "relation_name": "`dbt`.`api_execution_yields_overview_sdai_supply`", "batch_results": null}], "elapsed_time": 6.604769706726074, "args": {"print": true, "which": "generate", "project_dir": "/home/runner/work/dbt-cerebro/dbt-cerebro", "macro_debugging": false, "require_yaml_configuration_for_mf_time_spines": false, "warn_error_options": {"include": [], "exclude": []}, "empty_catalog": false, "quiet": false, "write_json": true, "static_parser": true, "require_batched_execution_for_custom_microbatch_strategy": false, "use_colors": true, "select": [], "log_path": "/home/runner/work/dbt-cerebro/dbt-cerebro/logs", "log_file_max_bytes": 10485760, "introspect": true, "partial_parse_file_diff": true, "strict_mode": false, "version_check": true, "compile": true, "require_explicit_package_overrides_for_builtin_materializations": true, "require_nested_cumulative_type_params": false, "exclude": [], "defer": false, "log_level_file": "debug", "source_freshness_run_project_hooks": false, "populate_cache": true, "cache_selected_only": false, "send_anonymous_usage_stats": true, "use_colors_file": true, "log_format": "default", "invocation_command": "dbt docs generate", "state_modified_compare_vars": false, "skip_nodes_if_on_run_start_fails": false, "static": false, "vars": {}, "indirect_selection": "eager", "printer_width": 80, "require_resource_names_without_spaces": false, "log_format_file": "debug", "profiles_dir": "/home/runner/work/dbt-cerebro/dbt-cerebro", "show_resource_report": false, "state_modified_compare_more_unrendered_values": false, "favor_state": false, "log_level": "info", "partial_parse": true}}