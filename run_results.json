{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.4", "generated_at": "2025-10-15T13:38:05.177591Z", "invocation_id": "1d06db99-109f-4758-b796-f4e02bfeca3e", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.798322Z", "completed_at": "2025-10-15T13:38:02.864366Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.864950Z", "completed_at": "2025-10-15T13:38:02.864965Z"}], "thread_id": "Thread-1", "execution_time": 0.06794929504394531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_topology_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    protocol,\n    date,\n    peer_discovery_id_prefix,\n    peer_client,\n    peer_city,\n    peer_country,\n    peer_org,\n    peer_lat,\n    peer_lon,\n    neighbor_discovery_id_prefix,\n    neighbor_client,\n    neighbor_city,\n    neighbor_country,\n    neighbor_org,\n    neighbor_lat,\n    neighbor_lon,\n    cnt\nFROM dbt.fct_p2p_topology_latest\nWHERE peer_lat != '' AND neighbor_lat != ''\nORDER BY protocol DESC", "relation_name": "`dbt`.`api_p2p_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.867727Z", "completed_at": "2025-10-15T13:38:02.871890Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.872479Z", "completed_at": "2025-10-15T13:38:02.872487Z"}], "thread_id": "Thread-1", "execution_time": 0.0061016082763671875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__attestations", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    attestation_index,\n    aggregation_bits,\n    signature,\n    attestation_slot,\n    committee_index,\n    beacon_block_root,\n    source_epoch,\n    source_root,\n    target_epoch,\n    target_root,\n    slot_timestamp\nFROM \n    `consensus`.`attestations` FINAL", "relation_name": "`dbt`.`stg_consensus__attestations`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.875350Z", "completed_at": "2025-10-15T13:38:02.879220Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.879793Z", "completed_at": "2025-10-15T13:38:02.879801Z"}], "thread_id": "Thread-1", "execution_time": 0.0059587955474853516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__blob_commitments", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    commitment_index,\n    commitment,\n    slot_timestamp\nFROM \n    `consensus`.`blob_commitments` FINAL", "relation_name": "`dbt`.`stg_consensus__blob_commitments`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.882529Z", "completed_at": "2025-10-15T13:38:02.886497Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.887052Z", "completed_at": "2025-10-15T13:38:02.887059Z"}], "thread_id": "Thread-1", "execution_time": 0.00574493408203125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__blocks", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    proposer_index,\n    parent_root,\n    state_root,\n    signature,\n    version,\n    randao_reveal,\n    graffiti,\n    eth1_deposit_root,\n    eth1_deposit_count,\n    eth1_block_hash,\n    sync_aggregate_participation,\n    withdrawals_count,\n    blob_kzg_commitments_count,\n    execution_requests_count,\n    slot_timestamp\nFROM \n    `consensus`.`blocks` FINAL", "relation_name": "`dbt`.`stg_consensus__blocks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.889707Z", "completed_at": "2025-10-15T13:38:02.893800Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.894395Z", "completed_at": "2025-10-15T13:38:02.894403Z"}], "thread_id": "Thread-1", "execution_time": 0.005978822708129883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__deposits", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    deposit_index,\n    pubkey,\n    withdrawal_credentials,\n    amount,\n    signature,\n    proof,\n    slot_timestamp\nFROM \n    `consensus`.`deposits` FINAL", "relation_name": "`dbt`.`stg_consensus__deposits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.897122Z", "completed_at": "2025-10-15T13:38:02.901791Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.902373Z", "completed_at": "2025-10-15T13:38:02.902380Z"}], "thread_id": "Thread-1", "execution_time": 0.0065648555755615234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__execution_requests", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    payload,\n    deposits_count,\n    withdrawals_count,\n    consolidations_count,\n    slot_timestamp\nFROM \n    `consensus`.`execution_requests` FINAL", "relation_name": "`dbt`.`stg_consensus__execution_requests`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.905034Z", "completed_at": "2025-10-15T13:38:02.908944Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.909568Z", "completed_at": "2025-10-15T13:38:02.909575Z"}], "thread_id": "Thread-1", "execution_time": 0.005822420120239258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__rewards", "compiled": true, "compiled_code": "\n\nSELECT\n    slot\n    proposer_index,\n    total,\n    attestations,\n    sync_aggregate,\n    proposer_slashings,\n    attester_slashings,\n    slot_timestamp\nFROM \n    `consensus`.`rewards` FINAL", "relation_name": "`dbt`.`stg_consensus__rewards`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.912260Z", "completed_at": "2025-10-15T13:38:02.916036Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.916610Z", "completed_at": "2025-10-15T13:38:02.916617Z"}], "thread_id": "Thread-1", "execution_time": 0.005692243576049805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__specs", "compiled": true, "compiled_code": "\n\nSELECT\n    parameter_name,\n    parameter_value,\nFROM \n    `consensus`.`specs` FINAL", "relation_name": "`dbt`.`stg_consensus__specs`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.919255Z", "completed_at": "2025-10-15T13:38:02.923070Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.923640Z", "completed_at": "2025-10-15T13:38:02.923647Z"}], "thread_id": "Thread-1", "execution_time": 0.005636930465698242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__time_helpers", "compiled": true, "compiled_code": "\n\nSELECT\n    genesis_time_unix,\n    seconds_per_slot,\n    slots_per_epoch\nFROM \n    `consensus`.`time_helpers` FINAL", "relation_name": "`dbt`.`stg_consensus__time_helpers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.926310Z", "completed_at": "2025-10-15T13:38:02.930396Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.931010Z", "completed_at": "2025-10-15T13:38:02.931018Z"}], "thread_id": "Thread-1", "execution_time": 0.006001472473144531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__validators", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    validator_index,\n    balance,\n    status,\n    pubkey,\n    withdrawal_credentials,\n    effective_balance,\n    slashed,\n    activation_eligibility_epoch,\n    activation_epoch,\n    exit_epoch,\n    withdrawable_epoch,\n    slot_timestamp\nFROM \n    `consensus`.`validators` FINAL", "relation_name": "`dbt`.`stg_consensus__validators`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.933745Z", "completed_at": "2025-10-15T13:38:02.937897Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.938503Z", "completed_at": "2025-10-15T13:38:02.938510Z"}], "thread_id": "Thread-1", "execution_time": 0.006059408187866211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__withdrawals", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    block_number,\n    block_hash,\n    withdrawal_index,\n    validator_index,\n    address,\n    amount,\n    slot_timestamp\nFROM \n    `consensus`.`withdrawals` FINAL", "relation_name": "`dbt`.`stg_consensus__withdrawals`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.941286Z", "completed_at": "2025-10-15T13:38:02.946287Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.946867Z", "completed_at": "2025-10-15T13:38:02.946874Z"}], "thread_id": "Thread-1", "execution_time": 0.006997585296630859, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__country_codes", "compiled": true, "compiled_code": "\n\n\nSELECT\n    \"name\",\n    \"alpha-2\",\n    \"alpha-3\",\n    \"country-code\",\n    \"iso_3166-2\",\n    \"region\",\n    \"sub-region\",\n    \"intermediate-region\",\n    \"region-code\",\n    \"sub-region-code\",\n    \"intermediate-region-code\"\nFROM\n    `crawlers_data`.`country_codes`", "relation_name": "`dbt`.`stg_crawlers_data__country_codes`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.949563Z", "completed_at": "2025-10-15T13:38:02.953396Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.953976Z", "completed_at": "2025-10-15T13:38:02.953983Z"}], "thread_id": "Thread-1", "execution_time": 0.00564885139465332, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_prices", "compiled": true, "compiled_code": "\n\nSELECT\n  toDate(block_date)                    AS date,\n  upper(symbol)                         AS symbol,\n  anyLast(toFloat64(price))             AS price   \nFROM `crawlers_data`.`dune_prices`\nGROUP BY date, symbol\nORDER BY date, symbol", "relation_name": "`dbt`.`stg_crawlers_data__dune_prices`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.956814Z", "completed_at": "2025-10-15T13:38:02.960758Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.961367Z", "completed_at": "2025-10-15T13:38:02.961374Z"}], "thread_id": "Thread-1", "execution_time": 0.0059871673583984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__ember_electricity_data", "compiled": true, "compiled_code": "\n\n\nSELECT\n    \"Area\",\n    \"ISO 3 code\",\n    \"Date\",\n    \"Area type\",\n    \"Continent\",\n    \"Ember region\",\n    \"EU\" ,\n    \"OECD\",\n    \"G20\",\n    \"G7\",\n    \"ASEAN\",\n    \"Category\",\n    \"Subcategory\",\n    \"Variable\",\n    \"Unit\",\n    \"Value\",\n    \"YoY absolute change\",\n    \"YoY % change\" \nFROM\n    `crawlers_data`.`ember_electricity_data`", "relation_name": "`dbt`.`stg_crawlers_data__ember_electricity_data`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.964120Z", "completed_at": "2025-10-15T13:38:02.968576Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.969148Z", "completed_at": "2025-10-15T13:38:02.969155Z"}], "thread_id": "Thread-1", "execution_time": 0.006433725357055664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__ipinfo", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    ip,\n    hostname,\n    city,\n    region,\n    country,\n    loc,\n    org,\n    postal,\n    timezone,\n    asn,\n    company,\n    carrier,\n    is_bogon,\n    is_mobile,\n    multiIf(\n      lowerUTF8(org) ILIKE '%amazon web services%' OR lowerUTF8(org) ILIKE '%amazon data services%' OR lowerUTF8(org) ILIKE '%aws%' OR lowerUTF8(org) ILIKE '%amazon.com%', 'AWS',\n      (lowerUTF8(org) ILIKE '%google cloud%' OR lowerUTF8(org) ILIKE '%google llc%' OR lowerUTF8(org) ILIKE '%gcp%' OR lowerUTF8(org) ILIKE '%google%') AND lowerUTF8(org) NOT ILIKE '%fiber%', 'Google',\n      lowerUTF8(org) ILIKE '%microsoft azure%' OR lowerUTF8(org) ILIKE '%azure%' OR lowerUTF8(org) ILIKE '%microsoft corporation%' OR lowerUTF8(org) ILIKE '%msft%', 'Azure',\n      lowerUTF8(org) ILIKE '%oracle cloud%' OR lowerUTF8(org) ILIKE '%oracle america%' OR lowerUTF8(org) ILIKE '%oci%', 'Oracle Cloud',\n      lowerUTF8(org) ILIKE '%alibaba cloud%' OR lowerUTF8(org) ILIKE '%aliyun%' OR lowerUTF8(org) ILIKE '%alibaba%', 'Alibaba Cloud',\n\n      lowerUTF8(org) ILIKE '%cloudflare%', 'Cloudflare',\n      (lowerUTF8(org) ILIKE '%akamai%' AND lowerUTF8(org) NOT ILIKE '%linode%'), 'Akamai',\n      lowerUTF8(org) ILIKE '%fastly%', 'Fastly',\n\n      lowerUTF8(org) ILIKE '%digitalocean%' OR lowerUTF8(org) ILIKE '%digital ocean%', 'DigitalOcean',\n      lowerUTF8(org) ILIKE '%ovh%', 'OVHcloud',\n      lowerUTF8(org) ILIKE '%hetzner%', 'Hetzner',\n      lowerUTF8(org) ILIKE '%scaleway%' OR lowerUTF8(org) ILIKE '%online s.a.s%' OR lowerUTF8(org) ILIKE '%iliad%', 'Scaleway',\n      lowerUTF8(org) ILIKE '%linode%', 'Linode',\n      lowerUTF8(org) ILIKE '%vultr%' OR lowerUTF8(org) ILIKE '%choopa%', 'Vultr',\n      lowerUTF8(org) ILIKE '%equinix metal%' OR lowerUTF8(org) ILIKE '%packet host%' OR lowerUTF8(org) ILIKE '%packet, inc%', 'Equinix Metal',\n      lowerUTF8(org) ILIKE '%fly.io%' OR lowerUTF8(org) ILIKE '%fly io%', 'Fly.io',\n      lowerUTF8(org) ILIKE '%netlify%', 'Netlify',\n      lowerUTF8(org) ILIKE '%vercel%' OR lowerUTF8(org) ILIKE '%zeit%', 'Vercel',\n      lowerUTF8(org) ILIKE '%heroku%', 'Heroku',\n      lowerUTF8(org) ILIKE '%render.com%' OR lowerUTF8(org) ILIKE '% render %', 'Render',\n\n      -- Carrier / transit networks (keep as its own bucket; change to 'Public ISP (Home/Office)' if you prefer)\n      lowerUTF8(org) ILIKE '%cogent%' OR lowerUTF8(org) ILIKE '%lumen%' OR lowerUTF8(org) ILIKE '%level 3%' OR lowerUTF8(org) ILIKE '%centurylink%' OR\n      lowerUTF8(org) ILIKE '%telia carrier%' OR lowerUTF8(org) ILIKE '%arelion%' OR lowerUTF8(org) ILIKE '%gtt%' OR lowerUTF8(org) ILIKE '%hurricane electric%' OR\n      lowerUTF8(org) ILIKE '%he.net%' OR lowerUTF8(org) ILIKE '%ntt communications%' OR lowerUTF8(org) ILIKE '%tata communications%' OR lowerUTF8(org) ILIKE '%zayo%' OR\n      lowerUTF8(org) ILIKE '%kddi%' OR lowerUTF8(org) ILIKE '%sparkle%' OR lowerUTF8(org) ILIKE '%backbone%' OR lowerUTF8(org) ILIKE '%chinanet-backbone%', 'Carrier/Transit',\n\n      -- Education / government \u2192 treat like public access\n      lowerUTF8(org) ILIKE '%university%' OR lowerUTF8(org) ILIKE '%college%' OR lowerUTF8(org) ILIKE '%school%' OR lowerUTF8(org) ILIKE '%ministry%' OR lowerUTF8(org) ILIKE '%government%', 'Public ISP (Home/Office)',\n\n      -- Generic hosting/CDN hints\n      lowerUTF8(org) ILIKE '%datacenter%' OR lowerUTF8(org) ILIKE '%data center%' OR lowerUTF8(org) ILIKE '%colo%' OR lowerUTF8(org) ILIKE '%hosting%' OR lowerUTF8(org) ILIKE '%vps%' OR lowerUTF8(org) ILIKE '%server%' OR lowerUTF8(org) ILIKE '%incapsula%' OR lowerUTF8(org) ILIKE '%imperva%', 'Hosting/CDN (Other)',\n\n      -- Fallback for residential & office ISPs\n      lowerUTF8(org) ILIKE '%telecom%' OR lowerUTF8(org) ILIKE '%telekom%' OR lowerUTF8(org) ILIKE '%telecommunications%' OR lowerUTF8(org) ILIKE '%communications%' OR lowerUTF8(org) ILIKE '%wireless%' OR\n      lowerUTF8(org) ILIKE '%cable%' OR lowerUTF8(org) ILIKE '%broadband%' OR lowerUTF8(org) ILIKE '%internet%' OR lowerUTF8(org) ILIKE '%fibre%' OR lowerUTF8(org) ILIKE '%fiber%' OR lowerUTF8(org) ILIKE '%mobile%', 'Public ISP (Home/Office)',\n      lowerUTF8(org) = '', 'Unknown',\n      'Public ISP (Home/Office)'\n  ) AS generic_provider\n  FROM `crawlers_data`.`ipinfo` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_crawlers_data__ipinfo`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.971942Z", "completed_at": "2025-10-15T13:38:02.975865Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.976457Z", "completed_at": "2025-10-15T13:38:02.976465Z"}], "thread_id": "Thread-1", "execution_time": 0.00588536262512207, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_agent_semvers_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    agent_version_semver,\n    agent_version_semver_str,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_agent_semvers_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.979414Z", "completed_at": "2025-10-15T13:38:02.984338Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.984920Z", "completed_at": "2025-10-15T13:38:02.984928Z"}], "thread_id": "Thread-1", "execution_time": 0.007078647613525391, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_cloud_provider_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    cloud_provider,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_cloud_provider_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.987792Z", "completed_at": "2025-10-15T13:38:02.991695Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.992286Z", "completed_at": "2025-10-15T13:38:02.992294Z"}], "thread_id": "Thread-1", "execution_time": 0.005888938903808594, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_countries_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    country_name,\n    country,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_countries_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_countries_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:02.995376Z", "completed_at": "2025-10-15T13:38:02.999168Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:02.999756Z", "completed_at": "2025-10-15T13:38:02.999764Z"}], "thread_id": "Thread-1", "execution_time": 0.005768299102783203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_quic_support_over_7d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    crawl_created_at,\n    quic_support,\n    __count,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_quic_support_over_7d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_quic_support_over_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.002577Z", "completed_at": "2025-10-15T13:38:03.006882Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.007472Z", "completed_at": "2025-10-15T13:38:03.007479Z"}], "thread_id": "Thread-1", "execution_time": 0.006159782409667969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__blocks", "compiled": true, "compiled_code": "\n\n\nWITH\n\nsource AS (\n    SELECT \n        block_number,\n        block_hash,\n        parent_hash,\n        uncles_hash,\n        author,\n        state_root,\n        transactions_root,\n        receipts_root,\n        gas_used,\n        gas_limit,\n        extra_data,\n        size,\n        mix_hash,\n        nonce,\n        base_fee_per_gas,\n        withdrawals_root,\n        block_timestamp\n    FROM \n        `execution`.`blocks`\n    WHERE \n        block_timestamp > '1970-01-01' -- remove genesis\n)\n\nSELECT\n    block_number,\n    block_hash,\n    parent_hash,\n    uncles_hash,\n    CONCAT('0x',author) AS author,\n    state_root,\n    transactions_root,\n    receipts_root,\n    gas_used,\n    gas_limit,\n    extra_data,\n    \narrayFilter(\n    x -> x != '',\n    /* split on every \u201cnon word-ish\u201d character (dash, @, space, etc.) */\n    splitByRegexp(\n        '[^A-Za-z0-9\\\\.]+',            -- \u21fd anything that isn\u2019t a\u2013z, 0\u20139 or \u201c.\u201d\n        arrayStringConcat(\n            arrayMap(\n                i -> if(\n                    reinterpretAsUInt8(substring(unhex(coalesce(extra_data, '')), i, 1)) BETWEEN 32 AND 126,\n                    reinterpretAsString(substring(unhex(coalesce(extra_data, '')), i, 1)),\n                    ' '\n                ),\n                range(1, length(unhex(coalesce(extra_data, ''))) + 1)\n            ),\n            ''\n        )\n    )\n)\n AS decoded_extra_data,\n    size,\n    mix_hash,\n    nonce,\n    base_fee_per_gas,\n    withdrawals_root,\n    block_timestamp\nFROM source", "relation_name": "`dbt`.`stg_execution__blocks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.010278Z", "completed_at": "2025-10-15T13:38:03.014313Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.014887Z", "completed_at": "2025-10-15T13:38:03.014894Z"}], "thread_id": "Thread-1", "execution_time": 0.005903005599975586, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__storage_diffs", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n    SELECT \n        block_number,\n        transaction_index,\n        CONCAT('0x', transaction_hash) AS transaction_hash,\n        CONCAT('0x', address) AS address,\n        slot,\n        from_value,\n        to_value,\n        block_timestamp\n    FROM \n        `execution`.`storage_diffs`\n)\n\nSELECT\n    *\nFROM source", "relation_name": "`dbt`.`stg_execution__storage_diffs`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.017597Z", "completed_at": "2025-10-15T13:38:03.021792Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.022378Z", "completed_at": "2025-10-15T13:38:03.022385Z"}], "thread_id": "Thread-1", "execution_time": 0.006010293960571289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__transactions", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n    SELECT\n        block_number,\n        transaction_index,\n        transaction_hash,\n        nonce,\n        from_address,\n        to_address,\n        value_string,\n        input,\n        gas_limit,\n        gas_used,\n        gas_price,\n        transaction_type,\n        max_priority_fee_per_gas,\n        max_fee_per_gas,\n        success,\n        n_input_bytes,\n        n_input_zero_bytes,\n        n_input_nonzero_bytes,\n        n_rlp_bytes,\n        r,\n        s,\n        v,\n        block_hash,\n        block_timestamp\n    FROM `execution`.`transactions` FINAL\n)\n\nSELECT\n    block_number,\n    transaction_index,\n    transaction_hash,\n    nonce,\n    CONCAT('0x',from_address) AS from_address,\n    IF(to_address IS NULL, NULL, CONCAT('0x',to_address)) AS to_address,\n    CAST(value_string AS UInt256) AS value,\n    input,\n    gas_limit,\n    gas_used,\n    gas_price,\n    transaction_type,\n    max_priority_fee_per_gas,\n    max_fee_per_gas,\n    success,\n    n_input_bytes,\n    n_input_zero_bytes,\n    n_input_nonzero_bytes,\n    n_rlp_bytes,\n    r,\n    s,\n    v,\n    block_hash,\n    block_timestamp\nFROM source", "relation_name": "`dbt`.`stg_execution__transactions`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.025112Z", "completed_at": "2025-10-15T13:38:03.030079Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.030680Z", "completed_at": "2025-10-15T13:38:03.030687Z"}], "thread_id": "Thread-1", "execution_time": 0.006899356842041016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__discovery_id_prefixes_x_peer_ids", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    discovery_id_prefix,\n    peer_id\n  FROM `nebula_discv4`.`discovery_id_prefixes_x_peer_ids` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.033322Z", "completed_at": "2025-10-15T13:38:03.037151Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.037740Z", "completed_at": "2025-10-15T13:38:03.037747Z"}], "thread_id": "Thread-1", "execution_time": 0.005676746368408203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__neighbors", "compiled": true, "compiled_code": "\n\nWITH \n\nsource AS (\n  SELECT \n    crawl_id,\n    crawl_created_at,\n    peer_discovery_id_prefix,\n    neighbor_discovery_id_prefix,\n    error_bits\n  FROM `nebula_discv4`.`neighbors` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__neighbors`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.040373Z", "completed_at": "2025-10-15T13:38:03.044275Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.044849Z", "completed_at": "2025-10-15T13:38:03.044857Z"}], "thread_id": "Thread-1", "execution_time": 0.0057086944580078125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__visits", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    crawl_id,\n    peer_id,\n    agent_version,\n    protocols,\n    dial_maddrs,\n    filtered_maddrs,\n    extra_maddrs,\n    dial_errors,\n    connect_maddr,\n    crawl_error,\n    visit_started_at,\n    visit_ended_at,\n    peer_properties\n  FROM `nebula_discv4`.`visits` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__visits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.047608Z", "completed_at": "2025-10-15T13:38:03.051446Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.052016Z", "completed_at": "2025-10-15T13:38:03.052024Z"}], "thread_id": "Thread-1", "execution_time": 0.0056610107421875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__discovery_id_prefixes_x_peer_ids", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    discovery_id_prefix,\n    peer_id\n  FROM `nebula`.`discovery_id_prefixes_x_peer_ids` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.054761Z", "completed_at": "2025-10-15T13:38:03.058555Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.059119Z", "completed_at": "2025-10-15T13:38:03.059126Z"}], "thread_id": "Thread-1", "execution_time": 0.005596160888671875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__neighbors", "compiled": true, "compiled_code": "\n\nWITH \n\nsource AS (\n  SELECT \n    crawl_id,\n    crawl_created_at,\n    peer_discovery_id_prefix,\n    neighbor_discovery_id_prefix,\n    error_bits\n  FROM `nebula`.`neighbors` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__neighbors`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.061727Z", "completed_at": "2025-10-15T13:38:03.065749Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.066327Z", "completed_at": "2025-10-15T13:38:03.066335Z"}], "thread_id": "Thread-1", "execution_time": 0.005822658538818359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__visits", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    crawl_id,\n    peer_id,\n    agent_version,\n    protocols,\n    dial_maddrs,\n    filtered_maddrs,\n    extra_maddrs,\n    dial_errors,\n    connect_maddr,\n    crawl_error,\n    visit_started_at,\n    visit_ended_at,\n    peer_properties\n  FROM `nebula`.`visits` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__visits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.069016Z", "completed_at": "2025-10-15T13:38:03.072163Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.072761Z", "completed_at": "2025-10-15T13:38:03.072767Z"}], "thread_id": "Thread-1", "execution_time": 0.004983186721801758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.contracts_abi", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.075820Z", "completed_at": "2025-10-15T13:38:03.077714Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.078293Z", "completed_at": "2025-10-15T13:38:03.078299Z"}], "thread_id": "Thread-1", "execution_time": 0.003696918487548828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.event_signatures", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.081446Z", "completed_at": "2025-10-15T13:38:03.083325Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.083884Z", "completed_at": "2025-10-15T13:38:03.083890Z"}], "thread_id": "Thread-1", "execution_time": 0.0037436485290527344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.function_signatures", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.086522Z", "completed_at": "2025-10-15T13:38:03.088413Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.089249Z", "completed_at": "2025-10-15T13:38:03.089256Z"}], "thread_id": "Thread-1", "execution_time": 0.004053354263305664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.tokens_whitelist", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.091926Z", "completed_at": "2025-10-15T13:38:03.099971Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.100562Z", "completed_at": "2025-10-15T13:38:03.100570Z"}], "thread_id": "Thread-1", "execution_time": 0.009882926940917969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_attestations_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,slot - attestation_slot AS inclusion_delay\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__attestations`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_attestations_daily`\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_attestations_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.103304Z", "completed_at": "2025-10-15T13:38:03.109776Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.110372Z", "completed_at": "2025-10-15T13:38:03.110379Z"}], "thread_id": "Thread-1", "execution_time": 0.008309125900268555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_blob_commitments_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__blob_commitments`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_blob_commitments_daily`\n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_consensus_blob_commitments_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.113075Z", "completed_at": "2025-10-15T13:38:03.118717Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.119310Z", "completed_at": "2025-10-15T13:38:03.119317Z"}], "thread_id": "Thread-1", "execution_time": 0.0074901580810546875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_graffiti_daily", "compiled": true, "compiled_code": "\n\nWITH\n    -- Canonical lists\n    ['nethermind','erigon','geth','besu','reth'] AS el_keys,\n    ['Nethermind','Erigon','Geth','Besu','Reth'] AS el_names,\n    ['lighthouse','teku','prysm','lodestar','nimbus'] AS cl_keys,\n    ['Lighthouse','Teku','Prysm','Lodestar','Nimbus'] AS cl_names,\n\n    -- Platform/hosting brands \n    ['dappnode','avado','allnodes','twinstake','stakewise','gateway','kleros',\n     'filoozom','kpk-validators','hopr','digitalconsultantsllc',\n     'synthex'] AS brand_keys,\n    ['DappNode','Avado','Allnodes','Twinstake','StakeWise','gateway.fm','kleros.io',\n     'filoozom.eth','kpk-validators','HOPR','DigitalConsultantsLLC.xyz',\n     'Synthex'] AS brand_names,\n\n\nfinal AS (\n    SELECT\n        date\n        ,graffiti\n        ,cnt\n        -- Lowercased text to search in\n        ,lowerUTF8(graffiti) AS g\n\n        -- Detect any brand first (highest precedence)\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, brand_keys) AS brands_found\n        ,if(length(brands_found) > 0,\n            arrayElement(brand_names, indexOf(brand_keys, brands_found[1])),\n            null) AS brand_label\n\n        -- Detect EL/CL clients (order-insensitive, separator-agnostic)\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, el_keys) AS el_found\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, cl_keys) AS cl_found\n\n        -- Pick the first match per side by priority order above\n        ,if(length(el_found) > 0,\n            arrayElement(el_names, indexOf(el_keys, el_found[1])),\n            null) AS el_label\n\n        ,if(length(cl_found) > 0,\n            arrayElement(cl_names, indexOf(cl_keys, cl_found[1])),\n            null) AS cl_label\n\n        -- Final label priority:\n        -- 1) Brand/platform if any\n        -- 2) EL+CL combo if both found\n        -- 3) Single client if only one side found\n        -- 4) Other\n        ,coalesce(\n            brand_label,\n            if(el_label IS NOT NULL AND cl_label IS NOT NULL, concat(el_label, '+', cl_label), null),\n            el_label,\n            cl_label,\n            if(graffiti = 'None', graffiti, null),\n            'Other'\n        ) AS label\n    FROM (\n        SELECT\n            toStartOfDay(slot_timestamp) AS date\n            ,IF(graffiti='0x0000000000000000000000000000000000000000000000000000000000000000', \n                'None', \n                unhex(right(graffiti,-2))\n            ) AS graffiti\n            ,COUNT(*) AS cnt\n        FROM `dbt`.`stg_consensus__blocks`\n        WHERE\n            slot_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_graffiti_daily`\n    )\n  \n\n        GROUP BY 1, 2\n    )\n)\n\nSELECT\n    date\n    ,graffiti\n    ,label\n    ,cnt\nFROM final", "relation_name": "`dbt`.`int_consensus_graffiti_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.122101Z", "completed_at": "2025-10-15T13:38:03.127457Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.128024Z", "completed_at": "2025-10-15T13:38:03.128031Z"}], "thread_id": "Thread-1", "execution_time": 0.007300853729248047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_deposits_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,SUM(amount/POWER(10,9)) AS total_amount\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__deposits`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_deposits_daily`\n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_consensus_deposits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.130680Z", "completed_at": "2025-10-15T13:38:03.135103Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.135699Z", "completed_at": "2025-10-15T13:38:03.135706Z"}], "thread_id": "Thread-1", "execution_time": 0.006251335144042969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_forks", "compiled": true, "compiled_code": "\n\nWITH\n\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\nfork_version AS (\n    SELECT\n        IF(fork_name='GENESIS', 'PHASE0', fork_name) AS fork_name\n        ,parameter_value\n    FROM (\n        SELECT\n            arrayElement(splitByChar('_', ifNull(parameter_name, '')), 1) AS fork_name\n            ,parameter_value\n        FROM `dbt`.`stg_consensus__specs`\n        WHERE parameter_name LIKE '%_FORK_VERSION'\n    )\n),\n\nfork_epoch AS (\n    SELECT\n        arrayElement(splitByChar('_', ifNull(parameter_name, '')), 1) AS fork_name\n        ,parameter_value\n    FROM `dbt`.`stg_consensus__specs`\n    WHERE parameter_name LIKE '%_FORK_EPOCH'\n\n    UNION ALL \n\n    SELECT 'PHASE0' AS fork_name, '0' AS parameter_value \n)\n\nSELECT \n  t1.cl_fork_name AS fork_name\n  ,t2.parameter_value AS fork_version \n  ,t1.fork_digest AS fork_digest\n  ,t3.parameter_value AS fork_epoch \n  ,IF(CAST(t3.parameter_value AS Int) = -1, NULL,\n    addSeconds(\n          toDateTime(t4.genesis_time_unix, 'UTC'),\n          CAST(t3.parameter_value AS Int) * (t4.seconds_per_slot * t4.slots_per_epoch )\n      )\n   ) AS fork_time\nFROM \n  fork_digests t1\nINNER JOIN\n  fork_version t2\n  ON LOWER(t2.fork_name) = LOWER(t1.cl_fork_name)\nINNER JOIN\n  fork_epoch t3\n  ON LOWER(t3.fork_name) = LOWER(t1.cl_fork_name)\nCROSS JOIN `dbt`.`stg_consensus__time_helpers` t4", "relation_name": "`dbt`.`fct_consensus_forks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.138427Z", "completed_at": "2025-10-15T13:38:03.144133Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.144719Z", "completed_at": "2025-10-15T13:38:03.144726Z"}], "thread_id": "Thread-1", "execution_time": 0.00762629508972168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_blocks_daily", "compiled": true, "compiled_code": "\n\nWITH\n\ntime_helpers AS (\n    SELECT\n        genesis_time_unix,\n        seconds_per_slot\n    FROM \n        `dbt`.`stg_consensus__time_helpers`\n)\n\nSELECT\n    date\n    ,cnt AS blocks_produced\n    ,CASE\n        WHEN toStartOfDay(toDateTime(genesis_time_unix)) = date \n            THEN CAST((86400 - toUnixTimestamp(toDateTime(genesis_time_unix)) % 86400) / seconds_per_slot - cnt AS UInt64)\n        ELSE CAST(86400 / seconds_per_slot - cnt AS UInt64)\n    END AS blocks_missed\nFROM (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date\n        ,COUNT(*) AS cnt\n    FROM `dbt`.`stg_consensus__blocks`\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_blocks_daily`\n    )\n  \n\n    GROUP BY 1\n) t1\nCROSS JOIN time_helpers t2", "relation_name": "`dbt`.`int_consensus_blocks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.147450Z", "completed_at": "2025-10-15T13:38:03.153086Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.153675Z", "completed_at": "2025-10-15T13:38:03.153682Z"}], "thread_id": "Thread-1", "execution_time": 0.007480144500732422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_credentials_daily", "compiled": true, "compiled_code": "\n\n\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,leftUTF8(withdrawal_credentials, 4) AS credentials_type\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__validators`\n\n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_credentials_daily`\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_credentials_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.156497Z", "completed_at": "2025-10-15T13:38:03.163211Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.163794Z", "completed_at": "2025-10-15T13:38:03.163801Z"}], "thread_id": "Thread-1", "execution_time": 0.008713960647583008, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_entry_queue_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nqueue_activation AS (\n    SELECT\n        validator_index\n        ,date\n        ,epoch_eligibility\n        ,epoch_activation\n        ,(epoch_activation - epoch_eligibility) * 16 * 5 /(60 * 60 * 24) AS activation_days\n    FROM (\n        SELECT \n            validator_index\n            ,toStartOfDay(argMin(slot_timestamp,slot)) AS date\n            ,argMin(activation_eligibility_epoch,slot) AS epoch_eligibility\n            ,argMin(activation_epoch,slot) AS epoch_activation\n        FROM `dbt`.`stg_consensus__validators`\n        WHERE \n            activation_epoch < 18446744073709551615\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_entry_queue_daily`\n    )\n  \n\n        GROUP BY 1\n    )\n)\n\nSELECT\n    date\n    ,validator_count\n    ,q_activation[1] AS q05\n    ,q_activation[2] AS q10\n    ,q_activation[3] AS q25\n    ,q_activation[4] AS q50\n    ,q_activation[5] AS q75\n    ,q_activation[6] AS q90\n    ,q_activation[7] AS q95\n    ,mean\nFROM (\n    SELECT\n        date,\n        count() AS validator_count\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(activation_days) AS q_activation\n        ,avg(activation_days) AS  mean\n    FROM queue_activation\n    GROUP BY date\n)", "relation_name": "`dbt`.`int_consensus_entry_queue_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.166520Z", "completed_at": "2025-10-15T13:38:03.171859Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.172440Z", "completed_at": "2025-10-15T13:38:03.172447Z"}], "thread_id": "Thread-1", "execution_time": 0.007163047790527344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_balances_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,SUM(balance/POWER(10,9)) AS balance\n    ,SUM(effective_balance/POWER(10,9)) AS effective_balance\nFROM `dbt`.`stg_consensus__validators`\nWHERE \n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_balances_daily`\n    )\n  \n\nGROUP BY date", "relation_name": "`dbt`.`int_consensus_validators_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.175193Z", "completed_at": "2025-10-15T13:38:03.180564Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.181140Z", "completed_at": "2025-10-15T13:38:03.181148Z"}], "thread_id": "Thread-1", "execution_time": 0.007335186004638672, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_balances_dist_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q_balance[1] AS q05,\n    q_balance[2] AS q10,\n    q_balance[3] AS q25,\n    q_balance[4] AS q50,\n    q_balance[5] AS q75,\n    q_balance[6] AS q90,\n    q_balance[7] AS q95\nFROM (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n       quantilesTDigest(-- quantilesExactExclusive(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(balance/POWER(10,9)) AS q_balance\n    FROM `dbt`.`stg_consensus__validators`\n    WHERE \n        status = 'active_ongoing'\n        AND\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_balances_dist_daily`\n    )\n  \n\n    GROUP BY date\n)", "relation_name": "`dbt`.`int_consensus_validators_balances_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.183822Z", "completed_at": "2025-10-15T13:38:03.189103Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.189682Z", "completed_at": "2025-10-15T13:38:03.189689Z"}], "thread_id": "Thread-1", "execution_time": 0.007080793380737305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_status_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,status\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__validators`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_status_daily`\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_validators_status_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.192443Z", "completed_at": "2025-10-15T13:38:03.198125Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.198722Z", "completed_at": "2025-10-15T13:38:03.198729Z"}], "thread_id": "Thread-1", "execution_time": 0.00751948356628418, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_apy_dist", "compiled": true, "compiled_code": "\n\nWITH\n\n/* 1) Daily per-validator balance snapshot (already 1 row/day) */\ndaily_validator_balances AS (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n        pubkey,\n        validator_index,\n        balance\n    FROM `dbt`.`stg_consensus__validators`\n    WHERE \n        balance > 0\n        AND\n        toStartOfDay(slot_timestamp) >= DATE '2023-01-01'\n        AND\n        toStartOfDay(slot_timestamp) < DATE '2023-02-01'\n),\n\n/* 2) True previous-day balance per validator using a window function */\nvalidator_with_prev AS (\n    SELECT\n        date,\n        pubkey,\n        validator_index,\n        balance,\n        -- default value = current balance on first day\n        lagInFrame(balance, 1, balance) OVER (\n            PARTITION BY pubkey, validator_index\n            ORDER BY date\n        ) AS prev_balance\n    FROM daily_validator_balances\n),\n\n/* 3) Get date range to filter other tables - materialize this first */\ndate_range AS (\n    SELECT \n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM validator_with_prev\n),\n\n/* 4) Per-day deposits - direct pubkey and amount columns */\ndeposits AS (\n    SELECT\n        toStartOfDay(d.slot_timestamp) AS dep_date,\n        d.pubkey AS dep_pubkey,\n        sum(d.amount) AS dep_amount\n    FROM `dbt`.`stg_consensus__deposits` d\n    CROSS JOIN date_range dr\n    WHERE toStartOfDay(d.slot_timestamp) >= dr.min_date \n      AND toStartOfDay(d.slot_timestamp) <= dr.max_date\n    GROUP BY toStartOfDay(d.slot_timestamp), d.pubkey\n),\n\n/* 5) Deposit requests - use JSON extraction with explicit date range */\ndeposit_requests AS (\n    SELECT\n        toStartOfDay(dr_table.slot_timestamp) AS dr_date,\n        toString(JSONExtractString(deposit, 'pubkey')) AS dr_pubkey,\n        sum(toUInt64(JSONExtractString(deposit, 'amount'))) AS dep_req_amount\n    FROM `dbt`.`stg_consensus__execution_requests` dr_table\n    ARRAY JOIN JSONExtractArrayRaw(dr_table.payload, 'deposits') AS deposit\n    CROSS JOIN date_range dr\n    WHERE toStartOfDay(dr_table.slot_timestamp) >= dr.min_date \n      AND toStartOfDay(dr_table.slot_timestamp) <= dr.max_date\n    GROUP BY toStartOfDay(dr_table.slot_timestamp), toString(JSONExtractString(deposit, 'pubkey'))\n),\n\n/* 6) Withdrawals - uses validator_index, not pubkey */\nwithdrawals AS (\n    SELECT\n        toStartOfDay(w.slot_timestamp) AS w_date,\n        w.validator_index AS w_validator_index,\n        sum(w.amount) AS wdr_amount\n    FROM `dbt`.`stg_consensus__withdrawals` w\n    CROSS JOIN date_range dr\n    WHERE toStartOfDay(w.slot_timestamp) >= dr.min_date \n      AND toStartOfDay(w.slot_timestamp) <= dr.max_date\n    GROUP BY toStartOfDay(w.slot_timestamp), w.validator_index\n),\n\n/* 7) Withdrawal requests - use JSON extraction with explicit date range */\nwithdrawal_requests AS (\n    SELECT\n        toStartOfDay(wr_table.slot_timestamp) AS wr_date,\n        toString(JSONExtractString(withdrawals, 'validator_pubkey')) AS wr_pubkey,\n        sum(toUInt64(JSONExtractString(withdrawals, 'amount'))) AS wdr_req_amount\n    FROM `dbt`.`stg_consensus__execution_requests` wr_table\n    ARRAY JOIN JSONExtractArrayRaw(wr_table.payload, 'withdrawals') AS withdrawals\n    CROSS JOIN date_range dr\n    WHERE toStartOfDay(wr_table.slot_timestamp) >= dr.min_date \n      AND toStartOfDay(wr_table.slot_timestamp) <= dr.max_date\n    GROUP BY toStartOfDay(wr_table.slot_timestamp), toString(JSONExtractString(withdrawals, 'validator_pubkey'))\n),\n\n/* 8) Per-validator daily net change excluding external flows */\nvalidator_rates AS (\n    SELECT\n        v.date,\n        v.pubkey,\n        v.validator_index,\n        v.prev_balance,\n        v.balance,\n        (v.balance - v.prev_balance) AS raw_diff,\n\n        coalesce(d.dep_amount, 0) AS deposits_amt,\n        coalesce(dr.dep_req_amount, 0) AS deposit_req_amt,\n        coalesce(w.wdr_amount, 0) AS withdrawals_amt,\n        coalesce(wr.wdr_req_amount, 0) AS withdrawal_req_amt,\n\n        /* Adjust for external flows (requests set to 0 unless you want them) */\n        (\n            (v.balance - v.prev_balance)\n            - coalesce(d.dep_amount, 0)   -- deposits increase balance -> subtract to isolate rewards\n            + coalesce(w.wdr_amount, 0)   -- withdrawals decrease balance -> add back\n            - coalesce(dr.dep_req_amount, 0)\n            + coalesce(wr.wdr_req_amount, 0)\n        ) AS adjusted_diff,\n\n        /* Daily rate per validator; guard against division by zero. */\n        CASE \n            WHEN v.prev_balance > 0 \n            THEN toFloat64(adjusted_diff) / toFloat64(v.prev_balance)\n            ELSE toFloat64(0)\n        END AS rate\n    FROM validator_with_prev v\n    LEFT JOIN deposits d ON d.dep_date = v.date AND d.dep_pubkey = v.pubkey\n    LEFT JOIN deposit_requests dr ON dr.dr_date = v.date AND dr.dr_pubkey = v.pubkey\n    LEFT JOIN withdrawals w ON w.w_date = v.date AND w.w_validator_index = v.validator_index\n    LEFT JOIN withdrawal_requests wr ON wr.wr_date = v.date AND wr.wr_pubkey = v.pubkey\n    WHERE v.prev_balance > 0  -- Only consider validators with positive previous balance\n        AND v.date > DATE '2023-01-01'\n)\n\n\nSELECT\n    date,\n    ROUND(q_apy[1],2) AS q05,\n    ROUND(q_apy[2],2) AS q10,\n    ROUND(q_apy[3],2) AS q25,\n    ROUND(q_apy[4],2) AS q50,\n    ROUND(q_apy[5],2) AS q75,\n    ROUND(q_apy[6],2) AS q90,\n    ROUND(q_apy[7],2) AS q95 \nFROM (\n    SELECT\n        toStartOfMonth(date) AS date\n        ,quantilesTDigest(-- quantilesExactExclusive(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )((power(1 + rate, 365) - 1) * 100) AS q_apy\n    FROM validator_rates\n    GROUP BY 1\n)", "relation_name": "`dbt`.`int_consensus_validators_apy_dist`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.201433Z", "completed_at": "2025-10-15T13:38:03.208004Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.208582Z", "completed_at": "2025-10-15T13:38:03.208589Z"}], "thread_id": "Thread-1", "execution_time": 0.008385181427001953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_withdrawls_dist_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,total_amount\n    ,cnt\n    ,q_amount[1] AS min\n    ,q_amount[2] AS q05\n    ,q_amount[3] AS q10\n    ,q_amount[4] AS q25\n    ,q_amount[5] AS q50\n    ,q_amount[6] AS q75\n    ,q_amount[7] AS q90\n    ,q_amount[8] AS q95\n    ,q_amount[9] AS max\nFROM (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date\n        ,SUM(amount/POWER(10,9)) AS total_amount\n        ,COUNT(*) AS cnt\n        ,quantilesTDigest(\n            0.0, 0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95, 1\n        )(amount/POWER(10,9)) AS q_amount\n    FROM `dbt`.`stg_consensus__withdrawals`\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_withdrawls_dist_daily`\n    )\n  \n\n    GROUP BY 1\n)", "relation_name": "`dbt`.`int_consensus_withdrawls_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.211343Z", "completed_at": "2025-10-15T13:38:03.216140Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.216737Z", "completed_at": "2025-10-15T13:38:03.216745Z"}], "thread_id": "Thread-1", "execution_time": 0.006823539733886719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.dbt_utils_unique_combination_of_columns_stg_crawlers_data__dune_prices_date__symbol.12e0dbaa70", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        date, symbol\n    from `dbt`.`stg_crawlers_data__dune_prices`\n    group by date, symbol\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.219315Z", "completed_at": "2025-10-15T13:38:03.228434Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.228988Z", "completed_at": "2025-10-15T13:38:03.228996Z"}], "thread_id": "Thread-1", "execution_time": 0.010904312133789062, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_prices_date.a7e4d781b8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`stg_crawlers_data__dune_prices`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.231610Z", "completed_at": "2025-10-15T13:38:03.236031Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.236614Z", "completed_at": "2025-10-15T13:38:03.236621Z"}], "thread_id": "Thread-1", "execution_time": 0.006247997283935547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_prices_price.c31ece6228", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect price\nfrom `dbt`.`stg_crawlers_data__dune_prices`\nwhere price is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.239205Z", "completed_at": "2025-10-15T13:38:03.243782Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.244355Z", "completed_at": "2025-10-15T13:38:03.244362Z"}], "thread_id": "Thread-1", "execution_time": 0.006369829177856445, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_stg_crawlers_data__dune_prices_symbol.4496b19dac", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect symbol\nfrom `dbt`.`stg_crawlers_data__dune_prices`\nwhere symbol is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.246954Z", "completed_at": "2025-10-15T13:38:03.253078Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.253665Z", "completed_at": "2025-10-15T13:38:03.253672Z"}], "thread_id": "Thread-1", "execution_time": 0.007938861846923828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_carbon_intensity_ensemble", "compiled": true, "compiled_code": "\n\nWITH ember_monthly AS (\n    -- Monthly carbon intensity from Ember with enhanced uncertainty\n    SELECT\n        toDate(\"Date\") AS month_date,\n        CASE \n            WHEN \"Area\" = 'World' THEN 'WORLD'  -- World average as special country code\n            ELSE \"ISO 3 code\"\n        END AS country_code,\n        \"Value\" AS carbon_intensity_gco2_kwh,\n        COALESCE(\"Continent\", 'World') AS continent,\n        'ember' AS source,\n        0.85 AS base_confidence\n    FROM `dbt`.`stg_crawlers_data__ember_electricity_data`\n    WHERE   \n        \"Unit\" = 'gCO2/kWh'\n        AND (\n            (\"ISO 3 code\" IS NOT NULL AND \"ISO 3 code\" != '') OR \n            (\"Area\" = 'World')  -- Include World data\n        )\n        AND \"Value\" IS NOT NULL\n        AND \"Value\" > 0\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(\"Date\")) >= (\n      SELECT\n        max(toStartOfMonth(month_date))\n      FROM `dbt`.`int_esg_carbon_intensity_ensemble`\n    )\n  \n\n),\n\n-- Enhanced uncertainty modeling for monthly data\nuncertainty_enhanced AS (\n    SELECT\n        month_date,\n        country_code,\n        continent,\n        carbon_intensity_gco2_kwh AS base_ci,\n        \n        -- Calculate temporal uncertainty based on grid characteristics\n        -- Higher uncertainty for countries with more variable generation\n        carbon_intensity_gco2_kwh * (\n            CASE \n                -- High renewable countries have more temporal variation\n                WHEN carbon_intensity_gco2_kwh < 100 THEN 0.25  -- Low carbon grids (solar/wind heavy)\n                WHEN carbon_intensity_gco2_kwh < 300 THEN 0.20  -- Medium carbon grids  \n                WHEN carbon_intensity_gco2_kwh < 600 THEN 0.15  -- High carbon grids (more stable)\n                ELSE 0.12  -- Very high carbon grids (coal/gas baseload)\n            END\n        ) AS temporal_uncertainty,\n        \n        -- Data quality uncertainty (monthly averages hide daily/hourly variation)\n        carbon_intensity_gco2_kwh * 0.10 AS measurement_uncertainty,\n        \n        -- Continent-based seasonal adjustment factors\n        CASE continent\n            -- Europe & Asia (mostly Northern Hemisphere, heating-dominant)\n            WHEN 'Europe' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.18  -- Winter heating peak\n                    WHEN month(month_date) IN (6, 7, 8) THEN 0.92   -- Summer low + solar\n                    WHEN month(month_date) IN (3, 4, 11) THEN 1.08  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- Asia (mix of climates, but mostly Northern Hemisphere)\n            WHEN 'Asia' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.12  -- Winter (heating + industrial)\n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.08   -- Summer (cooling demand)\n                    WHEN month(month_date) IN (4, 5, 9, 10) THEN 1.05  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- North America (heating-dominant north, cooling-dominant south)\n            WHEN 'North America' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.15  -- Winter heating\n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.12   -- Summer cooling\n                    WHEN month(month_date) IN (4, 5, 9, 10) THEN 1.03  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- Oceania (Southern Hemisphere - reversed seasons)\n            WHEN 'Oceania' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.15   -- Southern winter\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.95  -- Southern summer\n                    WHEN month(month_date) IN (3, 4, 9, 10) THEN 1.05  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- South America (Southern Hemisphere + tropical)\n            WHEN 'South America' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.10   -- Southern winter (milder)\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.98  -- Southern summer\n                    ELSE 1.0\n                END\n                \n            -- Africa (mix of Northern/Southern + tropical, minimal variation)\n            WHEN 'Africa' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.05   -- Slight dry season effect\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.98  -- Wet season\n                    ELSE 1.0\n                END\n                \n            -- World/Default (minimal adjustment)\n            ELSE 1.0\n        END AS seasonal_factor,\n        \n        source,\n        base_confidence\n        \n    FROM ember_monthly\n),\n\n-- Final aggregation with confidence intervals\nfinal_estimates AS (\n    SELECT\n        month_date,\n        country_code,\n        \n        -- Point estimates with seasonal adjustment\n        round(base_ci * seasonal_factor, 2) AS carbon_intensity_mean,\n        \n        -- Combined uncertainty (temporal + measurement)\n        round(sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS carbon_intensity_std,\n        \n        -- Confidence intervals for Monte Carlo sampling\n        round(greatest(0, base_ci * seasonal_factor - 1.96 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2))), 2) AS ci_lower_95,\n        round(base_ci * seasonal_factor + 1.96 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS ci_upper_95,\n        \n        round(greatest(0, base_ci * seasonal_factor - 1.645 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2))), 2) AS ci_lower_90,\n        round(base_ci * seasonal_factor + 1.645 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS ci_upper_90,\n        \n        -- Coefficient of variation for uncertainty assessment\n        round(sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor), 3) AS coefficient_of_variation,\n        \n        -- Raw values for diagnostics\n        round(base_ci, 2) AS base_carbon_intensity,\n        round(temporal_uncertainty, 2) AS temporal_std,\n        round(measurement_uncertainty, 2) AS measurement_std,\n        round(seasonal_factor, 3) AS seasonal_adjustment,\n        continent,\n        \n        -- Data quality indicators\n        arrayPushFront([], source) AS sources_used,\n        base_confidence AS confidence_score,\n        1 AS n_sources,\n        \n        -- Uncertainty category for diagnostics\n        CASE \n            WHEN sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor) < 0.15 THEN 'Low'\n            WHEN sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor) < 0.25 THEN 'Medium' \n            ELSE 'High'\n        END AS uncertainty_category\n        \n    FROM uncertainty_enhanced\n)\n\nSELECT\n    month_date,\n    country_code,\n    \n    -- Core metrics for carbon footprint calculation\n    carbon_intensity_mean,\n    carbon_intensity_std,\n    ci_lower_95,\n    ci_upper_95,\n    ci_lower_90,\n    ci_upper_90,\n    \n    -- Uncertainty analysis\n    coefficient_of_variation,\n    uncertainty_category,\n    \n    -- Component breakdown for diagnostics\n    base_carbon_intensity,\n    temporal_std,\n    measurement_std,\n    seasonal_adjustment,\n    \n    -- Data provenance and quality\n    sources_used,\n    confidence_score,\n    n_sources,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM final_estimates", "relation_name": "`dbt`.`int_esg_carbon_intensity_ensemble`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.256292Z", "completed_at": "2025-10-15T13:38:03.261156Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.261746Z", "completed_at": "2025-10-15T13:38:03.261753Z"}], "thread_id": "Thread-1", "execution_time": 0.006697893142700195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,any_value(toInt32(floor(__total))) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d` \nGROUP BY 1, 2\nORDER BY date ASC, client ASC", "relation_name": "`dbt`.`api_probelab_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.264374Z", "completed_at": "2025-10-15T13:38:03.268053Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.268635Z", "completed_at": "2025-10-15T13:38:03.268642Z"}], "thread_id": "Thread-1", "execution_time": 0.005563974380493164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_version_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,agent_version_semver_str AS version\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d` \nORDER BY date ASC, client ASC, version ASC", "relation_name": "`dbt`.`api_probelab_clients_version_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.271295Z", "completed_at": "2025-10-15T13:38:03.274984Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.275568Z", "completed_at": "2025-10-15T13:38:03.275575Z"}], "thread_id": "Thread-1", "execution_time": 0.005522966384887695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_cloud_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,cloud_provider AS cloud\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d` \nORDER BY date ASC, client ASC, cloud ASC", "relation_name": "`dbt`.`api_probelab_clients_cloud_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.278202Z", "completed_at": "2025-10-15T13:38:03.281901Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.282475Z", "completed_at": "2025-10-15T13:38:03.282483Z"}], "thread_id": "Thread-1", "execution_time": 0.005494356155395508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_country_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,country\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_countries_avg_1d` \nORDER BY date ASC, client ASC, country ASC", "relation_name": "`dbt`.`api_probelab_clients_country_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.285075Z", "completed_at": "2025-10-15T13:38:03.288782Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.289362Z", "completed_at": "2025-10-15T13:38:03.289370Z"}], "thread_id": "Thread-1", "execution_time": 0.005568027496337891, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_quic_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,quic_support AS quic\n    ,__count AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_quic_support_over_7d` \nORDER BY date ASC, client ASC, quic ASC", "relation_name": "`dbt`.`api_probelab_clients_quic_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.291974Z", "completed_at": "2025-10-15T13:38:03.297443Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.298006Z", "completed_at": "2025-10-15T13:38:03.298013Z"}], "thread_id": "Thread-1", "execution_time": 0.00732731819152832, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_blocks_clients_version_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nclients_version AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date\n        ,multiIf(\n             lower(decoded_extra_data[1]) = 'choose' \n            OR lower(decoded_extra_data[1]) = 'mysticryuujin'  \n            OR lower(decoded_extra_data[1]) = 'sanae.io'\n            OR decoded_extra_data[1] = ''  , \n            'Unknown',\n            decoded_extra_data[1]\n        )   AS client\n        ,IF(length(decoded_extra_data)>1, \n            IF(decoded_extra_data[2]='Ethereum',decoded_extra_data[3],decoded_extra_data[2]), \n            ''\n        ) AS version\n        ,COUNT(*) AS cnt\n    FROM `dbt`.`stg_execution__blocks`\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_blocks_clients_version_daily`\n    )\n  \n\n    GROUP BY 1, 2, 3\n)\n\nSELECT\n    *\nFROM clients_version", "relation_name": "`dbt`.`int_execution_blocks_clients_version_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.300749Z", "completed_at": "2025-10-15T13:38:03.307297Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.307872Z", "completed_at": "2025-10-15T13:38:03.307880Z"}], "thread_id": "Thread-1", "execution_time": 0.008444070816040039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_blocks_gas_usage_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  toDate(block_timestamp)         AS date,\n  SUM(gas_used)                   AS gas_used_sum,\n  SUM(gas_limit)                  AS gas_limit_sum,\n  gas_used_sum / NULLIF(gas_limit_sum, 0) AS gas_used_fraq\nFROM `dbt`.`stg_execution__blocks`\n\n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_blocks_gas_usage_daily`\n    )\n  \n\nGROUP BY date", "relation_name": "`dbt`.`int_execution_blocks_gas_usage_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.310819Z", "completed_at": "2025-10-15T13:38:03.316197Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.316788Z", "completed_at": "2025-10-15T13:38:03.316795Z"}], "thread_id": "Thread-1", "execution_time": 0.007359504699707031, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_state_size_full_diff_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\n\nstate_size_diff AS (\n    SELECT \n        toStartOfDay(block_timestamp) AS date \n        ,SUM(IF(to_value!='0000000000000000000000000000000000000000000000000000000000000000',32,-32)) AS bytes_diff\n    FROM \n        `dbt`.`stg_execution__storage_diffs`\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_state_size_full_diff_daily`\n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT\n    *\nFROM state_size_diff", "relation_name": "`dbt`.`int_execution_state_size_full_diff_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.319462Z", "completed_at": "2025-10-15T13:38:03.326816Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.327417Z", "completed_at": "2025-10-15T13:38:03.327425Z"}], "thread_id": "Thread-1", "execution_time": 0.00929570198059082, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_info_daily", "compiled": true, "compiled_code": "\n\nWITH tx AS (\n  SELECT\n    block_timestamp,\n    toDate(block_timestamp)             AS date,\n    toString(transaction_type)          AS transaction_type,\n    coalesce(success, 0)                AS success,\n    toFloat64(value) / 1e18             AS value_native,             \n    toFloat64(coalesce(gas_used, 0))    AS gas_used,                 \n    toFloat64(coalesce(gas_price, 0))   AS gas_price                 \n  FROM `dbt`.`stg_execution__transactions`\n  WHERE block_timestamp < today()\n  \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_transactions_info_daily`\n    )\n  \n\n),\n\nagg_base AS (\n  SELECT\n    date,\n    transaction_type,\n    success,\n    COUNT()                     AS n_txs,\n    SUM(value_native)           AS xdai_value_sum_raw,\n    AVG(value_native)           AS xdai_value_avg_raw,\n    median(value_native)        AS xdai_value_median_raw,\n    SUM(gas_used)               AS gas_used_sum_raw,          -- \u201cgas units\u201d\n    AVG(gas_price)              AS gas_price_avg_raw_wei,     -- in wei\n    median(gas_price)           AS gas_price_med_raw_wei,     -- in wei\n    SUM(gas_used * gas_price)   AS fee_sum_raw_wei            -- in wei\n  FROM tx\n  GROUP BY date, transaction_type, success\n),\n\nagg AS (\n  SELECT\n    date,\n    transaction_type,\n    success,\n    n_txs,\n    xdai_value_sum_raw                       AS xdai_value,\n    xdai_value_avg_raw                       AS xdai_value_avg,\n    xdai_value_median_raw                    AS xdai_value_median,\n    gas_used_sum_raw                         AS gas_used,\n    CAST(gas_price_avg_raw_wei / 1e9 AS Int32)   AS gas_price_avg,       -- Gwei\n    CAST(gas_price_med_raw_wei / 1e9 AS Int32)   AS gas_price_median,    -- Gwei\n    fee_sum_raw_wei / 1e18                   AS fee_native_sum          -- xDai\n  FROM agg_base\n),\n\npx AS (\n  SELECT\n    date,\n    price\n  FROM `dbt`.`stg_crawlers_data__dune_prices`\n  WHERE symbol = 'XDAI'\n  \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_transactions_info_daily`\n    )\n  \n\n)\n\nSELECT\n  a.date,\n  a.transaction_type,\n  a.success,\n  a.n_txs,\n  a.xdai_value,\n  a.xdai_value_avg,\n  a.xdai_value_median,\n  a.gas_used,\n  a.gas_price_avg,\n  a.gas_price_median,\n  a.fee_native_sum,\n  a.fee_native_sum * coalesce(px.price, 1.0) AS fee_usd_sum\nFROM agg a\nLEFT JOIN px\n  ON px.date = a.date", "relation_name": "`dbt`.`int_execution_transactions_info_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.330240Z", "completed_at": "2025-10-15T13:38:03.336567Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.337128Z", "completed_at": "2025-10-15T13:38:03.337136Z"}], "thread_id": "Thread-1", "execution_time": 0.008401632308959961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_peers", "compiled": true, "compiled_code": "\n\nWITH\n\n  peers AS (\n    SELECT \n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors\n  FROM `dbt`.`stg_nebula_discv4__visits` A\n  WHERE\n      toString(peer_properties.network_id) = '100'\n      \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(visit_ended_at))\n      FROM `dbt`.`int_p2p_discv4_peers`\n    )\n  \n\n  ),\n\n  parsed AS (\n    SELECT\n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors,\n      -- break into slash-delimited parts\n      splitByChar('/', agent_version)                        AS slash_parts,\n      length(slash_parts)                                    AS sp_len,\n\n      -- if 4+ parts, take last two as platform+runtime; otherwise only platform\n      IF(\n        length(slash_parts) > 3,\n        arrayElement(slash_parts, sp_len-1),\n        arrayElement(slash_parts, sp_len)\n      )                                                       AS platform,\n\n      IF(\n        length(slash_parts) > 3,\n        arrayElement(slash_parts, sp_len),\n        ''\n      )                                                       AS runtime,\n\n      -- head_parts = everything before the last 1 or 2 elements\n      arraySlice(\n        slash_parts,\n        1,\n        sp_len - IF(sp_len > 3, 2, 1)\n      )                                                       AS head_parts\n\n    FROM peers\n  ),\n\n  exploded AS (\n    SELECT\n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors,\n      head_parts[1]                                          AS client,\n\n      -- if head_parts has 3 elements, the middle is variant\n      IF(\n        length(head_parts) = 3,\n        head_parts[2],\n        ''\n      )                                                       AS variant,\n\n      -- the last element of head_parts is our raw \u201cver_blob\u201d\n      arrayElement(head_parts, length(head_parts))            AS ver_blob,\n\n      platform,\n      runtime,\n\n      -- split out \u201c+\u201d-style metadata\n      IF(ver_blob LIKE '%+%', arrayElement(splitByChar('+', ver_blob), 1), ver_blob) AS pre_blob,\n      IF(ver_blob LIKE '%+%', arrayElement(splitByChar('+', ver_blob), 2), '')        AS plus_build\n\n    FROM parsed\n  ),\n\nbasic_info AS (\n  SELECT\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    --replaceRegexpAll(connect_maddr, '^/ip4/([0-9.]+)/tcp/[0-9]+$', '\\\\1') AS ip,\n    arrayElement(splitByChar('/', ifNull(connect_maddr, '')), 3) AS ip,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    IF(\n      plus_build != '',\n      arrayElement(splitByChar('-', pre_blob), 1),\n      splitByChar('-', ver_blob)[1]\n    )                                                       AS version,\n    IF(\n      plus_build != '',\n      IF(\n        length(splitByChar('-', pre_blob)) >= 2,\n        arrayElement(splitByChar('-', pre_blob), 2),\n        ''\n      ),\n      IF(\n        length(splitByChar('-', ver_blob)) = 3,\n        arrayElement(splitByChar('-', ver_blob), 2),\n        ''\n      )\n    )                                                       AS channel,\n    IF(\n      plus_build != '',\n      plus_build,\n      IF(\n        length(splitByChar('-', ver_blob)) > 1,\n        arrayElement(splitByChar('-', ver_blob), -1),\n        ''\n      )\n    )                                                       AS build,\n    platform,\n    runtime\n  FROM exploded\n)\n\nSELECT\n  t1.visit_ended_at,\n  t1.peer_id,\n  t1.agent_version,\n  t1.ip,\n  t1.peer_properties,\n  t1.crawl_error,\n  t1.dial_errors,\n  t1.client,\n  t1.variant,\n  t1.version,\n  t1.channel,\n  t1.build,\n  t1.platform,\n  t1.runtime,\n  t2.hostname   AS peer_hostname,\n  t2.city       AS peer_city,\n  t2.country    AS peer_country,\n  t2.org        AS peer_org,\n  t2.loc        AS peer_loc,\n  t2.generic_provider AS generic_provider\nFROM\n  basic_info t1\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS t2\n  ON t2.ip = t1.ip", "relation_name": "`dbt`.`int_p2p_discv4_peers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.339882Z", "completed_at": "2025-10-15T13:38:03.345421Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.345973Z", "completed_at": "2025-10-15T13:38:03.345981Z"}], "thread_id": "Thread-1", "execution_time": 0.007325649261474609, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_visits_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nvisits_info AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,COUNT(visit_ended_at) AS total_visits\n        ,SUM(IF( empty(dial_errors) = 1 OR crawl_error IS NULL, 1, 0)) AS successful_visits\n        ,COUNT(DISTINCT crawl_id) AS crawls\n    FROM `dbt`.`stg_nebula_discv4__visits`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        toString(peer_properties.network_id) = '100'\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_p2p_discv4_visits_daily`\n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT * FROM visits_info", "relation_name": "`dbt`.`int_p2p_discv4_visits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.348634Z", "completed_at": "2025-10-15T13:38:03.356378Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.356942Z", "completed_at": "2025-10-15T13:38:03.356949Z"}], "thread_id": "Thread-1", "execution_time": 0.00960087776184082, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_peers", "compiled": true, "compiled_code": "\n\nWITH\n\n-- Known fork digests \u2192 names\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\n-- Known fork versions \u2192 names\nfork_version AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_version,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0x00000064','Phase0'),\n      ('0x01000064','Altair'),\n      ('0x02000064','Bellatrix'),\n      ('0x03000064','Capella'),\n      ('0x04000064','Deneb'),\n      ('0x05000064','Electra'),\n      ('0x06000064','Fulu')\n    ]) AS tup\n  )\n),\n\n/* Pull only relevant rows from source and normalize Dynamic\u2192String once */\npeers AS (\n  SELECT \n    t1.crawl_id,\n    t1.visit_ended_at,\n    t1.peer_id,\n    t1.connect_maddr,\n    -- Dynamic JSON leaves \u2192 String for safe joins/filters\n    toString(t1.peer_properties.fork_digest)         AS fork_digest,\n    toString(t1.peer_properties.next_fork_version)   AS next_fork_version,\n\n    -- Map to fork names\n    t2.cl_fork_name                                  AS cl_fork_name,\n    coalesce(t3.cl_fork_name, toString(t1.peer_properties.next_fork_version))\n                                                    AS cl_next_fork_name,\n\n    t1.agent_version,\n    t1.peer_properties,\n    t1.crawl_error,\n    t1.dial_errors\n  FROM `dbt`.`stg_nebula_discv5__visits` AS t1\n  LEFT JOIN fork_digests t2\n    ON toString(t1.peer_properties.fork_digest) = t2.fork_digest\n  LEFT JOIN fork_version t3\n    ON toString(t1.peer_properties.next_fork_version) = t3.fork_version\n  WHERE\n    (\n      toString(t1.peer_properties.fork_digest) IN (SELECT fork_digest FROM fork_digests)\n      OR toString(t1.peer_properties.next_fork_version) LIKE '%064'\n    )\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(visit_ended_at))\n      FROM `dbt`.`int_p2p_discv5_peers`\n    )\n  \n\n),\n\n/* Split and locate version token via regex */\nparsed AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    agent_version,\n\n    splitByChar('/', agent_version)                                         AS parts,\n    length(splitByChar('/', agent_version))                                 AS parts_len,\n    arraySlice(splitByChar('/', agent_version), 2)                         AS tail,\n    length(arraySlice(splitByChar('/', agent_version), 2))                 AS tail_len,\n\n    splitByChar('/', agent_version)[1]                                     AS client,\n\n    -- first tail index that looks like a version (v?digits(.digits){0,3}\u2026)\n    arrayFirstIndex(x ->\n        (substring(x, 1, 1) = 'v' OR match(x, '^[0-9]')) AND\n        match(x, '^v?[0-9]+(\\\\.[0-9]+){0,3}([\\\\-\\\\w\\\\.\\\\+]+)?$')\n      , arraySlice(splitByChar('/', agent_version), 2))                    AS ver_idx_tail\n  FROM peers\n),\n\n/* Derive variant, version blob, platform, runtime */\nwith_parts AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    agent_version,\n    parts,\n    parts_len,\n    tail,\n    tail_len,\n    client,\n    ver_idx_tail,\n\n    /* variant: exactly one token between client and version */\n    IF(ver_idx_tail > 1, tail[1], '')                                       AS variant,\n\n    /* raw version token (may include '-' channel and/or '+' build) */\n    IF(ver_idx_tail > 0, tail[ver_idx_tail], '')                            AS ver_blob,\n\n    /* tokens after version for platform/runtime */\n    IF(ver_idx_tail > 0 AND tail_len >= ver_idx_tail + 1, tail[ver_idx_tail + 1], '')\n      AS platform,\n    IF(ver_idx_tail > 0 AND tail_len >= ver_idx_tail + 2, tail[ver_idx_tail + 2], '')\n      AS runtime\n  FROM parsed\n),\n\n/* Split version blob and prep hyphen parts; also clean runtime */\nexploded AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    ver_blob,\n\n    -- strip leading '-' in runtime\n    replaceRegexpOne(runtime, '^-+', '')                                    AS runtime,\n    platform,\n\n    /* version blob split around '+' */\n    IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[1], ver_blob) AS pre_blob,\n    IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[2], '')       AS plus_build,\n\n    /* hyphen parts for channel/build logic (work off pre_blob) */\n    splitByChar('-', IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[1], ver_blob))\n                                                                            AS hy_parts\n  FROM with_parts\n),\n\nbasic_info AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    replaceRegexpAll(connect_maddr, '^/ip4/([0-9.]+)/tcp/[0-9]+$', '\\\\1') AS ip,\n    fork_digest,\n    cl_fork_name,\n    cl_next_fork_name,\n    next_fork_version,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    IF(length(hy_parts) >= 1, hy_parts[1], '')                                AS version,\n    IF(length(hy_parts) >= 3, hy_parts[2], '')                                 AS channel,\n    IF(\n      plus_build != '',\n      plus_build,\n      IF(length(hy_parts) >= 2, hy_parts[length(hy_parts)], '')\n    )                                                                          AS build,\n    platform,\n    runtime\n  FROM exploded\n)\n\nSELECT\n  t1.crawl_id,\n  t1.visit_ended_at,\n  t1.peer_id,\n  t1.agent_version,\n  t1.ip,\n  t1.fork_digest,\n  t1.cl_fork_name,\n  t1.cl_next_fork_name,\n  t1.next_fork_version,\n  t1.peer_properties,\n  t1.crawl_error,\n  t1.dial_errors,\n  t1.client,\n  t1.variant,\n  t1.version,\n  t1.channel,\n  t1.build,\n  CASE\n      WHEN t1.platform = '' THEN 'Unknown'\n      WHEN t1.platform = 'aarch64-linux' THEN 'linux-aarch_64'\n      WHEN t1.platform = 'x86_64-linux' THEN 'linux-x86_64'\n      WHEN t1.platform = 'x86_64-windows' THEN 'windows-x86_64'\n      ELSE t1.platform\n  END AS platform,\n  t1.runtime,\n  t2.hostname   AS peer_hostname,\n  t2.city       AS peer_city,\n  t2.country    AS peer_country,\n  t2.org        AS peer_org,\n  t2.loc        AS peer_loc,\n  t2.generic_provider AS generic_provider\nFROM\n  basic_info t1\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS t2\n  ON t2.ip = t1.ip", "relation_name": "`dbt`.`int_p2p_discv5_peers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.359764Z", "completed_at": "2025-10-15T13:38:03.365245Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.365811Z", "completed_at": "2025-10-15T13:38:03.365819Z"}], "thread_id": "Thread-1", "execution_time": 0.007302761077880859, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_visits_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\nvisits_info AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,COUNT(visit_ended_at) AS total_visits\n        ,SUM(IF( empty(dial_errors) = 1 OR crawl_error IS NULL, 1, 0)) AS successful_visits\n        ,COUNT(DISTINCT crawl_id) AS crawls\n    FROM `dbt`.`stg_nebula_discv5__visits`\n    WHERE\n      toStartOfDay(visit_ended_at) < today()\n      AND\n      (\n        toString(peer_properties.fork_digest) IN (SELECT fork_digest FROM fork_digests)\n        OR toString(peer_properties.next_fork_version) LIKE '%064'\n      )\n      \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_p2p_discv5_visits_daily`\n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT * FROM visits_info", "relation_name": "`dbt`.`int_p2p_discv5_visits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.368550Z", "completed_at": "2025-10-15T13:38:03.373913Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.374499Z", "completed_at": "2025-10-15T13:38:03.374506Z"}], "thread_id": "Thread-1", "execution_time": 0.007283687591552734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_AgentResultMapping_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '99c43743a2dbd406160cc43cf08113b17178789c'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2025-06-10'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_AgentResultMapping_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_AgentResultMapping_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.377111Z", "completed_at": "2025-10-15T13:38:03.382447Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.383018Z", "completed_at": "2025-10-15T13:38:03.383025Z"}], "thread_id": "Thread-1", "execution_time": 0.007139444351196289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_ConditionalTokens_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-01'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_ConditionalTokens_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_ConditionalTokens_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.385651Z", "completed_at": "2025-10-15T13:38:03.391108Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.391703Z", "completed_at": "2025-10-15T13:38:03.391710Z"}], "thread_id": "Thread-1", "execution_time": 0.007280111312866211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_FPMMDeterministicFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-04'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_FPMMDeterministicFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_FPMMDeterministicFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.394341Z", "completed_at": "2025-10-15T13:38:03.400568Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.401132Z", "completed_at": "2025-10-15T13:38:03.401139Z"}], "thread_id": "Thread-1", "execution_time": 0.008079290390014648, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_GBCDeposit_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '0b98057ea310f4d31f2a452b414647007d1645d9'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_GBCDeposit_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_GBCDeposit_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.403873Z", "completed_at": "2025-10-15T13:38:03.409168Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.409756Z", "completed_at": "2025-10-15T13:38:03.409764Z"}], "thread_id": "Thread-1", "execution_time": 0.0072727203369140625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_OmenAgentResultMapping_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-09-30'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_OmenAgentResultMapping_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_OmenAgentResultMapping_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.412396Z", "completed_at": "2025-10-15T13:38:03.417683Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.418285Z", "completed_at": "2025-10-15T13:38:03.418292Z"}], "thread_id": "Thread-1", "execution_time": 0.007201433181762695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Realitio_v2_1_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2021-01-13'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Realitio_v2_1_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Realitio_v2_1_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.420900Z", "completed_at": "2025-10-15T13:38:03.426268Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.426840Z", "completed_at": "2025-10-15T13:38:03.426847Z"}], "thread_id": "Thread-1", "execution_time": 0.007174015045166016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_MarketFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-10-08'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Seer_MarketFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_MarketFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.429481Z", "completed_at": "2025-10-15T13:38:03.434854Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.435443Z", "completed_at": "2025-10-15T13:38:03.435450Z"}], "thread_id": "Thread-1", "execution_time": 0.007192134857177734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_Wrapped1155Factory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-02-07'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Seer_Wrapped1155Factory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_Wrapped1155Factory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.438024Z", "completed_at": "2025-10-15T13:38:03.443516Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.444080Z", "completed_at": "2025-10-15T13:38:03.444087Z"}], "thread_id": "Thread-1", "execution_time": 0.007277727127075195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-09-22'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.446736Z", "completed_at": "2025-10-15T13:38:03.453142Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.453728Z", "completed_at": "2025-10-15T13:38:03.453736Z"}], "thread_id": "Thread-1", "execution_time": 0.008224010467529297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraPool_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-11-30'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraPool_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.456366Z", "completed_at": "2025-10-15T13:38:03.461726Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.462322Z", "completed_at": "2025-10-15T13:38:03.462330Z"}], "thread_id": "Thread-1", "execution_time": 0.007219076156616211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_aaveV3_PoolConfigurator_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '7304979ec9e4eaa0273b6a037a31c4e9e5a75d16'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-10-04'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_aaveV3_PoolConfigurator_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '7304979ec9e4eaa0273b6a037a31c4e9e5a75d16'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_aaveV3_PoolConfigurator_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.464976Z", "completed_at": "2025-10-15T13:38:03.470250Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.470819Z", "completed_at": "2025-10-15T13:38:03.470826Z"}], "thread_id": "Thread-1", "execution_time": 0.007146120071411133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_aaveV3_PoolInstance_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'b50201558b00496a145fe76f7424749556e326d8'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-10-04'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_aaveV3_PoolInstance_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'b50201558b00496a145fe76f7424749556e326d8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_aaveV3_PoolInstance_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.473518Z", "completed_at": "2025-10-15T13:38:03.478750Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.479338Z", "completed_at": "2025-10-15T13:38:03.479345Z"}], "thread_id": "Thread-1", "execution_time": 0.007137298583984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_TSLAx_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '19972d1750f959dd14cf436da6360185bd54cea0'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_TSLAx_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '19972d1750f959dd14cf436da6360185bd54cea0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_TSLAx_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.481957Z", "completed_at": "2025-10-15T13:38:03.487134Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.487722Z", "completed_at": "2025-10-15T13:38:03.487729Z"}], "thread_id": "Thread-1", "execution_time": 0.0070726871490478516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bC3M_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '83ec02059f686e747392a22ddfed7833ba0d7ce3'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bC3M_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83ec02059f686e747392a22ddfed7833ba0d7ce3'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bC3M_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.490333Z", "completed_at": "2025-10-15T13:38:03.495618Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.496179Z", "completed_at": "2025-10-15T13:38:03.496186Z"}], "thread_id": "Thread-1", "execution_time": 0.007099628448486328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bCOIN_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '69b2d456e8830847f488afdde2a636bfb26218c6'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bCOIN_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '69b2d456e8830847f488afdde2a636bfb26218c6'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bCOIN_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.498802Z", "completed_at": "2025-10-15T13:38:03.505136Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.505717Z", "completed_at": "2025-10-15T13:38:03.505724Z"}], "thread_id": "Thread-1", "execution_time": 0.008199691772460938, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bCSPX_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '1332d2b4dc83238b621b7f7d0f72fec58bb81a9b'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bCSPX_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '1332d2b4dc83238b621b7f7d0f72fec58bb81a9b'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bCSPX_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.508357Z", "completed_at": "2025-10-15T13:38:03.513525Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.514088Z", "completed_at": "2025-10-15T13:38:03.514095Z"}], "thread_id": "Thread-1", "execution_time": 0.0070438385009765625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bHIGH_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '9e8e794ad6ecdb6d5c7eabe059d30e907f58859b'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bHIGH_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9e8e794ad6ecdb6d5c7eabe059d30e907f58859b'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bHIGH_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.516753Z", "completed_at": "2025-10-15T13:38:03.522000Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.522583Z", "completed_at": "2025-10-15T13:38:03.522591Z"}], "thread_id": "Thread-1", "execution_time": 0.007058143615722656, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bIB01_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '788d911ae7c95121a89a0f0306db65d87422e1de'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bIB01_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '788d911ae7c95121a89a0f0306db65d87422e1de'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bIB01_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.525210Z", "completed_at": "2025-10-15T13:38:03.530486Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.531049Z", "completed_at": "2025-10-15T13:38:03.531056Z"}], "thread_id": "Thread-1", "execution_time": 0.0071337223052978516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bIBTA_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '9f9953d8a2c5366f098754d48f2d69b144ce03da'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bIBTA_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9f9953d8a2c5366f098754d48f2d69b144ce03da'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bIBTA_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.533682Z", "completed_at": "2025-10-15T13:38:03.538944Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.539577Z", "completed_at": "2025-10-15T13:38:03.539585Z"}], "thread_id": "Thread-1", "execution_time": 0.007120847702026367, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bMSTR_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'c8429803dcda7df86822ab173ea285c10bf1eb66'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bMSTR_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'c8429803dcda7df86822ab173ea285c10bf1eb66'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bMSTR_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.542154Z", "completed_at": "2025-10-15T13:38:03.548424Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.548985Z", "completed_at": "2025-10-15T13:38:03.548993Z"}], "thread_id": "Thread-1", "execution_time": 0.008048295974731445, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bNVDA_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '1d3be4d05eba2aa6c4eede85a74f491c31766e64'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bNVDA_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '1d3be4d05eba2aa6c4eede85a74f491c31766e64'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bNVDA_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.551737Z", "completed_at": "2025-10-15T13:38:03.556937Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.557524Z", "completed_at": "2025-10-15T13:38:03.557531Z"}], "thread_id": "Thread-1", "execution_time": 0.007043600082397461, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v1_Hub_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '29b9a7fbb8995b2423a71cc17cf9810798f6c543'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v1_Hub_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '29b9a7fbb8995b2423a71cc17cf9810798f6c543'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v1_Hub_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.560157Z", "completed_at": "2025-10-15T13:38:03.565428Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.565991Z", "completed_at": "2025-10-15T13:38:03.565998Z"}], "thread_id": "Thread-1", "execution_time": 0.007063150405883789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_CirclesBackingFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'eced91232c609a42f6016860e8223b8aecaa7bd0'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2025-04-25'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_CirclesBackingFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'eced91232c609a42f6016860e8223b8aecaa7bd0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_CirclesBackingFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.568717Z", "completed_at": "2025-10-15T13:38:03.573887Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.574471Z", "completed_at": "2025-10-15T13:38:03.574478Z"}], "thread_id": "Thread-1", "execution_time": 0.007058620452880859, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_Hub_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'c12c1e50abb450d6205ea2c3fa861b3b834d13e8'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_Hub_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'c12c1e50abb450d6205ea2c3fa861b3b834d13e8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_Hub_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.577282Z", "completed_at": "2025-10-15T13:38:03.582856Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.583458Z", "completed_at": "2025-10-15T13:38:03.583466Z"}], "thread_id": "Thread-1", "execution_time": 0.007497549057006836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_NameRegistry_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'a27566fd89162cc3d40cb59c87aaaa49b85f3474'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_NameRegistry_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a27566fd89162cc3d40cb59c87aaaa49b85f3474'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_NameRegistry_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.586110Z", "completed_at": "2025-10-15T13:38:03.591417Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.591978Z", "completed_at": "2025-10-15T13:38:03.591985Z"}], "thread_id": "Thread-1", "execution_time": 0.007109165191650391, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_sdai_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'af204776c7245bf4147c2612bf6e5972ee483701'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_sdai_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'af204776c7245bf4147c2612bf6e5972ee483701'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_sdai_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.594723Z", "completed_at": "2025-10-15T13:38:03.601187Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.601781Z", "completed_at": "2025-10-15T13:38:03.601788Z"}], "thread_id": "Thread-1", "execution_time": 0.008409261703491211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_wxdai_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_wxdai_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_wxdai_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.604463Z", "completed_at": "2025-10-15T13:38:03.609712Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.610304Z", "completed_at": "2025-10-15T13:38:03.610311Z"}], "thread_id": "Thread-1", "execution_time": 0.007088184356689453, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_AgentResultMapping_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2025-06-30'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_AgentResultMapping_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_AgentResultMapping_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.612974Z", "completed_at": "2025-10-15T13:38:03.618261Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.618840Z", "completed_at": "2025-10-15T13:38:03.618847Z"}], "thread_id": "Thread-1", "execution_time": 0.007167339324951172, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_ConditionalTokens_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-01'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_ConditionalTokens_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_ConditionalTokens_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.621577Z", "completed_at": "2025-10-15T13:38:03.626851Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.627446Z", "completed_at": "2025-10-15T13:38:03.627453Z"}], "thread_id": "Thread-1", "execution_time": 0.007169485092163086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_FPMMDeterministicFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-04'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_FPMMDeterministicFactory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_FPMMDeterministicFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.630166Z", "completed_at": "2025-10-15T13:38:03.635427Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.635997Z", "completed_at": "2025-10-15T13:38:03.636004Z"}], "thread_id": "Thread-1", "execution_time": 0.007157087326049805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_GBCDeposit_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_GBCDeposit_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_GBCDeposit_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.638649Z", "completed_at": "2025-10-15T13:38:03.644989Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.645575Z", "completed_at": "2025-10-15T13:38:03.645583Z"}], "thread_id": "Thread-1", "execution_time": 0.008152961730957031, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_OmenAgentResultMapping_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-09-30'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_OmenAgentResultMapping_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_OmenAgentResultMapping_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.648308Z", "completed_at": "2025-10-15T13:38:03.653526Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.654088Z", "completed_at": "2025-10-15T13:38:03.654095Z"}], "thread_id": "Thread-1", "execution_time": 0.0071332454681396484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Realitio_v2_1_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2021-01-13'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Realitio_v2_1_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Realitio_v2_1_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.656796Z", "completed_at": "2025-10-15T13:38:03.662032Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.662635Z", "completed_at": "2025-10-15T13:38:03.662642Z"}], "thread_id": "Thread-1", "execution_time": 0.007142782211303711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_MarketFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-10-08'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Seer_MarketFactory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_MarketFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.665339Z", "completed_at": "2025-10-15T13:38:03.670676Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.671269Z", "completed_at": "2025-10-15T13:38:03.671277Z"}], "thread_id": "Thread-1", "execution_time": 0.007260560989379883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_Wrapped1155Factory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-02-07'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Seer_Wrapped1155Factory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_Wrapped1155Factory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.673971Z", "completed_at": "2025-10-15T13:38:03.679276Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.679847Z", "completed_at": "2025-10-15T13:38:03.679855Z"}], "thread_id": "Thread-1", "execution_time": 0.00719904899597168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-09-22'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.682518Z", "completed_at": "2025-10-15T13:38:03.687828Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.688408Z", "completed_at": "2025-10-15T13:38:03.688415Z"}], "thread_id": "Thread-1", "execution_time": 0.0071260929107666016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraPool_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-11-30'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraPool_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.691117Z", "completed_at": "2025-10-15T13:38:03.697531Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.698086Z", "completed_at": "2025-10-15T13:38:03.698093Z"}], "thread_id": "Thread-1", "execution_time": 0.008314371109008789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_wxdai_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_wxdai_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_wxdai_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.700744Z", "completed_at": "2025-10-15T13:38:03.705693Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.706316Z", "completed_at": "2025-10-15T13:38:03.706329Z"}], "thread_id": "Thread-1", "execution_time": 0.0068628787994384766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_labels", "compiled": true, "compiled_code": "\n\n\nWITH latest AS (\n  SELECT\n    lower(address) AS address,\n    argMax( (label, introduced_at), (introduced_at, label) ) AS agg\n  FROM `crawlers_data`.`dune_labels`\n  GROUP BY address\n),\n\nclean AS (\n  SELECT\n    address,\n    tupleElement(agg, 1) AS label_raw,\n    tupleElement(agg, 2) AS introduced_at,\n\n    trim(replaceRegexpAll(tupleElement(agg, 1), '\\\\s*([:/|>])\\\\s*', '\\\\1'))                           AS s1,\n\n    replaceRegexpAll(\n      replaceRegexpAll(s1, '_0x[0-9a-fA-F]{40}$', ''),\n      '_0x[0-9a-fA-F]{1,}\u2026[0-9a-fA-F]{1,}$',\n      ''\n    )                                                                                                AS s2,\n\n    trim(extract(s2, '^([^:/|>]+)'))                                                                 AS s3,\n\n    trim(replaceRegexpAll(s3, '(?:\\\\s*[-_ ]?[Vv]\\\\d+(?:[._-]\\\\d+)*)\\\\b', ''))                        AS s4,\n\n    lowerUTF8(s4)                                                                                    AS s4_l,\n\n    (\n      match(s1, '_0x[0-9a-fA-F]{40}$')\n      OR match(s1, '_0x[0-9a-fA-F]{1,}\u2026[0-9a-fA-F]{1,}$')\n    )                                                                                                AS looks_like_token_tail\n  FROM latest\n),\n\nwl AS (\n  SELECT\n    lower(address) AS address,\n    symbol\n  FROM `dbt`.`tokens_whitelist`\n),\n\nbucketed AS (\n \n  SELECT\n    c.address,\n    c.label_raw,\n    c.introduced_at,\n    c.s4,\n    c.s4_l,\n    c.looks_like_token_tail,\n    w.symbol AS wl_symbol,\n\n    coalesce(\n      if(c.looks_like_token_tail,\n         if(w.symbol IS NOT NULL, w.symbol, 'ERC20'),\n         NULL\n      ),\n\n      multiIf(\n        match(c.s4_l, '^(realtoken|realtokens)\\\\b'),              'REALTOKEN',\n        match(lowerUTF8(c.label_raw), '(^|[^a-z0-9])gnosis[\\\\s_-]*safe(?:l2)?([^a-z0-9]|$)') OR match(c.s4_l, '^(safe(?:l2)?)\\\\b'), 'Safe',\n\n        match(c.s4_l, '(^|[^a-z])balancer([^a-z]|$)'),            'Balancer',\n        match(c.s4_l, '(^|[-_])gaug(e)?(\\\\b|_)'),                 'Balancer',\n        match(c.s4_l, '\\\\b\\\\d{1,3}%[a-z0-9._-]+'),                'Balancer',\n        match(c.s4_l, '\\\\b(w?moo)[a-z0-9]*balancer'),             'Balancer',\n\n        match(c.s4_l, '(^|[^a-z])curve([^a-z]|$)'),               'Curve',\n        match(c.s4_l, '^(yv\\\\s*curve|yvcurve|y\\\\s*curve|ycurve)'), 'Curve',\n        match(c.s4_l, '^curvefi\\\\b'),                             'Curve',\n\n        match(c.s4_l, '\\\\buniswap\\\\b'),                           'Uniswap',\n        match(c.s4_l, '\\\\buni[- _]?v?3\\\\b'),                      'Uniswap',\n        match(c.s4_l, '\\\\buni[- _]?v?2\\\\b'),                      'Uniswap',\n        match(c.s4_l, '\\\\bnonfungiblepositionmanager\\\\b'),        'Uniswap',\n        match(c.s4_l, '\\\\bpositions?\\\\s*nft\\\\b'),                 'Uniswap',\n        match(c.s4_l, '\\\\b(rcow|cow|moo\\\\w*)\\\\s*uniswap'),        'Uniswap',\n\n        match(c.s4_l, 'sushi'),                                   'Sushi',\n\n        match(c.s4_l, '\\\\bswapr\\\\b'),                             'Swapr',\n        match(c.s4_l, '^swaprv?3\\\\b'),                            'Swapr',\n        match(c.s4_l, '\\\\bswpr\\\\b'),                              'Swapr',\n\n        match(c.s4_l, '\\\\bcow\\\\s*swap\\\\b|\\\\bcow[_\\\\s-]?protocol\\\\b|^b_cow_amm\\\\b'), 'CowSwap',\n        match(c.s4_l, '^aave\\\\b'),                                'Aave',\n        match(c.s4_l, '\\\\baave\\\\s*v?2\\\\b|\\\\baave\\\\s*v?3\\\\b'),     'Aave',\n        match(c.s4_l, '^aavepool\\\\b'),                            'Aave',\n\n        c.s4\n      )\n    ) AS s5\n  FROM clean c\n  LEFT JOIN wl w\n    ON c.address = w.address\n),\n\ntidy AS (\n  SELECT\n    address,\n    label_raw,\n    introduced_at,\n    trim(\n      replaceRegexpAll(\n        replaceRegexpAll(\n          replaceRegexpAll(\n            left(s5, length(\n              replaceRegexpAll(\n                lowerUTF8(s5),\n                '\\\\b(factory|router|vault|pool|implementation|proxy|token|bridge|aggregator|registry|controller|manager|oracle|staking|treasury|multisig|gnosis\\\\s*safe|deployer|fee\\\\s*collector|minter|burner|timelock|governor|council|rewards?|distributor|airdrop)s?\\\\s*$',\n                ''\n              )\n            )),\n            '\\\\s*\\\\([^)]*\\\\)\\\\s*$', ''\n          ),\n          '\\\\?+$', ''\n        ),\n        '[_\\\\s-]+', ' '\n      )\n    ) AS s7\n  FROM bucketed\n),\n\ncanon AS (\n  SELECT\n    address,\n    label_raw,\n    introduced_at,\n    s7,\n    multiIf(\n      match(lowerUTF8(s7), '^(aa\\\\s*entrypoint|erc-?4337\\\\s*entry\\\\s*point|entrypointsimulations|pimlicoentrypointsimulations)$'), 'ERC-4337 Entry Point',\n      match(lowerUTF8(s7), '^(uni|uni\\\\s*v?3\\\\s*swaprouter02)$'),                                      'Uniswap',\n      match(lowerUTF8(s7), '^(oneinch)$'),                                                             '1inch',\n      match(lowerUTF8(s7), '^layerzero$'),                                                             'LayerZero',\n      match(lowerUTF8(s7), '^(cowswap|b_cow_amm)$'),                                                   'CowSwap',\n      match(lowerUTF8(s7), '^angle(\\\\s+ageur)?$'),                                                     'Angle',\n      match(lowerUTF8(s7), '^sablier(\\\\s+.*)?$|^sablier\\\\s*flow\\\\b|^sablier\\\\s*lockup\\\\b'),            'Sablier',\n      match(lowerUTF8(s7), '^hats[_\\\\s-]?protocol'),                                                   'Hats Protocol',\n      match(lowerUTF8(s7), '^seaport\\\\??$'),                                                           'Seaport',\n      match(lowerUTF8(s7), '^poap(\\\\s+top)?$'),                                                        'POAP',\n      match(lowerUTF8(s7), '^merkly(\\\\s+onft)?$'),                                                     'Merkly',\n      match(lowerUTF8(s7), '^circles(\\\\s*ubi)?$'),                                                     'Circles',\n      match(lowerUTF8(s7), '^(hop|hop\\\\s*protocol)$'),                                                 'Hop Protocol',\n      match(lowerUTF8(s7), '^opensea$'),                                                               'OpenSea',\n      match(lowerUTF8(s7), '^paraswap$'),                                                              'ParaSwap',\n      match(lowerUTF8(s7), '^realt(oken)?(\\\\s*money\\\\s*market)?$|^realtoken\\\\s*dao$|^realtyam$|^real_rmm$'), 'REALTOKEN',\n      match(lowerUTF8(s7), '^nulladdress$|^burn\\\\s*address$'),                                         'Null/Burn',\n      match(lowerUTF8(s7), '^eoa$'),                                                                   'EOA',\n      match(lowerUTF8(s7), '^proxyadmin$|^transparentupgradeableproxy$|^upgradeablecommunitytoken$|^contractaddressfeehelper$|^controllermodule$'), 'Infrastructure',\n      match(lowerUTF8(s7), '^unnamed$|^oracle\\\\?$|^dex\\\\s*aggregator\\\\?$|^\\\\?$'),                      'Unknown',\n      s7\n    ) AS project_canon\n  FROM tidy\n)\n\nSELECT\n  address,\n  if(\n    lengthUTF8(project_canon) = 0\n    OR positionCaseInsensitive(project_canon, '0x') > 0\n    OR match(label_raw, '_0x[0-9a-fA-F]{40}$')\n    OR match(label_raw, '_0x[0-9a-fA-F]{1,}\u2026[0-9a-fA-F]{1,}$'),\n    'ERC20',\n    project_canon\n  ) AS project,\n  label_raw AS project_raw,\n  introduced_at\nFROM canon", "relation_name": "`dbt`.`stg_crawlers_data__dune_labels`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.708986Z", "completed_at": "2025-10-15T13:38:03.712927Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.713542Z", "completed_at": "2025-10-15T13:38:03.713549Z"}], "thread_id": "Thread-1", "execution_time": 0.005860805511474609, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_attestations_daily", "compiled": true, "compiled_code": "\nSELECT\n    date\n    ,inclusion_delay\n    ,cnt\nFROM `dbt`.`int_consensus_attestations_daily`\nORDER BY date, inclusion_delay", "relation_name": "`dbt`.`api_consensus_attestations_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.716321Z", "completed_at": "2025-10-15T13:38:03.720121Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.720728Z", "completed_at": "2025-10-15T13:38:03.720735Z"}], "thread_id": "Thread-1", "execution_time": 0.005814552307128906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_blob_commitments_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,cnt AS value\nFROM `dbt`.`int_consensus_blob_commitments_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_blob_commitments_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.723492Z", "completed_at": "2025-10-15T13:38:03.727212Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.727786Z", "completed_at": "2025-10-15T13:38:03.727793Z"}], "thread_id": "Thread-1", "execution_time": 0.005686044692993164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_graffiti_label_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,SUM(cnt) AS value\nFROM `dbt`.`int_consensus_graffiti_daily`\nGROUP BY date, label\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_graffiti_label_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.730436Z", "completed_at": "2025-10-15T13:38:03.734417Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.734995Z", "completed_at": "2025-10-15T13:38:03.735002Z"}], "thread_id": "Thread-1", "execution_time": 0.0058438777923583984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_graffiti_cloud", "compiled": true, "compiled_code": "\n\n\nWITH base AS (\n  SELECT\n      graffiti,\n      sumIf(cnt, date >= today() - 7)  AS v_7d,\n      sumIf(cnt, date >= today() - 30) AS v_30d,\n      sumIf(cnt, date >= today() - 90) AS v_90d,\n      sum(cnt)                         AS v_all\n  FROM `dbt`.`int_consensus_graffiti_daily`\n  WHERE graffiti != 'None'\n  GROUP BY graffiti\n)\nSELECT\n  label,\n  graffiti,\n  value\nFROM base\nARRAY JOIN\n  ['7D','30D','90D','All'] AS label,\n  [v_7d, v_30d, v_90d, v_all] AS value\nORDER BY label, value DESC\nLIMIT 50 BY label", "relation_name": "`dbt`.`fct_consensus_graffiti_cloud`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.737766Z", "completed_at": "2025-10-15T13:38:03.742868Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.743468Z", "completed_at": "2025-10-15T13:38:03.743476Z"}], "thread_id": "Thread-1", "execution_time": 0.007078409194946289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_forks", "compiled": true, "compiled_code": "\n\nSELECT\n  fork_name\n  ,fork_version \n  ,fork_digest\n  ,fork_epoch \nFROM `dbt`.`fct_consensus_forks`\nORDER BY fork_version ASC", "relation_name": "`dbt`.`api_consensus_forks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.746128Z", "completed_at": "2025-10-15T13:38:03.750185Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.750762Z", "completed_at": "2025-10-15T13:38:03.750769Z"}], "thread_id": "Thread-1", "execution_time": 0.005949258804321289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_blocks_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,label\n    ,value\nFROM (\n    SELECT date, 'produced' AS label, blocks_produced AS value FROM `dbt`.`int_consensus_blocks_daily`\n    UNION ALL \n    SELECT date, 'missed' AS label, blocks_missed AS value FROM `dbt`.`int_consensus_blocks_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_blocks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.753453Z", "completed_at": "2025-10-15T13:38:03.757189Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.757763Z", "completed_at": "2025-10-15T13:38:03.757770Z"}], "thread_id": "Thread-1", "execution_time": 0.0055675506591796875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_credentials_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,credentials_type\n    ,cnt\n    ,ROUND(cnt/(SUM(cnt) OVER (PARTITION BY date)) * 100,2) AS pct \nFROM `dbt`.`int_consensus_credentials_daily`\nORDER BY date, credentials_type", "relation_name": "`dbt`.`api_consensus_credentials_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.760428Z", "completed_at": "2025-10-15T13:38:03.764506Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.765070Z", "completed_at": "2025-10-15T13:38:03.765077Z"}], "thread_id": "Thread-1", "execution_time": 0.00595402717590332, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_credentials_latest", "compiled": true, "compiled_code": "\n\nSELECT \n    credentials_type\n    ,cnt\nFROM `dbt`.`int_consensus_credentials_daily`\nWHERE date = (SELECT MAX(date) FROM `dbt`.`int_consensus_credentials_daily`)", "relation_name": "`dbt`.`api_consensus_credentials_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.767753Z", "completed_at": "2025-10-15T13:38:03.771583Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.772159Z", "completed_at": "2025-10-15T13:38:03.772167Z"}], "thread_id": "Thread-1", "execution_time": 0.0057256221771240234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_entry_queue_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,validator_count\n    ,q05\n    ,q10\n    ,q25\n    ,q50\n    ,q75\n    ,q90\n    ,q95\n    ,mean\nFROM `dbt`.`int_consensus_entry_queue_daily`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_entry_queue_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.774874Z", "completed_at": "2025-10-15T13:38:03.778783Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.779357Z", "completed_at": "2025-10-15T13:38:03.779364Z"}], "thread_id": "Thread-1", "execution_time": 0.005799770355224609, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_staked_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,effective_balance/32 AS value\nFROM `dbt`.`int_consensus_validators_balances_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_staked_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.781997Z", "completed_at": "2025-10-15T13:38:03.787393Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.787954Z", "completed_at": "2025-10-15T13:38:03.787962Z"}], "thread_id": "Thread-1", "execution_time": 0.007256984710693359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_balances_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,value\nFROM (\n    SELECT\n        date\n        ,'balance' AS label\n        ,balance AS value\n    FROM `dbt`.`int_consensus_validators_balances_daily`\n\n    UNION ALL \n\n    SELECT\n        date\n        ,'eff. balance' AS label\n        ,effective_balance AS value\n    FROM `dbt`.`int_consensus_validators_balances_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_validators_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.790657Z", "completed_at": "2025-10-15T13:38:03.794511Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.795088Z", "completed_at": "2025-10-15T13:38:03.795096Z"}], "thread_id": "Thread-1", "execution_time": 0.005742549896240234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_balances_dist_daily", "compiled": true, "compiled_code": "\n\n-- in GNO\nSELECT\n    date,\n    q05/32 AS q05,\n    q10/32 AS q10,\n    q25/32 AS q25,\n    q50/32 AS q50,\n    q75/32 AS q75,\n    q90/32 AS q90,\n    q95/32 AS q95\nFROM `dbt`.`int_consensus_validators_balances_dist_daily`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_validators_balances_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.797766Z", "completed_at": "2025-10-15T13:38:03.801604Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.802171Z", "completed_at": "2025-10-15T13:38:03.802178Z"}], "thread_id": "Thread-1", "execution_time": 0.0057146549224853516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_active_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,cnt\nFROM `dbt`.`int_consensus_validators_status_daily`\nWHERE status = 'active_ongoing'\nORDER BY date", "relation_name": "`dbt`.`api_consensus_validators_active_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.804882Z", "completed_at": "2025-10-15T13:38:03.808652Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.809211Z", "completed_at": "2025-10-15T13:38:03.809218Z"}], "thread_id": "Thread-1", "execution_time": 0.005612373352050781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_status_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,status\n    ,cnt\nFROM `dbt`.`int_consensus_validators_status_daily`\nWHERE status NOT IN ('active_ongoing', 'withdrawal_done')\nORDER BY date, status", "relation_name": "`dbt`.`api_consensus_validators_status_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.811928Z", "completed_at": "2025-10-15T13:38:03.815722Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.816291Z", "completed_at": "2025-10-15T13:38:03.816298Z"}], "thread_id": "Thread-1", "execution_time": 0.005687713623046875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_apy_dist", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q05,\n    q10,\n    q25,\n    q50,\n    q75,\n    q90,\n    q95 \nFROM `dbt`.`int_consensus_validators_apy_dist`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_validators_apy_dist`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.818930Z", "completed_at": "2025-10-15T13:38:03.822896Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.823496Z", "completed_at": "2025-10-15T13:38:03.823503Z"}], "thread_id": "Thread-1", "execution_time": 0.0058498382568359375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_withdrawls_dist_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,q05\n    ,q10\n    ,q25\n    ,q50\n    ,q75\n    ,q90\n    ,q95\nFROM \n    `dbt`.`int_consensus_withdrawls_dist_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_withdrawls_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.826133Z", "completed_at": "2025-10-15T13:38:03.831554Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.832132Z", "completed_at": "2025-10-15T13:38:03.832139Z"}], "thread_id": "Thread-1", "execution_time": 0.007310628890991211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_deposits_withdrawls_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,'withdrawls' AS label\n    ,cnt\n    ,total_amount\nFROM \n    `dbt`.`int_consensus_withdrawls_dist_daily`\n\nUNION ALL\n\nSELECT\n    date\n    ,'deposits' AS label\n    ,cnt\n    ,total_amount\nFROM \n    `dbt`.`int_consensus_deposits_daily`", "relation_name": "`dbt`.`fct_consensus_deposits_withdrawls_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.834948Z", "completed_at": "2025-10-15T13:38:03.838781Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.839363Z", "completed_at": "2025-10-15T13:38:03.839370Z"}], "thread_id": "Thread-1", "execution_time": 0.0056726932525634766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_blocks_clients_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\nclients_blocks AS (\n    SELECT\n        date\n        ,client\n        ,SUM(cnt) AS cnt\n    FROM `dbt`.`int_execution_blocks_clients_version_daily`\n    WHERE date < today()\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,client\n    ,cnt\n    ,cnt/(SUM(cnt) OVER (PARTITION BY date)) AS fraq\nFROM \n    clients_blocks", "relation_name": "`dbt`.`fct_execution_blocks_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.842273Z", "completed_at": "2025-10-15T13:38:03.846022Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.846605Z", "completed_at": "2025-10-15T13:38:03.846613Z"}], "thread_id": "Thread-1", "execution_time": 0.005885601043701172, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_gas_usage_pct_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  ROUND(gas_used_fraq * 100, 2) AS value\nFROM `dbt`.`int_execution_blocks_gas_usage_daily`\nWHERE date < today()   \nORDER BY date", "relation_name": "`dbt`.`api_execution_blocks_gas_usage_pct_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.849322Z", "completed_at": "2025-10-15T13:38:03.853086Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.853667Z", "completed_at": "2025-10-15T13:38:03.853674Z"}], "thread_id": "Thread-1", "execution_time": 0.005705833435058594, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_blocks_gas_usage_monthly", "compiled": true, "compiled_code": "\n\nWITH monthly AS (\n  SELECT\n    date_trunc('month', date) AS month,\n    SUM(gas_used_sum)         AS gas_used_sum_monthly,\n    SUM(gas_limit_sum)        AS gas_limit_sum_monthly\n  FROM `dbt`.`int_execution_blocks_gas_usage_daily`\n  GROUP BY month\n)\nSELECT\n  month,\n  gas_used_sum_monthly,\n  gas_limit_sum_monthly,\n  gas_used_sum_monthly / NULLIF(gas_limit_sum_monthly, 0) AS used\nFROM monthly", "relation_name": "`dbt`.`fct_execution_blocks_gas_usage_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.856435Z", "completed_at": "2025-10-15T13:38:03.860951Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.861528Z", "completed_at": "2025-10-15T13:38:03.861536Z"}], "thread_id": "Thread-1", "execution_time": 0.006512880325317383, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_blocks_gas_usage_daily_date.1b2b9e203e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_blocks_gas_usage_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.864186Z", "completed_at": "2025-10-15T13:38:03.869836Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.870430Z", "completed_at": "2025-10-15T13:38:03.870438Z"}], "thread_id": "Thread-1", "execution_time": 0.007546901702880859, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_blocks_gas_usage_daily_gas_limit_sum.2a534bfddb", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect gas_limit_sum\nfrom `dbt`.`int_execution_blocks_gas_usage_daily`\nwhere gas_limit_sum is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.873124Z", "completed_at": "2025-10-15T13:38:03.877570Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.878152Z", "completed_at": "2025-10-15T13:38:03.878159Z"}], "thread_id": "Thread-1", "execution_time": 0.006375312805175781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_blocks_gas_usage_daily_gas_used_sum.21cc0473f2", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect gas_used_sum\nfrom `dbt`.`int_execution_blocks_gas_usage_daily`\nwhere gas_used_sum is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.880887Z", "completed_at": "2025-10-15T13:38:03.884779Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.885365Z", "completed_at": "2025-10-15T13:38:03.885373Z"}], "thread_id": "Thread-1", "execution_time": 0.005829811096191406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_state_full_size_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,SUM(bytes_diff) OVER (ORDER BY date ASC) AS bytes\nFROM `dbt`.`int_execution_state_size_full_diff_daily`\nWHERE date < today()", "relation_name": "`dbt`.`fct_execution_state_full_size_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.888094Z", "completed_at": "2025-10-15T13:38:03.892020Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.892612Z", "completed_at": "2025-10-15T13:38:03.892620Z"}], "thread_id": "Thread-1", "execution_time": 0.005860328674316406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_cnt_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,n_txs AS value\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.895328Z", "completed_at": "2025-10-15T13:38:03.899387Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.899959Z", "completed_at": "2025-10-15T13:38:03.899967Z"}], "thread_id": "Thread-1", "execution_time": 0.005949497222900391, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_cnt_total", "compiled": true, "compiled_code": "\n\nSELECT\n    transaction_type\n    ,SUM(n_txs) AS value\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nGROUP BY transaction_type\nORDER BY transaction_type", "relation_name": "`dbt`.`api_execution_transactions_cnt_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.902631Z", "completed_at": "2025-10-15T13:38:03.906594Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.907165Z", "completed_at": "2025-10-15T13:38:03.907172Z"}], "thread_id": "Thread-1", "execution_time": 0.005845546722412109, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_gas_used_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,gas_used\n    ,gas_price_avg\n    ,gas_price_median\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_gas_used_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.909924Z", "completed_at": "2025-10-15T13:38:03.915011Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.915605Z", "completed_at": "2025-10-15T13:38:03.915613Z"}], "thread_id": "Thread-1", "execution_time": 0.007026195526123047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_value_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,xdai_value \n    ,xdai_value_avg \n    ,xdai_value_median\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_value_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.918310Z", "completed_at": "2025-10-15T13:38:03.922748Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.923324Z", "completed_at": "2025-10-15T13:38:03.923332Z"}], "thread_id": "Thread-1", "execution_time": 0.00637054443359375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_info_daily_date.5c42bfc6c2", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_transactions_info_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.926022Z", "completed_at": "2025-10-15T13:38:03.930411Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.930964Z", "completed_at": "2025-10-15T13:38:03.930972Z"}], "thread_id": "Thread-1", "execution_time": 0.00628352165222168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_info_daily_success.15552423e9", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect success\nfrom `dbt`.`int_execution_transactions_info_daily`\nwhere success is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.933647Z", "completed_at": "2025-10-15T13:38:03.938128Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.938739Z", "completed_at": "2025-10-15T13:38:03.938747Z"}], "thread_id": "Thread-1", "execution_time": 0.00638890266418457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_info_daily_transaction_type.b1687eae24", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect transaction_type\nfrom `dbt`.`int_execution_transactions_info_daily`\nwhere transaction_type is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.941574Z", "completed_at": "2025-10-15T13:38:03.947553Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.948102Z", "completed_at": "2025-10-15T13:38:03.948109Z"}], "thread_id": "Thread-1", "execution_time": 0.007991552352905273, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_clients_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,argMax(IF(client='','Unknown',client),visit_ended_at) AS client\n        ,argMax(platform,visit_ended_at) AS platform\n        ,argMax(generic_provider,visit_ended_at) AS generic_provider\n        ,argMax(peer_country,visit_ended_at) AS peer_country\n    FROM `dbt`.`int_p2p_discv4_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_p2p_discv4_clients_daily`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT date , 'Clients' AS metric, client AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Platform' AS metric, platform AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Provider' AS metric, generic_provider AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Country' AS metric, peer_country AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv4_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.951050Z", "completed_at": "2025-10-15T13:38:03.957471Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.958031Z", "completed_at": "2025-10-15T13:38:03.958038Z"}], "thread_id": "Thread-1", "execution_time": 0.008533000946044922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\n-- 1) First CTE: basic peer info\ngnosis_peers AS (\n    SELECT \n        peer_id,\n        ip,\n        any(client) AS client\n    FROM `dbt`.`int_p2p_discv4_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) = today() - INTERVAL 1 DAY\n        AND empty(dial_errors) = 1\n        AND crawl_error IS NULL\n    GROUP BY\n        peer_id,\n        ip\n),\n\n-- 2) Second CTE: attach discovery_id_prefix to each peer\ngnosis_prefixes AS (\n    SELECT \n        d.discovery_id_prefix,\n        d.peer_id,\n        p.ip,\n        IF(p.client='', 'Unknown', p.client) AS client\n    FROM `dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids` AS d\n    INNER JOIN gnosis_peers AS p\n      ON p.peer_id = d.peer_id\n)\n\nSELECT\n    t1.date,\n\n    -- Peer columns from the subquery t1\n    t1.peer_ip,\n    t1.peer_discovery_id_prefix,\n    t1.peer_client,\n\n    -- Geographical info for peer (from crawlers_data.ipinfo)\n    peer_info.hostname   AS peer_hostname,\n    peer_info.city       AS peer_city,\n    peer_info.country    AS peer_country,\n    peer_info.org        AS peer_org,\n    peer_info.loc        AS peer_loc,\n\n    -- Neighbor columns from subquery t1\n    t1.neighbor_ip,\n    t1.neighbor_discovery_id_prefix,\n    t1.neighbor_client,\n\n    -- Geographical info for neighbor (from crawlers_data.ipinfo)\n    neighbor_info.city    AS neighbor_city,\n    neighbor_info.country AS neighbor_country,\n    neighbor_info.org     AS neighbor_org,\n    neighbor_info.loc     AS neighbor_loc,\n\n    -- Finally, the count of edges\n    t1.cnt\nFROM (\n    SELECT\n        toStartOfDay(n.crawl_created_at) AS date,\n\n        -- \u201cPeer\u201d side of the edge\n        peer_p.ip                      AS peer_ip,\n        peer_p.discovery_id_prefix     AS peer_discovery_id_prefix,\n        peer_p.client                  AS peer_client,\n\n        -- \u201cNeighbor\u201d side of the edge\n        neighbor_p.ip                      AS neighbor_ip,\n        neighbor_p.discovery_id_prefix     AS neighbor_discovery_id_prefix,\n        neighbor_p.client                  AS neighbor_client,\n\n        COUNT(*) AS cnt\n    FROM `dbt`.`stg_nebula_discv4__neighbors` AS n\n\n    -- join to get the discovery_prefix + client/fork info for \u201cpeer\u201d\n    INNER JOIN gnosis_prefixes AS peer_p\n      ON peer_p.discovery_id_prefix = n.peer_discovery_id_prefix\n\n    -- join to get the discovery_prefix + client/fork info for \u201cneighbor\u201d\n    INNER JOIN gnosis_prefixes AS neighbor_p\n      ON neighbor_p.discovery_id_prefix = n.neighbor_discovery_id_prefix\n\n    WHERE\n        toStartOfDay(n.crawl_created_at) = today() - INTERVAL 1 DAY\n\n    GROUP BY\n        date,\n        peer_p.ip,\n        peer_p.discovery_id_prefix,\n        peer_p.client,\n        neighbor_p.ip,\n        neighbor_p.discovery_id_prefix,\n        neighbor_p.client\n) AS t1\n\n-- LEFT JOIN to ipinfo for \u201cpeer\u201d\nLEFT JOIN  `dbt`.`stg_crawlers_data__ipinfo` AS peer_info\n  ON peer_info.ip = t1.peer_ip\n\n-- LEFT JOIN to ipinfo for \u201cneighbor\u201d\nLEFT JOIN  `dbt`.`stg_crawlers_data__ipinfo` AS neighbor_info\n  ON neighbor_info.ip = t1.neighbor_ip", "relation_name": "`dbt`.`int_p2p_discv4_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.960711Z", "completed_at": "2025-10-15T13:38:03.971688Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.972259Z", "completed_at": "2025-10-15T13:38:03.972267Z"}], "thread_id": "Thread-1", "execution_time": 0.012836217880249023, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_population_chao1", "compiled": true, "compiled_code": "\n\nWITH peer_connection_analysis AS (\n    SELECT\n        toDate(visit_ended_at) AS observation_date,\n        peer_id,\n        crawl_id,\n        \n        -- Categorize connection attempts\n        CASE \n            WHEN empty(dial_errors) = 1 AND crawl_error IS NULL THEN 'successful'\n            WHEN empty(dial_errors) = 0 OR crawl_error IS NOT NULL THEN 'failed'\n            ELSE 'unknown'\n        END AS connection_status,\n        \n        -- More granular failure analysis\n        CASE \n            WHEN empty(dial_errors) = 1 AND crawl_error IS NULL THEN 'successful'\n            WHEN crawl_error LIKE '%timeout%' THEN 'timeout'\n            WHEN crawl_error LIKE '%refused%' OR crawl_error LIKE '%connection refused%' THEN 'refused' \n            WHEN crawl_error LIKE '%unreachable%' THEN 'unreachable'\n            WHEN crawl_error LIKE '%protocol%' THEN 'protocol_mismatch'\n            WHEN NOT empty(dial_errors) THEN 'dial_error'\n            ELSE 'other_failure'\n        END AS failure_type\n        \n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(observation_date))\n      FROM `dbt`.`int_esg_node_population_chao1`\n    )\n  \n\n),\n\n-- Chao-1 for successful connections only\nsuccessful_chao1 AS (\n    SELECT\n        observation_date,\n        peer_id,\n        COUNT(DISTINCT crawl_id) AS times_observed\n    FROM peer_connection_analysis\n    WHERE connection_status = 'successful'\n    \n        AND observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nsuccessful_stats AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS s_obs_successful,\n        SUM(CASE WHEN times_observed = 1 THEN 1 ELSE 0 END) AS f1_successful,\n        SUM(CASE WHEN times_observed = 2 THEN 1 ELSE 0 END) AS f2_successful\n    FROM successful_chao1\n    GROUP BY observation_date\n),\n\n-- Chao-1 for ALL connection attempts (successful + failed)\nall_attempts_chao1 AS (\n    SELECT\n        observation_date,\n        peer_id,\n        COUNT(DISTINCT crawl_id) AS times_observed\n    FROM peer_connection_analysis\n    \n        WHERE observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nall_attempts_stats AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS s_obs_all,\n        SUM(CASE WHEN times_observed = 1 THEN 1 ELSE 0 END) AS f1_all,\n        SUM(CASE WHEN times_observed = 2 THEN 1 ELSE 0 END) AS f2_all\n    FROM all_attempts_chao1\n    GROUP BY observation_date\n),\n\n-- Additional peers known from failed connections\npeer_status_summary AS (\n    SELECT\n        observation_date,\n        peer_id,\n        MAX(CASE WHEN connection_status = 'successful' THEN 1 ELSE 0 END) AS had_success,\n        MAX(CASE WHEN connection_status = 'failed' THEN 1 ELSE 0 END) AS had_failure\n    FROM peer_connection_analysis\n    \n        WHERE observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nfailed_only_peers AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS peers_with_only_failures\n    FROM peer_status_summary\n    WHERE had_failure = 1 AND had_success = 0\n    GROUP BY observation_date\n),\n\n-- Connection success rates by failure type\nfailure_analysis AS (\n    SELECT\n        observation_date,\n        failure_type,\n        COUNT(DISTINCT peer_id) AS peer_count,\n        COUNT(*) AS attempt_count,\n        \n        -- Estimate reachability probability based on failure type\n        CASE failure_type\n            WHEN 'timeout' THEN 0.3      -- Sometimes reachable\n            WHEN 'refused' THEN 0.1      -- Rarely reachable (firewall/NAT)\n            WHEN 'unreachable' THEN 0.05 -- Very rarely reachable\n            WHEN 'protocol_mismatch' THEN 0.8  -- Likely reachable with right protocol\n            WHEN 'dial_error' THEN 0.2   -- Sometimes reachable\n            ELSE 0.1\n        END AS estimated_reachability_prob\n        \n    FROM peer_connection_analysis\n    WHERE connection_status = 'failed'\n    \n        AND observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, failure_type\n),\n\n-- Calculate enhanced estimates\nenhanced_calculations AS (\n    SELECT\n        COALESCE(s.observation_date, a.observation_date) AS observation_date,\n        \n        -- Successful connection metrics\n        COALESCE(s.s_obs_successful, 0) AS observed_successful_nodes,\n        CASE\n            WHEN COALESCE(s.f2_successful, 0) > 0 THEN \n                COALESCE(s.s_obs_successful, 0) + toFloat64(s.f1_successful * (s.f1_successful - 1)) / (2.0 * toFloat64(s.f2_successful + 1))\n            WHEN COALESCE(s.f1_successful, 0) > 0 THEN \n                COALESCE(s.s_obs_successful, 0) + toFloat64(s.f1_successful * (s.f1_successful - 1)) / 2.0\n            ELSE \n                toFloat64(COALESCE(s.s_obs_successful, 0))\n        END AS chao1_successful,\n        \n        -- All attempt metrics  \n        COALESCE(a.s_obs_all, 0) AS observed_total_peers,\n        CASE\n            WHEN COALESCE(a.f2_all, 0) > 0 THEN \n                COALESCE(a.s_obs_all, 0) + toFloat64(a.f1_all * (a.f1_all - 1)) / (2.0 * toFloat64(a.f2_all + 1))\n            WHEN COALESCE(a.f1_all, 0) > 0 THEN \n                COALESCE(a.s_obs_all, 0) + toFloat64(a.f1_all * (a.f1_all - 1)) / 2.0\n            ELSE \n                toFloat64(COALESCE(a.s_obs_all, 0))\n        END AS chao1_all_attempts,\n        \n        -- Failed connection insights\n        COALESCE(f.peers_with_only_failures, 0) AS failed_only_peers,\n        \n        COALESCE(s.f1_successful, 0) AS f1_successful,\n        COALESCE(s.f2_successful, 0) AS f2_successful,\n        COALESCE(a.f1_all, 0) AS f1_all,\n        COALESCE(a.f2_all, 0) AS f2_all\n        \n    FROM successful_stats s\n    FULL OUTER JOIN all_attempts_stats a ON s.observation_date = a.observation_date\n    LEFT JOIN failed_only_peers f ON COALESCE(s.observation_date, a.observation_date) = f.observation_date\n),\n\n-- Separate CTE for failure analysis aggregation\nfailure_reachability AS (\n    SELECT\n        observation_date,\n        SUM(toFloat64(peer_count) * estimated_reachability_prob) AS estimated_reachable_from_failures\n    FROM failure_analysis\n    GROUP BY observation_date\n),\n\n-- Combine all estimates\ncombined_estimates AS (\n    SELECT\n        e.*,\n        COALESCE(fr.estimated_reachable_from_failures, 0.0) AS estimated_reachable_from_failures\n    FROM enhanced_calculations e\n    LEFT JOIN failure_reachability fr ON e.observation_date = fr.observation_date\n),\n\nfinal_estimates AS (\n    SELECT\n        observation_date,\n        observed_successful_nodes,\n        observed_total_peers,\n        failed_only_peers,\n        \n        -- Different estimation approaches\n        toUInt64(round(chao1_successful, 0)) AS chao1_successful_only,\n        toUInt64(round(chao1_all_attempts, 0)) AS chao1_all_discovered,\n        toUInt64(round(estimated_reachable_from_failures, 0)) AS estimated_additional_reachable,\n        \n        -- Enhanced total estimate combining multiple signals\n        toUInt64(round(\n            chao1_successful +  -- Hidden successful nodes\n            estimated_reachable_from_failures  -- Additional reachable from failures\n        , 0)) AS enhanced_total_reachable,\n        \n        -- Network size estimate (includes unreachable nodes)\n        toUInt64(round(chao1_all_attempts, 0)) AS estimated_network_size,\n        \n        -- Success rates\n        CASE WHEN observed_total_peers > 0 THEN \n            round(100.0 * observed_successful_nodes / observed_total_peers, 2)\n        ELSE 0 END AS connection_success_rate_pct,\n        \n        -- Coverage estimates\n        CASE WHEN chao1_all_attempts > 0 THEN\n            round(100.0 * observed_total_peers / chao1_all_attempts, 2)\n        ELSE 100 END AS network_discovery_coverage_pct,\n        \n        CASE WHEN enhanced_total_reachable > 0 THEN\n            round(100.0 * observed_successful_nodes / enhanced_total_reachable, 2) \n        ELSE 100 END AS reachable_discovery_coverage_pct,\n        \n        -- Diagnostic info\n        f1_successful, f2_successful, f1_all, f2_all\n        \n    FROM combined_estimates\n)\n\nSELECT\n    observation_date,\n    \n    -- Core metrics\n    observed_successful_nodes,\n    observed_total_peers, \n    failed_only_peers,\n    \n    -- Population estimates\n    chao1_successful_only,\n    enhanced_total_reachable,\n    estimated_network_size,\n    estimated_additional_reachable,\n    \n    -- Success and coverage rates\n    connection_success_rate_pct,\n    network_discovery_coverage_pct,\n    reachable_discovery_coverage_pct,\n    \n    -- Hidden node estimates\n    chao1_successful_only - observed_successful_nodes AS hidden_successful_nodes,\n    enhanced_total_reachable - observed_successful_nodes AS hidden_reachable_nodes,\n    estimated_network_size - observed_total_peers AS hidden_total_nodes,\n    \n    -- Percentages\n    CASE WHEN chao1_successful_only > 0 THEN\n        round(100.0 * (chao1_successful_only - observed_successful_nodes) / chao1_successful_only, 2)\n    ELSE 0 END AS hidden_successful_pct,\n    \n    CASE WHEN estimated_network_size > 0 THEN\n        round(100.0 * (estimated_network_size - observed_total_peers) / estimated_network_size, 2) \n    ELSE 0 END AS hidden_total_pct,\n    \n    -- Diagnostic information\n    f1_successful AS successful_singletons,\n    f2_successful AS successful_doubletons,\n    f1_all AS all_singletons,\n    f2_all AS all_doubletons,\n    \n    now() AS calculated_at\n\nFROM final_estimates\nORDER BY observation_date DESC", "relation_name": "`dbt`.`int_esg_node_population_chao1`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.974937Z", "completed_at": "2025-10-15T13:38:03.980665Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.981269Z", "completed_at": "2025-10-15T13:38:03.981277Z"}], "thread_id": "Thread-1", "execution_time": 0.007643699645996094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_clients_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,argMax(IF(client='','Unknown',client),visit_ended_at) AS client\n        ,argMax(platform,visit_ended_at) AS platform\n        ,argMax(generic_provider,visit_ended_at) AS generic_provider\n        ,argMax(peer_country,visit_ended_at) AS peer_country\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_p2p_discv5_clients_daily`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT date , 'Clients' AS metric, client AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Platform' AS metric, platform AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Provider' AS metric, generic_provider AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Country' AS metric, peer_country AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv5_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.983934Z", "completed_at": "2025-10-15T13:38:03.989737Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:03.990332Z", "completed_at": "2025-10-15T13:38:03.990340Z"}], "thread_id": "Thread-1", "execution_time": 0.007690906524658203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_forks_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,toString(any(cl_fork_name)) AS fork\n        ,toString(any(cl_next_fork_name)) AS next_fork\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_p2p_discv5_forks_daily`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,'Current Fork' AS label\n    ,fork AS fork\n    ,COUNT(*) AS cnt\nFROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL\n\nSELECT\n    date\n    ,'Next Fork' AS label\n    ,next_fork AS fork\n    ,COUNT(*) AS cnt\nFROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv5_forks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:03.993118Z", "completed_at": "2025-10-15T13:38:03.999516Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.000075Z", "completed_at": "2025-10-15T13:38:04.000082Z"}], "thread_id": "Thread-1", "execution_time": 0.008212804794311523, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_geo_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers_ip AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,any(peer_properties.ip) AS ip\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_p2p_discv5_geo_daily`\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT\n    t1.date\n    ,IF(t2.country='',NULL,splitByString(',',t2.loc)[1]) AS lat\n    ,IF(t2.country='',NULL,splitByString(',',t2.loc)[2]) AS long\n    ,IF(t2.country='','Unknown', t2.country) AS country\n    ,COUNT(*) AS cnt\nFROM peers_ip t1\nLEFT JOIN\n    `crawlers_data`.`ipinfo` t2\n    ON t1.ip = t2.ip\nGROUP BY 1, 2, 3, 4", "relation_name": "`dbt`.`int_p2p_discv5_geo_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.002791Z", "completed_at": "2025-10-15T13:38:04.008453Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.009026Z", "completed_at": "2025-10-15T13:38:04.009033Z"}], "thread_id": "Thread-1", "execution_time": 0.007547140121459961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\n-- 1) First CTE: basic peer info\ngnosis_peers AS (\n    SELECT \n        peer_id,\n        cl_fork_name,\n        cl_next_fork_name,\n        peer_properties.ip AS ip,\n        any(splitByChar('/', agent_version)[1]) AS client\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) = today() - INTERVAL 1 DAY\n        AND empty(dial_errors) = 1\n        AND crawl_error IS NULL\n    GROUP BY\n        peer_id,\n        cl_fork_name,\n        cl_next_fork_name,\n        ip\n),\n\n-- 2) Second CTE: attach discovery_id_prefix to each peer\ngnosis_prefixes AS (\n    SELECT \n        d.discovery_id_prefix,\n        d.peer_id,\n        p.ip,\n        p.cl_fork_name,\n        p.cl_next_fork_name,\n        IF(p.client='', 'Unknown', p.client) AS client\n    FROM `dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids` AS d\n    INNER JOIN gnosis_peers AS p\n      ON p.peer_id = d.peer_id\n)\n\nSELECT\n    t1.date,\n\n    -- Peer columns from the subquery t1\n    t1.peer_ip,\n    t1.peer_discovery_id_prefix,\n    t1.peer_cl_fork_name,\n    t1.peer_cl_next_fork_name,\n    t1.peer_client,\n\n    -- Geographical info for peer (from crawlers_data.ipinfo)\n    peer_info.hostname   AS peer_hostname,\n    peer_info.city       AS peer_city,\n    peer_info.country    AS peer_country,\n    peer_info.org        AS peer_org,\n    peer_info.loc        AS peer_loc,\n\n    -- Neighbor columns from subquery t1\n    t1.neighbor_ip,\n    t1.neighbor_discovery_id_prefix,\n    t1.neighbor_cl_fork_name,\n    t1.neighbor_cl_next_fork_name,\n    t1.neighbor_client,\n\n    -- Geographical info for neighbor (from crawlers_data.ipinfo)\n    neighbor_info.city    AS neighbor_city,\n    neighbor_info.country AS neighbor_country,\n    neighbor_info.org     AS neighbor_org,\n    neighbor_info.loc     AS neighbor_loc,\n\n    -- Finally, the count of edges\n    t1.cnt\nFROM (\n    SELECT\n        toStartOfDay(n.crawl_created_at) AS date,\n\n        -- \u201cPeer\u201d side of the edge\n        peer_p.ip                      AS peer_ip,\n        peer_p.discovery_id_prefix     AS peer_discovery_id_prefix,\n        peer_p.cl_fork_name            AS peer_cl_fork_name,\n        peer_p.cl_next_fork_name       AS peer_cl_next_fork_name,\n        peer_p.client                  AS peer_client,\n\n        -- \u201cNeighbor\u201d side of the edge\n        neighbor_p.ip                      AS neighbor_ip,\n        neighbor_p.discovery_id_prefix     AS neighbor_discovery_id_prefix,\n        neighbor_p.cl_fork_name            AS neighbor_cl_fork_name,\n        neighbor_p.cl_next_fork_name       AS neighbor_cl_next_fork_name,\n        neighbor_p.client                  AS neighbor_client,\n\n        COUNT(*) AS cnt\n    FROM `dbt`.`stg_nebula_discv5__neighbors` AS n\n\n    -- join to get the discovery_prefix + client/fork info for \u201cpeer\u201d\n    INNER JOIN gnosis_prefixes AS peer_p\n      ON peer_p.discovery_id_prefix = n.peer_discovery_id_prefix\n\n    -- join to get the discovery_prefix + client/fork info for \u201cneighbor\u201d\n    INNER JOIN gnosis_prefixes AS neighbor_p\n      ON neighbor_p.discovery_id_prefix = n.neighbor_discovery_id_prefix\n\n    WHERE\n        toStartOfDay(n.crawl_created_at) = today() - INTERVAL 1 DAY\n\n    GROUP BY\n        date,\n        peer_p.ip,\n        peer_p.discovery_id_prefix,\n        peer_p.cl_fork_name,\n        peer_p.cl_next_fork_name,\n        peer_p.client,\n        neighbor_p.ip,\n        neighbor_p.discovery_id_prefix,\n        neighbor_p.cl_fork_name,\n        neighbor_p.cl_next_fork_name,\n        neighbor_p.client\n) AS t1\n\n-- LEFT JOIN to ipinfo for \u201cpeer\u201d\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS peer_info\n  ON peer_info.ip = t1.peer_ip\n\n-- LEFT JOIN to ipinfo for \u201cneighbor\u201d\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS neighbor_info\n  ON neighbor_info.ip = t1.neighbor_ip", "relation_name": "`dbt`.`int_p2p_discv5_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.011789Z", "completed_at": "2025-10-15T13:38:04.018751Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.019345Z", "completed_at": "2025-10-15T13:38:04.019352Z"}], "thread_id": "Thread-1", "execution_time": 0.008931398391723633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_visits_latest", "compiled": true, "compiled_code": "\n\nWITH \n\ndiscv4_prev7D AS (\n    SELECT\n        date,\n        crawls\n    FROM `dbt`.`int_p2p_discv4_visits_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_visits_daily`), 7)\n),\n\ndiscv4 AS (\n    SELECT\n        date,\n        total_visits,\n        ROUND(COALESCE(successful_visits / NULLIF(total_visits, 0), 0) * 100, 1) AS pct_successful,\n        crawls\n    FROM `dbt`.`int_p2p_discv4_visits_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_visits_daily`)\n),\n\ndiscv5_prev7D AS (\n    SELECT\n        date,\n        crawls\n    FROM `dbt`.`int_p2p_discv5_visits_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_visits_daily`), 7)\n),\n\ndiscv5 AS (\n    SELECT\n        date,\n        total_visits,\n        ROUND(COALESCE(successful_visits / NULLIF(total_visits, 0), 0) * 100, 1) AS pct_successful,\n        crawls\n    FROM `dbt`.`int_p2p_discv5_visits_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_visits_daily`)\n)\n\nSELECT\n    t2.total_visits AS discv4_total_visits,\n    t2.pct_successful AS discv4_pct_successful,\n    t2.crawls AS discv4_crawls,\n    ROUND((COALESCE(t2.crawls / NULLIF(t1.crawls, 0), 0) - 1) * 100, 1) AS change_discv4_crawls_pct,\n    t4.total_visits AS discv5_total_visits,\n    t4.pct_successful AS discv5_pct_successful,\n    t4.crawls AS discv5_crawls,\n    ROUND((COALESCE(t4.crawls / NULLIF(t3.crawls, 0), 0) - 1) * 100, 1) AS change_discv5_crawls_pct\nFROM discv4_prev7D t1\nCROSS JOIN discv4 t2\nCROSS JOIN discv5_prev7D t3\nCROSS JOIN discv5 t4", "relation_name": "`dbt`.`api_p2p_visits_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.022012Z", "completed_at": "2025-10-15T13:38:04.027158Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.027798Z", "completed_at": "2025-10-15T13:38:04.027806Z"}], "thread_id": "Thread-1", "execution_time": 0.007086992263793945, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_GBCDeposit_deposists_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(block_timestamp) AS date\n    ,decoded_params['withdrawal_credentials'] AS withdrawal_credentials\n    ,SUM(reinterpretAsUInt64(unhex(substring(decoded_params['amount'], 3)))) AS amount\nFROM `dbt`.`contracts_GBCDeposit_events`\nWHERE\n    event_name = 'DepositEvent'\n    \n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_GBCDeposit_deposists_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.030547Z", "completed_at": "2025-10-15T13:38:04.046117Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.046704Z", "completed_at": "2025-10-15T13:38:04.046711Z"}], "thread_id": "Thread-1", "execution_time": 0.017390966415405273, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_rwa_backedfi_prices", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n\n\n        SELECT\n            'bC3M' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bC3M_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bCOIN' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bCOIN_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bCSPX' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bCSPX_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bHIGH' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bHIGH_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bIB01' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bIB01_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bIBTA' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bIBTA_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bMSTR' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bMSTR_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bNVDA' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bNVDA_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'TSLAx' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_TSLAx_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices`\n    )\n  \n\n        GROUP BY 1, 2\n    ", "relation_name": "`dbt`.`int_execution_rwa_backedfi_prices`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.049538Z", "completed_at": "2025-10-15T13:38:04.055325Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.055892Z", "completed_at": "2025-10-15T13:38:04.055899Z"}], "thread_id": "Thread-1", "execution_time": 0.007822990417480469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_backing", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(block_timestamp) AS date\n    ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_CirclesBackingFactory_events`\nWHERE \n    event_name = 'CirclesBackingCompleted'\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_circles_backing`\n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_execution_circles_backing`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.058685Z", "completed_at": "2025-10-15T13:38:04.064389Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.064949Z", "completed_at": "2025-10-15T13:38:04.064957Z"}], "thread_id": "Thread-1", "execution_time": 0.007680654525756836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_transitive_transfers", "compiled": true, "compiled_code": "\n\n\nSELECT\n  toStartOfDay(block_timestamp) AS date\n  ,decoded_params['from'] AS from_avatar\n  ,decoded_params['to']   AS  to_avatar\n  ,SUM(\n    toUInt256OrZero(\n      arrayJoin(\n        JSONExtract(\n          ifNull(decoded_params['amounts'], '[]'),   -- remove Nullable\n          'Array(String)'                            -- get Array(String)\n        )\n      )\n    )\n  ) AS total_amount\n  ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE\n  event_name = 'StreamCompleted'\n  \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_circles_transitive_transfers`\n    )\n  \n\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_execution_circles_transitive_transfers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.067696Z", "completed_at": "2025-10-15T13:38:04.074681Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.075273Z", "completed_at": "2025-10-15T13:38:04.075281Z"}], "thread_id": "Thread-1", "execution_time": 0.008869647979736328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_v1_avatars", "compiled": true, "compiled_code": "\n\n\nSELECT\n    block_timestamp\n    ,decoded_params['avatar'] AS user_address\n    ,decoded_params['inviter'] AS inviter_address\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE \n    event_name = 'RegisterHuman'\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_circles_v1_avatars`\n    )\n  \n", "relation_name": "`dbt`.`int_execution_circles_v1_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.077922Z", "completed_at": "2025-10-15T13:38:04.083649Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.084204Z", "completed_at": "2025-10-15T13:38:04.084211Z"}], "thread_id": "Thread-1", "execution_time": 0.00754094123840332, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_v2_avatars", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(block_timestamp) AS date\n    ,CASE  \n        WHEN event_name = 'RegisterHuman' THEN 'Human' \n        WHEN event_name = 'RegisterGroup' THEN 'Group' \n        WHEN event_name = 'RegisterOrganization' THEN 'Org'\n        ELSE 'Unknown' \n    END AS avatar_type\n    ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE \n    event_name IN ('RegisterHuman','RegisterGroup','RegisterOrganization')\n    \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_circles_v2_avatars`\n    )\n  \n\nGROUP BY 1,2", "relation_name": "`dbt`.`int_execution_circles_v2_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.087031Z", "completed_at": "2025-10-15T13:38:04.095207Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.095795Z", "completed_at": "2025-10-15T13:38:04.095802Z"}], "thread_id": "Thread-1", "execution_time": 0.010126590728759766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_yields_sdai_rate_daily", "compiled": true, "compiled_code": "\n\n\nWITH \n\nsdai_rate_sparse_daily AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date\n        ,argMin(\n          toUInt256OrNull(decoded_params['assets']) / toUInt256OrNull(decoded_params['shares']),\n          block_timestamp\n        ) AS sdai_conversion\n    FROM \n        `dbt`.`contracts_sdai_events`\n    WHERE \n        event_name = 'Deposit'\n        AND toUInt256OrNull(decoded_params['shares']) != 0\n        AND block_timestamp < today()\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_yields_sdai_rate_daily`\n    )\n  \n\n    GROUP BY 1\n),\n\ncalendar AS (\n    SELECT\n        arrayJoin(\n            arrayMap(\n                x -> toStartOfDay(start_date + x),\n                range(toUInt32(end_date - start_date) + 1)\n            )\n        ) AS date\n    FROM (\n        SELECT \n          min(toDate(date)) AS start_date\n          ,max(toDate(date)) AS end_date\n        FROM sdai_rate_sparse_daily\n    )\n),\n\n\nlast_partition_value AS (\n    SELECT \n        sdai_conversion\n    FROM \n        `dbt`.`int_yields_sdai_rate_daily`\n    WHERE\n        toStartOfMonth(date) = (\n            SELECT addMonths(max(toStartOfMonth(date)), -1)\n            FROM `dbt`.`int_yields_sdai_rate_daily`\n        )\n    ORDER BY date DESC\n    LIMIT 1\n),\n\n\nsdai_daily_rate AS (\n  SELECT\n      date\n      ,sdai_conversion\n      ,floor(\n          sdai_conversion \n          - (\n            \n            COALESCE(\n                lagInFrame(sdai_conversion) OVER (\n                    ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n                ),\n                (SELECT sdai_conversion FROM last_partition_value)\n            )\n            \n            )\n      ,12) AS rate\n  FROM (\n    SELECT \n      t1.date\n      ,last_value(t2.sdai_conversion) ignore nulls OVER (ORDER BY t1.date) AS sdai_conversion\n    FROM calendar t1\n    LEFT JOIN\n      sdai_rate_sparse_daily t2\n      ON t2.date = t1.date\n  )\n)\n\n\nSELECT \n  date\n  ,sdai_conversion\n  ,rate\nFROM sdai_daily_rate\nWHERE rate IS NOT NULL", "relation_name": "`dbt`.`int_yields_sdai_rate_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.098537Z", "completed_at": "2025-10-15T13:38:04.102799Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.103382Z", "completed_at": "2025-10-15T13:38:04.103389Z"}], "thread_id": "Thread-1", "execution_time": 0.006106376647949219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_crawlers_data_labels", "compiled": true, "compiled_code": "\n\nWITH src AS (\n  SELECT\n    lower(address) AS address,\n    project\n  FROM `dbt`.`stg_crawlers_data__dune_labels`\n),\n\nlabeled AS (\n  SELECT\n    address,\n    project,\n\n    multiIf(\n\n      match(project, '(?i)^Unknown$'),           'Unknown',\n      match(project, '(?i)^EOA$'),               'EOAs',\n      match(project, '(?i)^ERC20$'),             'ERC20 Tokens',\n\n      match(project, '(?i)(uniswap|sushi|swapr|balancer|curve|honeyswap|levinswap|openocean|openoceanexchange|1inch|paraswap|cow\\\\s*swap|cowswap|gnosis\\\\s*protocol|xswap|symmetric(\\\\s*finance)?|elk\\\\s*finance|\\\\bdex\\\\b|aggregator|dex\\\\s*aggregator|zerion|kinetex\\\\s*xswap|baoswap)'),\n      'DEX',\n\n      match(project, '(?i)(\\\\baave\\\\b|spark(\\\\s*protocol)?|agave|compound|compoundadapter|\\\\bidle\\\\b|beefy|jarvis(\\\\s*network)?|gyroscope|qidao|powerpool|lending(manager)?|stakewise|aura\\\\s*finance|merkl)'),\n      'Lending & Yield',\n\n      match(project, '(?i)(\\\\bbridge\\\\b|omnibridge|hop(\\\\s*protocol)?|\\\\bbungee\\\\b|\\\\bacross\\\\b|connext|celer|stargate|lifi|li\\\\.?fi|\\\\bamb\\\\b|eth\\\\s*xdai\\\\s*amb|bsc\\\\s*xdai\\\\s*amb|\\\\brelay\\\\b|spokebridge|spokegateway|socket(\\\\b|\\\\s)|rango\\\\s*exchange|rubic(\\\\s*(onchain|crosschain))?|swaps?\\\\s*io|eywa|symbiosis|squid(\\\\s*spoke)?)'),\n      'Bridges',\n\n      match(project, '(?i)(layer\\\\s*zero|hyperlane|zk\\\\s*bridge|zkbridge|polyhedra|zk(light|client)|telepathy|messag(?:ing|e)|everclear|interop)'),\n      'Messaging / Interop',\n\n      match(project, '(?i)(safe(?:\\\\s*l2)?|gnosis\\\\s*safe|ambirewallet|biconomy|erc[- ]?4337|erc\\\\s*4337\\\\s*entry\\\\s*point|entry\\\\s*point|wethgateway|tokenbound|delegatecash|rhinestone|apex\\\\s*smart\\\\s*wallet|zeroexsettlerdeployersafemodule)'),\n      'Wallets & AA',\n\n      match(project, '(?i)(monerium(\\\\s*(iske|usde|blacklist))?|gnosis\\\\s*pay(\\\\s*(vip|spender|eiffel))?|\\\\bgpay\\\\b|request(\\\\s*network)?|\\\\busdc\\\\b|\\\\bsdai\\\\b|\\\\bxdai\\\\b|payments?|invoice|smart\\\\s*invoice|superfluid|sablier|swing\\\\s*xdai\\\\s*single\\\\s*chain)'),\n      'Payments & Stablecoins',\n\n      match(project, '(?i)(chainlink|tellor|pyth|\\\\boracle\\\\b|origin\\\\s*trail|origintrail|marketview|analytics|\\\\bdata\\\\b|\\\\bindex\\\\b|mu\\\\s*exchange\\\\s*pythoracle)'),\n      'Oracles & Data',\n\n      match(project, '(?i)(opensea|seaport|poap|nifty(ink|fair)?|\\\\bnft\\\\b|erc721|erc1155|foundation|eporio|marketplace|creator|mint|mech\\\\s*marketplace|ghost\\\\s*nft\\\\s*faucet|nfts2me|crypto\\\\s*stamp|nondescriptive\\\\s*1155)'),\n      'NFTs & Marketplaces',\n\n      match(project, '(?i)(dark\\\\s*forest|conquest\\\\.eth|mithraeum|\\\\bgame\\\\b|gaming)'),\n      'Gaming',\n\n      match(project, '(?i)(dao\\\\s*haus|daoh?a?us|daostack|\\\\bdao\\\\b|daosquare|plazadao|zodiac|snapshot|kleros(\\\\s*curate)?|reality\\\\s*eth|vocdoni|proof\\\\s*of\\\\s*humanity|sismo(\\\\s*(badges|roots|attestations\\\\s*registry))?|attestation|identity|omen|ran\\\\s*dao|circles|polkamarkets)'),\n      'DAOs & Governance',\n\n      match(project, '(?i)(tornado(?:\\\\.?\\\\s*cash)?|tornado\\\\s*cash\\\\s*nova|umbra|privacy|\\\\bmix\\\\b)'),\n      'Privacy',\n\n      match(project, '(?i)(autonolas|gnosis\\\\s*ai|autonomous|agent)'),\n      'AI & Agents',\n\n      match(project, '(?i)(real\\\\s*token|realtoken|real\\\\s*rmm|\\\\brmm\\\\b|emblem)'),\n      'RWA & Tokenization',\n\n      match(project, '(?i)(^infrastructure$|gelato|opengsn|obol|ankr|shutter|infra(structure)?|registry|deployer|factory|controller|manager|router|vault|pool|proxy|multisig|gnosis\\\\s*protocol|gnosis\\\\s*chain|xdai\\\\s*posdao|swarm|ethswarm|address\\\\s*tag\\\\s*registry|judicialassetfactory|hopr(\\\\s*(token|network|protocol))?)'),\n      'Infrastructure & DevTools',\n\n      'Others'\n    ) AS sector\n  FROM src\n)\n\nSELECT\n  address,\n  anyLast(project) AS project,\n  anyLast(sector)  AS sector\nFROM labeled\nGROUP BY address", "relation_name": "`dbt`.`int_crawlers_data_labels`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.106132Z", "completed_at": "2025-10-15T13:38:04.110178Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.110770Z", "completed_at": "2025-10-15T13:38:04.110777Z"}], "thread_id": "Thread-1", "execution_time": 0.00599360466003418, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_graffiti_cloud", "compiled": true, "compiled_code": "\n\n\nSELECT\n    label\n    ,graffiti\n    ,value\nFROM `dbt`.`fct_consensus_graffiti_cloud`\nORDER BY label DESC, value DESC", "relation_name": "`dbt`.`api_consensus_graffiti_cloud`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.113454Z", "completed_at": "2025-10-15T13:38:04.117405Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.117977Z", "completed_at": "2025-10-15T13:38:04.117985Z"}], "thread_id": "Thread-1", "execution_time": 0.005816936492919922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_deposits_withdrawls_cnt_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,cnt AS value\nFROM \n    `dbt`.`fct_consensus_deposits_withdrawls_daily`\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_deposits_withdrawls_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.120748Z", "completed_at": "2025-10-15T13:38:04.125678Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.126249Z", "completed_at": "2025-10-15T13:38:04.126256Z"}], "thread_id": "Thread-1", "execution_time": 0.006822109222412109, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_deposits_withdrawls_volume_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,total_amount AS value\nFROM \n    `dbt`.`fct_consensus_deposits_withdrawls_daily`\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_deposits_withdrawls_volume_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.128971Z", "completed_at": "2025-10-15T13:38:04.132719Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.133296Z", "completed_at": "2025-10-15T13:38:04.133304Z"}], "thread_id": "Thread-1", "execution_time": 0.005671262741088867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_clients_cnt_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,client\n    ,cnt AS value\nFROM `dbt`.`fct_execution_blocks_clients_daily`\nORDER BY date, client", "relation_name": "`dbt`.`api_execution_blocks_clients_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.136020Z", "completed_at": "2025-10-15T13:38:04.140009Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.140604Z", "completed_at": "2025-10-15T13:38:04.140612Z"}], "thread_id": "Thread-1", "execution_time": 0.005947589874267578, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_clients_pct_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,client\n    ,ROUND(fraq * 100, 2) AS value\nFROM `dbt`.`fct_execution_blocks_clients_daily`\nORDER BY date, client", "relation_name": "`dbt`.`api_execution_blocks_clients_pct_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.143217Z", "completed_at": "2025-10-15T13:38:04.147746Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.148319Z", "completed_at": "2025-10-15T13:38:04.148327Z"}], "thread_id": "Thread-1", "execution_time": 0.006320476531982422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_blocks_clients_daily_client.98762fe995", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect client\nfrom `dbt`.`fct_execution_blocks_clients_daily`\nwhere client is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.150932Z", "completed_at": "2025-10-15T13:38:04.155548Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.156099Z", "completed_at": "2025-10-15T13:38:04.156107Z"}], "thread_id": "Thread-1", "execution_time": 0.006450653076171875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_blocks_clients_daily_cnt.b8671865c8", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect cnt\nfrom `dbt`.`fct_execution_blocks_clients_daily`\nwhere cnt is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.158787Z", "completed_at": "2025-10-15T13:38:04.164326Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.164881Z", "completed_at": "2025-10-15T13:38:04.164888Z"}], "thread_id": "Thread-1", "execution_time": 0.0074100494384765625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_blocks_clients_daily_date.ba453188e6", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_execution_blocks_clients_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.167594Z", "completed_at": "2025-10-15T13:38:04.171380Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.171942Z", "completed_at": "2025-10-15T13:38:04.171949Z"}], "thread_id": "Thread-1", "execution_time": 0.005677938461303711, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_gas_usage_pct_monthly", "compiled": true, "compiled_code": "\n\nSELECT\n  month AS date,\n  ROUND(used * 100, 2) AS value\nFROM `dbt`.`fct_execution_blocks_gas_usage_monthly`\nORDER BY date", "relation_name": "`dbt`.`api_execution_blocks_gas_usage_pct_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.174665Z", "completed_at": "2025-10-15T13:38:04.178535Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.179101Z", "completed_at": "2025-10-15T13:38:04.179109Z"}], "thread_id": "Thread-1", "execution_time": 0.0057523250579833984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_state_full_size_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,bytes/POWER(10,9) AS value\nFROM `dbt`.`fct_execution_state_full_size_daily`", "relation_name": "`dbt`.`api_execution_state_full_size_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.181830Z", "completed_at": "2025-10-15T13:38:04.186361Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.186928Z", "completed_at": "2025-10-15T13:38:04.186936Z"}], "thread_id": "Thread-1", "execution_time": 0.006386756896972656, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_cnt_daily_date.f29b9945e6", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_cnt_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.189614Z", "completed_at": "2025-10-15T13:38:04.194064Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.194632Z", "completed_at": "2025-10-15T13:38:04.194640Z"}], "thread_id": "Thread-1", "execution_time": 0.006270885467529297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_cnt_daily_transaction_type.b0dc7eaceb", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect transaction_type\nfrom `dbt`.`api_execution_transactions_cnt_daily`\nwhere transaction_type is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.197342Z", "completed_at": "2025-10-15T13:38:04.201837Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.202412Z", "completed_at": "2025-10-15T13:38:04.202419Z"}], "thread_id": "Thread-1", "execution_time": 0.00642848014831543, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_cnt_daily_value.12fb2dc1d2", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect value\nfrom `dbt`.`api_execution_transactions_cnt_daily`\nwhere value is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.205247Z", "completed_at": "2025-10-15T13:38:04.210933Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.211508Z", "completed_at": "2025-10-15T13:38:04.211516Z"}], "thread_id": "Thread-1", "execution_time": 0.007750988006591797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_gas_used_daily_date.1f6b125a22", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_gas_used_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.214145Z", "completed_at": "2025-10-15T13:38:04.218654Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.219217Z", "completed_at": "2025-10-15T13:38:04.219245Z"}], "thread_id": "Thread-1", "execution_time": 0.006388187408447266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_gas_used_daily_gas_used.8db0fee0ba", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect gas_used\nfrom `dbt`.`api_execution_transactions_gas_used_daily`\nwhere gas_used is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.221980Z", "completed_at": "2025-10-15T13:38:04.225815Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.226391Z", "completed_at": "2025-10-15T13:38:04.226399Z"}], "thread_id": "Thread-1", "execution_time": 0.00576019287109375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv4_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv4_clients_daily`\nWHERE date < today()\nORDER BY date, metric, label", "relation_name": "`dbt`.`api_p2p_discv4_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.229056Z", "completed_at": "2025-10-15T13:38:04.233160Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.233763Z", "completed_at": "2025-10-15T13:38:04.233770Z"}], "thread_id": "Thread-1", "execution_time": 0.006009578704833984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv4_clients_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv4_clients_daily`\nWHERE date = (SELECT MAX(date) FROM  `dbt`.`int_p2p_discv4_clients_daily` )\nORDER BY metric, label", "relation_name": "`dbt`.`api_p2p_discv4_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.236456Z", "completed_at": "2025-10-15T13:38:04.244067Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.244640Z", "completed_at": "2025-10-15T13:38:04.244647Z"}], "thread_id": "Thread-1", "execution_time": 0.009430170059204102, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_classification", "compiled": true, "compiled_code": "\n\n\nWITH latest_observations AS (\n    SELECT \n        toDate(visit_ended_at) as observation_date,\n        peer_id,\n        argMax(ip, visit_ended_at) AS ip_address,\n        argMax(client, visit_ended_at) AS client_type,\n        argMax(peer_country, visit_ended_at) AS country_code,\n        argMax(generic_provider, visit_ended_at) AS generic_provider,\n        argMax(peer_org, visit_ended_at) AS peer_org,\n        MAX(visit_ended_at) AS last_seen_that_day\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE \n        empty(dial_errors) = 1 \n        AND crawl_error IS NULL\n        AND toStartOfDay(visit_ended_at) < today()\n        \n            AND toDate(visit_ended_at) > (SELECT MAX(date) FROM `dbt`.`int_esg_node_classification`)\n        \n    GROUP BY observation_date, peer_id\n),\n\nnode_categories AS (\n    SELECT\n        observation_date,\n        peer_id,\n        ip_address,\n        client_type,\n        country_code,\n        generic_provider,\n        peer_org,\n        \n        -- Classify nodes into operational archetypes based on generic_provider\n        CASE\n            WHEN generic_provider IN ('AWS', 'Google', 'Azure', 'Oracle Cloud', 'Alibaba Cloud') \n                THEN 'cloud_hosted'\n            WHEN generic_provider IN ('DigitalOcean', 'OVHcloud', 'Hetzner', 'Scaleway', 'Linode', 'Vultr', \n                                    'Equinix Metal', 'Hosting/CDN (Other)') \n                THEN 'cloud_hosted'\n            WHEN generic_provider = 'Carrier/Transit' \n                THEN 'professional_operator'\n            WHEN lower(peer_org) LIKE '%datacenter%' \n                OR lower(peer_org) LIKE '%data center%'\n                OR lower(peer_org) LIKE '%hosting%'\n                OR lower(peer_org) LIKE '%server%'\n                THEN 'professional_operator'\n            WHEN generic_provider = 'Public ISP (Home/Office)' \n                THEN 'home_staker'\n            WHEN lower(peer_org) LIKE '%telecom%'\n                OR lower(peer_org) LIKE '%broadband%'\n                OR lower(peer_org) LIKE '%cable%'\n                OR lower(peer_org) LIKE '%fiber%'\n                OR lower(peer_org) LIKE '%residential%'\n                THEN 'home_staker'\n            ELSE 'unknown'\n        END AS node_category,\n        \n        CASE\n            WHEN generic_provider IN ('AWS', 'Google', 'Azure', 'Oracle Cloud', 'Alibaba Cloud') THEN 0.95\n            WHEN generic_provider IN ('DigitalOcean', 'OVHcloud', 'Hetzner', 'Scaleway', 'Linode', 'Vultr') THEN 0.90\n            WHEN generic_provider = 'Public ISP (Home/Office)' THEN 0.80\n            WHEN generic_provider = 'Hosting/CDN (Other)' THEN 0.75\n            WHEN generic_provider = 'Carrier/Transit' THEN 0.70\n            WHEN generic_provider = 'Unknown' THEN 0.30\n            ELSE 0.50\n        END AS classification_confidence\n        \n    FROM latest_observations\n),\n\ndaily_distribution AS (\n    SELECT\n        observation_date AS date,\n        node_category,\n        COUNT(DISTINCT peer_id) AS observed_nodes,\n        AVG(classification_confidence) AS avg_confidence\n    FROM node_categories\n    GROUP BY observation_date, node_category\n),\n\nchao1_data AS (\n    SELECT\n        p.observation_date,\n        p.observed_successful_nodes,\n        p.enhanced_total_reachable,\n        p.connection_success_rate_pct\n    FROM `dbt`.`int_esg_node_population_chao1` p\n    WHERE 1=1\n        \n            AND p.observation_date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_classification`)\n        \n),\n\nscaled_distribution AS (\n    SELECT\n        d.date,\n        d.node_category,\n        d.observed_nodes,\n        d.avg_confidence,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(greatest(toFloat64(d.observed_nodes), \n                    toFloat64(d.observed_nodes) * c.enhanced_total_reachable / c.observed_successful_nodes))\n            ELSE d.observed_nodes\n        END AS estimated_total_nodes,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(greatest(toFloat64(d.observed_nodes), \n                    toFloat64(d.observed_nodes) * c.enhanced_total_reachable * 0.85 / c.observed_successful_nodes))\n            ELSE toUInt64(d.observed_nodes * 0.85)\n        END AS nodes_lower_95,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(toFloat64(d.observed_nodes) * c.enhanced_total_reachable * 1.15 / c.observed_successful_nodes)\n            ELSE toUInt64(d.observed_nodes * 1.15)\n        END AS nodes_upper_95,\n        \n        COALESCE(c.connection_success_rate_pct / 100.0, 0.75) AS sample_coverage,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                round(toFloat64(c.enhanced_total_reachable) / c.observed_successful_nodes, 3)\n            ELSE 1.0\n        END AS scaling_factor\n        \n    FROM daily_distribution d\n    LEFT JOIN chao1_data c ON d.date = c.observation_date\n),\n\ngeographic_distribution AS (\n    SELECT\n        observation_date AS date,\n        node_category,\n        country_code,\n        COUNT(DISTINCT peer_id) AS country_observed_nodes\n    FROM node_categories\n    WHERE country_code IS NOT NULL AND country_code != '' AND country_code != 'Unknown'\n    GROUP BY observation_date, node_category, country_code\n),\n\ngeographic_scaled AS (\n    SELECT\n        g.date,\n        g.node_category,\n        g.country_code,\n        g.country_observed_nodes,\n        \n        CASE \n            WHEN s.scaling_factor > 0 THEN\n                toUInt64(toFloat64(g.country_observed_nodes) * s.scaling_factor)\n            ELSE g.country_observed_nodes\n        END AS country_estimated_nodes\n        \n    FROM geographic_distribution g\n    JOIN scaled_distribution s\n        ON g.date = s.date AND g.node_category = s.node_category\n)\n\nSELECT\n    s.date,\n    s.node_category,\n    s.observed_nodes,\n    s.estimated_total_nodes,\n    s.nodes_lower_95,\n    s.nodes_upper_95,\n    s.avg_confidence,\n    s.sample_coverage,\n    s.scaling_factor,\n    \n    round(100.0 * s.estimated_total_nodes / \n          SUM(s.estimated_total_nodes) OVER (PARTITION BY s.date), 2) AS category_percentage,\n    \n    s.estimated_total_nodes - s.observed_nodes AS hidden_nodes_estimated,\n    round(100.0 * (s.estimated_total_nodes - s.observed_nodes) / s.estimated_total_nodes, 2) AS hidden_nodes_percentage,\n    \n    CASE \n        WHEN COUNT(g.country_code) > 0 THEN\n            toJSONString(groupArray((g.country_code, g.country_estimated_nodes)))\n        ELSE '[]'\n    END AS geographic_distribution,\n    \n    CASE \n        WHEN COUNT(g.country_code) > 0 THEN\n            arrayStringConcat(\n                arraySlice(\n                    arrayMap(x -> tupleElement(x, 1),\n                        arraySort(x -> -tupleElement(x, 2),\n                            groupArray((g.country_code, g.country_estimated_nodes))\n                        )\n                    ), 1, 5\n                ), ', '\n            )\n        ELSE 'No geographic data'\n    END AS top_countries,\n    \n    now() AS calculated_at\n    \nFROM scaled_distribution s\nLEFT JOIN geographic_scaled g\n    ON s.date = g.date AND s.node_category = g.node_category\n\nGROUP BY \n    s.date, s.node_category, s.observed_nodes, s.estimated_total_nodes,\n    s.nodes_lower_95, s.nodes_upper_95, s.avg_confidence, s.sample_coverage, s.scaling_factor\n\nORDER BY s.date, s.estimated_total_nodes DESC", "relation_name": "`dbt`.`int_esg_node_classification`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.247496Z", "completed_at": "2025-10-15T13:38:04.253266Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.253841Z", "completed_at": "2025-10-15T13:38:04.253848Z"}], "thread_id": "Thread-1", "execution_time": 0.007835149765014648, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_clients_latest", "compiled": true, "compiled_code": "\n\nWITH \n\ndiscv4_prev7D AS (\n    SELECT\n        date,\n        SUM(value) AS discv4_count\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`), 7)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv4 AS (\n    SELECT\n        date,\n        SUM(value) AS discv4_count\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv5_prev7D AS (\n    SELECT\n        date,\n        SUM(value) AS discv5_count\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_clients_daily`), 7)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv5 AS (\n    SELECT\n        date,\n        SUM(value) AS discv5_count\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_clients_daily`)\n        AND metric = 'Clients'\n    GROUP BY date\n)\n\nSELECT\n    t2.discv4_count AS discv4_count,\n    ROUND((COALESCE(t2.discv4_count / NULLIF(t1.discv4_count, 0), 0) - 1) * 100, 1) AS change_discv4_pct,\n    t4.discv5_count AS discv5_count,\n    ROUND((COALESCE(t4.discv5_count / NULLIF(t3.discv5_count, 0), 0) - 1) * 100, 1) AS change_discv5_pct\nFROM discv4_prev7D t1\nCROSS JOIN discv4 t2\nCROSS JOIN discv5_prev7D t3\nCROSS JOIN discv5 t4", "relation_name": "`dbt`.`api_p2p_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.256549Z", "completed_at": "2025-10-15T13:38:04.261638Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.262211Z", "completed_at": "2025-10-15T13:38:04.262218Z"}], "thread_id": "Thread-1", "execution_time": 0.007009983062744141, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv5_clients_daily`\nWHERE date < today()\nORDER BY date, metric, label", "relation_name": "`dbt`.`api_p2p_discv5_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.264895Z", "completed_at": "2025-10-15T13:38:04.269051Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.269651Z", "completed_at": "2025-10-15T13:38:04.269658Z"}], "thread_id": "Thread-1", "execution_time": 0.006051778793334961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_clients_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv5_clients_daily`\nWHERE date = (SELECT MAX(date) FROM  `dbt`.`int_p2p_discv5_clients_daily` )\nORDER BY metric, label", "relation_name": "`dbt`.`api_p2p_discv5_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.272364Z", "completed_at": "2025-10-15T13:38:04.276274Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.276842Z", "completed_at": "2025-10-15T13:38:04.276849Z"}], "thread_id": "Thread-1", "execution_time": 0.005816221237182617, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_current_fork_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`\nWHERE label = 'Current Fork' \nORDER BY date ASC, fork ASC", "relation_name": "`dbt`.`api_p2p_discv5_current_fork_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.279534Z", "completed_at": "2025-10-15T13:38:04.283370Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.283926Z", "completed_at": "2025-10-15T13:38:04.283933Z"}], "thread_id": "Thread-1", "execution_time": 0.005635976791381836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_next_fork_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`\nWHERE label = 'Next Fork' \nORDER BY date ASC, fork ASC", "relation_name": "`dbt`.`api_p2p_discv5_next_fork_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.286564Z", "completed_at": "2025-10-15T13:38:04.289796Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.290366Z", "completed_at": "2025-10-15T13:38:04.290373Z"}], "thread_id": "Thread-1", "execution_time": 0.005083560943603516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_p2p_discv5_forks_daily", "compiled": true, "compiled_code": "SELECT\n    date\n    ,label\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`", "relation_name": "`dbt`.`fct_p2p_discv5_forks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.292947Z", "completed_at": "2025-10-15T13:38:04.298069Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.298656Z", "completed_at": "2025-10-15T13:38:04.298664Z"}], "thread_id": "Thread-1", "execution_time": 0.00699162483215332, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_topology_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    peer_ip,\n    peer_discovery_id_prefix,\n    peer_cl_fork_name,\n    peer_cl_next_fork_name,\n    peer_client,\n    peer_hostname,\n    peer_city,\n    peer_country,\n    peer_org,\n    splitByChar(',', peer_loc)[1] AS peer_lat,\n    splitByChar(',', peer_loc)[2] AS peer_lon,\n    neighbor_ip,\n    neighbor_discovery_id_prefix,\n    neighbor_cl_fork_name,\n    neighbor_cl_next_fork_name,\n    neighbor_client,\n    neighbor_city,\n    neighbor_country,\n    neighbor_org,\n    splitByChar(',', neighbor_loc)[1] AS neighbor_lat,\n    splitByChar(',', neighbor_loc)[2] AS neighbor_lon,\n    cnt\nFROM  `dbt`.`int_p2p_discv5_topology_latest`", "relation_name": "`dbt`.`api_p2p_discv5_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.301282Z", "completed_at": "2025-10-15T13:38:04.375433Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.376004Z", "completed_at": "2025-10-15T13:38:04.376015Z"}], "thread_id": "Thread-1", "execution_time": 0.07599520683288574, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_p2p_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ndiscv4_topology AS (\n    SELECT\n        date,\n        peer_ip,\n        peer_discovery_id_prefix,\n        peer_client,\n        peer_hostname,\n        peer_city,\n        peer_country,\n        peer_org,\n        splitByChar(',', peer_loc)[1] AS peer_lat,\n        splitByChar(',', peer_loc)[2] AS peer_lon,\n        neighbor_ip,\n        neighbor_discovery_id_prefix,\n        neighbor_client,\n        neighbor_city,\n        neighbor_country,\n        neighbor_org,\n        splitByChar(',', neighbor_loc)[1] AS neighbor_lat,\n        splitByChar(',', neighbor_loc)[2] AS neighbor_lon,\n        cnt\n    FROM `dbt`.`int_p2p_discv4_topology_latest`\n),\n\ndiscv5_topology AS (\n    SELECT\n        date,\n        peer_ip,\n        peer_discovery_id_prefix,\n        peer_client,\n        peer_hostname,\n        peer_city,\n        peer_country,\n        peer_org,\n        splitByChar(',', peer_loc)[1] AS peer_lat,\n        splitByChar(',', peer_loc)[2] AS peer_lon,\n        neighbor_ip,\n        neighbor_discovery_id_prefix,\n        neighbor_client,\n        neighbor_city,\n        neighbor_country,\n        neighbor_org,\n        splitByChar(',', neighbor_loc)[1] AS neighbor_lat,\n        splitByChar(',', neighbor_loc)[2] AS neighbor_lon,\n        cnt\n    FROM `dbt`.`int_p2p_discv5_topology_latest`\n)\n\nSELECT 'DiscV4' AS protocol, * FROM discv4_topology\nUNION ALL\nSELECT 'DiscV5' AS protocol, * FROM discv5_topology", "relation_name": "`dbt`.`fct_p2p_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.378778Z", "completed_at": "2025-10-15T13:38:04.392054Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.392641Z", "completed_at": "2025-10-15T13:38:04.392649Z"}], "thread_id": "Thread-1", "execution_time": 0.015224456787109375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_apy_daily", "compiled": true, "compiled_code": "\n\nWITH\n\ndeposists AS (\n    SELECT \n        toStartOfDay(slot_timestamp) AS date\n        ,SUM(amount) AS amount\n    FROM `dbt`.`stg_consensus__deposits`\n    WHERE \n        slot_timestamp < toDate('2025-04-30')\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_apy_daily`\n    )\n  \n\n    GROUP BY 1\n\n    UNION ALL \n\n    SELECT \n        date\n        ,SUM(amount) AS amount\n    FROM `dbt`.`int_GBCDeposit_deposists_daily`\n    WHERE \n        date >= toDate('2025-04-30')\n        \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_apy_daily`\n    )\n  \n\n    GROUP BY 1\n),\n\ndeposists_requests AS (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n        SUM(toUInt64(JSONExtractString(deposit, 'amount'))) AS amount\n    FROM `dbt`.`stg_consensus__execution_requests`\n    ARRAY JOIN JSONExtractArrayRaw(payload, 'deposits') AS deposit\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_apy_daily`\n    )\n  \n\n    GROUP BY 1\n),\n\n\nwithdrawals AS (\n    SELECT \n        toStartOfDay(slot_timestamp) AS date \n        ,SUM(amount) AS amount\n    FROM `dbt`.`stg_consensus__withdrawals`\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_apy_daily`\n    )\n  \n\n    GROUP BY 1\n),\n\nwithdrawals_requests AS (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n        SUM(toUInt64(JSONExtractString(withdrawals, 'amount'))) AS amount\n    FROM `dbt`.`stg_consensus__execution_requests`\n    ARRAY JOIN JSONExtractArrayRaw(payload, 'withdrawals') AS withdrawals\n    \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_apy_daily`\n    )\n  \n\n    GROUP BY 1\n),\n\nvalidators AS (\n    SELECT\n        date,\n        balance,\n        lagInFrame(balance, 1, balance) OVER (\n            ORDER BY date\n            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n        ) AS prev_balance,\n        balance - prev_balance AS balance_diff\n    FROM (\n        SELECT\n            toStartOfDay(slot_timestamp) AS date,\n            SUM(balance) AS balance\n        FROM `dbt`.`stg_consensus__validators`\n        \n  \n    \n      \n    \n\n    WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_consensus_validators_apy_daily`\n    )\n  \n\n        GROUP BY 1\n    )\n)\n\nSELECT \n    t1.date AS date\n    ,t1.balance AS balance\n    ,t1.balance_diff AS balance_diff_original\n    ,COALESCE(t2.amount,0)  AS deposited_amount\n    ,COALESCE(t3.amount,0)  AS withdrawaled_amount\n    ,COALESCE(t4.amount,0)  AS deposited_amount_request\n    ,COALESCE(t5.amount,0)  AS withdrawaled_amount_request\n    ,t1.balance_diff - COALESCE(t2.amount,0) - COALESCE(t4.amount,0) + COALESCE(t3.amount,0) + COALESCE(t5.amount,0) AS eff_balance_diff\n    ,eff_balance_diff/t1.prev_balance AS rate\n    ,ROUND((POWER((1+rate),365) - 1) * 100,2) AS apy\nFROM validators t1\nLEFT JOIN \n    deposists t2\n    ON t2.date = t1.date\nLEFT JOIN \n    withdrawals t3\n    ON t3.date = t1.date\nLEFT JOIN \n    deposists_requests t4\n    ON t4.date = t1.date\nLEFT JOIN \n    withdrawals_requests t5\n    ON t5.date = t1.date", "relation_name": "`dbt`.`int_consensus_validators_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.395430Z", "completed_at": "2025-10-15T13:38:04.402404Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.402975Z", "completed_at": "2025-10-15T13:38:04.402983Z"}], "thread_id": "Thread-1", "execution_time": 0.008991003036499023, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_rwa_backedfi_prices_daily", "compiled": true, "compiled_code": "\n\n\n\n   -- safely before any token was listed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bC3M'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bC3M'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bCOIN'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bCOIN'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bCSPX'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bCSPX'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bHIGH'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bHIGH'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bIB01'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bIB01'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bIBTA'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bIBTA'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bMSTR'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bMSTR'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bNVDA'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bNVDA'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'TSLAx'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'TSLAx'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nORDER BY bticker, date", "relation_name": "`dbt`.`fct_execution_rwa_backedfi_prices_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.405715Z", "completed_at": "2025-10-15T13:38:04.409855Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.410436Z", "completed_at": "2025-10-15T13:38:04.410443Z"}], "thread_id": "Thread-1", "execution_time": 0.00603795051574707, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_circles_backing", "compiled": true, "compiled_code": "\n\nWITH dates AS (\n    -- get min/max date \n    SELECT\n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM `dbt`.`int_execution_circles_backing`\n),\ndate_series AS (\n    -- generate dense series of dates\n    SELECT\n        toDate(min_date) + number AS date\n    FROM dates\n    ARRAY JOIN range(dateDiff('day', min_date, max_date) + 1) AS number\n),\n\nfilled AS (\n    SELECT\n        g.date,\n        coalesce(t.cnt, 0) AS cnt\n    FROM date_series g\n    LEFT JOIN `dbt`.`int_execution_circles_backing` t\n        ON g.date = t.date\n)\n\nSELECT\n    date,\n    cnt,\n    SUM(cnt) OVER (ORDER BY date) AS total\nFROM filled\nWHERE date < today()", "relation_name": "`dbt`.`fct_execution_circles_backing`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.413096Z", "completed_at": "2025-10-15T13:38:04.417449Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.418002Z", "completed_at": "2025-10-15T13:38:04.418009Z"}], "thread_id": "Thread-1", "execution_time": 0.0061266422271728516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_circles_avatars", "compiled": true, "compiled_code": "\n\nWITH dates AS (\n    -- get min/max date \n    SELECT\n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM `dbt`.`int_execution_circles_v2_avatars`\n),\ndate_series AS (\n    -- generate dense series of dates\n    SELECT\n        toDate(min_date) + number AS date\n    FROM dates\n    ARRAY JOIN range(dateDiff('day', min_date, max_date) + 1) AS number\n),\navatar_types AS (\n    SELECT DISTINCT avatar_type\n    FROM `dbt`.`int_execution_circles_v2_avatars`\n),\ndense_grid AS (\n    SELECT\n        d.date,\n        a.avatar_type\n    FROM date_series d\n    CROSS JOIN avatar_types a\n),\nfilled AS (\n    SELECT\n        g.date,\n        g.avatar_type,\n        coalesce(t.cnt, 0) AS cnt\n    FROM dense_grid g\n    LEFT JOIN `dbt`.`int_execution_circles_v2_avatars` t\n        ON g.date = t.date\n       AND g.avatar_type = t.avatar_type\n)\n\nSELECT\n    date,\n    avatar_type,\n    cnt,\n    SUM(cnt) OVER (PARTITION BY avatar_type ORDER BY date) AS total\nFROM filled", "relation_name": "`dbt`.`fct_execution_circles_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.420875Z", "completed_at": "2025-10-15T13:38:04.425721Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.426306Z", "completed_at": "2025-10-15T13:38:04.426314Z"}], "thread_id": "Thread-1", "execution_time": 0.006773233413696289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_yields_sdai_apy_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nsdai_apy_daily AS (\n    SELECT\n        date,\n        floor(POWER((1+rate),365) - 1,4) * 100 AS apy,\n        floor(\n            avg(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 6  PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_7DMA,\n        floor(\n            avg(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_30DMA,\n         floor(\n            median(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 6  PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_7DMM,\n        floor(\n            median(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_30DMM\n    FROM `dbt`.`int_yields_sdai_rate_daily`\n)\n\nSELECT date, apy, 'Daily' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_7DMA, '7DMA' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_30DMA, '30DMA' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_7DMM, '7DMM' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_30DMM, '30DMM' AS label FROM sdai_apy_daily", "relation_name": "`dbt`.`fct_yields_sdai_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.429011Z", "completed_at": "2025-10-15T13:38:04.437306Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.437862Z", "completed_at": "2025-10-15T13:38:04.437870Z"}], "thread_id": "Thread-1", "execution_time": 0.010194778442382812, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_by_project_daily", "compiled": true, "compiled_code": "\n\n\n\n\n\nWITH lbl AS (\n  SELECT address, project, sector\n  FROM `dbt`.`int_crawlers_data_labels`\n),\n\ntx_labeled AS (\n  SELECT\n    toDate(t.block_timestamp)                        AS date,\n    coalesce(nullIf(trim(l.project), ''), 'Unknown') AS project,\n    lower(t.from_address)                            AS from_address,\n    toFloat64(coalesce(t.gas_used, 0))               AS gas_used,\n    toFloat64(coalesce(t.gas_price, 0))              AS gas_price\n  FROM `dbt`.`stg_execution__transactions` t\n  ANY LEFT JOIN lbl l ON lower(t.to_address) = l.address\n  WHERE t.block_timestamp < today()\n    AND t.from_address IS NOT NULL\n    AND t.success = 1\n    \n      \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT\n        max(toStartOfMonth(date))\n      FROM `dbt`.`int_execution_transactions_by_project_daily`\n    )\n  \n\n    \n),\n\nagg AS (\n  SELECT\n    date,\n    project,\n    count()                                    AS tx_count,\n    groupBitmapState(cityHash64(from_address)) AS ua_bitmap_state,\n    sum(gas_used)                              AS gas_used_sum,\n    sum(gas_used * gas_price) / 1e18           AS fee_native_sum\n  FROM tx_labeled\n  GROUP BY date, project\n),\n\nproj_sector AS (\n  SELECT\n    project,\n    coalesce(nullIf(trim(sector), ''), 'Unknown') AS sector\n  FROM (\n    SELECT project, anyHeavy(sector) AS sector\n    FROM `dbt`.`int_crawlers_data_labels`\n    GROUP BY project\n  )\n)\n\nSELECT\n  a.date                AS date,\n  a.project             AS project,\n  ps.sector             AS sector,\n  a.tx_count            AS tx_count,\n  a.ua_bitmap_state     AS ua_bitmap_state,\n  a.gas_used_sum        AS gas_used_sum,\n  a.fee_native_sum      AS fee_native_sum\nFROM agg a\nLEFT JOIN proj_sector ps ON ps.project = a.project", "relation_name": "`dbt`.`int_execution_transactions_by_project_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.440691Z", "completed_at": "2025-10-15T13:38:04.445716Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.446301Z", "completed_at": "2025-10-15T13:38:04.446308Z"}], "thread_id": "Thread-1", "execution_time": 0.007018089294433594, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_by_project_hourly_recent", "compiled": true, "compiled_code": "\n\nWITH lbl AS (\n  SELECT address, project, sector\n  FROM `dbt`.`int_crawlers_data_labels`\n),\n\nwm AS (\n  SELECT toStartOfHour(max(block_timestamp)) AS max_hour\n  FROM `dbt`.`stg_execution__transactions`\n),\n\ntx AS (\n  SELECT\n    date_trunc('hour', t.block_timestamp) AS hour,\n    lower(t.from_address)                 AS from_address,\n    lower(t.to_address)                   AS to_address,\n    toFloat64(coalesce(t.gas_used, 0))    AS gas_used,\n    toFloat64(coalesce(t.gas_price, 0))   AS gas_price\n  FROM `dbt`.`stg_execution__transactions` t\n  CROSS JOIN wm\n  WHERE t.block_timestamp >  subtractHours(max_hour, 47)\n    AND t.block_timestamp <= max_hour\n    AND t.from_address IS NOT NULL\n    AND t.success = 1\n),\n\nclassified AS (\n  SELECT\n    tx.hour,\n    coalesce(nullIf(trim(l.project), ''), 'Unknown') AS project,\n    count()                                          AS tx_count,\n    countDistinct(tx.from_address)                   AS active_accounts,\n    groupBitmapState(cityHash64(tx.from_address))    AS ua_bitmap_state,\n    sum(tx.gas_used * tx.gas_price) / 1e18           AS fee_native_sum\n  FROM tx\n  ANY LEFT JOIN lbl l ON tx.to_address = l.address\n  GROUP BY tx.hour, project\n),\n\nproj_sector AS (\n  SELECT\n    project,\n    coalesce(nullIf(trim(sector), ''), 'Unknown') AS sector\n  FROM (\n    SELECT project, anyHeavy(sector) AS sector\n    FROM `dbt`.`int_crawlers_data_labels`\n    GROUP BY project\n  )\n)\n\nSELECT\n  c.hour,\n  c.project,\n  ps.sector,\n  c.tx_count,\n  c.active_accounts,\n  c.ua_bitmap_state,\n  c.fee_native_sum\nFROM classified c\nLEFT JOIN proj_sector ps ON ps.project = c.project", "relation_name": "`dbt`.`int_execution_transactions_by_project_hourly_recent`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.449113Z", "completed_at": "2025-10-15T13:38:04.453529Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.454070Z", "completed_at": "2025-10-15T13:38:04.454078Z"}], "thread_id": "Thread-1", "execution_time": 0.0061910152435302734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_blocks_clients_cnt_daily_client.0dab4f5da1", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect client\nfrom `dbt`.`api_execution_blocks_clients_cnt_daily`\nwhere client is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.456650Z", "completed_at": "2025-10-15T13:38:04.461106Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.461680Z", "completed_at": "2025-10-15T13:38:04.461688Z"}], "thread_id": "Thread-1", "execution_time": 0.006257057189941406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_blocks_clients_cnt_daily_date.9319e2b653", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_blocks_clients_cnt_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.464240Z", "completed_at": "2025-10-15T13:38:04.469629Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.470181Z", "completed_at": "2025-10-15T13:38:04.470189Z"}], "thread_id": "Thread-1", "execution_time": 0.007193565368652344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_blocks_clients_cnt_daily_value.884552d242", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect value\nfrom `dbt`.`api_execution_blocks_clients_cnt_daily`\nwhere value is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.472747Z", "completed_at": "2025-10-15T13:38:04.481570Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.482120Z", "completed_at": "2025-10-15T13:38:04.482127Z"}], "thread_id": "Thread-1", "execution_time": 0.010578155517578125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_client_distribution", "compiled": true, "compiled_code": "\n\nWITH node_classification AS (\n    -- Get total nodes per category from classification model\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        scaling_factor\n    FROM `dbt`.`int_esg_node_classification`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`)\n    \n),\n\n-- Combine client data from both DiscV4 (execution) and DiscV5 (consensus)\ncombined_client_data AS (\n    -- DiscV5 Consensus clients\n    SELECT\n        date,\n        'consensus_' || label AS client_type,\n        value AS observed_client_nodes\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE metric = 'Clients' \n        AND value > 0\n        AND label NOT IN ('Unknown', '')\n        \n            AND date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`) - INTERVAL 1 DAY\n        \n    \n    UNION ALL\n    \n    -- DiscV4 Execution clients  \n    SELECT\n        date,\n        'execution_' || label AS client_type,\n        value AS observed_client_nodes\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE metric = 'Clients'\n        AND value > 0  \n        AND label NOT IN ('Unknown', '')\n        \n            AND date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`) - INTERVAL 1 DAY\n        \n),\n\n-- Calculate client distribution percentages\nobserved_client_distribution AS (\n    SELECT\n        date,\n        client_type,\n        observed_client_nodes,\n        round(100.0 * observed_client_nodes / SUM(observed_client_nodes) OVER (PARTITION BY date), 3) AS observed_client_percentage\n    FROM combined_client_data\n),\n\n-- Apply client distribution to each node category\nclient_distribution_by_category AS (\n    SELECT\n        nc.date,\n        nc.node_category, \n        ocd.client_type,\n        ocd.observed_client_nodes,\n        ocd.observed_client_percentage,\n        \n        -- Calculate client nodes for this category\n        -- Each client gets same percentage of each category\n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.estimated_total_nodes\n        )) AS estimated_client_nodes,\n        \n        -- Proportional bounds\n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.nodes_lower_95\n        )) AS client_nodes_lower_95,\n        \n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.nodes_upper_95\n        )) AS client_nodes_upper_95,\n        \n        -- Client efficiency factors\n        CASE \n            -- Consensus client efficiency (relative to baseline)\n            WHEN ocd.client_type = 'consensus_Lighthouse' THEN 0.95\n            WHEN ocd.client_type = 'consensus_Nimbus' THEN 0.85  \n            WHEN ocd.client_type = 'consensus_Teku' THEN 1.15\n            WHEN ocd.client_type = 'consensus_Prysm' THEN 1.05\n            WHEN ocd.client_type = 'consensus_Lodestar' THEN 1.10\n            \n            -- Execution client efficiency (relative to baseline)\n            WHEN ocd.client_type = 'execution_Erigon' THEN 0.95\n            WHEN ocd.client_type = 'execution_Nethermind' THEN 1.00\n            WHEN ocd.client_type = 'execution_Besu' THEN 1.02\n            WHEN ocd.client_type = 'execution_Geth' THEN 0.98\n            \n            -- Default for other/unknown clients\n            ELSE 1.0\n        END AS client_efficiency_factor,\n        \n        nc.scaling_factor\n        \n    FROM node_classification nc\n    JOIN observed_client_distribution ocd ON nc.date = ocd.date\n    WHERE nc.estimated_total_nodes > 0\n),\n\n-- Calculate final metrics with rankings\nfinal_client_distribution AS (\n    SELECT\n        date,\n        node_category,\n        client_type,\n        estimated_client_nodes,\n        client_nodes_lower_95,\n        client_nodes_upper_95,\n        client_efficiency_factor,\n        \n        -- Percentage within this node category\n        round(100.0 * estimated_client_nodes / \n              NULLIF(SUM(estimated_client_nodes) OVER (PARTITION BY date, node_category), 0), 2\n        ) AS category_client_percentage,\n        \n        -- Global percentage across all categories  \n        round(100.0 * estimated_client_nodes /\n              NULLIF(SUM(estimated_client_nodes) OVER (PARTITION BY date), 0), 2\n        ) AS global_client_percentage,\n        \n        -- Ranking within category\n        ROW_NUMBER() OVER (\n            PARTITION BY date, node_category \n            ORDER BY estimated_client_nodes DESC, client_type\n        ) AS rank_in_category,\n        \n        -- Global ranking\n        ROW_NUMBER() OVER (\n            PARTITION BY date \n            ORDER BY estimated_client_nodes DESC, node_category, client_type\n        ) AS global_rank\n        \n    FROM client_distribution_by_category\n    WHERE estimated_client_nodes > 0\n)\n\nSELECT\n    date,\n    node_category,\n    client_type,\n    estimated_client_nodes,\n    client_nodes_lower_95,\n    client_nodes_upper_95,\n    client_efficiency_factor,\n    category_client_percentage,\n    global_client_percentage,\n    rank_in_category,\n    global_rank,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM final_client_distribution\nORDER BY date, node_category, estimated_client_nodes DESC", "relation_name": "`dbt`.`int_esg_node_client_distribution`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.484692Z", "completed_at": "2025-10-15T13:38:04.490591Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.491137Z", "completed_at": "2025-10-15T13:38:04.491144Z"}], "thread_id": "Thread-1", "execution_time": 0.007720232009887695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_geographic_distribution", "compiled": true, "compiled_code": "\n\nWITH node_classification AS (\n    -- Get node classification data\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        geographic_distribution\n    FROM `dbt`.`int_esg_node_classification`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_geographic_distribution`)\n    \n),\n\n-- Parse geographic distribution JSON\ngeographic_parsed AS (\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        \n        -- Parse JSON array of country distributions\n        JSONExtract(geographic_distribution, 'Array(Tuple(String, UInt32))') AS country_array\n    FROM node_classification\n),\n\ngeographic_expanded AS (\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95, \n        nodes_upper_95,\n        \n        -- Unpack country data\n        arrayJoin(country_array) AS country_tuple,\n        tupleElement(country_tuple, 1) AS country_code,\n        tupleElement(country_tuple, 2) AS estimated_nodes\n        \n    FROM geographic_parsed\n    WHERE length(country_array) > 0\n),\n\n-- Add country metadata from country_codes table\ncountry_enriched AS (\n    SELECT\n        g.date,\n        g.node_category,\n        g.country_code,\n        g.estimated_nodes,\n        \n        -- Calculate bounds proportionally\n        round(toFloat64(g.estimated_nodes) * g.nodes_lower_95 / g.estimated_total_nodes) AS nodes_lower_95,\n        round(toFloat64(g.estimated_nodes) * g.nodes_upper_95 / g.estimated_total_nodes) AS nodes_upper_95,\n        \n        -- Country percentage within this category\n        round(100.0 * g.estimated_nodes / g.estimated_total_nodes, 2) AS category_percentage,\n        \n        -- Get country metadata from reference table\n        COALESCE(cc.name, 'Unknown') AS country_name,\n        COALESCE(cc.region, 'Other') AS region,\n        cc.`sub-region` AS sub_region,\n        cc.`alpha-3` AS country_code_alpha3\n        \n    FROM geographic_expanded g\n    LEFT JOIN `dbt`.`stg_crawlers_data__country_codes` cc\n        ON g.country_code = cc.`alpha-2`\n    WHERE g.estimated_nodes > 0  -- Only include countries with nodes\n)\n\nSELECT\n    date,\n    node_category,\n    country_code,\n    country_name,\n    region,\n    sub_region,\n    country_code_alpha3,\n    estimated_nodes AS estimated_total_nodes,\n    nodes_lower_95,\n    nodes_upper_95,\n    category_percentage,\n    \n    -- Overall percentage across all categories\n    round(100.0 * estimated_nodes / SUM(estimated_nodes) OVER (PARTITION BY date), 2) AS global_percentage,\n    \n    -- Ranking within category\n    ROW_NUMBER() OVER (PARTITION BY date, node_category ORDER BY estimated_nodes DESC) AS rank_in_category,\n    \n    -- Ranking globally\n    ROW_NUMBER() OVER (PARTITION BY date ORDER BY estimated_nodes DESC) AS global_rank,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM country_enriched\nORDER BY date, node_category, estimated_nodes DESC", "relation_name": "`dbt`.`int_esg_node_geographic_distribution`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.493836Z", "completed_at": "2025-10-15T13:38:04.497596Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.498151Z", "completed_at": "2025-10-15T13:38:04.498158Z"}], "thread_id": "Thread-1", "execution_time": 0.005576610565185547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_validators_apy_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,balance\n    ,rate\n    ,avg(rate) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rate_7dma\n    ,apy\n    ,ROUND((POWER((1+rate_7dma),365) - 1) * 100,2) AS apy_7dma\nFROM `dbt`.`int_consensus_validators_apy_daily`\nWHERE date > DATE '2021-12-08'", "relation_name": "`dbt`.`fct_consensus_validators_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.500941Z", "completed_at": "2025-10-15T13:38:04.504761Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.505334Z", "completed_at": "2025-10-15T13:38:04.505342Z"}], "thread_id": "Thread-1", "execution_time": 0.005762577056884766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_rwa_backedfi_prices_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  bticker,\n  date,\n  price         \nFROM `dbt`.`fct_execution_rwa_backedfi_prices_daily`\nORDER BY\n  bticker,\n  date", "relation_name": "`dbt`.`api_execution_rwa_backedfi_prices_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.507920Z", "completed_at": "2025-10-15T13:38:04.512506Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.513061Z", "completed_at": "2025-10-15T13:38:04.513068Z"}], "thread_id": "Thread-1", "execution_time": 0.0063648223876953125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_backers_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nbackers_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_backing`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_backing`)\n),\n\nbackers_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_backing`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_backing`), 7)\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM backers_latest t1\nCROSS JOIN backers_7d t2", "relation_name": "`dbt`.`api_execution_circles_backers_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.515660Z", "completed_at": "2025-10-15T13:38:04.520639Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.521189Z", "completed_at": "2025-10-15T13:38:04.521196Z"}], "thread_id": "Thread-1", "execution_time": 0.0067636966705322266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_avatars", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,avatar_type\n    ,cnt\n    ,total\nFROM `dbt`.`fct_execution_circles_avatars`\nORDER BY date, avatar_type", "relation_name": "`dbt`.`api_execution_circles_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.523769Z", "completed_at": "2025-10-15T13:38:04.528464Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.529024Z", "completed_at": "2025-10-15T13:38:04.529031Z"}], "thread_id": "Thread-1", "execution_time": 0.006478071212768555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_groups_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ngroups_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Group'\n),\n\ngroups_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Group'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM groups_latest t1\nCROSS JOIN groups_7d t2", "relation_name": "`dbt`.`api_execution_circles_groups_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.531607Z", "completed_at": "2025-10-15T13:38:04.536258Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.536824Z", "completed_at": "2025-10-15T13:38:04.536831Z"}], "thread_id": "Thread-1", "execution_time": 0.006432533264160156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_humans_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nhumans_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Human'\n),\n\nhumans_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Human'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM humans_latest t1\nCROSS JOIN humans_7d t2", "relation_name": "`dbt`.`api_execution_circles_humans_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.539535Z", "completed_at": "2025-10-15T13:38:04.544084Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.544663Z", "completed_at": "2025-10-15T13:38:04.544671Z"}], "thread_id": "Thread-1", "execution_time": 0.006351470947265625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_orgs_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\norgs_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Org'\n),\n\norgs_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Org'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM orgs_latest t1\nCROSS JOIN orgs_7d t2", "relation_name": "`dbt`.`api_execution_circles_orgs_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.547249Z", "completed_at": "2025-10-15T13:38:04.551284Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.551844Z", "completed_at": "2025-10-15T13:38:04.551851Z"}], "thread_id": "Thread-1", "execution_time": 0.005844831466674805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_gas_share_by_project_daily", "compiled": true, "compiled_code": "\n\nWITH tot AS (\n  SELECT\n    date,\n    SUM(gas_used_sum) AS day_gas_used\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  WHERE date < today()     \n  GROUP BY date\n)\nSELECT\n  p.date,\n  p.project AS label,\n  ROUND(p.gas_used_sum / NULLIF(t.day_gas_used, 0) * 100, 2) AS value\nFROM `dbt`.`int_execution_transactions_by_project_daily` p\nJOIN tot t USING (date)\nWHERE p.date < today()\nORDER BY p.date DESC, label", "relation_name": "`dbt`.`api_execution_transactions_gas_share_by_project_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.554597Z", "completed_at": "2025-10-15T13:38:04.558771Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.559339Z", "completed_at": "2025-10-15T13:38:04.559347Z"}], "thread_id": "Thread-1", "execution_time": 0.0059719085693359375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_project_monthly_top5", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT\n    toStartOfMonth(date)                    AS month,\n    project,\n    sum(tx_count)                           AS txs,\n    sum(fee_native_sum)                     AS fee_native,\n    sum(gas_used_sum)                       AS gas_used,\n    groupBitmapMergeState(ua_bitmap_state)  AS active_state\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  GROUP BY month, project\n),\nranked AS (\n  SELECT\n    month, project, txs, fee_native, gas_used, active_state,\n    row_number() OVER (PARTITION BY month ORDER BY txs DESC, fee_native DESC, project ASC) AS rk\n  FROM base\n),\nbucketed AS (\n  SELECT\n    month,\n    if(rk <= 5, project, 'Others') AS project_label,\n    txs, fee_native, gas_used, active_state\n  FROM ranked\n),\nmonthly AS (\n  SELECT\n    month,\n    project_label AS project,\n    sum(txs)                            AS txs,\n    sum(fee_native)                     AS fee_native,\n    sum(gas_used)                       AS gas_used,\n    groupBitmapMergeState(active_state) AS active_state\n  FROM bucketed\n  GROUP BY month, project_label\n)\n\nSELECT * FROM (\n  SELECT month AS date, project AS label, 'Transactions'  AS metric, toFloat64(txs)                              AS value FROM monthly\n  UNION ALL\n  SELECT month AS date, project AS label, 'FeesNative'    AS metric, round(toFloat64(fee_native), 6)             AS value FROM monthly\n  UNION ALL\n  SELECT month AS date, project AS label, 'GasUsed'       AS metric, toFloat64(gas_used)                         AS value FROM monthly\n  UNION ALL\n  SELECT\n    month AS date,\n    project AS label,\n    'ActiveAccounts' AS metric,\n    toFloat64(finalizeAggregation(active_state)) AS value\n  FROM monthly\n)\nORDER BY date ASC, label ASC, metric ASC", "relation_name": "`dbt`.`fct_execution_transactions_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.562066Z", "completed_at": "2025-10-15T13:38:04.567258Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.567818Z", "completed_at": "2025-10-15T13:38:04.567826Z"}], "thread_id": "Thread-1", "execution_time": 0.006981849670410156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_sector_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    sector,\n    groupBitmapMerge(ua_bitmap_state)                 AS active_accounts,\n    sum(tx_count)                                     AS txs,\n    sum(gas_used_sum)                                 AS gas_used_sum,\n    round(toFloat64(sum(fee_native_sum)), 6)          AS fee_native_sum\nFROM `dbt`.`int_execution_transactions_by_project_daily`\nGROUP BY\n  date, sector", "relation_name": "`dbt`.`fct_execution_transactions_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.570669Z", "completed_at": "2025-10-15T13:38:04.577262Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.577820Z", "completed_at": "2025-10-15T13:38:04.577827Z"}], "thread_id": "Thread-1", "execution_time": 0.00839686393737793, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_by_project_alltime_state", "compiled": true, "compiled_code": "\n\n\n\n\nWITH src AS (\n  SELECT\n    toStartOfMonth(date)                   AS month,\n    project,\n    sumState(tx_count)                     AS txs_state,\n    sumState(fee_native_sum)               AS fee_state,\n    groupBitmapMergeState(ua_bitmap_state) AS aa_state\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  WHERE 1=1\n    \n      \n  \n    \n      \n    \n\n    AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT\n        max(toStartOfMonth(month))\n      FROM `dbt`.`int_execution_transactions_by_project_alltime_state`\n    )\n  \n\n    \n  GROUP BY month, project\n)\n\nSELECT project, month, txs_state, fee_state, aa_state\nFROM src", "relation_name": "`dbt`.`int_execution_transactions_by_project_alltime_state`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.580572Z", "completed_at": "2025-10-15T13:38:04.585157Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.585733Z", "completed_at": "2025-10-15T13:38:04.585741Z"}], "thread_id": "Thread-1", "execution_time": 0.006396055221557617, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_by_project_daily_date.fe1b429be9", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`int_execution_transactions_by_project_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.588319Z", "completed_at": "2025-10-15T13:38:04.592689Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.593242Z", "completed_at": "2025-10-15T13:38:04.593250Z"}], "thread_id": "Thread-1", "execution_time": 0.0061533451080322266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_by_project_daily_project.94b35ddc4b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect project\nfrom `dbt`.`int_execution_transactions_by_project_daily`\nwhere project is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.595779Z", "completed_at": "2025-10-15T13:38:04.600176Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.600745Z", "completed_at": "2025-10-15T13:38:04.600753Z"}], "thread_id": "Thread-1", "execution_time": 0.006170988082885742, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_by_project_daily_sector.40d857cb69", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect sector\nfrom `dbt`.`int_execution_transactions_by_project_daily`\nwhere sector is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.603289Z", "completed_at": "2025-10-15T13:38:04.608881Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.609453Z", "completed_at": "2025-10-15T13:38:04.609461Z"}], "thread_id": "Thread-1", "execution_time": 0.007388591766357422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_by_project_daily_tx_count.f7f9e187b1", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect tx_count\nfrom `dbt`.`int_execution_transactions_by_project_daily`\nwhere tx_count is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.612054Z", "completed_at": "2025-10-15T13:38:04.615868Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.616445Z", "completed_at": "2025-10-15T13:38:04.616452Z"}], "thread_id": "Thread-1", "execution_time": 0.005637645721435547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_sector_hourly", "compiled": true, "compiled_code": "\n\nSELECT\n  hour AS date,\n  sector AS label,\n  groupBitmapMerge(ua_bitmap_state) AS value\nFROM `dbt`.`int_execution_transactions_by_project_hourly_recent`\nGROUP BY date, label\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_sector_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.619182Z", "completed_at": "2025-10-15T13:38:04.623002Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.623576Z", "completed_at": "2025-10-15T13:38:04.623584Z"}], "thread_id": "Thread-1", "execution_time": 0.005640268325805664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_sector_hourly", "compiled": true, "compiled_code": "\n\nSELECT\n  hour AS date,\n  sector AS label,\n  sum(tx_count) AS value\nFROM `dbt`.`int_execution_transactions_by_project_hourly_recent`\nGROUP BY date, label\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_sector_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.626243Z", "completed_at": "2025-10-15T13:38:04.630164Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.630750Z", "completed_at": "2025-10-15T13:38:04.630757Z"}], "thread_id": "Thread-1", "execution_time": 0.0058650970458984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_sector_hourly", "compiled": true, "compiled_code": "\n\nSELECT\n  hour AS date,\n  sector AS label,\n  round(toFloat64(sum(fee_native_sum)), 2) AS value\nFROM `dbt`.`int_execution_transactions_by_project_hourly_recent`\nGROUP BY date, label\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_sector_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.633323Z", "completed_at": "2025-10-15T13:38:04.638027Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.638602Z", "completed_at": "2025-10-15T13:38:04.638610Z"}], "thread_id": "Thread-1", "execution_time": 0.0065059661865234375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_by_project_hourly_recent_active_accounts.82b19fb74d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect active_accounts\nfrom `dbt`.`int_execution_transactions_by_project_hourly_recent`\nwhere active_accounts is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.641170Z", "completed_at": "2025-10-15T13:38:04.645869Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.646439Z", "completed_at": "2025-10-15T13:38:04.646447Z"}], "thread_id": "Thread-1", "execution_time": 0.006485462188720703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_by_project_hourly_recent_hour.5270417e9a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect hour\nfrom `dbt`.`int_execution_transactions_by_project_hourly_recent`\nwhere hour is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.648986Z", "completed_at": "2025-10-15T13:38:04.654898Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.655474Z", "completed_at": "2025-10-15T13:38:04.655482Z"}], "thread_id": "Thread-1", "execution_time": 0.007702350616455078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_by_project_hourly_recent_project.72a63a38ad", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect project\nfrom `dbt`.`int_execution_transactions_by_project_hourly_recent`\nwhere project is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.658023Z", "completed_at": "2025-10-15T13:38:04.662654Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.663207Z", "completed_at": "2025-10-15T13:38:04.663215Z"}], "thread_id": "Thread-1", "execution_time": 0.006421804428100586, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_by_project_hourly_recent_tx_count.1b15e22668", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect tx_count\nfrom `dbt`.`int_execution_transactions_by_project_hourly_recent`\nwhere tx_count is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.665811Z", "completed_at": "2025-10-15T13:38:04.674368Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.674944Z", "completed_at": "2025-10-15T13:38:04.674951Z"}], "thread_id": "Thread-1", "execution_time": 0.010366201400756836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_dynamic_power_consumption", "compiled": true, "compiled_code": "\n\nWITH node_distribution AS (\n    SELECT\n        date,\n        node_category,\n        country_code,\n        country_name,\n        region,\n        sub_region,\n        country_code_alpha3,\n        estimated_total_nodes,  \n        nodes_lower_95,           \n        nodes_upper_95          \n    FROM `dbt`.`int_esg_node_geographic_distribution` n\n    \n        WHERE n.date > (SELECT MAX(date) FROM `dbt`.`int_esg_dynamic_power_consumption`)\n    \n),\n\n-- Get client efficiency from upstream client distribution model\nclient_efficiency_by_category AS (\n    SELECT\n        date,\n        node_category,\n        \n        -- Weighted average client efficiency for this category\n        SUM(category_client_percentage / 100.0 * client_efficiency_factor) AS avg_client_efficiency,\n        \n        -- Client diversity count for resilience bonus\n        COUNT(DISTINCT client_type) AS client_diversity,\n        \n        -- Total estimated client nodes for validation\n        SUM(estimated_client_nodes) AS total_client_nodes,\n        \n        -- Client breakdown for diagnostics\n        groupArray((client_type, category_client_percentage, estimated_client_nodes)) AS client_breakdown\n        \n    FROM `dbt`.`int_esg_node_client_distribution` ncd\n    \n        WHERE ncd.date > (SELECT MAX(date) FROM `dbt`.`int_esg_dynamic_power_consumption`) - INTERVAL 1 DAY\n    \n    GROUP BY date, node_category\n),\n\n-- Base power calculations by hardware tier with CCRI empirical values\npower_per_category AS (\n    SELECT\n        nd.date,\n        nd.node_category,\n        nd.country_code,\n        nd.country_name,\n        nd.region,\n        nd.sub_region,\n        nd.country_code_alpha3,\n        nd.estimated_total_nodes,\n        nd.nodes_lower_95,\n        nd.nodes_upper_95,\n        \n        -- CCRI empirical power consumption (Watts per node)\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 22.0        -- CCRI Tier 4: mean of 16.56-25.97W\n            WHEN 'professional_operator' THEN 48.0  -- CCRI Tier 5: mean of 36.82-59.95W\n            WHEN 'cloud_hosted' THEN 155.0      -- CCRI Tier 6: mean of 139.90-186.76W\n            ELSE 50.0\n        END AS base_power_watts,\n        \n        -- Standard deviation based on CCRI measurement ranges\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 3.3        -- ~15% of 22W (conservative uncertainty)\n            WHEN 'professional_operator' THEN 7.2  -- ~15% of 48W\n            WHEN 'cloud_hosted' THEN 23.0       -- ~15% of 155W\n            ELSE 7.5\n        END AS power_std_watts,\n        \n        -- Data source for traceability\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 'CCRI_Tier4_Empirical'\n            WHEN 'professional_operator' THEN 'CCRI_Tier5_Empirical'\n            WHEN 'cloud_hosted' THEN 'CCRI_Tier6_Empirical'\n            ELSE 'CCRI_Default'\n        END AS power_source,\n        \n        -- Measurement confidence (CCRI empirical data is high quality)\n        0.85 AS measurement_confidence,\n        \n        -- PUE by category  \n        CASE nd.node_category\n            WHEN 'home_staker' THEN 1.0         -- No datacenter overhead\n            WHEN 'professional_operator' THEN 1.58  -- Traditional datacenter\n            WHEN 'cloud_hosted' THEN 1.15       -- Efficient cloud datacenter\n            ELSE 1.1\n        END AS pue_factor,\n        \n        -- Client efficiency from upstream model\n        COALESCE(ce.avg_client_efficiency, 1.0) AS client_efficiency_multiplier,\n        \n        -- Diversity bonus (more client types = better resilience)\n        CASE \n            WHEN ce.client_diversity > 0 THEN 0.95 + 0.05 * least(4, ce.client_diversity) / 4.0\n            ELSE 1.0\n        END AS diversity_bonus,\n        \n        ce.client_breakdown,\n        ce.total_client_nodes\n        \n    FROM node_distribution nd\n    LEFT JOIN client_efficiency_by_category ce ON nd.date = ce.date AND nd.node_category = ce.node_category\n),\n\n-- Apply all efficiency factors\nfinal_power_calculations AS (\n    SELECT\n        p.*,\n        \n        -- Final power per node with all efficiency factors\n        p.base_power_watts * p.client_efficiency_multiplier * p.diversity_bonus AS avg_power_watts_per_node,\n        p.power_std_watts * p.client_efficiency_multiplier * p.diversity_bonus AS power_std_dev_per_node,\n        \n        -- Daily energy consumption (kWh)\n        p.estimated_total_nodes * \n        p.base_power_watts * \n        p.client_efficiency_multiplier * \n        p.diversity_bonus * \n        24.0 / 1000.0 AS daily_energy_kwh_mean\n\n    FROM power_per_category p\n),\n\n-- Carbon intensity lookup with robust fallback\ncarbon_intensity_lookup AS (\n    SELECT DISTINCT\n        p.date,\n        p.country_code_alpha3,\n        \n        -- Robust fallback hierarchy\n        COALESCE(\n            ci_country.carbon_intensity_mean,\n            ci_world.carbon_intensity_mean,\n            450.0\n        ) AS carbon_intensity_gco2_kwh,\n        \n        COALESCE(\n            ci_country.carbon_intensity_std,\n            ci_world.carbon_intensity_std, \n            45.0\n        ) AS carbon_intensity_std_gco2_kwh,\n        \n        CASE \n            WHEN ci_country.carbon_intensity_mean IS NOT NULL THEN 'country_specific'\n            WHEN ci_world.carbon_intensity_mean IS NOT NULL THEN 'world_average'\n            ELSE 'conservative_default'\n        END AS carbon_intensity_source\n        \n    FROM final_power_calculations p\n    LEFT JOIN `dbt`.`int_esg_carbon_intensity_ensemble` ci_country\n        ON p.country_code_alpha3 = ci_country.country_code\n        AND ci_country.month_date = toStartOfMonth(p.date)\n        AND p.country_code_alpha3 IS NOT NULL\n        AND p.country_code_alpha3 != ''\n    LEFT JOIN `dbt`.`int_esg_carbon_intensity_ensemble` ci_world\n        ON ci_world.country_code = 'WORLD'\n        AND ci_world.month_date = toStartOfMonth(p.date)\n    WHERE ci_country.month_date != DATE '1970-01-01' OR ci_world.month_date != DATE '1970-01-01' -- nu;;s ghet repl;ace by date...\n),\n\n-- Final calculations with carbon emissions\nfinal_calculations AS (\n    SELECT\n        p.date AS date,\n        p.node_category AS node_category,\n        p.country_code AS country_code,\n        p.country_code_alpha3 AS country_code_alpha3,\n        p.country_name AS country_name,\n        p.region AS region,\n        p.sub_region AS sub_region,\n        p.estimated_total_nodes AS estimated_total_nodes,\n        p.nodes_lower_95 AS nodes_lower_95,\n        p.nodes_upper_95 AS nodes_upper_95,\n        p.avg_power_watts_per_node AS avg_power_watts_per_node,\n        p.power_std_dev_per_node AS power_std_dev_per_node,\n        p.daily_energy_kwh_mean AS daily_energy_kwh_mean,\n        p.pue_factor AS pue_factor,\n        p.client_efficiency_multiplier AS client_efficiency,\n        p.diversity_bonus,\n        \n        -- CCRI source tracking\n        p.power_source,\n        p.measurement_confidence,\n        p.base_power_watts AS ccri_base_power_watts,\n        \n        -- Carbon intensity from lookup\n        ci.carbon_intensity_gco2_kwh,\n        ci.carbon_intensity_std_gco2_kwh,\n        ci.carbon_intensity_source,\n        \n        -- CO2 calculations\n        p.daily_energy_kwh_mean * p.pue_factor * ci.carbon_intensity_gco2_kwh / 1000.0 AS daily_co2_kg_mean,\n        \n        -- CO2 standard deviation\n        sqrt(\n            pow(p.daily_energy_kwh_mean * p.pue_factor * ci.carbon_intensity_std_gco2_kwh / 1000.0, 2) +\n            pow(p.power_std_dev_per_node * 24 / 1000.0 * p.pue_factor * ci.carbon_intensity_gco2_kwh / 1000.0, 2)\n        ) AS daily_co2_kg_std,\n        \n        -- Diagnostics\n        p.client_breakdown,\n        p.total_client_nodes\n        \n    FROM final_power_calculations p\n    INNER JOIN carbon_intensity_lookup ci\n        ON p.date = ci.date\n        AND COALESCE(p.country_code_alpha3, '') = COALESCE(ci.country_code_alpha3, '')\n)\n\nSELECT\n    date,\n    node_category,\n    country_code,\n    country_name,\n    region,\n    estimated_total_nodes,\n    nodes_lower_95,\n    nodes_upper_95,\n    \n    -- Power consumption metrics\n    round(avg_power_watts_per_node, 2) AS avg_power_watts_per_node,\n    round(power_std_dev_per_node, 2) AS power_std_dev_per_node,\n    round(daily_energy_kwh_mean, 2) AS daily_energy_kwh_mean,\n    round(pue_factor, 3) AS pue_mean,\n    round(client_efficiency, 3) AS client_efficiency_factor,\n    round(diversity_bonus, 3) AS diversity_bonus,\n    \n    -- Carbon emissions\n    round(daily_co2_kg_mean, 4) AS daily_co2_kg_mean,\n    round(daily_co2_kg_std, 4) AS daily_co2_kg_std,\n    round(carbon_intensity_gco2_kwh, 2) AS carbon_intensity_gco2_kwh,\n    round(carbon_intensity_std_gco2_kwh, 2) AS carbon_intensity_std_gco2_kwh,\n    \n    -- Confidence intervals\n    round(greatest(0, daily_co2_kg_mean - 1.96 * daily_co2_kg_std), 4) AS daily_co2_kg_lower_95,\n    round(daily_co2_kg_mean + 1.96 * daily_co2_kg_std, 4) AS daily_co2_kg_upper_95,\n    \n    -- CCRI data quality and source tracking\n    carbon_intensity_source,\n    round(ccri_base_power_watts, 2) AS ccri_base_power_watts,\n    power_source,\n    round(measurement_confidence, 3) AS measurement_confidence,\n    \n    -- Performance comparison with previous estimates\n    round(\n        100.0 * (avg_power_watts_per_node - CASE node_category\n            WHEN 'home_staker' THEN 75.0\n            WHEN 'professional_operator' THEN 200.0  \n            WHEN 'cloud_hosted' THEN 110.0\n            ELSE 100.0\n        END) / CASE node_category\n            WHEN 'home_staker' THEN 75.0\n            WHEN 'professional_operator' THEN 200.0\n            WHEN 'cloud_hosted' THEN 110.0  \n            ELSE 100.0\n        END, 1\n    ) AS power_reduction_vs_previous_pct,\n    \n    -- Diagnostics\n    toJSONString(client_breakdown) AS client_breakdown_json,\n    total_client_nodes AS debug_total_clients,\n    \n    -- Metadata\n    now() AS calculated_at\n\nFROM final_calculations\nWHERE estimated_total_nodes > 0", "relation_name": "`dbt`.`int_esg_dynamic_power_consumption`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.677788Z", "completed_at": "2025-10-15T13:38:04.681796Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.682372Z", "completed_at": "2025-10-15T13:38:04.682379Z"}], "thread_id": "Thread-1", "execution_time": 0.00607752799987793, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_apy_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,label\n    ,apy\nFROM (\n    SELECT date, 'Daily' AS label, apy AS apy FROM `dbt`.`fct_consensus_validators_apy_daily`\n    UNION ALL \n    SELECT date, '7DMA' AS label, apy_7dma AS apy FROM `dbt`.`fct_consensus_validators_apy_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_validators_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.684929Z", "completed_at": "2025-10-15T13:38:04.692717Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.693295Z", "completed_at": "2025-10-15T13:38:04.693302Z"}], "thread_id": "Thread-1", "execution_time": 0.00957345962524414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_info_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ndeposits_withdrawls_latest AS (\n    SELECT\n        label\n        ,cnt\n        ,total_amount\n    FROM \n        `dbt`.`fct_consensus_deposits_withdrawls_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`fct_consensus_deposits_withdrawls_daily`)\n),\n\ndeposits_withdrawls_7d AS (\n    SELECT\n        label\n        ,cnt\n        ,total_amount\n    FROM \n        `dbt`.`fct_consensus_deposits_withdrawls_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`), 7)\n),\n\napy_latest AS (\n    SELECT\n        apy_7dma\n    FROM \n        `dbt`.`fct_consensus_validators_apy_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`fct_consensus_validators_apy_daily`)\n),\n\napy_7d AS (\n    SELECT\n       apy_7dma\n    FROM \n        `dbt`.`fct_consensus_validators_apy_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`fct_consensus_validators_apy_daily`), 7)\n),\n\nstatus_latest AS (\n    SELECT\n        status AS label\n        ,CAST(COALESCE(cnt,0) AS Float64) AS value\n    FROM \n        `dbt`.`int_consensus_validators_status_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_validators_status_daily`)\n),\n\nstatus_7d AS (\n    SELECT\n        status AS label\n        ,CAST(COALESCE(cnt,0) AS Float64) AS value\n    FROM \n        `dbt`.`int_consensus_validators_status_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_validators_status_daily`), 7)\n),\n\n\nstaked_latest AS (\n    SELECT\n        'Staked' AS label\n        ,effective_balance/32 AS value\n    FROM \n        `dbt`.`int_consensus_validators_balances_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_validators_balances_daily`)\n),\n\nstaked_7d AS (\n    SELECT\n        'Staked' AS label\n        ,effective_balance/32 AS value\n    FROM \n        `dbt`.`int_consensus_validators_balances_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_validators_balances_daily`), 7)\n),\n\n\ninfo_latest AS ( \n    SELECT\n        'deposits_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_latest WHERE label = 'deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_latest WHERE label = 'withdrawls'), 0) AS value\n    UNION ALL\n    SELECT\n        'deposits_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'withdrawls'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'withdrawls'), 0) AS value\n    UNION ALL\n    SELECT\n        'APY7D' AS label \n    ,COALESCE((SELECT ROUND(apy_7dma,2) FROM apy_latest),0) AS value\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM status_latest\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM staked_latest\n),\n\ninfo_7d AS ( \n    SELECT\n        'deposits_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_7d WHERE label = 'deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_7d WHERE label = 'withdrawls'), 0) AS value\n    UNION ALL\n    SELECT\n        'deposits_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_7d WHERE label = 'deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'APY7D' AS label \n    ,COALESCE((SELECT ROUND(apy_7dma,2) FROM apy_7d),0) AS value\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM status_7d\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM staked_7d\n)\n\nSELECT\n    t1.label\n    ,t1.value AS value\n    ,IF(t1.value=0 AND t2.value=0, 0, ROUND(( COALESCE(t1.value / NULLIF(t2.value, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM info_latest t1\nINNER JOIN info_7d t2\nON t2.label = t1.label", "relation_name": "`dbt`.`fct_consensus_info_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.696384Z", "completed_at": "2025-10-15T13:38:04.702121Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.702699Z", "completed_at": "2025-10-15T13:38:04.702706Z"}], "thread_id": "Thread-1", "execution_time": 0.008053779602050781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_gas_share_by_project_daily_date.9a0f9c0df3", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_gas_share_by_project_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.705348Z", "completed_at": "2025-10-15T13:38:04.710087Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.710678Z", "completed_at": "2025-10-15T13:38:04.710685Z"}], "thread_id": "Thread-1", "execution_time": 0.0066394805908203125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_gas_share_by_project_daily_label.f033fcb95a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect label\nfrom `dbt`.`api_execution_transactions_gas_share_by_project_daily`\nwhere label is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.713374Z", "completed_at": "2025-10-15T13:38:04.717990Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.718562Z", "completed_at": "2025-10-15T13:38:04.718570Z"}], "thread_id": "Thread-1", "execution_time": 0.006536245346069336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_gas_share_by_project_daily_value.339c013119", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect value\nfrom `dbt`.`api_execution_transactions_gas_share_by_project_daily`\nwhere value is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.721314Z", "completed_at": "2025-10-15T13:38:04.725082Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.725667Z", "completed_at": "2025-10-15T13:38:04.725674Z"}], "thread_id": "Thread-1", "execution_time": 0.005743980407714844, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_project_monthly_top5", "compiled": true, "compiled_code": "\nSELECT\n  date,\n  label,\n  value\nFROM `dbt`.`fct_execution_transactions_by_project_monthly_top5`\nWHERE metric = 'ActiveAccounts'\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.728378Z", "completed_at": "2025-10-15T13:38:04.732382Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.732959Z", "completed_at": "2025-10-15T13:38:04.732966Z"}], "thread_id": "Thread-1", "execution_time": 0.005921602249145508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_project_monthly_top5", "compiled": true, "compiled_code": "\nSELECT\n  date,\n  label,\n  value\nFROM `dbt`.`fct_execution_transactions_by_project_monthly_top5`\nWHERE metric = 'Transactions'\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.735641Z", "completed_at": "2025-10-15T13:38:04.739597Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.740154Z", "completed_at": "2025-10-15T13:38:04.740162Z"}], "thread_id": "Thread-1", "execution_time": 0.005773067474365234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_project_monthly_top5", "compiled": true, "compiled_code": "\nSELECT\n  date,\n  label,\n  value\nFROM `dbt`.`fct_execution_transactions_by_project_monthly_top5`\nWHERE metric = 'FeesNative'\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.742899Z", "completed_at": "2025-10-15T13:38:04.748166Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.748767Z", "completed_at": "2025-10-15T13:38:04.748774Z"}], "thread_id": "Thread-1", "execution_time": 0.007223844528198242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_sector_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  sector AS label,\n  active_accounts AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_daily`\nWHERE date < today()\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.751439Z", "completed_at": "2025-10-15T13:38:04.755297Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.755878Z", "completed_at": "2025-10-15T13:38:04.755885Z"}], "thread_id": "Thread-1", "execution_time": 0.005738735198974609, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_sector_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  sector AS label,\n  txs AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_daily`\nWHERE date < today()\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.758584Z", "completed_at": "2025-10-15T13:38:04.762578Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.763159Z", "completed_at": "2025-10-15T13:38:04.763166Z"}], "thread_id": "Thread-1", "execution_time": 0.005903959274291992, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_sector_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  sector AS label,\n  fee_native_sum AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_daily`\nWHERE date < today()\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.765833Z", "completed_at": "2025-10-15T13:38:04.770587Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.771150Z", "completed_at": "2025-10-15T13:38:04.771158Z"}], "thread_id": "Thread-1", "execution_time": 0.0066242218017578125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_transactions_by_sector_daily_active_accounts.a97d812173", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect active_accounts\nfrom `dbt`.`fct_execution_transactions_by_sector_daily`\nwhere active_accounts is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.773824Z", "completed_at": "2025-10-15T13:38:04.778371Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.778966Z", "completed_at": "2025-10-15T13:38:04.778973Z"}], "thread_id": "Thread-1", "execution_time": 0.006433963775634766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_transactions_by_sector_daily_date.cf19023a9f", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`fct_execution_transactions_by_sector_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.781652Z", "completed_at": "2025-10-15T13:38:04.786413Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.786966Z", "completed_at": "2025-10-15T13:38:04.786973Z"}], "thread_id": "Thread-1", "execution_time": 0.006603240966796875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_transactions_by_sector_daily_fee_native_sum.d48374bd5e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect fee_native_sum\nfrom `dbt`.`fct_execution_transactions_by_sector_daily`\nwhere fee_native_sum is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.791073Z", "completed_at": "2025-10-15T13:38:04.795697Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.796274Z", "completed_at": "2025-10-15T13:38:04.796281Z"}], "thread_id": "Thread-1", "execution_time": 0.00792384147644043, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_transactions_by_sector_daily_gas_used_sum.f2684b1b10", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect gas_used_sum\nfrom `dbt`.`fct_execution_transactions_by_sector_daily`\nwhere gas_used_sum is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.798906Z", "completed_at": "2025-10-15T13:38:04.803394Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.803956Z", "completed_at": "2025-10-15T13:38:04.803963Z"}], "thread_id": "Thread-1", "execution_time": 0.006337642669677734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_transactions_by_sector_daily_sector.0d9bc9ca69", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect sector\nfrom `dbt`.`fct_execution_transactions_by_sector_daily`\nwhere sector is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.806649Z", "completed_at": "2025-10-15T13:38:04.811031Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.811603Z", "completed_at": "2025-10-15T13:38:04.811611Z"}], "thread_id": "Thread-1", "execution_time": 0.00628209114074707, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_fct_execution_transactions_by_sector_daily_txs.571093b839", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect txs\nfrom `dbt`.`fct_execution_transactions_by_sector_daily`\nwhere txs is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.814264Z", "completed_at": "2025-10-15T13:38:04.819195Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.819777Z", "completed_at": "2025-10-15T13:38:04.819784Z"}], "thread_id": "Thread-1", "execution_time": 0.006766557693481445, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_project_snapshots", "compiled": true, "compiled_code": "\n\nWITH wd AS (\n  SELECT max(date) AS max_date\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n),\nrng AS (\n  SELECT '1D'  AS window,  1  AS days UNION ALL\n  SELECT '7D'  AS window,  7  AS days UNION ALL\n  SELECT '30D' AS window,  30 AS days UNION ALL\n  SELECT '90D' AS window,  90 AS days\n),\nbounds AS (\n  SELECT\n    r.window,\n    r.days,\n    w.max_date,\n    subtractDays(w.max_date, r.days)        AS curr_start,\n    w.max_date                              AS curr_end,\n    subtractDays(w.max_date, 2 * r.days)    AS prev_start,\n    subtractDays(w.max_date, r.days)        AS prev_end\n  FROM rng r\n  CROSS JOIN wd w\n),\n\ncurr_win AS (\n  SELECT\n    b.window,\n    d.project,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.curr_start\n   AND d.date <= b.curr_end\n  GROUP BY b.window, d.project\n),\nprev_win AS (\n  SELECT\n    b.window,\n    d.project,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.prev_start\n   AND d.date <= b.prev_end\n  GROUP BY b.window, d.project\n),\n\n/* all-time from AMT */\ncurr_all AS (\n  SELECT\n    'All' AS window,\n    a.project,\n    sumMerge(a.txs_state)             AS txs,\n    sumMerge(a.fee_state)             AS fee_native,\n    groupBitmapMerge(a.aa_state)      AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_alltime_state` a\n  GROUP BY a.project\n),\n\njoined AS (\n  SELECT\n    c.window,\n    c.project,\n    c.txs        AS txs_curr,\n    p.txs        AS txs_prev,\n    c.fee_native AS fee_curr,\n    p.fee_native AS fee_prev,\n    c.aa_uniques AS aa_curr,\n    p.aa_uniques AS aa_prev\n  FROM curr_win c\n  LEFT JOIN prev_win p\n    ON p.window = c.window AND p.project = c.project\n),\n\nall_windows AS (\n  SELECT window, project, txs, fee_native, aa_uniques FROM curr_win\n  UNION ALL\n  SELECT window, project, txs, fee_native, aa_uniques FROM curr_all\n)\n\nSELECT\n  'Transactions'            AS label,\n  w.window                  AS window,\n  w.project                 AS bucket,\n  toFloat64(w.txs)          AS value,\n  multiIf(\n    w.window = 'All', NULL,\n    round((coalesce(j.txs_curr / nullIf(j.txs_prev, 0), 0) - 1) * 100, 1)\n  )                         AS change_pct\nFROM all_windows w\nLEFT JOIN joined j\n  ON j.window = w.window AND j.project = w.project\n\nUNION ALL\nSELECT\n  'FeesNative',\n  w.window,\n  w.project,\n  round(toFloat64(w.fee_native), 6),\n  multiIf(\n    w.window = 'All', NULL,\n    round((coalesce(j.fee_curr / nullIf(j.fee_prev, 0), 0) - 1) * 100, 1)\n  )\nFROM all_windows w\nLEFT JOIN joined j\n  ON j.window = w.window AND j.project = w.project\n\nUNION ALL\nSELECT\n  'ActiveAccounts',\n  w.window,\n  w.project,\n  toFloat64(w.aa_uniques),\n  multiIf(\n    w.window = 'All', NULL,\n    round((coalesce(j.aa_curr / nullIf(j.aa_prev, 0), 0) - 1) * 100, 1)\n  )\nFROM all_windows w\nLEFT JOIN joined j\n  ON j.window = w.window AND j.project = w.project", "relation_name": "`dbt`.`fct_execution_transactions_by_project_snapshots`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.822690Z", "completed_at": "2025-10-15T13:38:04.827633Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.828203Z", "completed_at": "2025-10-15T13:38:04.828211Z"}], "thread_id": "Thread-1", "execution_time": 0.007046937942504883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_snapshots", "compiled": true, "compiled_code": "\n\nWITH wd AS (\n  SELECT max(date) AS max_date\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n),\nrng AS (\n  SELECT '1D'  AS window,  1  AS days UNION ALL\n  SELECT '7D'  AS window,  7  AS days UNION ALL\n  SELECT '30D' AS window,  30 AS days UNION ALL\n  SELECT '90D' AS window,  90 AS days\n),\nbounds AS (\n  SELECT\n    r.window,\n    r.days,\n    w.max_date,\n    subtractDays(w.max_date, r.days)        AS curr_start,\n    w.max_date                              AS curr_end,\n    subtractDays(w.max_date, 2 * r.days)    AS prev_start,\n    subtractDays(w.max_date, r.days)        AS prev_end\n  FROM rng r\n  CROSS JOIN wd w\n),\n\ncurr_win AS (\n  SELECT\n    b.window,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.curr_start\n   AND d.date <= b.curr_end\n  GROUP BY b.window\n),\nprev_win AS (\n  SELECT\n    b.window,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.prev_start\n   AND d.date <= b.prev_end\n  GROUP BY b.window\n),\n\ncurr_all AS (\n  SELECT\n    'All' AS window,\n    sumMerge(a.txs_state)           AS txs,\n    sumMerge(a.fee_state)           AS fee_native,\n    groupBitmapMerge(a.aa_state)    AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_alltime_state` a\n),\n\ncurr AS (\n  SELECT * FROM curr_win\n  UNION ALL\n  SELECT * FROM curr_all\n)\n\nSELECT\n  'Transactions'            AS label,\n  c.window                  AS window,\n  toFloat64(c.txs)          AS value,\n  CASE\n    WHEN c.window = 'All' THEN NULL\n    ELSE round((coalesce(c.txs / nullIf(p.txs, 0), 0) - 1) * 100, 1)\n  END AS change_pct\nFROM curr c\nLEFT JOIN prev_win p ON p.window = c.window\n\nUNION ALL\nSELECT\n  'FeesNative',\n  c.window,\n  round(toFloat64(c.fee_native), 6),\n  CASE\n    WHEN c.window = 'All' THEN NULL\n    ELSE round((coalesce(c.fee_native / nullIf(p.fee_native, 0), 0) - 1) * 100, 1)\n  END\nFROM curr c\nLEFT JOIN prev_win p ON p.window = c.window\n\nUNION ALL\nSELECT\n  'ActiveAccounts',\n  c.window,\n  toFloat64(c.aa_uniques),\n  CASE\n    WHEN c.window = 'All' THEN NULL\n    ELSE round((coalesce(c.aa_uniques / nullIf(p.aa_uniques, 0), 0) - 1) * 100, 1)\n  END\nFROM curr c\nLEFT JOIN prev_win p ON p.window = c.window", "relation_name": "`dbt`.`fct_execution_transactions_snapshots`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.830860Z", "completed_at": "2025-10-15T13:38:04.837303Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.837883Z", "completed_at": "2025-10-15T13:38:04.837891Z"}], "thread_id": "Thread-1", "execution_time": 0.008311271667480469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_by_project_alltime_state_month.89db02a301", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect month\nfrom `dbt`.`int_execution_transactions_by_project_alltime_state`\nwhere month is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.840619Z", "completed_at": "2025-10-15T13:38:04.845265Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.845821Z", "completed_at": "2025-10-15T13:38:04.845828Z"}], "thread_id": "Thread-1", "execution_time": 0.006537199020385742, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_int_execution_transactions_by_project_alltime_state_project.5dd2512fcd", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect project\nfrom `dbt`.`int_execution_transactions_by_project_alltime_state`\nwhere project is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.848497Z", "completed_at": "2025-10-15T13:38:04.853192Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.853785Z", "completed_at": "2025-10-15T13:38:04.853792Z"}], "thread_id": "Thread-1", "execution_time": 0.00659632682800293, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_sector_hourly_date.e77654a051", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_active_accounts_by_sector_hourly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.856460Z", "completed_at": "2025-10-15T13:38:04.861144Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.861740Z", "completed_at": "2025-10-15T13:38:04.861748Z"}], "thread_id": "Thread-1", "execution_time": 0.006588459014892578, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_sector_hourly_label.7f2d083570", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect label\nfrom `dbt`.`api_execution_transactions_active_accounts_by_sector_hourly`\nwhere label is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.864426Z", "completed_at": "2025-10-15T13:38:04.869138Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.869757Z", "completed_at": "2025-10-15T13:38:04.869765Z"}], "thread_id": "Thread-1", "execution_time": 0.006645679473876953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_sector_hourly_value.4aa505dc36", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect value\nfrom `dbt`.`api_execution_transactions_active_accounts_by_sector_hourly`\nwhere value is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.872609Z", "completed_at": "2025-10-15T13:38:04.878392Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.878944Z", "completed_at": "2025-10-15T13:38:04.878951Z"}], "thread_id": "Thread-1", "execution_time": 0.0076940059661865234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_sector_hourly_date.d5137ceba4", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_by_sector_hourly`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.881630Z", "completed_at": "2025-10-15T13:38:04.886107Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.886699Z", "completed_at": "2025-10-15T13:38:04.886707Z"}], "thread_id": "Thread-1", "execution_time": 0.006372690200805664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_sector_hourly_label.ccee33f0c2", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect label\nfrom `dbt`.`api_execution_transactions_by_sector_hourly`\nwhere label is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.889399Z", "completed_at": "2025-10-15T13:38:04.893871Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.894460Z", "completed_at": "2025-10-15T13:38:04.894468Z"}], "thread_id": "Thread-1", "execution_time": 0.006395101547241211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_sector_hourly_value.e817ca373a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect value\nfrom `dbt`.`api_execution_transactions_by_sector_hourly`\nwhere value is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.897143Z", "completed_at": "2025-10-15T13:38:04.905965Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.906544Z", "completed_at": "2025-10-15T13:38:04.906551Z"}], "thread_id": "Thread-1", "execution_time": 0.010727405548095703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_esg_carbon_footprint_uncertainty", "compiled": true, "compiled_code": "\n\nWITH node_country_distribution AS (\n    -- Get node distribution by country and category with their carbon intensities\n    SELECT\n        date,\n        node_category,\n        country_code,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        carbon_intensity_gco2_kwh,\n        daily_energy_kwh_mean,\n        avg_power_watts_per_node,\n        power_std_dev_per_node,\n        daily_co2_kg_mean,\n        daily_co2_kg_std\n    FROM `dbt`.`int_esg_dynamic_power_consumption`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`)\n    \n),\n\n-- Calculate network effective CIF from geographic distribution\nnetwork_effective_cif AS (\n    SELECT\n        date,\n        -- Network Effective CIF = \u03a3(nodes_in_country \u00d7 country_CIF) / total_nodes\n        SUM(estimated_total_nodes * carbon_intensity_gco2_kwh) / \n        NULLIF(SUM(estimated_total_nodes), 0) AS network_weighted_cif,\n        \n        -- Weighted standard deviation of network CIF\n        -- Using variance formula: Var = \u03a3(w_i * (x_i - mean)\u00b2) / \u03a3(w_i)\n        -- Then std = sqrt(var)\n        SQRT(\n            SUM(estimated_total_nodes * pow(carbon_intensity_gco2_kwh, 2)) / NULLIF(SUM(estimated_total_nodes), 0) -\n            pow(SUM(estimated_total_nodes * carbon_intensity_gco2_kwh) / NULLIF(SUM(estimated_total_nodes), 0), 2)\n        ) AS network_cif_std\n    FROM node_country_distribution\n    GROUP BY date\n),\n\ndaily_power_data AS (\n    -- Aggregate power consumption across all categories and countries\n    SELECT\n        date,\n        node_category,\n        \n        -- Node counts with uncertainty\n        SUM(estimated_total_nodes) AS category_nodes,\n        SUM(nodes_lower_95) AS category_nodes_lower_95,\n        SUM(nodes_upper_95) AS category_nodes_upper_95,\n        \n        -- Energy totals with uncertainty calculation\n        SUM(daily_energy_kwh_mean) AS category_energy_kwh_mean,\n        \n        -- Energy standard deviation (propagate uncertainty from power and node count)\n        SQRT(SUM(\n            pow(power_std_dev_per_node * estimated_total_nodes * 24 / 1000.0, 2) + \n            pow(avg_power_watts_per_node * (nodes_upper_95 - nodes_lower_95) / 3.92 * 24 / 1000.0, 2)\n        )) AS category_energy_kwh_std,\n        \n        -- Carbon totals\n        SUM(daily_co2_kg_mean) AS category_co2_kg,\n        SQRT(SUM(pow(daily_co2_kg_std, 2))) AS category_co2_kg_std,\n        \n        -- Weighted averages\n        SUM(daily_energy_kwh_mean * estimated_total_nodes) / NULLIF(SUM(estimated_total_nodes), 0) AS weighted_avg_energy_per_node,\n        SUM(daily_co2_kg_mean * estimated_total_nodes) / NULLIF(SUM(estimated_total_nodes), 0) AS weighted_avg_co2_per_node,\n        \n        -- Country count for this category\n        COUNT(DISTINCT country_code) AS countries_represented\n        \n    FROM node_country_distribution\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`)\n    \n    GROUP BY date, node_category\n),\n\nnetwork_totals AS (\n    -- Calculate network-wide totals with full uncertainty propagation\n    SELECT\n        date,\n        \n        -- Total network size with bounds\n        SUM(category_nodes) AS total_estimated_nodes,\n        SUM(category_nodes_lower_95) AS total_nodes_lower_95,\n        SUM(category_nodes_upper_95) AS total_nodes_upper_95,\n        \n        -- Total energy consumption with uncertainty\n        SUM(category_energy_kwh_mean) AS total_energy_kwh_mean,\n        SQRT(SUM(pow(category_energy_kwh_std, 2))) AS total_energy_kwh_std,\n        \n        -- Total emissions with error propagation\n        SUM(category_co2_kg) AS total_co2_kg_mean,\n        SQRT(SUM(pow(category_co2_kg_std, 2))) AS total_co2_kg_std,\n        \n        -- Category breakdown for energy\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_energy_kwh_mean ELSE 0 END) AS home_staker_energy_kwh,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_energy_kwh_mean ELSE 0 END) AS professional_energy_kwh,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_energy_kwh_mean ELSE 0 END) AS cloud_energy_kwh,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_energy_kwh_mean ELSE 0 END) AS unknown_energy_kwh,\n        \n        -- Category breakdown for carbon\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_co2_kg ELSE 0 END) AS home_staker_co2_kg,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_co2_kg ELSE 0 END) AS professional_co2_kg,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_co2_kg ELSE 0 END) AS cloud_co2_kg,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_co2_kg ELSE 0 END) AS unknown_co2_kg,\n        \n        -- Node breakdown\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_nodes ELSE 0 END) AS home_staker_nodes,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_nodes ELSE 0 END) AS professional_nodes,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_nodes ELSE 0 END) AS cloud_nodes,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_nodes ELSE 0 END) AS unknown_nodes,\n        \n        -- Quality metrics\n        COUNT(DISTINCT CASE WHEN category_nodes > 0 THEN node_category END) AS active_categories,\n        MAX(countries_represented) AS max_countries_in_category\n        \n    FROM daily_power_data\n    GROUP BY date\n),\n\n-- Add Chao-1 population estimates for comparison\nchao1_comparison AS (\n    SELECT\n        nt.date AS date,\n        nt.*,\n        necif.network_weighted_cif,\n        necif.network_cif_std,\n        \n        -- Link to Chao-1 estimates\n        c.observed_successful_nodes AS chao1_observed,\n        c.enhanced_total_reachable AS chao1_estimated,\n        c.connection_success_rate_pct AS chao1_success_rate,\n        c.reachable_discovery_coverage_pct AS chao1_coverage,\n        \n        -- Compare our estimates to Chao-1\n        round(100.0 * nt.total_estimated_nodes / NULLIF(c.enhanced_total_reachable, 0), 1) AS node_estimate_vs_chao1_pct,\n        \n        -- Calculate scaling factor applied\n        round(toFloat64(nt.total_estimated_nodes) / NULLIF(c.observed_successful_nodes, 0), 2) AS applied_scaling_factor\n        \n    FROM network_totals nt\n    JOIN network_effective_cif necif ON nt.date = necif.date\n    LEFT JOIN `dbt`.`int_esg_node_population_chao1` c\n        ON c.observation_date = nt.date\n),\n\nenhanced_statistics AS (\n    SELECT\n        date,\n        \n        -- Node population metrics with bounds\n        total_estimated_nodes,\n        total_nodes_lower_95,\n        total_nodes_upper_95,\n        chao1_observed,\n        chao1_estimated,\n        chao1_success_rate,\n        chao1_coverage,\n        node_estimate_vs_chao1_pct,\n        applied_scaling_factor,\n        \n        -- Network carbon intensity with uncertainty\n        round(network_weighted_cif, 2) AS network_carbon_intensity_gco2_kwh,\n        round(network_cif_std, 2) AS network_carbon_intensity_std,\n        \n        -- Daily energy metrics with full uncertainty bands\n        round(total_energy_kwh_mean, 2) AS daily_energy_kwh_mean,\n        round(total_energy_kwh_std, 2) AS daily_energy_kwh_std,\n        \n        -- Daily energy confidence intervals (95%)\n        round(greatest(0, total_energy_kwh_mean - 1.96 * total_energy_kwh_std), 2) AS daily_energy_kwh_lower_95,\n        round(total_energy_kwh_mean + 1.96 * total_energy_kwh_std, 2) AS daily_energy_kwh_upper_95,\n        \n        -- Daily energy confidence intervals (90%)\n        round(greatest(0, total_energy_kwh_mean - 1.645 * total_energy_kwh_std), 2) AS daily_energy_kwh_lower_90,\n        round(total_energy_kwh_mean + 1.645 * total_energy_kwh_std, 2) AS daily_energy_kwh_upper_90,\n        \n        -- Annual energy projections with uncertainty\n        round(total_energy_kwh_mean * 365 / 1000, 2) AS annual_energy_mwh_mean,\n        round(total_energy_kwh_std * sqrt(365) / 1000, 2) AS annual_energy_mwh_std,\n        \n        -- Annual energy confidence intervals (95%)\n        round(greatest(0, (total_energy_kwh_mean * 365 / 1000) - 1.96 * (total_energy_kwh_std * sqrt(365) / 1000)), 2) AS annual_energy_mwh_lower_95,\n        round((total_energy_kwh_mean * 365 / 1000) + 1.96 * (total_energy_kwh_std * sqrt(365) / 1000), 2) AS annual_energy_mwh_upper_95,\n        \n        -- Annual energy confidence intervals (90%)\n        round(greatest(0, (total_energy_kwh_mean * 365 / 1000) - 1.645 * (total_energy_kwh_std * sqrt(365) / 1000)), 2) AS annual_energy_mwh_lower_90,\n        round((total_energy_kwh_mean * 365 / 1000) + 1.645 * (total_energy_kwh_std * sqrt(365) / 1000), 2) AS annual_energy_mwh_upper_90,\n        \n        -- Carbon emissions (primary metrics)\n        round(total_co2_kg_mean, 2) AS daily_co2_kg_mean,\n        round(total_co2_kg_std, 2) AS daily_co2_kg_std,\n        \n        -- Daily CO2 confidence intervals (95%)\n        round(greatest(0, total_co2_kg_mean - 1.96 * total_co2_kg_std), 2) AS daily_co2_kg_lower_95,\n        round(total_co2_kg_mean + 1.96 * total_co2_kg_std, 2) AS daily_co2_kg_upper_95,\n        \n        -- Daily CO2 confidence intervals (90%)\n        round(greatest(0, total_co2_kg_mean - 1.645 * total_co2_kg_std), 2) AS daily_co2_kg_lower_90,\n        round(total_co2_kg_mean + 1.645 * total_co2_kg_std, 2) AS daily_co2_kg_upper_90,\n        \n        -- Annual CO2 projections\n        round(total_co2_kg_mean * 365 / 1000, 2) AS annual_co2_tonnes_mean,\n        round(total_co2_kg_std * sqrt(365) / 1000, 2) AS annual_co2_tonnes_std,\n        \n        -- Category breakdowns for energy\n        round(home_staker_energy_kwh, 2) AS home_staker_energy_kwh_daily,\n        round(professional_energy_kwh, 2) AS professional_energy_kwh_daily,\n        round(cloud_energy_kwh, 2) AS cloud_energy_kwh_daily,\n        round(unknown_energy_kwh, 2) AS unknown_energy_kwh_daily,\n        \n        -- Category breakdowns for carbon\n        round(home_staker_co2_kg, 2) AS home_staker_co2_kg_daily,\n        round(professional_co2_kg, 2) AS professional_co2_kg_daily,\n        round(cloud_co2_kg, 2) AS cloud_co2_kg_daily,\n        round(unknown_co2_kg, 2) AS unknown_co2_kg_daily,\n        \n        -- Category percentages\n        round(100.0 * home_staker_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS home_staker_pct,\n        round(100.0 * professional_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS professional_pct,\n        round(100.0 * cloud_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS cloud_pct,\n        \n        -- Node distribution\n        home_staker_nodes,\n        professional_nodes,\n        cloud_nodes,\n        unknown_nodes,\n        \n        -- Relative uncertainties\n        round(100.0 * total_energy_kwh_std / NULLIF(total_energy_kwh_mean, 0), 1) AS energy_relative_uncertainty_pct,\n        round(100.0 * total_co2_kg_std / NULLIF(total_co2_kg_mean, 0), 1) AS carbon_relative_uncertainty_pct,\n        \n        -- Quality metrics\n        active_categories,\n        max_countries_in_category AS countries_with_nodes\n        \n    FROM chao1_comparison\n)\n\nSELECT\n    date,\n    \n    -- PRIMARY CARBON FOOTPRINT METRICS WITH BANDS\n    daily_co2_kg_mean,\n    daily_co2_kg_std,\n    daily_co2_kg_lower_95,\n    daily_co2_kg_upper_95,\n    daily_co2_kg_lower_90,\n    daily_co2_kg_upper_90,\n    \n    -- Annual CO2 projections with uncertainty bands\n    annual_co2_tonnes_mean AS annual_co2_tonnes_projected,\n    annual_co2_tonnes_std,\n    round(greatest(0, annual_co2_tonnes_mean - 1.96 * annual_co2_tonnes_std), 2) AS annual_co2_tonnes_lower_95,\n    round(annual_co2_tonnes_mean + 1.96 * annual_co2_tonnes_std, 2) AS annual_co2_tonnes_upper_95,\n    round(greatest(0, annual_co2_tonnes_mean - 1.645 * annual_co2_tonnes_std), 2) AS annual_co2_tonnes_lower_90,\n    round(annual_co2_tonnes_mean + 1.645 * annual_co2_tonnes_std, 2) AS annual_co2_tonnes_upper_90,\n    \n    -- PRIMARY ENERGY METRICS WITH BANDS\n    daily_energy_kwh_mean AS daily_energy_kwh_total,\n    daily_energy_kwh_std,\n    daily_energy_kwh_lower_95,\n    daily_energy_kwh_upper_95,\n    daily_energy_kwh_lower_90,\n    daily_energy_kwh_upper_90,\n    \n    -- Annual energy projections with uncertainty bands\n    annual_energy_mwh_mean AS annual_energy_Mwh_projected,\n    annual_energy_mwh_std,\n    annual_energy_mwh_lower_95,\n    annual_energy_mwh_upper_95,\n    annual_energy_mwh_lower_90,\n    annual_energy_mwh_upper_90,\n    \n    -- NETWORK CARBON INTENSITY WITH UNCERTAINTY\n    network_carbon_intensity_gco2_kwh AS effective_carbon_intensity,\n    network_carbon_intensity_std AS effective_carbon_intensity_std,\n    round(greatest(0, network_carbon_intensity_gco2_kwh - 1.96 * network_carbon_intensity_std), 2) AS effective_carbon_intensity_lower_95,\n    round(network_carbon_intensity_gco2_kwh + 1.96 * network_carbon_intensity_std, 2) AS effective_carbon_intensity_upper_95,\n    \n    -- NODE POPULATION WITH BOUNDS\n    total_estimated_nodes AS estimated_nodes,\n    total_nodes_lower_95 AS nodes_lower_95,\n    total_nodes_upper_95 AS nodes_upper_95,\n    \n    -- Category breakdown for energy (daily)\n    home_staker_energy_kwh_daily,\n    professional_energy_kwh_daily,\n    cloud_energy_kwh_daily,\n    unknown_energy_kwh_daily,\n    \n    -- Category breakdown for emissions (daily)\n    home_staker_co2_kg_daily,\n    professional_co2_kg_daily,\n    cloud_co2_kg_daily,\n    unknown_co2_kg_daily,\n    \n    -- Category percentages\n    home_staker_pct,\n    professional_pct,\n    cloud_pct,\n    \n    -- Node distribution by category\n    home_staker_nodes,\n    professional_nodes,\n    cloud_nodes,\n    unknown_nodes,\n    \n    -- UNCERTAINTY METRICS\n    energy_relative_uncertainty_pct,\n    carbon_relative_uncertainty_pct,\n    \n    -- Quality metrics\n    active_categories AS node_categories_active,\n    countries_with_nodes,\n    \n    -- Comparison with Chao-1 estimates\n    chao1_observed AS baseline_observed_nodes,\n    chao1_estimated AS chao1_total_estimated,\n    node_estimate_vs_chao1_pct,\n    applied_scaling_factor,\n    round(chao1_success_rate, 1) AS network_reachability_pct,\n    round(chao1_coverage, 1) AS discovery_completeness_pct,\n    \n    -- PER-NODE METRICS WITH BOUNDS\n    round(daily_co2_kg_mean / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS grams_co2_per_node_daily,\n    round(daily_energy_kwh_mean / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS wh_per_node_daily,\n    \n    -- Per-node uncertainty bands\n    round(greatest(0, (daily_co2_kg_mean - 1.96 * daily_co2_kg_std) / NULLIF(total_estimated_nodes, 0) * 1000), 1) AS grams_co2_per_node_lower_95,\n    round((daily_co2_kg_mean + 1.96 * daily_co2_kg_std) / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS grams_co2_per_node_upper_95,\n    \n    round(greatest(0, (daily_energy_kwh_mean - 1.96 * daily_energy_kwh_std) / NULLIF(total_estimated_nodes, 0) * 1000), 1) AS wh_per_node_lower_95,\n    round((daily_energy_kwh_mean + 1.96 * daily_energy_kwh_std) / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS wh_per_node_upper_95\n    \nFROM enhanced_statistics\nORDER BY date DESC", "relation_name": "`dbt`.`fct_esg_carbon_footprint_uncertainty`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.909297Z", "completed_at": "2025-10-15T13:38:04.913300Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.913880Z", "completed_at": "2025-10-15T13:38:04.913888Z"}], "thread_id": "Thread-1", "execution_time": 0.006066322326660156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_active_ongoing_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'active_ongoing'", "relation_name": "`dbt`.`api_consensus_info_active_ongoing_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.916661Z", "completed_at": "2025-10-15T13:38:04.920494Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.921058Z", "completed_at": "2025-10-15T13:38:04.921065Z"}], "thread_id": "Thread-1", "execution_time": 0.005699634552001953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_apy_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'APY7D'", "relation_name": "`dbt`.`api_consensus_info_apy_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.923778Z", "completed_at": "2025-10-15T13:38:04.928900Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.929483Z", "completed_at": "2025-10-15T13:38:04.929490Z"}], "thread_id": "Thread-1", "execution_time": 0.007036447525024414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_deposits_cnt_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'deposits_cnt'", "relation_name": "`dbt`.`api_consensus_info_deposits_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.932144Z", "completed_at": "2025-10-15T13:38:04.935879Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.936458Z", "completed_at": "2025-10-15T13:38:04.936465Z"}], "thread_id": "Thread-1", "execution_time": 0.005568981170654297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_staked_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    toUInt32(value) AS value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'Staked'", "relation_name": "`dbt`.`api_consensus_info_staked_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.939122Z", "completed_at": "2025-10-15T13:38:04.942946Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.943523Z", "completed_at": "2025-10-15T13:38:04.943531Z"}], "thread_id": "Thread-1", "execution_time": 0.005648374557495117, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_withdrawls_cnt_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'withdrawls_cnt'", "relation_name": "`dbt`.`api_consensus_info_withdrawls_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.946176Z", "completed_at": "2025-10-15T13:38:04.950889Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.951487Z", "completed_at": "2025-10-15T13:38:04.951495Z"}], "thread_id": "Thread-1", "execution_time": 0.0066070556640625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_project_monthly_top5_date.52939ba037", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_active_accounts_by_project_monthly_top5`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.954162Z", "completed_at": "2025-10-15T13:38:04.958832Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.959404Z", "completed_at": "2025-10-15T13:38:04.959412Z"}], "thread_id": "Thread-1", "execution_time": 0.006557464599609375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_project_monthly_top5_label.25162cce36", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect label\nfrom `dbt`.`api_execution_transactions_active_accounts_by_project_monthly_top5`\nwhere label is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.962053Z", "completed_at": "2025-10-15T13:38:04.966786Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.967381Z", "completed_at": "2025-10-15T13:38:04.967388Z"}], "thread_id": "Thread-1", "execution_time": 0.006628513336181641, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_active_accounts_by_project_monthly_top5_value.f4b4dece42", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect value\nfrom `dbt`.`api_execution_transactions_active_accounts_by_project_monthly_top5`\nwhere value is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.970048Z", "completed_at": "2025-10-15T13:38:04.976202Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.976779Z", "completed_at": "2025-10-15T13:38:04.976787Z"}], "thread_id": "Thread-1", "execution_time": 0.00803828239440918, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_fees_native_by_project_monthly_top5_date.32ac91a2c0", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_fees_native_by_project_monthly_top5`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.979475Z", "completed_at": "2025-10-15T13:38:04.984150Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.984746Z", "completed_at": "2025-10-15T13:38:04.984753Z"}], "thread_id": "Thread-1", "execution_time": 0.0065805912017822266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_fees_native_by_project_monthly_top5_label.c774ef9c4a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect label\nfrom `dbt`.`api_execution_transactions_fees_native_by_project_monthly_top5`\nwhere label is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.987460Z", "completed_at": "2025-10-15T13:38:04.992050Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:04.992640Z", "completed_at": "2025-10-15T13:38:04.992648Z"}], "thread_id": "Thread-1", "execution_time": 0.0065462589263916016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_fees_native_by_project_monthly_top5_value.618a58b73e", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect value\nfrom `dbt`.`api_execution_transactions_fees_native_by_project_monthly_top5`\nwhere value is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:04.995345Z", "completed_at": "2025-10-15T13:38:05.000036Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.000607Z", "completed_at": "2025-10-15T13:38:05.000615Z"}], "thread_id": "Thread-1", "execution_time": 0.006632089614868164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_sector_daily_date.7d6d9bbca5", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect date\nfrom `dbt`.`api_execution_transactions_by_sector_daily`\nwhere date is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.003286Z", "completed_at": "2025-10-15T13:38:05.007707Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.008298Z", "completed_at": "2025-10-15T13:38:05.008306Z"}], "thread_id": "Thread-1", "execution_time": 0.006332874298095703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_sector_daily_label.8ad1b1eb25", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect label\nfrom `dbt`.`api_execution_transactions_by_sector_daily`\nwhere label is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.010951Z", "completed_at": "2025-10-15T13:38:05.016635Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.017184Z", "completed_at": "2025-10-15T13:38:05.017191Z"}], "thread_id": "Thread-1", "execution_time": 0.007538795471191406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.gnosis_dbt.not_null_api_execution_transactions_by_sector_daily_value.70d25812b1", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect value\nfrom `dbt`.`api_execution_transactions_by_sector_daily`\nwhere value is null\n\n\n", "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.019875Z", "completed_at": "2025-10-15T13:38:05.023636Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.024195Z", "completed_at": "2025-10-15T13:38:05.024202Z"}], "thread_id": "Thread-1", "execution_time": 0.0055925846099853516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_project_7d", "compiled": true, "compiled_code": "\nSELECT t.bucket AS label, t.value, t.change_pct\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'ActiveAccounts' AND t.window = '7D'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_project_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.026910Z", "completed_at": "2025-10-15T13:38:05.030714Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.031290Z", "completed_at": "2025-10-15T13:38:05.031298Z"}], "thread_id": "Thread-1", "execution_time": 0.005696535110473633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_project_total", "compiled": true, "compiled_code": "\nSELECT bucket AS label, value, change_pct\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` t\nWHERE t.label = 'ActiveAccounts' AND window = 'All'\nORDER BY value DESC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_project_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.033914Z", "completed_at": "2025-10-15T13:38:05.037629Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.038183Z", "completed_at": "2025-10-15T13:38:05.038190Z"}], "thread_id": "Thread-1", "execution_time": 0.005515098571777344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_project_7d", "compiled": true, "compiled_code": "\nSELECT t.bucket AS label, t.value, t.change_pct\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'Transactions' AND t.window = '7D'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_by_project_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.040872Z", "completed_at": "2025-10-15T13:38:05.044697Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.045270Z", "completed_at": "2025-10-15T13:38:05.045277Z"}], "thread_id": "Thread-1", "execution_time": 0.005709171295166016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_project_total", "compiled": true, "compiled_code": "\nSELECT t.bucket AS label, t.value, t.change_pct\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'Transactions' AND t.window = 'All'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_by_project_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.047964Z", "completed_at": "2025-10-15T13:38:05.051761Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.052339Z", "completed_at": "2025-10-15T13:38:05.052346Z"}], "thread_id": "Thread-1", "execution_time": 0.005709648132324219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_project_7d", "compiled": true, "compiled_code": "\nSELECT t.bucket AS label, t.value, t.change_pct\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'FeesNative' AND t.window = '7D'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_project_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.055011Z", "completed_at": "2025-10-15T13:38:05.060069Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.060652Z", "completed_at": "2025-10-15T13:38:05.060659Z"}], "thread_id": "Thread-1", "execution_time": 0.0069501399993896484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_project_total", "compiled": true, "compiled_code": "\nSELECT t.bucket AS label, t.value, t.change_pct\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'FeesNative' AND t.window = 'All'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_project_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.063359Z", "completed_at": "2025-10-15T13:38:05.067160Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.067757Z", "completed_at": "2025-10-15T13:38:05.067764Z"}], "thread_id": "Thread-1", "execution_time": 0.005750179290771484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_7d", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'Transactions' AND window = '7D'", "relation_name": "`dbt`.`api_execution_transactions_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.070431Z", "completed_at": "2025-10-15T13:38:05.074261Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.074836Z", "completed_at": "2025-10-15T13:38:05.074844Z"}], "thread_id": "Thread-1", "execution_time": 0.0057141780853271484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_7d", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'ActiveAccounts' AND window = '7D'", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.077495Z", "completed_at": "2025-10-15T13:38:05.081219Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.081795Z", "completed_at": "2025-10-15T13:38:05.081802Z"}], "thread_id": "Thread-1", "execution_time": 0.0055315494537353516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_total", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'ActiveAccounts' AND window = 'All'", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.084454Z", "completed_at": "2025-10-15T13:38:05.088150Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.088731Z", "completed_at": "2025-10-15T13:38:05.088738Z"}], "thread_id": "Thread-1", "execution_time": 0.005527496337890625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_7d", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'FeesNative' AND window = '7D'", "relation_name": "`dbt`.`api_execution_transactions_fees_native_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.091443Z", "completed_at": "2025-10-15T13:38:05.095191Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.095763Z", "completed_at": "2025-10-15T13:38:05.095771Z"}], "thread_id": "Thread-1", "execution_time": 0.005671501159667969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_total", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'FeesNative' AND window = 'All'", "relation_name": "`dbt`.`api_execution_transactions_fees_native_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.098443Z", "completed_at": "2025-10-15T13:38:05.103417Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.103972Z", "completed_at": "2025-10-15T13:38:05.103979Z"}], "thread_id": "Thread-1", "execution_time": 0.0067594051361083984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_total", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'Transactions' AND window = 'All'", "relation_name": "`dbt`.`api_execution_transactions_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.106654Z", "completed_at": "2025-10-15T13:38:05.110465Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.111026Z", "completed_at": "2025-10-15T13:38:05.111033Z"}], "thread_id": "Thread-1", "execution_time": 0.005682229995727539, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_emissions_annualised_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    annual_co2_tonnes_projected\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date DESC \nLIMIT 1", "relation_name": "`dbt`.`api_esg_carbon_emissions_annualised_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.113719Z", "completed_at": "2025-10-15T13:38:05.117595Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.118143Z", "completed_at": "2025-10-15T13:38:05.118150Z"}], "thread_id": "Thread-1", "execution_time": 0.0056803226470947266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_emissions_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    AVG(daily_co2_kg_mean) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_value,\n    AVG(daily_co2_kg_lower_90) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_90,\n    AVG(daily_co2_kg_upper_90) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_90,\n    AVG(daily_co2_kg_lower_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_95,\n    AVG(daily_co2_kg_upper_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_95\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date", "relation_name": "`dbt`.`api_esg_carbon_emissions_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.120837Z", "completed_at": "2025-10-15T13:38:05.124624Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.125176Z", "completed_at": "2025-10-15T13:38:05.125183Z"}], "thread_id": "Thread-1", "execution_time": 0.005610942840576172, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_timeseries_bands", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    daily_co2_kg_mean AS value,\n    daily_co2_kg_lower_95 AS lower_95,\n    daily_co2_kg_upper_95 AS upper_95,\n    daily_co2_kg_lower_90 AS lower_90,\n    daily_co2_kg_upper_90 AS upper_90,\n    \n    -- Moving averages for smoothing\n    AVG(daily_co2_kg_mean) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_value,\n    AVG(daily_co2_kg_lower_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_95,\n    AVG(daily_co2_kg_upper_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_95,\n    \n    -- Month-to-date statistics\n    AVG(daily_co2_kg_mean) OVER (PARTITION BY toStartOfMonth(date) ORDER BY date) AS mtd_avg,\n    SUM(daily_co2_kg_mean) OVER (PARTITION BY toStartOfMonth(date) ORDER BY date) AS mtd_total\n    \nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`", "relation_name": "`dbt`.`api_esg_carbon_timeseries_bands`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.127978Z", "completed_at": "2025-10-15T13:38:05.133092Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.133688Z", "completed_at": "2025-10-15T13:38:05.133696Z"}], "thread_id": "Thread-1", "execution_time": 0.0071032047271728516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_cif_network_vs_countries_daily", "compiled": true, "compiled_code": "\n\n\nWITH network_daily_cif AS (\n    -- Get network's daily effective carbon intensity\n    SELECT\n        date,\n        effective_carbon_intensity AS carbon_intensity,\n        'GNOSIS' AS entity_code\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE effective_carbon_intensity IS NOT NULL\n        AND effective_carbon_intensity > 0\n),\n\ncountry_monthly_cif AS (\n    -- Get all monthly country carbon intensities \n    SELECT\n        ci.country_code,\n        ci.carbon_intensity_mean AS carbon_intensity,\n        ci.month_date\n    FROM `dbt`.`int_esg_carbon_intensity_ensemble` ci\n    WHERE ci.country_code != 'WORLD'\n        AND ci.carbon_intensity_mean IS NOT NULL\n        AND ci.carbon_intensity_mean > 0\n        AND ci.country_code IN (\n            'USA',  -- United States\n            'DEU',  -- Germany  \n            'CHN',  -- China\n            'FRA',  -- France\n            'SWE',  -- Sweden \n            'AUS',  -- Australia\n            'BRA',  -- Brazil\n            'ISL'   -- Iceland\n        )\n),\n\ncountry_timeseries AS (\n    -- Join countries to dates using the correct month's CIF\n    SELECT\n        nd.date,\n        cm.carbon_intensity,\n        cm.country_code AS entity_code\n    FROM network_daily_cif nd\n    JOIN country_monthly_cif cm \n        ON cm.month_date = toStartOfMonth(nd.date)  -- Match date to its month\n),\n\n-- Combine network and country data\ncombined_data AS (\n    SELECT * FROM network_daily_cif\n    UNION ALL\n    SELECT * FROM country_timeseries\n),\n\n-- Add comparison metrics\nwith_comparisons AS (\n    SELECT\n        cd.*,\n        nd.carbon_intensity AS network_cif\n    FROM combined_data cd\n    LEFT JOIN network_daily_cif nd ON cd.date = nd.date\n)\n\nSELECT\n    date,\n    entity_code,\n    round(carbon_intensity, 1) AS carbon_intensity_gco2_kwh\nFROM with_comparisons\nORDER BY date, entity_code, carbon_intensity_gco2_kwh DESC", "relation_name": "`dbt`.`api_esg_cif_network_vs_countries_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.136577Z", "completed_at": "2025-10-15T13:38:05.141558Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.142130Z", "completed_at": "2025-10-15T13:38:05.142138Z"}], "thread_id": "Thread-1", "execution_time": 0.006888866424560547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_energy_consumption_annualised_latest", "compiled": true, "compiled_code": "\n\n\nSELECT\n    annual_energy_Mwh_projected\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nORDER BY date DESC \nLIMIT 1", "relation_name": "`dbt`.`api_esg_energy_consumption_annualised_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.144832Z", "completed_at": "2025-10-15T13:38:05.148680Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.149277Z", "completed_at": "2025-10-15T13:38:05.149291Z"}], "thread_id": "Thread-1", "execution_time": 0.005749225616455078, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_energy_monthly", "compiled": true, "compiled_code": "\n\n\nSELECT toStartOfMonth(date) AS date, SUM(daily_energy_kwh_total) AS value\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nGROUP BY 1\nORDER BY date", "relation_name": "`dbt`.`api_esg_energy_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.151962Z", "completed_at": "2025-10-15T13:38:05.155731Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.156301Z", "completed_at": "2025-10-15T13:38:05.156308Z"}], "thread_id": "Thread-1", "execution_time": 0.005663394927978516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_estimated_nodes_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT \n    date\n    ,baseline_observed_nodes\n    ,estimated_nodes\n    ,nodes_lower_95\n    ,nodes_upper_95\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date", "relation_name": "`dbt`.`api_esg_estimated_nodes_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.159003Z", "completed_at": "2025-10-15T13:38:05.163066Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.163645Z", "completed_at": "2025-10-15T13:38:05.163652Z"}], "thread_id": "Thread-1", "execution_time": 0.0059926509857177734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_info_annual_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,label\n    ,mean_val\n    ,lower_95\n    ,upper_95\n    ,lower_90\n    ,upper_90\nFROM (\n    SELECT \n        date\n        ,'Energy (MWh)' AS label\n        ,annual_energy_Mwh_projected AS mean_val\n        ,annual_energy_mwh_lower_95 AS lower_95\n        ,annual_energy_mwh_upper_95 AS upper_95\n        ,annual_energy_mwh_lower_90 AS lower_90\n        ,annual_energy_mwh_upper_90 AS upper_90\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT \n        date\n        ,'CO2e (tonnes)' AS label\n        ,annual_co2_tonnes_projected AS mean_val\n        ,annual_co2_tonnes_lower_95 AS lower_95\n        ,annual_co2_tonnes_upper_95 AS upper_95\n        ,annual_co2_tonnes_lower_90 AS lower_90\n        ,annual_co2_tonnes_upper_90 AS upper_90\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_esg_info_annual_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-15T13:38:05.166335Z", "completed_at": "2025-10-15T13:38:05.172943Z"}, {"name": "execute", "started_at": "2025-10-15T13:38:05.173536Z", "completed_at": "2025-10-15T13:38:05.173544Z"}], "thread_id": "Thread-1", "execution_time": 0.00853586196899414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_info_category_daily", "compiled": true, "compiled_code": "\n\n\n\n\nSELECT \n    date\n    ,label\n    ,category\n    ,value\nFROM (\n    SELECT date, 'Home Staker' AS label, 'CO2e (kg)' AS category, home_staker_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'CO2e (kg)' AS category, professional_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'CO2e (kg)' AS category, cloud_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'CO2e (kg)' AS category, unknown_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n\n    UNION ALL \n\n    SELECT date, 'Home Staker' AS label, 'Energy (kWh)' AS category, home_staker_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'Energy (kWh)' AS category, professional_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'Energy (kWh)' AS category, cloud_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'Energy (kWh)' AS category, unknown_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n\n    UNION ALL \n\n    SELECT date, 'Home Staker' AS label, 'Nodes' AS category, CAST(home_staker_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'Nodes' AS category, CAST(professional_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'Nodes' AS category, CAST(cloud_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'Nodes' AS category, CAST(unknown_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n)\nORDER BY date, label, category", "relation_name": "`dbt`.`api_esg_info_category_daily`", "batch_results": null}], "elapsed_time": 6.227515935897827, "args": {"introspect": true, "require_batched_execution_for_custom_microbatch_strategy": false, "log_format_file": "debug", "partial_parse": true, "compile": true, "print": true, "printer_width": 80, "project_dir": "/home/runner/work/dbt-cerebro/dbt-cerebro", "require_yaml_configuration_for_mf_time_spines": false, "log_path": "/home/runner/work/dbt-cerebro/dbt-cerebro/logs", "exclude": [], "quiet": false, "log_file_max_bytes": 10485760, "version_check": true, "skip_nodes_if_on_run_start_fails": false, "partial_parse_file_diff": true, "use_colors": true, "static_parser": true, "require_explicit_package_overrides_for_builtin_materializations": true, "vars": {}, "warn_error_options": {"include": [], "exclude": []}, "log_level_file": "debug", "which": "generate", "defer": false, "cache_selected_only": false, "macro_debugging": false, "strict_mode": false, "profiles_dir": "/home/runner/work/dbt-cerebro/dbt-cerebro", "state_modified_compare_vars": false, "source_freshness_run_project_hooks": false, "select": [], "show_resource_report": false, "invocation_command": "dbt docs generate", "use_colors_file": true, "send_anonymous_usage_stats": true, "favor_state": false, "write_json": true, "populate_cache": true, "empty_catalog": false, "require_nested_cumulative_type_params": false, "log_format": "default", "indirect_selection": "eager", "state_modified_compare_more_unrendered_values": false, "static": false, "log_level": "info", "require_resource_names_without_spaces": false}}