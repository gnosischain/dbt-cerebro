{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.4", "generated_at": "2025-10-24T12:23:14.754128Z", "invocation_id": "b3be3bc1-a37a-4339-b96a-6cbce38fcd3e", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.853416Z", "completed_at": "2025-10-24T12:23:12.863886Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.864528Z", "completed_at": "2025-10-24T12:23:12.864544Z"}], "thread_id": "Thread-1", "execution_time": 0.01239466667175293, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__attestations", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    attestation_index,\n    aggregation_bits,\n    signature,\n    attestation_slot,\n    committee_index,\n    beacon_block_root,\n    source_epoch,\n    source_root,\n    target_epoch,\n    target_root,\n    slot_timestamp\nFROM \n    `consensus`.`attestations` FINAL", "relation_name": "`dbt`.`stg_consensus__attestations`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.867372Z", "completed_at": "2025-10-24T12:23:12.871727Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.872309Z", "completed_at": "2025-10-24T12:23:12.872317Z"}], "thread_id": "Thread-1", "execution_time": 0.006277799606323242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__blob_commitments", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    commitment_index,\n    commitment,\n    slot_timestamp\nFROM \n    `consensus`.`blob_commitments` FINAL", "relation_name": "`dbt`.`stg_consensus__blob_commitments`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.875061Z", "completed_at": "2025-10-24T12:23:12.879147Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.879725Z", "completed_at": "2025-10-24T12:23:12.879733Z"}], "thread_id": "Thread-1", "execution_time": 0.0060694217681884766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__blocks", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    proposer_index,\n    parent_root,\n    state_root,\n    signature,\n    version,\n    randao_reveal,\n    graffiti,\n    eth1_deposit_root,\n    eth1_deposit_count,\n    eth1_block_hash,\n    sync_aggregate_participation,\n    withdrawals_count,\n    blob_kzg_commitments_count,\n    execution_requests_count,\n    slot_timestamp\nFROM \n    `consensus`.`blocks` FINAL", "relation_name": "`dbt`.`stg_consensus__blocks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.882446Z", "completed_at": "2025-10-24T12:23:12.886460Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.887031Z", "completed_at": "2025-10-24T12:23:12.887039Z"}], "thread_id": "Thread-1", "execution_time": 0.005957365036010742, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__deposits", "compiled": true, "compiled_code": "\n\nSELECT\n   slot,\n    deposit_index,\n    pubkey,\n    withdrawal_credentials,\n    amount,\n    signature,\n    proof,\n    slot_timestamp\nFROM \n    `consensus`.`deposits` FINAL", "relation_name": "`dbt`.`stg_consensus__deposits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.889806Z", "completed_at": "2025-10-24T12:23:12.893853Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.894439Z", "completed_at": "2025-10-24T12:23:12.894447Z"}], "thread_id": "Thread-1", "execution_time": 0.00603795051574707, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__execution_requests", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    payload,\n    deposits_count,\n    withdrawals_count,\n    consolidations_count,\n    slot_timestamp\nFROM \n    `consensus`.`execution_requests` FINAL", "relation_name": "`dbt`.`stg_consensus__execution_requests`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.897121Z", "completed_at": "2025-10-24T12:23:12.901081Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.901681Z", "completed_at": "2025-10-24T12:23:12.901689Z"}], "thread_id": "Thread-1", "execution_time": 0.005884885787963867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__rewards", "compiled": true, "compiled_code": "\n\nSELECT\n    slot\n    proposer_index,\n    total,\n    attestations,\n    sync_aggregate,\n    proposer_slashings,\n    attester_slashings,\n    slot_timestamp\nFROM \n    `consensus`.`rewards` FINAL", "relation_name": "`dbt`.`stg_consensus__rewards`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.904313Z", "completed_at": "2025-10-24T12:23:12.909086Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.909667Z", "completed_at": "2025-10-24T12:23:12.909675Z"}], "thread_id": "Thread-1", "execution_time": 0.0065953731536865234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__specs", "compiled": true, "compiled_code": "\n\nSELECT\n    parameter_name,\n    parameter_value,\nFROM \n    `consensus`.`specs` FINAL", "relation_name": "`dbt`.`stg_consensus__specs`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.912441Z", "completed_at": "2025-10-24T12:23:12.916321Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.916895Z", "completed_at": "2025-10-24T12:23:12.916902Z"}], "thread_id": "Thread-1", "execution_time": 0.005786418914794922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__time_helpers", "compiled": true, "compiled_code": "\n\nSELECT\n    genesis_time_unix,\n    seconds_per_slot,\n    slots_per_epoch\nFROM \n    `consensus`.`time_helpers` FINAL", "relation_name": "`dbt`.`stg_consensus__time_helpers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.919732Z", "completed_at": "2025-10-24T12:23:12.923629Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.924221Z", "completed_at": "2025-10-24T12:23:12.924229Z"}], "thread_id": "Thread-1", "execution_time": 0.005862712860107422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__validators", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    validator_index,\n    balance,\n    status,\n    pubkey,\n    withdrawal_credentials,\n    effective_balance,\n    slashed,\n    activation_eligibility_epoch,\n    activation_epoch,\n    exit_epoch,\n    withdrawable_epoch,\n    slot_timestamp\nFROM \n    `consensus`.`validators` FINAL", "relation_name": "`dbt`.`stg_consensus__validators`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.926851Z", "completed_at": "2025-10-24T12:23:12.930953Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.931585Z", "completed_at": "2025-10-24T12:23:12.931593Z"}], "thread_id": "Thread-1", "execution_time": 0.006012678146362305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_consensus__withdrawals", "compiled": true, "compiled_code": "\n\nSELECT\n    slot,\n    block_number,\n    block_hash,\n    withdrawal_index,\n    validator_index,\n    address,\n    amount,\n    slot_timestamp\nFROM \n    `consensus`.`withdrawals` FINAL", "relation_name": "`dbt`.`stg_consensus__withdrawals`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.934453Z", "completed_at": "2025-10-24T12:23:12.938388Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.938963Z", "completed_at": "2025-10-24T12:23:12.938971Z"}], "thread_id": "Thread-1", "execution_time": 0.005970001220703125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__country_codes", "compiled": true, "compiled_code": "\n\n\nSELECT\n    \"name\",\n    \"alpha-2\",\n    \"alpha-3\",\n    \"country-code\",\n    \"iso_3166-2\",\n    \"region\",\n    \"sub-region\",\n    \"intermediate-region\",\n    \"region-code\",\n    \"sub-region-code\",\n    \"intermediate-region-code\"\nFROM\n    `crawlers_data`.`country_codes`", "relation_name": "`dbt`.`stg_crawlers_data__country_codes`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.941567Z", "completed_at": "2025-10-24T12:23:12.945542Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.946108Z", "completed_at": "2025-10-24T12:23:12.946116Z"}], "thread_id": "Thread-1", "execution_time": 0.005788326263427734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_prices", "compiled": true, "compiled_code": "\n\nSELECT\n  toDate(block_date)                    AS date,\n  upper(symbol)                         AS symbol,\n  anyLast(toFloat64(price))             AS price   \nFROM `crawlers_data`.`dune_prices`\nGROUP BY date, symbol\nORDER BY date, symbol", "relation_name": "`dbt`.`stg_crawlers_data__dune_prices`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.948712Z", "completed_at": "2025-10-24T12:23:12.953711Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.954291Z", "completed_at": "2025-10-24T12:23:12.954299Z"}], "thread_id": "Thread-1", "execution_time": 0.006811618804931641, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__ember_electricity_data", "compiled": true, "compiled_code": "\n\n\nSELECT\n    \"Area\",\n    \"ISO 3 code\",\n    \"Date\",\n    \"Area type\",\n    \"Continent\",\n    \"Ember region\",\n    \"EU\" ,\n    \"OECD\",\n    \"G20\",\n    \"G7\",\n    \"ASEAN\",\n    \"Category\",\n    \"Subcategory\",\n    \"Variable\",\n    \"Unit\",\n    \"Value\",\n    \"YoY absolute change\",\n    \"YoY % change\" \nFROM\n    `crawlers_data`.`ember_electricity_data`", "relation_name": "`dbt`.`stg_crawlers_data__ember_electricity_data`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.956972Z", "completed_at": "2025-10-24T12:23:12.961391Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.961966Z", "completed_at": "2025-10-24T12:23:12.961973Z"}], "thread_id": "Thread-1", "execution_time": 0.006245613098144531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__ipinfo", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    ip,\n    hostname,\n    city,\n    region,\n    country,\n    loc,\n    org,\n    postal,\n    timezone,\n    asn,\n    company,\n    carrier,\n    is_bogon,\n    is_mobile,\n    multiIf(\n      lowerUTF8(org) ILIKE '%amazon web services%' OR lowerUTF8(org) ILIKE '%amazon data services%' OR lowerUTF8(org) ILIKE '%aws%' OR lowerUTF8(org) ILIKE '%amazon.com%', 'AWS',\n      (lowerUTF8(org) ILIKE '%google cloud%' OR lowerUTF8(org) ILIKE '%google llc%' OR lowerUTF8(org) ILIKE '%gcp%' OR lowerUTF8(org) ILIKE '%google%') AND lowerUTF8(org) NOT ILIKE '%fiber%', 'Google',\n      lowerUTF8(org) ILIKE '%microsoft azure%' OR lowerUTF8(org) ILIKE '%azure%' OR lowerUTF8(org) ILIKE '%microsoft corporation%' OR lowerUTF8(org) ILIKE '%msft%', 'Azure',\n      lowerUTF8(org) ILIKE '%oracle cloud%' OR lowerUTF8(org) ILIKE '%oracle america%' OR lowerUTF8(org) ILIKE '%oci%', 'Oracle Cloud',\n      lowerUTF8(org) ILIKE '%alibaba cloud%' OR lowerUTF8(org) ILIKE '%aliyun%' OR lowerUTF8(org) ILIKE '%alibaba%', 'Alibaba Cloud',\n\n      lowerUTF8(org) ILIKE '%cloudflare%', 'Cloudflare',\n      (lowerUTF8(org) ILIKE '%akamai%' AND lowerUTF8(org) NOT ILIKE '%linode%'), 'Akamai',\n      lowerUTF8(org) ILIKE '%fastly%', 'Fastly',\n\n      lowerUTF8(org) ILIKE '%digitalocean%' OR lowerUTF8(org) ILIKE '%digital ocean%', 'DigitalOcean',\n      lowerUTF8(org) ILIKE '%ovh%', 'OVHcloud',\n      lowerUTF8(org) ILIKE '%hetzner%', 'Hetzner',\n      lowerUTF8(org) ILIKE '%scaleway%' OR lowerUTF8(org) ILIKE '%online s.a.s%' OR lowerUTF8(org) ILIKE '%iliad%', 'Scaleway',\n      lowerUTF8(org) ILIKE '%linode%', 'Linode',\n      lowerUTF8(org) ILIKE '%vultr%' OR lowerUTF8(org) ILIKE '%choopa%', 'Vultr',\n      lowerUTF8(org) ILIKE '%equinix metal%' OR lowerUTF8(org) ILIKE '%packet host%' OR lowerUTF8(org) ILIKE '%packet, inc%', 'Equinix Metal',\n      lowerUTF8(org) ILIKE '%fly.io%' OR lowerUTF8(org) ILIKE '%fly io%', 'Fly.io',\n      lowerUTF8(org) ILIKE '%netlify%', 'Netlify',\n      lowerUTF8(org) ILIKE '%vercel%' OR lowerUTF8(org) ILIKE '%zeit%', 'Vercel',\n      lowerUTF8(org) ILIKE '%heroku%', 'Heroku',\n      lowerUTF8(org) ILIKE '%render.com%' OR lowerUTF8(org) ILIKE '% render %', 'Render',\n\n      -- Carrier / transit networks (keep as its own bucket; change to 'Public ISP (Home/Office)' if you prefer)\n      lowerUTF8(org) ILIKE '%cogent%' OR lowerUTF8(org) ILIKE '%lumen%' OR lowerUTF8(org) ILIKE '%level 3%' OR lowerUTF8(org) ILIKE '%centurylink%' OR\n      lowerUTF8(org) ILIKE '%telia carrier%' OR lowerUTF8(org) ILIKE '%arelion%' OR lowerUTF8(org) ILIKE '%gtt%' OR lowerUTF8(org) ILIKE '%hurricane electric%' OR\n      lowerUTF8(org) ILIKE '%he.net%' OR lowerUTF8(org) ILIKE '%ntt communications%' OR lowerUTF8(org) ILIKE '%tata communications%' OR lowerUTF8(org) ILIKE '%zayo%' OR\n      lowerUTF8(org) ILIKE '%kddi%' OR lowerUTF8(org) ILIKE '%sparkle%' OR lowerUTF8(org) ILIKE '%backbone%' OR lowerUTF8(org) ILIKE '%chinanet-backbone%', 'Carrier/Transit',\n\n      -- Education / government \u2192 treat like public access\n      lowerUTF8(org) ILIKE '%university%' OR lowerUTF8(org) ILIKE '%college%' OR lowerUTF8(org) ILIKE '%school%' OR lowerUTF8(org) ILIKE '%ministry%' OR lowerUTF8(org) ILIKE '%government%', 'Public ISP (Home/Office)',\n\n      -- Generic hosting/CDN hints\n      lowerUTF8(org) ILIKE '%datacenter%' OR lowerUTF8(org) ILIKE '%data center%' OR lowerUTF8(org) ILIKE '%colo%' OR lowerUTF8(org) ILIKE '%hosting%' OR lowerUTF8(org) ILIKE '%vps%' OR lowerUTF8(org) ILIKE '%server%' OR lowerUTF8(org) ILIKE '%incapsula%' OR lowerUTF8(org) ILIKE '%imperva%', 'Hosting/CDN (Other)',\n\n      -- Fallback for residential & office ISPs\n      lowerUTF8(org) ILIKE '%telecom%' OR lowerUTF8(org) ILIKE '%telekom%' OR lowerUTF8(org) ILIKE '%telecommunications%' OR lowerUTF8(org) ILIKE '%communications%' OR lowerUTF8(org) ILIKE '%wireless%' OR\n      lowerUTF8(org) ILIKE '%cable%' OR lowerUTF8(org) ILIKE '%broadband%' OR lowerUTF8(org) ILIKE '%internet%' OR lowerUTF8(org) ILIKE '%fibre%' OR lowerUTF8(org) ILIKE '%fiber%' OR lowerUTF8(org) ILIKE '%mobile%', 'Public ISP (Home/Office)',\n      lowerUTF8(org) = '', 'Unknown',\n      'Public ISP (Home/Office)'\n  ) AS generic_provider\n  FROM `crawlers_data`.`ipinfo` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_crawlers_data__ipinfo`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.964573Z", "completed_at": "2025-10-24T12:23:12.968461Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.969029Z", "completed_at": "2025-10-24T12:23:12.969036Z"}], "thread_id": "Thread-1", "execution_time": 0.0056726932525634766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_agent_semvers_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    agent_version_semver,\n    agent_version_semver_str,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_agent_semvers_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.971852Z", "completed_at": "2025-10-24T12:23:12.975662Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.976238Z", "completed_at": "2025-10-24T12:23:12.976246Z"}], "thread_id": "Thread-1", "execution_time": 0.005732297897338867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_cloud_provider_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    cloud_provider,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_cloud_provider_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.978905Z", "completed_at": "2025-10-24T12:23:12.982722Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.983300Z", "completed_at": "2025-10-24T12:23:12.983308Z"}], "thread_id": "Thread-1", "execution_time": 0.00563359260559082, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_countries_avg_1d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    country_name,\n    country,\n    __count,\n    __samples,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_countries_avg_1d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_countries_avg_1d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.985960Z", "completed_at": "2025-10-24T12:23:12.989865Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.990449Z", "completed_at": "2025-10-24T12:23:12.990457Z"}], "thread_id": "Thread-1", "execution_time": 0.005714893341064453, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__probelab_quic_support_over_7d", "compiled": true, "compiled_code": "\n\nSELECT\n    agent_version_type,\n    min_crawl_created_at,\n    max_crawl_created_at,\n    crawl_created_at,\n    quic_support,\n    __count,\n    __pct,\n    __total\nFROM \n    `crawlers_data`.`probelab_quic_support_over_7d`", "relation_name": "`dbt`.`stg_crawlers_data__probelab_quic_support_over_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:12.993107Z", "completed_at": "2025-10-24T12:23:12.998729Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:12.999320Z", "completed_at": "2025-10-24T12:23:12.999328Z"}], "thread_id": "Thread-1", "execution_time": 0.0074481964111328125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__blocks", "compiled": true, "compiled_code": "\n\n\nWITH\n\nsource AS (\n    SELECT \n        block_number,\n        block_hash,\n        parent_hash,\n        uncles_hash,\n        author,\n        state_root,\n        transactions_root,\n        receipts_root,\n        gas_used,\n        gas_limit,\n        extra_data,\n        size,\n        mix_hash,\n        nonce,\n        base_fee_per_gas,\n        withdrawals_root,\n        block_timestamp\n    FROM \n        `execution`.`blocks`\n    WHERE \n        block_timestamp > '1970-01-01' -- remove genesis\n)\n\nSELECT\n    block_number,\n    block_hash,\n    parent_hash,\n    uncles_hash,\n    CONCAT('0x',author) AS author,\n    state_root,\n    transactions_root,\n    receipts_root,\n    gas_used,\n    gas_limit,\n    extra_data,\n    \narrayFilter(\n    x -> x != '',\n    /* split on every \u201cnon word-ish\u201d character (dash, @, space, etc.) */\n    splitByRegexp(\n        '[^A-Za-z0-9\\\\.]+',            -- \u21fd anything that isn\u2019t a\u2013z, 0\u20139 or \u201c.\u201d\n        arrayStringConcat(\n            arrayMap(\n                i -> if(\n                    reinterpretAsUInt8(substring(unhex(coalesce(extra_data, '')), i, 1)) BETWEEN 32 AND 126,\n                    reinterpretAsString(substring(unhex(coalesce(extra_data, '')), i, 1)),\n                    ' '\n                ),\n                range(1, length(unhex(coalesce(extra_data, ''))) + 1)\n            ),\n            ''\n        )\n    )\n)\n AS decoded_extra_data,\n    size,\n    mix_hash,\n    nonce,\n    base_fee_per_gas,\n    withdrawals_root,\n    block_timestamp\nFROM source", "relation_name": "`dbt`.`stg_execution__blocks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.002012Z", "completed_at": "2025-10-24T12:23:13.005962Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.006554Z", "completed_at": "2025-10-24T12:23:13.006561Z"}], "thread_id": "Thread-1", "execution_time": 0.0057833194732666016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__storage_diffs", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n    SELECT \n        block_number,\n        transaction_index,\n        CONCAT('0x', transaction_hash) AS transaction_hash,\n        CONCAT('0x', address) AS address,\n        slot,\n        from_value,\n        to_value,\n        block_timestamp\n    FROM \n        `execution`.`storage_diffs`\n)\n\nSELECT\n    *\nFROM source", "relation_name": "`dbt`.`stg_execution__storage_diffs`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.009265Z", "completed_at": "2025-10-24T12:23:13.013310Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.013879Z", "completed_at": "2025-10-24T12:23:13.013887Z"}], "thread_id": "Thread-1", "execution_time": 0.005883216857910156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_execution__transactions", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n    SELECT\n        block_number,\n        transaction_index,\n        transaction_hash,\n        nonce,\n        from_address,\n        to_address,\n        value_string,\n        input,\n        gas_limit,\n        gas_used,\n        gas_price,\n        transaction_type,\n        max_priority_fee_per_gas,\n        max_fee_per_gas,\n        success,\n        n_input_bytes,\n        n_input_zero_bytes,\n        n_input_nonzero_bytes,\n        n_rlp_bytes,\n        r,\n        s,\n        v,\n        block_hash,\n        block_timestamp\n    FROM `execution`.`transactions` FINAL\n)\n\nSELECT\n    block_number,\n    transaction_index,\n    transaction_hash,\n    nonce,\n    CONCAT('0x',from_address) AS from_address,\n    IF(to_address IS NULL, NULL, CONCAT('0x',to_address)) AS to_address,\n    CAST(value_string AS UInt256) AS value,\n    input,\n    gas_limit,\n    gas_used,\n    gas_price,\n    transaction_type,\n    max_priority_fee_per_gas,\n    max_fee_per_gas,\n    success,\n    n_input_bytes,\n    n_input_zero_bytes,\n    n_input_nonzero_bytes,\n    n_rlp_bytes,\n    r,\n    s,\n    v,\n    block_hash,\n    block_timestamp\nFROM source", "relation_name": "`dbt`.`stg_execution__transactions`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.016719Z", "completed_at": "2025-10-24T12:23:13.020611Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.021179Z", "completed_at": "2025-10-24T12:23:13.021202Z"}], "thread_id": "Thread-1", "execution_time": 0.005837202072143555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__discovery_id_prefixes_x_peer_ids", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    discovery_id_prefix,\n    peer_id\n  FROM `nebula_discv4`.`discovery_id_prefixes_x_peer_ids` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.023793Z", "completed_at": "2025-10-24T12:23:13.027650Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.028232Z", "completed_at": "2025-10-24T12:23:13.028240Z"}], "thread_id": "Thread-1", "execution_time": 0.005716085433959961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__neighbors", "compiled": true, "compiled_code": "\n\nWITH \n\nsource AS (\n  SELECT \n    crawl_id,\n    crawl_created_at,\n    peer_discovery_id_prefix,\n    neighbor_discovery_id_prefix,\n    error_bits\n  FROM `nebula_discv4`.`neighbors` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__neighbors`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.030782Z", "completed_at": "2025-10-24T12:23:13.035774Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.036356Z", "completed_at": "2025-10-24T12:23:13.036364Z"}], "thread_id": "Thread-1", "execution_time": 0.006791591644287109, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv4__visits", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    crawl_id,\n    peer_id,\n    agent_version,\n    protocols,\n    dial_maddrs,\n    filtered_maddrs,\n    extra_maddrs,\n    dial_errors,\n    connect_maddr,\n    crawl_error,\n    visit_started_at,\n    visit_ended_at,\n    peer_properties\n  FROM `nebula_discv4`.`visits` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv4__visits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.039059Z", "completed_at": "2025-10-24T12:23:13.109204Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.109796Z", "completed_at": "2025-10-24T12:23:13.109806Z"}], "thread_id": "Thread-1", "execution_time": 0.07201647758483887, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__discovery_id_prefixes_x_peer_ids", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    discovery_id_prefix,\n    peer_id\n  FROM `nebula`.`discovery_id_prefixes_x_peer_ids` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.112561Z", "completed_at": "2025-10-24T12:23:13.116454Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.117017Z", "completed_at": "2025-10-24T12:23:13.117024Z"}], "thread_id": "Thread-1", "execution_time": 0.005812883377075195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__neighbors", "compiled": true, "compiled_code": "\n\nWITH \n\nsource AS (\n  SELECT \n    crawl_id,\n    crawl_created_at,\n    peer_discovery_id_prefix,\n    neighbor_discovery_id_prefix,\n    error_bits\n  FROM `nebula`.`neighbors` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__neighbors`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.119654Z", "completed_at": "2025-10-24T12:23:13.123587Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.124156Z", "completed_at": "2025-10-24T12:23:13.124163Z"}], "thread_id": "Thread-1", "execution_time": 0.005817890167236328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_nebula_discv5__visits", "compiled": true, "compiled_code": "\n\nWITH\n\nsource AS (\n  SELECT \n    crawl_id,\n    peer_id,\n    agent_version,\n    protocols,\n    dial_maddrs,\n    filtered_maddrs,\n    extra_maddrs,\n    dial_errors,\n    connect_maddr,\n    crawl_error,\n    visit_started_at,\n    visit_ended_at,\n    peer_properties\n  FROM `nebula`.`visits` \n)\n\nSELECT * FROM source", "relation_name": "`dbt`.`stg_nebula_discv5__visits`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.126838Z", "completed_at": "2025-10-24T12:23:13.128850Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.129465Z", "completed_at": "2025-10-24T12:23:13.129472Z"}], "thread_id": "Thread-1", "execution_time": 0.0039904117584228516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.contracts_abi", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.132303Z", "completed_at": "2025-10-24T12:23:13.134182Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.134792Z", "completed_at": "2025-10-24T12:23:13.134800Z"}], "thread_id": "Thread-1", "execution_time": 0.003815889358520508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.event_signatures", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.137536Z", "completed_at": "2025-10-24T12:23:13.139434Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.140030Z", "completed_at": "2025-10-24T12:23:13.140038Z"}], "thread_id": "Thread-1", "execution_time": 0.0037746429443359375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.function_signatures", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.144756Z", "completed_at": "2025-10-24T12:23:13.146591Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.147199Z", "completed_at": "2025-10-24T12:23:13.147207Z"}], "thread_id": "Thread-1", "execution_time": 0.003951072692871094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.gnosis_dbt.tokens_whitelist", "compiled": null, "compiled_code": null, "relation_name": null, "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.149961Z", "completed_at": "2025-10-24T12:23:13.157276Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.157853Z", "completed_at": "2025-10-24T12:23:13.157860Z"}], "thread_id": "Thread-1", "execution_time": 0.009249448776245117, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_attestations_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,slot - attestation_slot AS inclusion_delay\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__attestations`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_attestations_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_attestations_daily` AS t2\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_attestations_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.160649Z", "completed_at": "2025-10-24T12:23:13.165690Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.166275Z", "completed_at": "2025-10-24T12:23:13.166283Z"}], "thread_id": "Thread-1", "execution_time": 0.0069310665130615234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_blob_commitments_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__blob_commitments`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_blob_commitments_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_blob_commitments_daily` AS t2\n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_consensus_blob_commitments_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.168964Z", "completed_at": "2025-10-24T12:23:13.174238Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.174812Z", "completed_at": "2025-10-24T12:23:13.174820Z"}], "thread_id": "Thread-1", "execution_time": 0.007092714309692383, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_graffiti_daily", "compiled": true, "compiled_code": "\n\nWITH\n    -- Canonical lists\n    ['nethermind','erigon','geth','besu','reth'] AS el_keys,\n    ['Nethermind','Erigon','Geth','Besu','Reth'] AS el_names,\n    ['lighthouse','teku','prysm','lodestar','nimbus'] AS cl_keys,\n    ['Lighthouse','Teku','Prysm','Lodestar','Nimbus'] AS cl_names,\n\n    -- Platform/hosting brands \n    ['dappnode','avado','allnodes','twinstake','stakewise','gateway','kleros',\n     'filoozom','kpk-validators','hopr','digitalconsultantsllc',\n     'synthex'] AS brand_keys,\n    ['DappNode','Avado','Allnodes','Twinstake','StakeWise','gateway.fm','kleros.io',\n     'filoozom.eth','kpk-validators','HOPR','DigitalConsultantsLLC.xyz',\n     'Synthex'] AS brand_names,\n\n\nfinal AS (\n    SELECT\n        date\n        ,graffiti\n        ,cnt\n        -- Lowercased text to search in\n        ,lowerUTF8(graffiti) AS g\n\n        -- Detect any brand first (highest precedence)\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, brand_keys) AS brands_found\n        ,if(length(brands_found) > 0,\n            arrayElement(brand_names, indexOf(brand_keys, brands_found[1])),\n            null) AS brand_label\n\n        -- Detect EL/CL clients (order-insensitive, separator-agnostic)\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, el_keys) AS el_found\n        ,arrayFilter(x -> positionCaseInsensitive(g, x) > 0, cl_keys) AS cl_found\n\n        -- Pick the first match per side by priority order above\n        ,if(length(el_found) > 0,\n            arrayElement(el_names, indexOf(el_keys, el_found[1])),\n            null) AS el_label\n\n        ,if(length(cl_found) > 0,\n            arrayElement(cl_names, indexOf(cl_keys, cl_found[1])),\n            null) AS cl_label\n\n        -- Final label priority:\n        -- 1) Brand/platform if any\n        -- 2) EL+CL combo if both found\n        -- 3) Single client if only one side found\n        -- 4) Other\n        ,coalesce(\n            brand_label,\n            if(el_label IS NOT NULL AND cl_label IS NOT NULL, concat(el_label, '+', cl_label), null),\n            el_label,\n            cl_label,\n            if(graffiti = 'None', graffiti, null),\n            'Other'\n        ) AS label\n    FROM (\n        SELECT\n            toStartOfDay(slot_timestamp) AS date\n            ,IF(graffiti='0x0000000000000000000000000000000000000000000000000000000000000000', \n                'None', \n                unhex(right(graffiti,-2))\n            ) AS graffiti\n            ,COUNT(*) AS cnt\n        FROM `dbt`.`stg_consensus__blocks`\n        WHERE\n            slot_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_graffiti_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_graffiti_daily` AS t2\n    )\n  \n\n        GROUP BY 1, 2\n    )\n)\n\nSELECT\n    date\n    ,graffiti\n    ,label\n    ,cnt\nFROM final", "relation_name": "`dbt`.`int_consensus_graffiti_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.177529Z", "completed_at": "2025-10-24T12:23:13.182582Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.183151Z", "completed_at": "2025-10-24T12:23:13.183159Z"}], "thread_id": "Thread-1", "execution_time": 0.006951093673706055, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_deposits_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,SUM(amount/POWER(10,9)) AS total_amount\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__deposits`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_deposits_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_deposits_daily` AS t2\n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_consensus_deposits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.185762Z", "completed_at": "2025-10-24T12:23:13.191512Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.192076Z", "completed_at": "2025-10-24T12:23:13.192084Z"}], "thread_id": "Thread-1", "execution_time": 0.007544517517089844, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_forks", "compiled": true, "compiled_code": "\n\nWITH\n\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\nfork_version AS (\n    SELECT\n        IF(fork_name='GENESIS', 'PHASE0', fork_name) AS fork_name\n        ,parameter_value\n    FROM (\n        SELECT\n            arrayElement(splitByChar('_', ifNull(parameter_name, '')), 1) AS fork_name\n            ,parameter_value\n        FROM `dbt`.`stg_consensus__specs`\n        WHERE parameter_name LIKE '%_FORK_VERSION'\n    )\n),\n\nfork_epoch AS (\n    SELECT\n        arrayElement(splitByChar('_', ifNull(parameter_name, '')), 1) AS fork_name\n        ,parameter_value\n    FROM `dbt`.`stg_consensus__specs`\n    WHERE parameter_name LIKE '%_FORK_EPOCH'\n\n    UNION ALL \n\n    SELECT 'PHASE0' AS fork_name, '0' AS parameter_value \n)\n\nSELECT \n  t1.cl_fork_name AS fork_name\n  ,t2.parameter_value AS fork_version \n  ,t1.fork_digest AS fork_digest\n  ,t3.parameter_value AS fork_epoch \n  ,IF(CAST(t3.parameter_value AS Int) = -1, NULL,\n    addSeconds(\n          toDateTime(t4.genesis_time_unix, 'UTC'),\n          CAST(t3.parameter_value AS Int) * (t4.seconds_per_slot * t4.slots_per_epoch )\n      )\n   ) AS fork_time\nFROM \n  fork_digests t1\nINNER JOIN\n  fork_version t2\n  ON LOWER(t2.fork_name) = LOWER(t1.cl_fork_name)\nINNER JOIN\n  fork_epoch t3\n  ON LOWER(t3.fork_name) = LOWER(t1.cl_fork_name)\nCROSS JOIN `dbt`.`stg_consensus__time_helpers` t4", "relation_name": "`dbt`.`fct_consensus_forks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.194766Z", "completed_at": "2025-10-24T12:23:13.199971Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.200558Z", "completed_at": "2025-10-24T12:23:13.200566Z"}], "thread_id": "Thread-1", "execution_time": 0.007030010223388672, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_blocks_daily", "compiled": true, "compiled_code": "\n\nWITH\n\ntime_helpers AS (\n    SELECT\n        genesis_time_unix,\n        seconds_per_slot\n    FROM \n        `dbt`.`stg_consensus__time_helpers`\n)\n\nSELECT\n    date\n    ,cnt AS blocks_produced\n    ,CASE\n        WHEN toStartOfDay(toDateTime(genesis_time_unix)) = date \n            THEN CAST((86400 - toUnixTimestamp(toDateTime(genesis_time_unix)) % 86400) / seconds_per_slot - cnt AS UInt64)\n        ELSE CAST(86400 / seconds_per_slot - cnt AS UInt64)\n    END AS blocks_missed\nFROM (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date\n        ,COUNT(*) AS cnt\n    FROM `dbt`.`stg_consensus__blocks`\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_blocks_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_blocks_daily` AS t2\n    )\n  \n\n    GROUP BY 1\n) t1\nCROSS JOIN time_helpers t2", "relation_name": "`dbt`.`int_consensus_blocks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.203277Z", "completed_at": "2025-10-24T12:23:13.208366Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.208926Z", "completed_at": "2025-10-24T12:23:13.208934Z"}], "thread_id": "Thread-1", "execution_time": 0.0070459842681884766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_credentials_daily", "compiled": true, "compiled_code": "\n\n\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,leftUTF8(withdrawal_credentials, 4) AS credentials_type\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__validators`\n\n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_credentials_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_credentials_daily` AS t2\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_credentials_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.211638Z", "completed_at": "2025-10-24T12:23:13.216815Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.217396Z", "completed_at": "2025-10-24T12:23:13.217404Z"}], "thread_id": "Thread-1", "execution_time": 0.007003068923950195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_entry_queue_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nqueue_activation AS (\n    SELECT\n        validator_index\n        ,date\n        ,epoch_eligibility\n        ,epoch_activation\n        ,(epoch_activation - epoch_eligibility) * 16 * 5 /(60 * 60 * 24) AS activation_days\n    FROM (\n        SELECT \n            validator_index\n            ,toStartOfDay(argMin(slot_timestamp,slot)) AS date\n            ,argMin(activation_eligibility_epoch,slot) AS epoch_eligibility\n            ,argMin(activation_epoch,slot) AS epoch_activation\n        FROM `dbt`.`stg_consensus__validators`\n        WHERE \n            activation_epoch < 18446744073709551615\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_entry_queue_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_entry_queue_daily` AS t2\n    )\n  \n\n        GROUP BY 1\n    )\n)\n\nSELECT\n    date\n    ,validator_count\n    ,q_activation[1] AS q05\n    ,q_activation[2] AS q10\n    ,q_activation[3] AS q25\n    ,q_activation[4] AS q50\n    ,q_activation[5] AS q75\n    ,q_activation[6] AS q90\n    ,q_activation[7] AS q95\n    ,mean\nFROM (\n    SELECT\n        date,\n        count() AS validator_count\n        ,quantilesTDigest(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(activation_days) AS q_activation\n        ,avg(activation_days) AS  mean\n    FROM queue_activation\n    GROUP BY date\n)", "relation_name": "`dbt`.`int_consensus_entry_queue_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.220201Z", "completed_at": "2025-10-24T12:23:13.225145Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.225729Z", "completed_at": "2025-10-24T12:23:13.225737Z"}], "thread_id": "Thread-1", "execution_time": 0.006791830062866211, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_balances_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(slot_timestamp) AS date\n    ,SUM(balance/POWER(10,9)) AS balance\n    ,SUM(effective_balance/POWER(10,9)) AS effective_balance\nFROM `dbt`.`stg_consensus__validators`\nWHERE \n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_validators_balances_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_balances_daily` AS t2\n    )\n  \n\nGROUP BY date", "relation_name": "`dbt`.`int_consensus_validators_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.228446Z", "completed_at": "2025-10-24T12:23:13.234724Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.235315Z", "completed_at": "2025-10-24T12:23:13.235323Z"}], "thread_id": "Thread-1", "execution_time": 0.008168935775756836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_balances_dist_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q_balance[1] AS q05,\n    q_balance[2] AS q10,\n    q_balance[3] AS q25,\n    q_balance[4] AS q50,\n    q_balance[5] AS q75,\n    q_balance[6] AS q90,\n    q_balance[7] AS q95\nFROM (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n       quantilesTDigest(-- quantilesExactExclusive(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )(balance/POWER(10,9)) AS q_balance\n    FROM `dbt`.`stg_consensus__validators`\n    WHERE \n        status = 'active_ongoing'\n        AND\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_validators_balances_dist_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_balances_dist_daily` AS t2\n    )\n  \n\n    GROUP BY date\n)", "relation_name": "`dbt`.`int_consensus_validators_balances_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.237993Z", "completed_at": "2025-10-24T12:23:13.242960Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.243546Z", "completed_at": "2025-10-24T12:23:13.243554Z"}], "thread_id": "Thread-1", "execution_time": 0.0069010257720947266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_status_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(slot_timestamp) AS date\n    ,status\n    ,COUNT(*) AS cnt\nFROM `dbt`.`stg_consensus__validators`\nWHERE\n    slot_timestamp < today()\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_validators_status_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_status_daily` AS t2\n    )\n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_consensus_validators_status_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.246242Z", "completed_at": "2025-10-24T12:23:13.251861Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.252455Z", "completed_at": "2025-10-24T12:23:13.252462Z"}], "thread_id": "Thread-1", "execution_time": 0.0074579715728759766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_apy_dist", "compiled": true, "compiled_code": "\n\nWITH\n\n/* 1) Daily per-validator balance snapshot (already 1 row/day) */\ndaily_validator_balances AS (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n        pubkey,\n        validator_index,\n        balance\n    FROM `dbt`.`stg_consensus__validators`\n    WHERE \n        balance > 0\n        AND\n        toStartOfDay(slot_timestamp) >= DATE '2023-01-01'\n        AND\n        toStartOfDay(slot_timestamp) < DATE '2023-02-01'\n),\n\n/* 2) True previous-day balance per validator using a window function */\nvalidator_with_prev AS (\n    SELECT\n        date,\n        pubkey,\n        validator_index,\n        balance,\n        -- default value = current balance on first day\n        lagInFrame(balance, 1, balance) OVER (\n            PARTITION BY pubkey, validator_index\n            ORDER BY date\n        ) AS prev_balance\n    FROM daily_validator_balances\n),\n\n/* 3) Get date range to filter other tables - materialize this first */\ndate_range AS (\n    SELECT \n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM validator_with_prev\n),\n\n/* 4) Per-day deposits - direct pubkey and amount columns */\ndeposits AS (\n    SELECT\n        toStartOfDay(d.slot_timestamp) AS dep_date,\n        d.pubkey AS dep_pubkey,\n        sum(d.amount) AS dep_amount\n    FROM `dbt`.`stg_consensus__deposits` d\n    CROSS JOIN date_range dr\n    WHERE toStartOfDay(d.slot_timestamp) >= dr.min_date \n      AND toStartOfDay(d.slot_timestamp) <= dr.max_date\n    GROUP BY toStartOfDay(d.slot_timestamp), d.pubkey\n),\n\n/* 5) Deposit requests - use JSON extraction with explicit date range */\ndeposit_requests AS (\n    SELECT\n        toStartOfDay(dr_table.slot_timestamp) AS dr_date,\n        toString(JSONExtractString(deposit, 'pubkey')) AS dr_pubkey,\n        sum(toUInt64(JSONExtractString(deposit, 'amount'))) AS dep_req_amount\n    FROM `dbt`.`stg_consensus__execution_requests` dr_table\n    ARRAY JOIN JSONExtractArrayRaw(dr_table.payload, 'deposits') AS deposit\n    CROSS JOIN date_range dr\n    WHERE toStartOfDay(dr_table.slot_timestamp) >= dr.min_date \n      AND toStartOfDay(dr_table.slot_timestamp) <= dr.max_date\n    GROUP BY toStartOfDay(dr_table.slot_timestamp), toString(JSONExtractString(deposit, 'pubkey'))\n),\n\n/* 6) Withdrawals - uses validator_index, not pubkey */\nwithdrawals AS (\n    SELECT\n        toStartOfDay(w.slot_timestamp) AS w_date,\n        w.validator_index AS w_validator_index,\n        sum(w.amount) AS wdr_amount\n    FROM `dbt`.`stg_consensus__withdrawals` w\n    CROSS JOIN date_range dr\n    WHERE toStartOfDay(w.slot_timestamp) >= dr.min_date \n      AND toStartOfDay(w.slot_timestamp) <= dr.max_date\n    GROUP BY toStartOfDay(w.slot_timestamp), w.validator_index\n),\n\n/* 7) Withdrawal requests - use JSON extraction with explicit date range */\nwithdrawal_requests AS (\n    SELECT\n        toStartOfDay(wr_table.slot_timestamp) AS wr_date,\n        toString(JSONExtractString(withdrawals, 'validator_pubkey')) AS wr_pubkey,\n        sum(toUInt64(JSONExtractString(withdrawals, 'amount'))) AS wdr_req_amount\n    FROM `dbt`.`stg_consensus__execution_requests` wr_table\n    ARRAY JOIN JSONExtractArrayRaw(wr_table.payload, 'withdrawals') AS withdrawals\n    CROSS JOIN date_range dr\n    WHERE toStartOfDay(wr_table.slot_timestamp) >= dr.min_date \n      AND toStartOfDay(wr_table.slot_timestamp) <= dr.max_date\n    GROUP BY toStartOfDay(wr_table.slot_timestamp), toString(JSONExtractString(withdrawals, 'validator_pubkey'))\n),\n\n/* 8) Per-validator daily net change excluding external flows */\nvalidator_rates AS (\n    SELECT\n        v.date,\n        v.pubkey,\n        v.validator_index,\n        v.prev_balance,\n        v.balance,\n        (v.balance - v.prev_balance) AS raw_diff,\n\n        coalesce(d.dep_amount, 0) AS deposits_amt,\n        coalesce(dr.dep_req_amount, 0) AS deposit_req_amt,\n        coalesce(w.wdr_amount, 0) AS withdrawals_amt,\n        coalesce(wr.wdr_req_amount, 0) AS withdrawal_req_amt,\n\n        /* Adjust for external flows (requests set to 0 unless you want them) */\n        (\n            (v.balance - v.prev_balance)\n            - coalesce(d.dep_amount, 0)   -- deposits increase balance -> subtract to isolate rewards\n            + coalesce(w.wdr_amount, 0)   -- withdrawals decrease balance -> add back\n            - coalesce(dr.dep_req_amount, 0)\n            + coalesce(wr.wdr_req_amount, 0)\n        ) AS adjusted_diff,\n\n        /* Daily rate per validator; guard against division by zero. */\n        CASE \n            WHEN v.prev_balance > 0 \n            THEN toFloat64(adjusted_diff) / toFloat64(v.prev_balance)\n            ELSE toFloat64(0)\n        END AS rate\n    FROM validator_with_prev v\n    LEFT JOIN deposits d ON d.dep_date = v.date AND d.dep_pubkey = v.pubkey\n    LEFT JOIN deposit_requests dr ON dr.dr_date = v.date AND dr.dr_pubkey = v.pubkey\n    LEFT JOIN withdrawals w ON w.w_date = v.date AND w.w_validator_index = v.validator_index\n    LEFT JOIN withdrawal_requests wr ON wr.wr_date = v.date AND wr.wr_pubkey = v.pubkey\n    WHERE v.prev_balance > 0  -- Only consider validators with positive previous balance\n        AND v.date > DATE '2023-01-01'\n)\n\n\nSELECT\n    date,\n    ROUND(q_apy[1],2) AS q05,\n    ROUND(q_apy[2],2) AS q10,\n    ROUND(q_apy[3],2) AS q25,\n    ROUND(q_apy[4],2) AS q50,\n    ROUND(q_apy[5],2) AS q75,\n    ROUND(q_apy[6],2) AS q90,\n    ROUND(q_apy[7],2) AS q95 \nFROM (\n    SELECT\n        toStartOfMonth(date) AS date\n        ,quantilesTDigest(-- quantilesExactExclusive(\n            0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95\n        )((power(1 + rate, 365) - 1) * 100) AS q_apy\n    FROM validator_rates\n    GROUP BY 1\n)", "relation_name": "`dbt`.`int_consensus_validators_apy_dist`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.255119Z", "completed_at": "2025-10-24T12:23:13.260137Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.260721Z", "completed_at": "2025-10-24T12:23:13.260728Z"}], "thread_id": "Thread-1", "execution_time": 0.0068356990814208984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_withdrawls_dist_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,total_amount\n    ,cnt\n    ,q_amount[1] AS min\n    ,q_amount[2] AS q05\n    ,q_amount[3] AS q10\n    ,q_amount[4] AS q25\n    ,q_amount[5] AS q50\n    ,q_amount[6] AS q75\n    ,q_amount[7] AS q90\n    ,q_amount[8] AS q95\n    ,q_amount[9] AS max\nFROM (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date\n        ,SUM(amount/POWER(10,9)) AS total_amount\n        ,COUNT(*) AS cnt\n        ,quantilesTDigest(\n            0.0, 0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95, 1\n        )(amount/POWER(10,9)) AS q_amount\n    FROM `dbt`.`stg_consensus__withdrawals`\n    WHERE\n        slot_timestamp < today()\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_withdrawls_dist_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_withdrawls_dist_daily` AS t2\n    )\n  \n\n    GROUP BY 1\n)", "relation_name": "`dbt`.`int_consensus_withdrawls_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.263428Z", "completed_at": "2025-10-24T12:23:13.269216Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.269789Z", "completed_at": "2025-10-24T12:23:13.269796Z"}], "thread_id": "Thread-1", "execution_time": 0.00775599479675293, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_carbon_intensity_ensemble", "compiled": true, "compiled_code": "\n\nWITH ember_monthly AS (\n    -- Monthly carbon intensity from Ember with enhanced uncertainty\n    SELECT\n        toDate(\"Date\") AS month_date,\n        CASE \n            WHEN \"Area\" = 'World' THEN 'WORLD'  -- World average as special country code\n            ELSE \"ISO 3 code\"\n        END AS country_code,\n        \"Value\" AS carbon_intensity_gco2_kwh,\n        COALESCE(\"Continent\", 'World') AS continent,\n        'ember' AS source,\n        0.85 AS base_confidence\n    FROM `dbt`.`stg_crawlers_data__ember_electricity_data`\n    WHERE   \n        \"Unit\" = 'gCO2/kWh'\n        AND (\n            (\"ISO 3 code\" IS NOT NULL AND \"ISO 3 code\" != '') OR \n            (\"Area\" = 'World')  -- Include World data\n        )\n        AND \"Value\" IS NOT NULL\n        AND \"Value\" > 0\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(\"Date\")) >= (\n      SELECT max(toStartOfMonth(t.month_date))\n      FROM `dbt`.`int_esg_carbon_intensity_ensemble` AS t\n    )\n    AND toStartOfDay(\"Date\") >= (\n      SELECT max(toStartOfDay(t2.month_date, 'UTC'))\n      FROM `dbt`.`int_esg_carbon_intensity_ensemble` AS t2\n    )\n  \n\n),\n\n-- Enhanced uncertainty modeling for monthly data\nuncertainty_enhanced AS (\n    SELECT\n        month_date,\n        country_code,\n        continent,\n        carbon_intensity_gco2_kwh AS base_ci,\n        \n        -- Calculate temporal uncertainty based on grid characteristics\n        -- Higher uncertainty for countries with more variable generation\n        carbon_intensity_gco2_kwh * (\n            CASE \n                -- High renewable countries have more temporal variation\n                WHEN carbon_intensity_gco2_kwh < 100 THEN 0.25  -- Low carbon grids (solar/wind heavy)\n                WHEN carbon_intensity_gco2_kwh < 300 THEN 0.20  -- Medium carbon grids  \n                WHEN carbon_intensity_gco2_kwh < 600 THEN 0.15  -- High carbon grids (more stable)\n                ELSE 0.12  -- Very high carbon grids (coal/gas baseload)\n            END\n        ) AS temporal_uncertainty,\n        \n        -- Data quality uncertainty (monthly averages hide daily/hourly variation)\n        carbon_intensity_gco2_kwh * 0.10 AS measurement_uncertainty,\n        \n        -- Continent-based seasonal adjustment factors\n        CASE continent\n            -- Europe & Asia (mostly Northern Hemisphere, heating-dominant)\n            WHEN 'Europe' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.18  -- Winter heating peak\n                    WHEN month(month_date) IN (6, 7, 8) THEN 0.92   -- Summer low + solar\n                    WHEN month(month_date) IN (3, 4, 11) THEN 1.08  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- Asia (mix of climates, but mostly Northern Hemisphere)\n            WHEN 'Asia' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.12  -- Winter (heating + industrial)\n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.08   -- Summer (cooling demand)\n                    WHEN month(month_date) IN (4, 5, 9, 10) THEN 1.05  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- North America (heating-dominant north, cooling-dominant south)\n            WHEN 'North America' THEN\n                CASE \n                    WHEN month(month_date) IN (12, 1, 2) THEN 1.15  -- Winter heating\n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.12   -- Summer cooling\n                    WHEN month(month_date) IN (4, 5, 9, 10) THEN 1.03  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- Oceania (Southern Hemisphere - reversed seasons)\n            WHEN 'Oceania' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.15   -- Southern winter\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.95  -- Southern summer\n                    WHEN month(month_date) IN (3, 4, 9, 10) THEN 1.05  -- Shoulder seasons\n                    ELSE 1.0\n                END\n                \n            -- South America (Southern Hemisphere + tropical)\n            WHEN 'South America' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.10   -- Southern winter (milder)\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.98  -- Southern summer\n                    ELSE 1.0\n                END\n                \n            -- Africa (mix of Northern/Southern + tropical, minimal variation)\n            WHEN 'Africa' THEN\n                CASE \n                    WHEN month(month_date) IN (6, 7, 8) THEN 1.05   -- Slight dry season effect\n                    WHEN month(month_date) IN (12, 1, 2) THEN 0.98  -- Wet season\n                    ELSE 1.0\n                END\n                \n            -- World/Default (minimal adjustment)\n            ELSE 1.0\n        END AS seasonal_factor,\n        \n        source,\n        base_confidence\n        \n    FROM ember_monthly\n),\n\n-- Final aggregation with confidence intervals\nfinal_estimates AS (\n    SELECT\n        month_date,\n        country_code,\n        \n        -- Point estimates with seasonal adjustment\n        round(base_ci * seasonal_factor, 2) AS carbon_intensity_mean,\n        \n        -- Combined uncertainty (temporal + measurement)\n        round(sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS carbon_intensity_std,\n        \n        -- Confidence intervals for Monte Carlo sampling\n        round(greatest(0, base_ci * seasonal_factor - 1.96 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2))), 2) AS ci_lower_95,\n        round(base_ci * seasonal_factor + 1.96 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS ci_upper_95,\n        \n        round(greatest(0, base_ci * seasonal_factor - 1.645 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2))), 2) AS ci_lower_90,\n        round(base_ci * seasonal_factor + 1.645 * sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)), 2) AS ci_upper_90,\n        \n        -- Coefficient of variation for uncertainty assessment\n        round(sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor), 3) AS coefficient_of_variation,\n        \n        -- Raw values for diagnostics\n        round(base_ci, 2) AS base_carbon_intensity,\n        round(temporal_uncertainty, 2) AS temporal_std,\n        round(measurement_uncertainty, 2) AS measurement_std,\n        round(seasonal_factor, 3) AS seasonal_adjustment,\n        continent,\n        \n        -- Data quality indicators\n        arrayPushFront([], source) AS sources_used,\n        base_confidence AS confidence_score,\n        1 AS n_sources,\n        \n        -- Uncertainty category for diagnostics\n        CASE \n            WHEN sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor) < 0.15 THEN 'Low'\n            WHEN sqrt(pow(temporal_uncertainty, 2) + pow(measurement_uncertainty, 2)) / (base_ci * seasonal_factor) < 0.25 THEN 'Medium' \n            ELSE 'High'\n        END AS uncertainty_category\n        \n    FROM uncertainty_enhanced\n)\n\nSELECT\n    month_date,\n    country_code,\n    \n    -- Core metrics for carbon footprint calculation\n    carbon_intensity_mean,\n    carbon_intensity_std,\n    ci_lower_95,\n    ci_upper_95,\n    ci_lower_90,\n    ci_upper_90,\n    \n    -- Uncertainty analysis\n    coefficient_of_variation,\n    uncertainty_category,\n    \n    -- Component breakdown for diagnostics\n    base_carbon_intensity,\n    temporal_std,\n    measurement_std,\n    seasonal_adjustment,\n    \n    -- Data provenance and quality\n    sources_used,\n    confidence_score,\n    n_sources,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM final_estimates", "relation_name": "`dbt`.`int_esg_carbon_intensity_ensemble`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.272394Z", "completed_at": "2025-10-24T12:23:13.276178Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.276754Z", "completed_at": "2025-10-24T12:23:13.276762Z"}], "thread_id": "Thread-1", "execution_time": 0.005579233169555664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,any_value(toInt32(floor(__total))) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d` \nGROUP BY 1, 2\nORDER BY date ASC, client ASC", "relation_name": "`dbt`.`api_probelab_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.279327Z", "completed_at": "2025-10-24T12:23:13.284352Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.284985Z", "completed_at": "2025-10-24T12:23:13.284993Z"}], "thread_id": "Thread-1", "execution_time": 0.0068683624267578125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_version_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,agent_version_semver_str AS version\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_agent_semvers_avg_1d` \nORDER BY date ASC, client ASC, version ASC", "relation_name": "`dbt`.`api_probelab_clients_version_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.287569Z", "completed_at": "2025-10-24T12:23:13.291266Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.291833Z", "completed_at": "2025-10-24T12:23:13.291844Z"}], "thread_id": "Thread-1", "execution_time": 0.005513906478881836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_cloud_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,cloud_provider AS cloud\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_cloud_provider_avg_1d` \nORDER BY date ASC, client ASC, cloud ASC", "relation_name": "`dbt`.`api_probelab_clients_cloud_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.294483Z", "completed_at": "2025-10-24T12:23:13.298153Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.298734Z", "completed_at": "2025-10-24T12:23:13.298742Z"}], "thread_id": "Thread-1", "execution_time": 0.005472660064697266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_country_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,country\n    ,toInt32(floor(__count)) AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_countries_avg_1d` \nORDER BY date ASC, client ASC, country ASC", "relation_name": "`dbt`.`api_probelab_clients_country_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.301315Z", "completed_at": "2025-10-24T12:23:13.304994Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.305577Z", "completed_at": "2025-10-24T12:23:13.305585Z"}], "thread_id": "Thread-1", "execution_time": 0.0054988861083984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_probelab_clients_quic_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    toStartOfDay(max_crawl_created_at) AS date\n    ,agent_version_type AS client\n    ,quic_support AS quic\n    ,__count AS value\nFROM \n    `dbt`.`stg_crawlers_data__probelab_quic_support_over_7d` \nORDER BY date ASC, client ASC, quic ASC", "relation_name": "`dbt`.`api_probelab_clients_quic_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.308371Z", "completed_at": "2025-10-24T12:23:13.313459Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.314028Z", "completed_at": "2025-10-24T12:23:13.314035Z"}], "thread_id": "Thread-1", "execution_time": 0.007073163986206055, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_blocks_clients_version_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nclients_version AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date\n        ,multiIf(\n             lower(decoded_extra_data[1]) = 'choose' \n            OR lower(decoded_extra_data[1]) = 'mysticryuujin'  \n            OR lower(decoded_extra_data[1]) = 'sanae.io'\n            OR decoded_extra_data[1] = ''  , \n            'Unknown',\n            decoded_extra_data[1]\n        )   AS client\n        ,IF(length(decoded_extra_data)>1, \n            IF(decoded_extra_data[2]='Ethereum',decoded_extra_data[3],decoded_extra_data[2]), \n            ''\n        ) AS version\n        ,COUNT(*) AS cnt\n    FROM `dbt`.`stg_execution__blocks`\n    \n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_blocks_clients_version_daily` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_blocks_clients_version_daily` AS t2\n    )\n  \n\n    GROUP BY 1, 2, 3\n)\n\nSELECT\n    *\nFROM clients_version", "relation_name": "`dbt`.`int_execution_blocks_clients_version_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.316799Z", "completed_at": "2025-10-24T12:23:13.321817Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.322402Z", "completed_at": "2025-10-24T12:23:13.322410Z"}], "thread_id": "Thread-1", "execution_time": 0.006886959075927734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_blocks_gas_usage_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  toDate(block_timestamp)         AS date,\n  SUM(gas_used)                   AS gas_used_sum,\n  SUM(gas_limit)                  AS gas_limit_sum,\n  gas_used_sum / NULLIF(gas_limit_sum, 0) AS gas_used_fraq\nFROM `dbt`.`stg_execution__blocks`\n\n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_blocks_gas_usage_daily` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_blocks_gas_usage_daily` AS t2\n    )\n  \n\nGROUP BY date", "relation_name": "`dbt`.`int_execution_blocks_gas_usage_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.325144Z", "completed_at": "2025-10-24T12:23:13.331515Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.332073Z", "completed_at": "2025-10-24T12:23:13.332080Z"}], "thread_id": "Thread-1", "execution_time": 0.00821065902709961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_state_size_full_diff_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\n\nstate_size_diff AS (\n    SELECT \n        toStartOfDay(block_timestamp) AS date \n        ,SUM(IF(to_value!='0000000000000000000000000000000000000000000000000000000000000000',32,-32)) AS bytes_diff\n    FROM \n        `dbt`.`stg_execution__storage_diffs`\n    \n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_state_size_full_diff_daily` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_state_size_full_diff_daily` AS t2\n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT\n    *\nFROM state_size_diff", "relation_name": "`dbt`.`int_execution_state_size_full_diff_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.334770Z", "completed_at": "2025-10-24T12:23:13.341399Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.341969Z", "completed_at": "2025-10-24T12:23:13.341976Z"}], "thread_id": "Thread-1", "execution_time": 0.008429527282714844, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_info_daily", "compiled": true, "compiled_code": "\n\nWITH tx AS (\n  SELECT\n    block_timestamp,\n    toDate(block_timestamp)             AS date,\n    toString(transaction_type)          AS transaction_type,\n    coalesce(success, 0)                AS success,\n    toFloat64(value) / 1e18             AS value_native,             \n    toFloat64(coalesce(gas_used, 0))    AS gas_used,                 \n    toFloat64(coalesce(gas_price, 0))   AS gas_price                 \n  FROM `dbt`.`stg_execution__transactions`\n  WHERE block_timestamp < today()\n  \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_transactions_info_daily` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_transactions_info_daily` AS t2\n    )\n  \n\n),\n\nagg_base AS (\n  SELECT\n    date,\n    transaction_type,\n    success,\n    COUNT()                     AS n_txs,\n    SUM(value_native)           AS xdai_value_sum_raw,\n    AVG(value_native)           AS xdai_value_avg_raw,\n    median(value_native)        AS xdai_value_median_raw,\n    SUM(gas_used)               AS gas_used_sum_raw,          -- \u201cgas units\u201d\n    AVG(gas_price)              AS gas_price_avg_raw_wei,     -- in wei\n    median(gas_price)           AS gas_price_med_raw_wei,     -- in wei\n    SUM(gas_used * gas_price)   AS fee_sum_raw_wei            -- in wei\n  FROM tx\n  GROUP BY date, transaction_type, success\n),\n\nagg AS (\n  SELECT\n    date,\n    transaction_type,\n    success,\n    n_txs,\n    xdai_value_sum_raw                       AS xdai_value,\n    xdai_value_avg_raw                       AS xdai_value_avg,\n    xdai_value_median_raw                    AS xdai_value_median,\n    gas_used_sum_raw                         AS gas_used,\n    CAST(gas_price_avg_raw_wei / 1e9 AS Int32)   AS gas_price_avg,       -- Gwei\n    CAST(gas_price_med_raw_wei / 1e9 AS Int32)   AS gas_price_median,    -- Gwei\n    fee_sum_raw_wei / 1e18                   AS fee_native_sum          -- xDai\n  FROM agg_base\n),\n\npx AS (\n  SELECT\n    date,\n    price\n  FROM `dbt`.`stg_crawlers_data__dune_prices`\n  WHERE symbol = 'XDAI'\n  \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_transactions_info_daily` AS t\n    )\n    AND toStartOfDay(date) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_transactions_info_daily` AS t2\n    )\n  \n\n)\n\nSELECT\n  a.date,\n  a.transaction_type,\n  a.success,\n  a.n_txs,\n  a.xdai_value,\n  a.xdai_value_avg,\n  a.xdai_value_median,\n  a.gas_used,\n  a.gas_price_avg,\n  a.gas_price_median,\n  a.fee_native_sum,\n  a.fee_native_sum * coalesce(px.price, 1.0) AS fee_usd_sum\nFROM agg a\nLEFT JOIN px\n  ON px.date = a.date", "relation_name": "`dbt`.`int_execution_transactions_info_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.344822Z", "completed_at": "2025-10-24T12:23:13.352103Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.352695Z", "completed_at": "2025-10-24T12:23:13.352703Z"}], "thread_id": "Thread-1", "execution_time": 0.009291648864746094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_peers", "compiled": true, "compiled_code": "\n\n\n\n\nWITH\n\n  peers AS (\n    SELECT \n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors\n  FROM `dbt`.`stg_nebula_discv4__visits` A\n  WHERE\n      toString(peer_properties.network_id) = '100'\n      \n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(t.visit_ended_at))\n      FROM `dbt`.`int_p2p_discv4_peers` AS t\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(t2.visit_ended_at, 'UTC'))\n      FROM `dbt`.`int_p2p_discv4_peers` AS t2\n    )\n  \n\n      \n  ),\n\n  parsed AS (\n    SELECT\n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors,\n      -- break into slash-delimited parts\n      splitByChar('/', agent_version)                        AS slash_parts,\n      length(slash_parts)                                    AS sp_len,\n\n      -- if 4+ parts, take last two as platform+runtime; otherwise only platform\n      IF(\n        length(slash_parts) > 3,\n        arrayElement(slash_parts, sp_len-1),\n        arrayElement(slash_parts, sp_len)\n      )                                                       AS platform,\n\n      IF(\n        length(slash_parts) > 3,\n        arrayElement(slash_parts, sp_len),\n        ''\n      )                                                       AS runtime,\n\n      -- head_parts = everything before the last 1 or 2 elements\n      arraySlice(\n        slash_parts,\n        1,\n        sp_len - IF(sp_len > 3, 2, 1)\n      )                                                       AS head_parts\n\n    FROM peers\n  ),\n\n  exploded AS (\n    SELECT\n      visit_ended_at,\n      peer_id,\n      agent_version,\n      connect_maddr,\n      peer_properties,\n      crawl_error,\n      dial_errors,\n      head_parts[1]                                          AS client,\n\n      -- if head_parts has 3 elements, the middle is variant\n      IF(\n        length(head_parts) = 3,\n        head_parts[2],\n        ''\n      )                                                       AS variant,\n\n      -- the last element of head_parts is our raw \u201cver_blob\u201d\n      arrayElement(head_parts, length(head_parts))            AS ver_blob,\n\n      platform,\n      runtime,\n\n      -- split out \u201c+\u201d-style metadata\n      IF(ver_blob LIKE '%+%', arrayElement(splitByChar('+', ver_blob), 1), ver_blob) AS pre_blob,\n      IF(ver_blob LIKE '%+%', arrayElement(splitByChar('+', ver_blob), 2), '')        AS plus_build\n\n    FROM parsed\n  ),\n\nbasic_info AS (\n  SELECT\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    --replaceRegexpAll(connect_maddr, '^/ip4/([0-9.]+)/tcp/[0-9]+$', '\\\\1') AS ip,\n    arrayElement(splitByChar('/', ifNull(connect_maddr, '')), 3) AS ip,\n    peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    IF(\n      plus_build != '',\n      arrayElement(splitByChar('-', pre_blob), 1),\n      splitByChar('-', ver_blob)[1]\n    )                                                       AS version,\n    IF(\n      plus_build != '',\n      IF(\n        length(splitByChar('-', pre_blob)) >= 2,\n        arrayElement(splitByChar('-', pre_blob), 2),\n        ''\n      ),\n      IF(\n        length(splitByChar('-', ver_blob)) = 3,\n        arrayElement(splitByChar('-', ver_blob), 2),\n        ''\n      )\n    )                                                       AS channel,\n    IF(\n      plus_build != '',\n      plus_build,\n      IF(\n        length(splitByChar('-', ver_blob)) > 1,\n        arrayElement(splitByChar('-', ver_blob), -1),\n        ''\n      )\n    )                                                       AS build,\n    platform,\n    runtime\n  FROM exploded\n)\n\nSELECT\n  t1.visit_ended_at,\n  t1.peer_id,\n  t1.agent_version,\n  t1.ip,\n  t1.peer_properties,\n  t1.crawl_error,\n  t1.dial_errors,\n  t1.client,\n  t1.variant,\n  t1.version,\n  t1.channel,\n  t1.build,\n  t1.platform,\n  t1.runtime,\n  t2.hostname   AS peer_hostname,\n  t2.city       AS peer_city,\n  t2.country    AS peer_country,\n  t2.org        AS peer_org,\n  t2.loc        AS peer_loc,\n  t2.generic_provider AS generic_provider\nFROM\n  basic_info t1\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS t2\n  ON t2.ip = t1.ip", "relation_name": "`dbt`.`int_p2p_discv4_peers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.355422Z", "completed_at": "2025-10-24T12:23:13.360453Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.361013Z", "completed_at": "2025-10-24T12:23:13.361021Z"}], "thread_id": "Thread-1", "execution_time": 0.0068209171295166016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_visits_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nvisits_info AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,COUNT(visit_ended_at) AS total_visits\n        ,SUM(IF( empty(dial_errors) = 1 OR crawl_error IS NULL, 1, 0)) AS successful_visits\n        ,COUNT(DISTINCT crawl_id) AS crawls\n    FROM `dbt`.`stg_nebula_discv4__visits`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        toString(peer_properties.network_id) = '100'\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_p2p_discv4_visits_daily` AS t\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_p2p_discv4_visits_daily` AS t2\n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT * FROM visits_info", "relation_name": "`dbt`.`int_p2p_discv4_visits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.363618Z", "completed_at": "2025-10-24T12:23:13.371307Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.371865Z", "completed_at": "2025-10-24T12:23:13.371873Z"}], "thread_id": "Thread-1", "execution_time": 0.009484291076660156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_peers", "compiled": true, "compiled_code": "\n\n\n\n\nWITH\n\n-- Known fork digests \u2192 names\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\n-- Known fork versions \u2192 names\nfork_version AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_version,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0x00000064','Phase0'),\n      ('0x01000064','Altair'),\n      ('0x02000064','Bellatrix'),\n      ('0x03000064','Capella'),\n      ('0x04000064','Deneb'),\n      ('0x05000064','Electra'),\n      ('0x06000064','Fulu')\n    ]) AS tup\n  )\n),\n\n/* Pull only relevant rows from source and normalize Dynamic\u2192String once */\npeers AS (\n  SELECT \n    t1.crawl_id,\n    t1.visit_ended_at,\n    t1.peer_id,\n    t1.connect_maddr,\n    -- Dynamic JSON leaves \u2192 String for safe joins/filters\n    toString(t1.peer_properties.fork_digest)         AS fork_digest,\n    toString(t1.peer_properties.next_fork_version)   AS next_fork_version,\n\n    -- Map to fork names\n    t2.cl_fork_name                                  AS cl_fork_name,\n    coalesce(t3.cl_fork_name, toString(t1.peer_properties.next_fork_version))\n                                                    AS cl_next_fork_name,\n\n    t1.agent_version,\n    --t1.peer_properties,\n    t1.crawl_error,\n    t1.dial_errors\n  FROM `dbt`.`stg_nebula_discv5__visits` AS t1\n  LEFT JOIN fork_digests t2\n    ON toString(t1.peer_properties.fork_digest) = t2.fork_digest\n  LEFT JOIN fork_version t3\n    ON toString(t1.peer_properties.next_fork_version) = t3.fork_version\n  WHERE\n    (\n      toString(t1.peer_properties.fork_digest) IN (SELECT fork_digest FROM fork_digests)\n      OR toString(t1.peer_properties.next_fork_version) LIKE '%064'\n    )\n    \n      \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(t.visit_ended_at))\n      FROM `dbt`.`int_p2p_discv5_peers` AS t\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(t2.visit_ended_at, 'UTC'))\n      FROM `dbt`.`int_p2p_discv5_peers` AS t2\n    )\n  \n\n    \n),\n\n/* Split and locate version token via regex */\nparsed AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n    --peer_properties,\n    crawl_error,\n    dial_errors,\n    agent_version,\n\n    splitByChar('/', agent_version)                                         AS parts,\n    length(splitByChar('/', agent_version))                                 AS parts_len,\n    arraySlice(splitByChar('/', agent_version), 2)                         AS tail,\n    length(arraySlice(splitByChar('/', agent_version), 2))                 AS tail_len,\n\n    splitByChar('/', agent_version)[1]                                     AS client,\n\n    -- first tail index that looks like a version (v?digits(.digits){0,3}\u2026)\n    arrayFirstIndex(x ->\n        (substring(x, 1, 1) = 'v' OR match(x, '^[0-9]')) AND\n        match(x, '^v?[0-9]+(\\\\.[0-9]+){0,3}([\\\\-\\\\w\\\\.\\\\+]+)?$')\n      , arraySlice(splitByChar('/', agent_version), 2))                    AS ver_idx_tail\n  FROM peers\n),\n\n/* Derive variant, version blob, platform, runtime */\nwith_parts AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n   -- peer_properties,\n    crawl_error,\n    dial_errors,\n    agent_version,\n    parts,\n    parts_len,\n    tail,\n    tail_len,\n    client,\n    ver_idx_tail,\n\n    /* variant: exactly one token between client and version */\n    IF(ver_idx_tail > 1, tail[1], '')                                       AS variant,\n\n    /* raw version token (may include '-' channel and/or '+' build) */\n    IF(ver_idx_tail > 0, tail[ver_idx_tail], '')                            AS ver_blob,\n\n    /* tokens after version for platform/runtime */\n    IF(ver_idx_tail > 0 AND tail_len >= ver_idx_tail + 1, tail[ver_idx_tail + 1], '')\n      AS platform,\n    IF(ver_idx_tail > 0 AND tail_len >= ver_idx_tail + 2, tail[ver_idx_tail + 2], '')\n      AS runtime\n  FROM parsed\n),\n\n/* Split version blob and prep hyphen parts; also clean runtime */\nexploded AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    connect_maddr,\n    fork_digest,\n    next_fork_version,\n    cl_fork_name,\n    cl_next_fork_name,\n   -- peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    ver_blob,\n\n    -- strip leading '-' in runtime\n    replaceRegexpOne(runtime, '^-+', '')                                    AS runtime,\n    platform,\n\n    /* version blob split around '+' */\n    IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[1], ver_blob) AS pre_blob,\n    IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[2], '')       AS plus_build,\n\n    /* hyphen parts for channel/build logic (work off pre_blob) */\n    splitByChar('-', IF(position(ver_blob, '+') > 0, splitByChar('+', ver_blob)[1], ver_blob))\n                                                                            AS hy_parts\n  FROM with_parts\n),\n\nbasic_info AS (\n  SELECT\n    crawl_id,\n    visit_ended_at,\n    peer_id,\n    agent_version,\n    replaceRegexpAll(connect_maddr, '^/ip4/([0-9.]+)/tcp/[0-9]+$', '\\\\1') AS ip,\n    fork_digest,\n    cl_fork_name,\n    cl_next_fork_name,\n    next_fork_version,\n   -- peer_properties,\n    crawl_error,\n    dial_errors,\n    client,\n    variant,\n    IF(length(hy_parts) >= 1, hy_parts[1], '')                                AS version,\n    IF(length(hy_parts) >= 3, hy_parts[2], '')                                 AS channel,\n    IF(\n      plus_build != '',\n      plus_build,\n      IF(length(hy_parts) >= 2, hy_parts[length(hy_parts)], '')\n    )                                                                          AS build,\n    platform,\n    runtime\n  FROM exploded\n)\n\nSELECT\n  t1.crawl_id,\n  t1.visit_ended_at,\n  t1.peer_id,\n  t1.agent_version,\n  t1.ip,\n  t1.fork_digest,\n  t1.cl_fork_name,\n  t1.cl_next_fork_name,\n  t1.next_fork_version,\n  t1.crawl_error,\n  t1.dial_errors,\n  t1.client,\n  t1.variant,\n  t1.version,\n  t1.channel,\n  t1.build,\n  CASE\n      WHEN t1.platform = '' THEN 'Unknown'\n      WHEN t1.platform = 'aarch64-linux' THEN 'linux-aarch_64'\n      WHEN t1.platform = 'x86_64-linux' THEN 'linux-x86_64'\n      WHEN t1.platform = 'x86_64-windows' THEN 'windows-x86_64'\n      ELSE t1.platform\n  END AS platform,\n  t1.runtime,\n  t2.hostname   AS peer_hostname,\n  t2.city       AS peer_city,\n  t2.country    AS peer_country,\n  t2.org        AS peer_org,\n  t2.loc        AS peer_loc,\n  t2.generic_provider AS generic_provider\nFROM\n  basic_info t1\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS t2\n  ON t2.ip = t1.ip", "relation_name": "`dbt`.`int_p2p_discv5_peers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.374577Z", "completed_at": "2025-10-24T12:23:13.381031Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.381617Z", "completed_at": "2025-10-24T12:23:13.381624Z"}], "thread_id": "Thread-1", "execution_time": 0.008347272872924805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_visits_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nfork_digests AS (\n  SELECT \n    tupleElement(tup, 1) AS fork_digest,\n    tupleElement(tup, 2) AS cl_fork_name\n  FROM (\n    SELECT arrayJoin([\n      ('0xbc9a6864','Phase0'),\n      ('0x56fdb5e0','Altair'),\n      ('0x824be431','Bellatrix'),\n      ('0x21a6f836','Capella'),\n      ('0x3ebfd484','Deneb'),\n      ('0x7d5aab40','Electra'),\n      ('0xf9ab5f85','Fulu')\n    ]) AS tup\n  )\n),\n\nvisits_info AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,COUNT(visit_ended_at) AS total_visits\n        ,SUM(IF( empty(dial_errors) = 1 OR crawl_error IS NULL, 1, 0)) AS successful_visits\n        ,COUNT(DISTINCT crawl_id) AS crawls\n    FROM `dbt`.`stg_nebula_discv5__visits`\n    WHERE\n      toStartOfDay(visit_ended_at) < today()\n      AND\n      (\n        toString(peer_properties.fork_digest) IN (SELECT fork_digest FROM fork_digests)\n        OR toString(peer_properties.next_fork_version) LIKE '%064'\n      )\n      \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_p2p_discv5_visits_daily` AS t\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_p2p_discv5_visits_daily` AS t2\n    )\n  \n\n    GROUP BY 1\n)\n\nSELECT * FROM visits_info", "relation_name": "`dbt`.`int_p2p_discv5_visits_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.384385Z", "completed_at": "2025-10-24T12:23:13.389721Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.390316Z", "completed_at": "2025-10-24T12:23:13.390324Z"}], "thread_id": "Thread-1", "execution_time": 0.0072917938232421875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_AgentResultMapping_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '99c43743a2dbd406160cc43cf08113b17178789c'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2025-06-10'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_AgentResultMapping_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_AgentResultMapping_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.392923Z", "completed_at": "2025-10-24T12:23:13.398161Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.398748Z", "completed_at": "2025-10-24T12:23:13.398756Z"}], "thread_id": "Thread-1", "execution_time": 0.0070590972900390625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_ConditionalTokens_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-01'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_ConditionalTokens_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_ConditionalTokens_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.401354Z", "completed_at": "2025-10-24T12:23:13.406622Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.407211Z", "completed_at": "2025-10-24T12:23:13.407219Z"}], "thread_id": "Thread-1", "execution_time": 0.00708460807800293, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_FPMMDeterministicFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-04'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_FPMMDeterministicFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_FPMMDeterministicFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.409821Z", "completed_at": "2025-10-24T12:23:13.415093Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.415686Z", "completed_at": "2025-10-24T12:23:13.415694Z"}], "thread_id": "Thread-1", "execution_time": 0.0070912837982177734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_GBCDeposit_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '0b98057ea310f4d31f2a452b414647007d1645d9'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_GBCDeposit_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_GBCDeposit_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.418343Z", "completed_at": "2025-10-24T12:23:13.423777Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.424379Z", "completed_at": "2025-10-24T12:23:13.424387Z"}], "thread_id": "Thread-1", "execution_time": 0.007258415222167969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_OmenAgentResultMapping_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-09-30'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_OmenAgentResultMapping_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_OmenAgentResultMapping_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.426957Z", "completed_at": "2025-10-24T12:23:13.433446Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.434009Z", "completed_at": "2025-10-24T12:23:13.434017Z"}], "thread_id": "Thread-1", "execution_time": 0.008279085159301758, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Realitio_v2_1_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2021-01-13'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Realitio_v2_1_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Realitio_v2_1_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.436598Z", "completed_at": "2025-10-24T12:23:13.441939Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.442526Z", "completed_at": "2025-10-24T12:23:13.442534Z"}], "thread_id": "Thread-1", "execution_time": 0.007153987884521484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_MarketFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-10-08'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Seer_MarketFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_MarketFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.445520Z", "completed_at": "2025-10-24T12:23:13.450859Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.451445Z", "completed_at": "2025-10-24T12:23:13.451453Z"}], "thread_id": "Thread-1", "execution_time": 0.007563114166259766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_Wrapped1155Factory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-02-07'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Seer_Wrapped1155Factory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_Wrapped1155Factory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.454037Z", "completed_at": "2025-10-24T12:23:13.459376Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.459953Z", "completed_at": "2025-10-24T12:23:13.459961Z"}], "thread_id": "Thread-1", "execution_time": 0.0071408748626708984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-09-22'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.462581Z", "completed_at": "2025-10-24T12:23:13.467857Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.468435Z", "completed_at": "2025-10-24T12:23:13.468443Z"}], "thread_id": "Thread-1", "execution_time": 0.007076740264892578, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraPool_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-11-30'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraPool_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.471034Z", "completed_at": "2025-10-24T12:23:13.477525Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.478093Z", "completed_at": "2025-10-24T12:23:13.478100Z"}], "thread_id": "Thread-1", "execution_time": 0.008366107940673828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_aaveV3_PoolConfigurator_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '7304979ec9e4eaa0273b6a037a31c4e9e5a75d16'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-10-04'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_aaveV3_PoolConfigurator_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '7304979ec9e4eaa0273b6a037a31c4e9e5a75d16'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_aaveV3_PoolConfigurator_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.480713Z", "completed_at": "2025-10-24T12:23:13.485934Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.486518Z", "completed_at": "2025-10-24T12:23:13.486525Z"}], "thread_id": "Thread-1", "execution_time": 0.0070343017578125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_aaveV3_PoolInstance_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'b50201558b00496a145fe76f7424749556e326d8'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-10-04'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_aaveV3_PoolInstance_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'b50201558b00496a145fe76f7424749556e326d8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_aaveV3_PoolInstance_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.489155Z", "completed_at": "2025-10-24T12:23:13.494379Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.494946Z", "completed_at": "2025-10-24T12:23:13.494953Z"}], "thread_id": "Thread-1", "execution_time": 0.007111549377441406, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_TSLAx_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '19972d1750f959dd14cf436da6360185bd54cea0'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_TSLAx_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '19972d1750f959dd14cf436da6360185bd54cea0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_TSLAx_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.497592Z", "completed_at": "2025-10-24T12:23:13.502772Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.503364Z", "completed_at": "2025-10-24T12:23:13.503372Z"}], "thread_id": "Thread-1", "execution_time": 0.007071018218994141, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bC3M_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '83ec02059f686e747392a22ddfed7833ba0d7ce3'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bC3M_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83ec02059f686e747392a22ddfed7833ba0d7ce3'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bC3M_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.506003Z", "completed_at": "2025-10-24T12:23:13.511326Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.511892Z", "completed_at": "2025-10-24T12:23:13.511900Z"}], "thread_id": "Thread-1", "execution_time": 0.007182598114013672, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bCOIN_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '69b2d456e8830847f488afdde2a636bfb26218c6'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bCOIN_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '69b2d456e8830847f488afdde2a636bfb26218c6'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bCOIN_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.514518Z", "completed_at": "2025-10-24T12:23:13.519809Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.520394Z", "completed_at": "2025-10-24T12:23:13.520401Z"}], "thread_id": "Thread-1", "execution_time": 0.007113456726074219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bCSPX_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '1332d2b4dc83238b621b7f7d0f72fec58bb81a9b'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bCSPX_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '1332d2b4dc83238b621b7f7d0f72fec58bb81a9b'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bCSPX_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.522975Z", "completed_at": "2025-10-24T12:23:13.529334Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.529899Z", "completed_at": "2025-10-24T12:23:13.529907Z"}], "thread_id": "Thread-1", "execution_time": 0.008152484893798828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bHIGH_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '9e8e794ad6ecdb6d5c7eabe059d30e907f58859b'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bHIGH_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9e8e794ad6ecdb6d5c7eabe059d30e907f58859b'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bHIGH_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.532504Z", "completed_at": "2025-10-24T12:23:13.537652Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.538231Z", "completed_at": "2025-10-24T12:23:13.538238Z"}], "thread_id": "Thread-1", "execution_time": 0.006959199905395508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bIB01_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '788d911ae7c95121a89a0f0306db65d87422e1de'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bIB01_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '788d911ae7c95121a89a0f0306db65d87422e1de'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bIB01_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.540802Z", "completed_at": "2025-10-24T12:23:13.545928Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.546514Z", "completed_at": "2025-10-24T12:23:13.546522Z"}], "thread_id": "Thread-1", "execution_time": 0.006935834884643555, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bIBTA_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '9f9953d8a2c5366f098754d48f2d69b144ce03da'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bIBTA_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9f9953d8a2c5366f098754d48f2d69b144ce03da'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bIBTA_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.549112Z", "completed_at": "2025-10-24T12:23:13.554288Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.554858Z", "completed_at": "2025-10-24T12:23:13.554865Z"}], "thread_id": "Thread-1", "execution_time": 0.006967306137084961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bMSTR_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'c8429803dcda7df86822ab173ea285c10bf1eb66'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bMSTR_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'c8429803dcda7df86822ab173ea285c10bf1eb66'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bMSTR_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.557494Z", "completed_at": "2025-10-24T12:23:13.562679Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.563262Z", "completed_at": "2025-10-24T12:23:13.563270Z"}], "thread_id": "Thread-1", "execution_time": 0.007061004638671875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_backedfi_bNVDA_Oracle_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '1d3be4d05eba2aa6c4eede85a74f491c31766e64'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_backedfi_bNVDA_Oracle_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '1d3be4d05eba2aa6c4eede85a74f491c31766e64'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_backedfi_bNVDA_Oracle_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.565838Z", "completed_at": "2025-10-24T12:23:13.572499Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.573065Z", "completed_at": "2025-10-24T12:23:13.573072Z"}], "thread_id": "Thread-1", "execution_time": 0.008463144302368164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v1_Hub_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = '29b9a7fbb8995b2423a71cc17cf9810798f6c543'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v1_Hub_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '29b9a7fbb8995b2423a71cc17cf9810798f6c543'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v1_Hub_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.575744Z", "completed_at": "2025-10-24T12:23:13.580990Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.581577Z", "completed_at": "2025-10-24T12:23:13.581584Z"}], "thread_id": "Thread-1", "execution_time": 0.007120609283447266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_CirclesBackingFactory_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'eced91232c609a42f6016860e8223b8aecaa7bd0'\n  \n    \n      AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2025-04-25'))\n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_CirclesBackingFactory_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'eced91232c609a42f6016860e8223b8aecaa7bd0'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_CirclesBackingFactory_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.584281Z", "completed_at": "2025-10-24T12:23:13.589411Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.589973Z", "completed_at": "2025-10-24T12:23:13.589981Z"}], "thread_id": "Thread-1", "execution_time": 0.006949424743652344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_Hub_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'c12c1e50abb450d6205ea2c3fa861b3b834d13e8'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_Hub_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'c12c1e50abb450d6205ea2c3fa861b3b834d13e8'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_Hub_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.592761Z", "completed_at": "2025-10-24T12:23:13.598078Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.598704Z", "completed_at": "2025-10-24T12:23:13.598712Z"}], "thread_id": "Thread-1", "execution_time": 0.00733637809753418, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_circles_v2_NameRegistry_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'a27566fd89162cc3d40cb59c87aaaa49b85f3474'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_circles_v2_NameRegistry_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a27566fd89162cc3d40cb59c87aaaa49b85f3474'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_circles_v2_NameRegistry_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.601491Z", "completed_at": "2025-10-24T12:23:13.606979Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.607572Z", "completed_at": "2025-10-24T12:23:13.607581Z"}], "thread_id": "Thread-1", "execution_time": 0.007361650466918945, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_sdai_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'af204776c7245bf4147c2612bf6e5972ee483701'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_sdai_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'af204776c7245bf4147c2612bf6e5972ee483701'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_sdai_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.610294Z", "completed_at": "2025-10-24T12:23:13.615661Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.616238Z", "completed_at": "2025-10-24T12:23:13.616246Z"}], "thread_id": "Thread-1", "execution_time": 0.007208347320556641, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_wxdai_events", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\n\nWITH\n\nlogs AS (\n  SELECT *\n  FROM `execution`.`logs`\n  WHERE address = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n  \n    \n\n    \n      AND block_timestamp >\n        (SELECT coalesce(max(block_timestamp),'1970-01-01')\n         FROM `dbt`.`contracts_wxdai_events`)\n    \n),\n\nabi AS ( \nSELECT\n  replace(signature,'0x','')                     AS topic0_sig,\n  event_name,\n  arrayMap(x->JSONExtractString(x,'name'),\n           JSONExtractArrayRaw(params))          AS names,\n  arrayMap(x->JSONExtractString(x,'type'),\n           JSONExtractArrayRaw(params))          AS types,\n  arrayMap(x->JSONExtractBool(x,'indexed'),\n           JSONExtractArrayRaw(params))          AS flags\nFROM `dbt`.`event_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n ),\n\nprocess AS (\n  SELECT\n    l.block_number,\n    l.block_timestamp,\n    l.transaction_hash,\n    l.transaction_index,\n    l.log_index,\n    l.address           AS contract_address,\n    a.event_name,\n\n    -- ABI arrays\n    a.names             AS param_names,\n    a.types             AS param_types,\n    a.flags             AS param_flags,\n    length(a.types)     AS n_params,\n\n    -- topics and data\n    [l.topic1, l.topic2, l.topic3]       AS raw_topics,\n    replaceAll(l.data,'0x','')           AS data_hex,\n\n    -- non-indexed metadata (zip flags/types/positions, then filter non-indexed)\n    arrayFilter((f,t,i) -> not f,\n      arrayZip(a.flags, a.types, range(n_params))\n    )                                    AS ni_meta,\n\n    arrayMap(x -> x.2, ni_meta)          AS ni_types,\n    arrayMap(x -> x.3, ni_meta)          AS ni_positions,\n\n    -- head words (32-byte) from start of the data head area\n    arrayMap(i ->\n      if(i*64 < length(data_hex),\n         substring(data_hex, 1 + i*64, 64),\n         NULL),\n      range(greatest(length(ni_types), 1) * 16)  -- generous upper bound\n    )                                    AS data_words,\n\n    -- base type for arrays (strip [])\n    arrayMap(j -> replaceRegexpOne(ni_types[j+1], '\\\\[\\\\]$', ''), range(length(ni_types))) AS ni_base_types,\n\n    /* ===================== DECODING ====================== */\n    -- For each non-indexed param j return a STRING:\n    --  - Arrays -> toJSONString(Array(String))\n    --  - Dynamic scalars -> String (hex or utf8)\n    --  - Static scalars -> String\n    arrayMap(j ->\n      if(\n        /* -------- ARRAY TYPES -------- */\n        endsWith(ni_types[j+1],'[]'),\n\n        /* Build JSON string of the fully decoded array */\n        toJSONString(\n          arrayMap(\n            k ->\n              multiIf(\n                ni_base_types[j+1] = 'address',\n                  concat(\n                    '0x',\n                    substring(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64 + 64 + (k + 1) * 64\n                      ),\n                      (64 + k*64) + 25, 40\n                    )\n                  ),\n\n                ni_base_types[j+1] = 'bytes32',\n                  concat(\n                    '0x',\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                      64\n                    )\n                  ),\n\n                startsWith(ni_base_types[j+1], 'uint') OR startsWith(ni_base_types[j+1], 'int'),\n                  toString(\n                    reinterpretAsUInt256(\n                      reverse(\n                        unhex(\n                          substring(\n                            data_hex,\n                            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                            64\n                          )\n                        )\n                      )\n                    )\n                  ),\n\n                /* Fallback: full 32-byte hex */\n                concat(\n                  '0x',\n                  substring(\n                    data_hex,\n                    1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64 + k*64,\n                    64\n                  )\n                )\n              ),\n            /* range(N) where N is array length at base */\n            range(\n              toUInt32(\n                reinterpretAsUInt256(\n                  reverse(\n                    unhex(\n                      substring(\n                        data_hex,\n                        1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                        64\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n\n        /* -------- DYNAMIC SCALARS (string/bytes/bytesN\u226032) -------- */\n        if(\n          ni_types[j+1] = 'bytes'\n          OR ni_types[j+1] = 'string'\n          OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'),\n\n          /* payload = hex of exactly len bytes; strings converted later */\n          substring(\n            data_hex,\n            1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2 + 64,\n            toUInt32(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    substring(\n                      data_hex,\n                      1 + toUInt32(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))) * 2,\n                      64\n                    )\n                  )\n                )\n              )\n            ) * 2\n          ),\n\n          /* -------- STATIC SCALARS -------- */\n          if(\n            data_words[j+1] IS NOT NULL,\n            multiIf(\n              ni_types[j+1] = 'bytes32',\n                concat('0x', data_words[j+1]),\n\n              ni_types[j+1] = 'address',\n                concat('0x', substring(data_words[j+1], 25, 40)),\n\n              startsWith(ni_types[j+1],'uint') OR startsWith(ni_types[j+1],'int'),\n                toString(reinterpretAsUInt256(reverse(unhex(data_words[j+1])))),\n\n              NULL\n            ),\n            NULL\n          )\n        )\n      ),\n      range(length(ni_types))\n    ) AS raw_values_str,\n\n    -- Human-friendly normalization to STRING:\n    -- - Arrays already JSON strings: pass through\n    -- - Strings: hex \u2192 utf8 (remove NULs)\n    -- - Bytes/bytesN: ensure 0x prefix\n    arrayMap(j ->\n      multiIf(\n        endsWith(ni_types[j+1],'[]') AND raw_values_str[j+1] IS NOT NULL,\n          raw_values_str[j+1],\n\n        ni_types[j+1] = 'string' AND raw_values_str[j+1] IS NOT NULL,\n          replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[j+1])),'\\0',''),\n\n        ((ni_types[j+1] = 'bytes') OR (startsWith(ni_types[j+1],'bytes') AND ni_types[j+1] != 'bytes32'))\n          AND raw_values_str[j+1] IS NOT NULL,\n          concat('0x', raw_values_str[j+1]),\n\n        /* else */\n        raw_values_str[j+1]\n      ),\n      range(length(ni_types))\n    ) AS decoded_ni_values,\n\n    -- positions of indexed params (0-based positions into the param list)\n    arrayMap(x -> x.3,\n      arrayFilter((f,t,i) -> f, arrayZip(a.flags, a.types, range(n_params)))\n    ) AS indexed_positions,\n\n    -- stitch back into full order (correct topic index using 1-based indexOf)\n    arrayMap(i ->\n      if(\n        param_flags[i+1],\n        /* k1 is 1-based; 0 means not found */\n        multiIf(\n          indexOf(indexed_positions, i) = 0,\n            NULL,\n          param_types[i+1] = 'address',\n            concat(\n              '0x',\n              substring(\n                replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n                25, 40\n              )\n            ),\n          startsWith(param_types[i+1],'uint') OR startsWith(param_types[i+1],'int'),\n            toString(\n              reinterpretAsUInt256(\n                reverse(\n                  unhex(\n                    replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x','')\n                  )\n                )\n              )\n            ),\n          /* default: bytes32/topic hash as 0x + 64 hex chars */\n          concat(\n            '0x',\n            substring(\n              replaceAll(arrayElement(raw_topics, indexOf(indexed_positions, i)), '0x',''),\n              1, 64\n            )\n          )\n        ),\n        /* non-indexed: pick correct decoded value */\n        decoded_ni_values[indexOf(ni_positions, i)]\n      ),\n      range(n_params)\n    ) AS param_values,\n\n    -- final JSON or map (all values are full strings; arrays are JSON strings)\n    \n      mapFromArrays(param_names, param_values) AS decoded_params\n    \n\n  FROM logs AS l\n  ANY LEFT JOIN abi AS a\n    --ON l.topic0 = concat('0x', a.topic0_sig)\n    ON replaceAll(l.topic0,'0x','') = a.topic0_sig\n)\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  transaction_index,\n  log_index,\n  contract_address,\n  event_name,\n  decoded_params\nFROM process\n", "relation_name": "`dbt`.`contracts_wxdai_events`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.618804Z", "completed_at": "2025-10-24T12:23:13.625481Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.626043Z", "completed_at": "2025-10-24T12:23:13.626051Z"}], "thread_id": "Thread-1", "execution_time": 0.008460760116577148, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_AgentResultMapping_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2025-06-30'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_AgentResultMapping_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '99c43743a2dbd406160cc43cf08113b17178789c'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_AgentResultMapping_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.628642Z", "completed_at": "2025-10-24T12:23:13.633931Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.634517Z", "completed_at": "2025-10-24T12:23:13.634525Z"}], "thread_id": "Thread-1", "execution_time": 0.007100820541381836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_ConditionalTokens_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-01'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_ConditionalTokens_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'ceafdd6bc0bef976fdcd1112955828e00543c0ce'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_ConditionalTokens_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.637089Z", "completed_at": "2025-10-24T12:23:13.642328Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.642992Z", "completed_at": "2025-10-24T12:23:13.643001Z"}], "thread_id": "Thread-1", "execution_time": 0.00713038444519043, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_FPMMDeterministicFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2020-09-04'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_FPMMDeterministicFactory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '9083a2b699c0a4ad06f63580bde2635d26a3eef0'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_FPMMDeterministicFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.645597Z", "completed_at": "2025-10-24T12:23:13.650771Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.651356Z", "completed_at": "2025-10-24T12:23:13.651364Z"}], "thread_id": "Thread-1", "execution_time": 0.006978273391723633, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_GBCDeposit_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_GBCDeposit_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '0b98057ea310f4d31f2a452b414647007d1645d9'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_GBCDeposit_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.653949Z", "completed_at": "2025-10-24T12:23:13.659176Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.659758Z", "completed_at": "2025-10-24T12:23:13.659766Z"}], "thread_id": "Thread-1", "execution_time": 0.0070455074310302734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_OmenAgentResultMapping_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-09-30'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_OmenAgentResultMapping_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '260e1077dea98e738324a6cefb0ee9a272ed471a'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_OmenAgentResultMapping_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.662413Z", "completed_at": "2025-10-24T12:23:13.667938Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.668528Z", "completed_at": "2025-10-24T12:23:13.668536Z"}], "thread_id": "Thread-1", "execution_time": 0.007345914840698242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Realitio_v2_1_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2021-01-13'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Realitio_v2_1_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '79e32ae03fb27b07c89c0c568f80287c01ca2e57'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Realitio_v2_1_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.671102Z", "completed_at": "2025-10-24T12:23:13.677614Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.678180Z", "completed_at": "2025-10-24T12:23:13.678204Z"}], "thread_id": "Thread-1", "execution_time": 0.008324623107910156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_MarketFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-10-08'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Seer_MarketFactory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '83183da839ce8228e31ae41222ead9edbb5cdcf1'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_MarketFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.680789Z", "completed_at": "2025-10-24T12:23:13.686063Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.686648Z", "completed_at": "2025-10-24T12:23:13.686656Z"}], "thread_id": "Thread-1", "execution_time": 0.0070819854736328125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Seer_Wrapped1155Factory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2024-02-07'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Seer_Wrapped1155Factory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'd194319d1804c1051dd21ba1dc931ca72410b79f'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Seer_Wrapped1155Factory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.689248Z", "completed_at": "2025-10-24T12:23:13.694571Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.695132Z", "completed_at": "2025-10-24T12:23:13.695139Z"}], "thread_id": "Thread-1", "execution_time": 0.0071637630462646484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraFactory_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-09-22'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Swapr_v3_AlgebraFactory_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'a0864cca6e114013ab0e27cbd5b6f4c8947da766'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraFactory_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.697760Z", "completed_at": "2025-10-24T12:23:13.702984Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.703571Z", "completed_at": "2025-10-24T12:23:13.703579Z"}], "thread_id": "Thread-1", "execution_time": 0.007034778594970703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_Swapr_v3_AlgebraPool_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n      \n        AND toStartOfMonth(block_timestamp) >= toStartOfMonth(toDateTime('2023-11-30'))\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_Swapr_v3_AlgebraPool_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = '2de7439f52d059e6cadbbeb4527683a94331cf65'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_Swapr_v3_AlgebraPool_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.706132Z", "completed_at": "2025-10-24T12:23:13.711301Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.711866Z", "completed_at": "2025-10-24T12:23:13.711874Z"}], "thread_id": "Thread-1", "execution_time": 0.006952524185180664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.contracts_wxdai_calls", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n\n\n\nWITH\n  tx AS (\n    SELECT *\n    FROM `execution`.`transactions`\n    WHERE replaceAll(lower(to_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n      \n      \n        AND block_timestamp >\n            (SELECT coalesce(max(block_timestamp), '1970-01-01') FROM `dbt`.`contracts_wxdai_calls`)\n      \n      AND length(replaceAll(coalesce(input,''),'0x','')) >= 8\n  ),\n  abi AS ( \nSELECT\n    substring(signature,1,8) AS selector,\n    function_name,\n    arraySort(x -> toInt32OrZero(JSONExtractRaw(x,'position')),\n              ifNull(JSONExtractArrayRaw(input_params), emptyArrayString())) AS params_raw,\n    arrayMap(x -> JSONExtractString(x,'name'), params_raw) AS names,\n    arrayMap(x -> JSONExtractString(x,'type'), params_raw) AS types\nFROM `dbt`.`function_signatures`\nWHERE replaceAll(lower(contract_address),'0x','') = 'e91d153e0b41518a2ce8dd3d7944fa863463a97d'\n ),\n\n  process AS (\n    SELECT\n      t.block_number,\n      t.block_timestamp,\n      t.transaction_hash,\n      t.nonce,\n      t.gas_price,\n      t.value_string AS value,\n      a.function_name,\n      substring(replaceAll(t.input,'0x',''),1,8) AS call_selector,\n      substring(replaceAll(t.input,'0x',''),9)   AS args_raw_hex,\n      a.names      AS param_names,\n      a.types      AS param_types,\n      a.params_raw AS param_objs,\n      length(a.types) AS n_params,\n\n      arrayMap(i -> if(i*64 < length(args_raw_hex), substring(args_raw_hex, 1 + i*64, 64), NULL),\n               range(greatest(length(param_types),1)*16)) AS head_words,\n\n      arrayMap(i -> replaceRegexpOne(param_types[i+1], '\\\\[\\\\]$', ''), range(length(param_types))) AS base_types,\n\n      arrayMap(i ->\n        if(i >= n_params, NULL,\n          if(param_types[i+1] = 'tuple',\n            toJSONString(\n              mapFromArrays(\n                arrayMap(c -> coalesce(JSONExtractString(c,'name'),''),\n                         ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                arrayMap(j ->\n                  if(\n                    endsWith(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ),\n                      '[]'\n                    ),\n                    toJSONString([]),\n                    if(\n                      arrayElement(\n                        arrayMap(c -> coalesce(JSONExtractString(c,'type'),''),\n                                 ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString())),\n                        j+1\n                      ) = 'address',\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      concat('0x',\n                        substring(\n                          args_raw_hex,\n                          (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + j*64,\n                          64\n                        )\n                      )\n                    )\n                  ),\n                  range(\n                    length(ifNull(JSONExtractArrayRaw(arrayElement(param_objs,i+1),'components'), emptyArrayString()))\n                  )\n                )\n              )\n            ),\n            if(endsWith(param_types[i+1],'[]'),\n              toJSONString(\n                if(\n                  base_types[i+1] = 'string',\n                    arrayMap(k ->\n                      replaceRegexpAll(\n                        reinterpretAsString(unhex(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                              + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                  substring(args_raw_hex,\n                                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                            64)\n                              )))) * 2\n                              + 64,\n                            toUInt64(reinterpretAsUInt256(reverse(unhex(\n                              substring(args_raw_hex,\n                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2)\n                                          + toUInt64(reinterpretAsUInt256(reverse(unhex(\n                                              substring(args_raw_hex,\n                                                        (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                                                        64)\n                                          )))) * 2,\n                                        64)\n                            )))) * 2\n                          )\n                        )),\n                        '\\0',''\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                  if(\n                    base_types[i+1] = 'address',\n                    arrayMap(k ->\n                      concat('0x',\n                        substring(\n                          substring(\n                            args_raw_hex,\n                            (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64 + k*64,\n                            64\n                          ),\n                          25, 40\n                        )\n                      ),\n                      range(\n                        toUInt64(reinterpretAsUInt256(reverse(unhex(\n                          substring(args_raw_hex,\n                                    (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2),\n                                    64)\n                        ))))\n                      )\n                    ),\n                    []\n                  )\n                )\n              ),\n              if(\n                (param_types[i+1] = 'bytes') OR (param_types[i+1] = 'string'),\n                substring(\n                  args_raw_hex,\n                  (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2) + 64,\n                  toUInt64(reinterpretAsUInt256(reverse(unhex(\n                    substring(args_raw_hex,\n                              (1 + toUInt64(reinterpretAsUInt256(reverse(unhex(arrayElement(head_words,i+1))))) * 2), 64)\n                  )))) * 2\n                ),\n                if(arrayElement(head_words,i+1) IS NULL, NULL,\n                  if(\n                    param_types[i+1] = 'address',\n                      concat('0x', substring(arrayElement(head_words,i+1), 25, 40)),\n                      concat('0x', arrayElement(head_words,i+1))\n                  )\n                )\n              )\n            )\n          )\n        ),\n        range(n_params)\n      ) AS raw_values_str,\n\n      arrayMap(i ->\n        if(\n          i < n_params AND param_types[i+1] = 'string' AND raw_values_str[i+1] IS NOT NULL,\n            replaceRegexpAll(reinterpretAsString(unhex(raw_values_str[i+1])),'\\0',''),\n          if(\n            i < n_params AND param_types[i+1] = 'bytes' AND raw_values_str[i+1] IS NOT NULL,\n            concat('0x', raw_values_str[i+1]),\n            raw_values_str[i+1]\n          )\n        ),\n        range(n_params)\n      ) AS param_values_str,\n\n      \n        mapFromArrays(param_names, param_values_str) AS decoded_input\n      \n\n    FROM tx AS t\n    ANY LEFT JOIN abi AS a\n      ON substring(replaceAll(t.input,'0x',''),1,8) = a.selector\n  )\n\nSELECT\n  block_number,\n  block_timestamp,\n  transaction_hash,\n  nonce,\n  gas_price,\n  value,\n  function_name,\n  decoded_input\nFROM process\n", "relation_name": "`dbt`.`contracts_wxdai_calls`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.714447Z", "completed_at": "2025-10-24T12:23:13.720749Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.721330Z", "completed_at": "2025-10-24T12:23:13.721337Z"}], "thread_id": "Thread-1", "execution_time": 0.008100748062133789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.stg_crawlers_data__dune_labels", "compiled": true, "compiled_code": "\n\n\nWITH latest AS (\n  SELECT\n    lower(address) AS address,\n    (label, introduced_at) AS agg\n  FROM `crawlers_data`.`dune_labels`\n),\n\nclean AS (\n  SELECT\n    address,\n    tupleElement(agg, 1) AS label_raw,\n    tupleElement(agg, 2) AS introduced_at,\n\n    trim(replaceRegexpAll(tupleElement(agg, 1), '\\\\s*([:/|>])\\\\s*', '\\\\1'))                           AS s1,\n\n    replaceRegexpAll(\n      replaceRegexpAll(s1, '_0x[0-9a-fA-F]{40}$', ''),\n      '_0x[0-9a-fA-F]{1,}\u2026[0-9a-fA-F]{1,}$',\n      ''\n    )                                                                                                AS s2,\n\n    trim(extract(s2, '^([^:/|>]+)'))                                                                 AS s3,\n\n    trim(replaceRegexpAll(s3, '(?:\\\\s*[-_ ]?[Vv]\\\\d+(?:[._-]\\\\d+)*)\\\\b', ''))                        AS s4,\n\n    lowerUTF8(s4)                                                                                    AS s4_l,\n\n    (\n      match(s1, '_0x[0-9a-fA-F]{40}$')\n      OR match(s1, '_0x[0-9a-fA-F]{1,}\u2026[0-9a-fA-F]{1,}$')\n    )                                                                                                AS looks_like_token_tail\n  FROM latest\n),\n\nwl AS (\n  SELECT\n    lower(address) AS address,\n    symbol\n  FROM `dbt`.`tokens_whitelist`\n),\n\nbucketed AS (\n \n  SELECT\n    c.address,\n    c.label_raw,\n    c.introduced_at,\n    c.s4,\n    c.s4_l,\n    c.looks_like_token_tail,\n    w.symbol AS wl_symbol,\n\n    coalesce(\n      if(c.looks_like_token_tail,\n         if(w.symbol IS NOT NULL, w.symbol, 'ERC20'),\n         NULL\n      ),\n\n      multiIf(\n        match(c.s4_l, '^(realtoken|realtokens)\\\\b'),              'REALTOKEN',\n        match(lowerUTF8(c.label_raw), '(^|[^a-z0-9])gnosis[\\\\s_-]*safe(?:l2)?([^a-z0-9]|$)') OR match(c.s4_l, '^(safe(?:l2)?)\\\\b'), 'Safe',\n\n        match(c.s4_l, '(^|[^a-z])balancer([^a-z]|$)'),            'Balancer',\n        match(c.s4_l, '(^|[-_])gaug(e)?(\\\\b|_)'),                 'Balancer',\n        match(c.s4_l, '\\\\b\\\\d{1,3}%[a-z0-9._-]+'),                'Balancer',\n        match(c.s4_l, '\\\\b(w?moo)[a-z0-9]*balancer'),             'Balancer',\n\n        match(c.s4_l, '(^|[^a-z])curve([^a-z]|$)'),               'Curve',\n        match(c.s4_l, '^(yv\\\\s*curve|yvcurve|y\\\\s*curve|ycurve)'), 'Curve',\n        match(c.s4_l, '^curvefi\\\\b'),                             'Curve',\n\n        match(c.s4_l, '\\\\buniswap\\\\b'),                           'Uniswap',\n        match(c.s4_l, '\\\\buni[- _]?v?3\\\\b'),                      'Uniswap',\n        match(c.s4_l, '\\\\buni[- _]?v?2\\\\b'),                      'Uniswap',\n        match(c.s4_l, '\\\\bnonfungiblepositionmanager\\\\b'),        'Uniswap',\n        match(c.s4_l, '\\\\bpositions?\\\\s*nft\\\\b'),                 'Uniswap',\n        match(c.s4_l, '\\\\b(rcow|cow|moo\\\\w*)\\\\s*uniswap'),        'Uniswap',\n\n        match(c.s4_l, 'sushi'),                                   'Sushi',\n\n        match(c.s4_l, '\\\\bswapr\\\\b'),                             'Swapr',\n        match(c.s4_l, '^swaprv?3\\\\b'),                            'Swapr',\n        match(c.s4_l, '\\\\bswpr\\\\b'),                              'Swapr',\n\n        match(c.s4_l, '\\\\bcow\\\\s*swap\\\\b|\\\\bcow[_\\\\s-]?protocol\\\\b|^b_cow_amm\\\\b'), 'CowSwap',\n        match(c.s4_l, '^aave\\\\b'),                                'Aave',\n        match(c.s4_l, '\\\\baave\\\\s*v?2\\\\b|\\\\baave\\\\s*v?3\\\\b'),     'Aave',\n        match(c.s4_l, '^aavepool\\\\b'),                            'Aave',\n\n        c.s4\n      )\n    ) AS s5\n  FROM clean c\n  LEFT JOIN wl w\n    ON c.address = w.address\n),\n\ntidy AS (\n  SELECT\n    address,\n    label_raw,\n    introduced_at,\n    trim(\n      replaceRegexpAll(\n        replaceRegexpAll(\n          replaceRegexpAll(\n            left(s5, length(\n              replaceRegexpAll(\n                lowerUTF8(s5),\n                '\\\\b(factory|router|vault|pool|implementation|proxy|token|bridge|aggregator|registry|controller|manager|oracle|staking|treasury|multisig|gnosis\\\\s*safe|deployer|fee\\\\s*collector|minter|burner|timelock|governor|council|rewards?|distributor|airdrop)s?\\\\s*$',\n                ''\n              )\n            )),\n            '\\\\s*\\\\([^)]*\\\\)\\\\s*$', ''\n          ),\n          '\\\\?+$', ''\n        ),\n        '[_\\\\s-]+', ' '\n      )\n    ) AS s7\n  FROM bucketed\n),\n\ncanon AS (\n  SELECT\n    address,\n    label_raw,\n    introduced_at,\n    s7,\n    multiIf(\n      match(lowerUTF8(s7), '^unlock(\\\\s*protocol)?$'),                        'Unlock Protocol',\n      match(lowerUTF8(s7), '^(eth\\\\s*swarm|ethereum\\\\s*swarm|swarm)$'),       'Swarm',\n      match(lowerUTF8(s7), '^symmetric(\\\\s*finance)?$'),                      'Symmetric',\n      match(lowerUTF8(s7), '^elk(\\\\s*finance)?$'),                            'Elk Finance',\n      match(lowerUTF8(s7), '^monerium(\\\\s*(usde|iske|blacklist))?$'),         'Monerium',\n      match(lowerUTF8(s7), '^gnosis\\\\s*pay(\\\\s*(vip|spender|eiffel))?$|^gnosispay$'), 'Gnosis Pay',\n      match(lowerUTF8(s7), '^hopr(\\\\s*(protocol|network|token|boost\\\\s*nft))?$'),    'HOPR',\n      match(lowerUTF8(s7), '^kleros(\\\\s*curate)?$'),                          'Kleros',\n      match(lowerUTF8(s7), '^sismo(\\\\s*(badges|roots))?$'),                   'Sismo',\n      match(lowerUTF8(s7), '^request(\\\\s*network)?$'),                        'Request Network',\n      match(lowerUTF8(s7), '^event\\\\s*sbt(\\\\s*\\\\(esbt\\\\)\\\\s*test)?$'),        'EventSBT',\n      match(lowerUTF8(s7), '^polkamarkets(\\\\s*aa)?$'),                        'Polkamarkets',\n      match(lowerUTF8(s7), '^everclear.*$'),                                  'Everclear',\n      match(lowerUTF8(s7), '^merkly(\\\\s*farmer)?$'),                          'Merkly',\n      match(lowerUTF8(s7), '^zerion(\\\\s*premium\\\\s*purchaser\\\\s*l2)?$'),      'Zerion',\n      match(lowerUTF8(s7), '^aura(\\\\s*finance)?$'),                           'Aura Finance',\n      match(lowerUTF8(s7), '^open\\\\s*ocean(exchange)?$|^openoceanexchange$'), 'OpenOcean',\n      match(lowerUTF8(s7), '^(amb|.*\\\\sxdai\\\\s*amb)$'),                       'AMB',\n      match(lowerUTF8(s7), '^cow\\\\s*swap$'),                                  'CowSwap',\n      match(lowerUTF8(s7), '^(rmm|real\\\\s*rmm|rmm\\\\s*ecosystem\\\\s*reserve)$'), 'RMM',\n      match(lowerUTF8(s7), '^erc\\\\s*-?\\\\s*4337(\\\\s*entry\\\\s*point)?$'), 'ERC-4337 Entry Point',\n      match(lowerUTF8(s7), '^(aa\\\\s*entrypoint|erc-?4337\\\\s*entry\\\\s*point|entrypointsimulations|pimlicoentrypointsimulations)$'), 'ERC-4337 Entry Point',\n      match(lowerUTF8(s7), '^(uni|uni\\\\s*v?3\\\\s*swaprouter02)$'),                                      'Uniswap',\n      match(lowerUTF8(s7), '^(oneinch)$'),                                                             '1inch',\n      match(lowerUTF8(s7), '^layerzero$'),                                                             'LayerZero',\n      match(lowerUTF8(s7), '^(cowswap|b_cow_amm)$'),                                                   'CowSwap',\n      match(lowerUTF8(s7), '^angle(\\\\s+ageur)?$'),                                                     'Angle',\n      match(lowerUTF8(s7), '^sablier(\\\\s+.*)?$|^sablier\\\\s*flow\\\\b|^sablier\\\\s*lockup\\\\b'),            'Sablier',\n      match(lowerUTF8(s7), '^hats[_\\\\s-]?protocol'),                                                   'Hats Protocol',\n      match(lowerUTF8(s7), '^seaport\\\\??$'),                                                           'Seaport',\n      match(lowerUTF8(s7), '^poap(\\\\s+top)?$'),                                                        'POAP',\n      match(lowerUTF8(s7), '^merkly(\\\\s+onft)?$'),                                                     'Merkly',\n      match(lowerUTF8(s7), '^circles(\\\\s*ubi)?$'),                                                     'Circles',\n      match(lowerUTF8(s7), '^(hop|hop\\\\s*protocol)$'),                                                 'Hop Protocol',\n      match(lowerUTF8(s7), '^opensea$'),                                                               'OpenSea',\n      match(lowerUTF8(s7), '^paraswap$'),                                                              'ParaSwap',\n      match(lowerUTF8(s7), '^realt(oken)?(\\\\s*money\\\\s*market)?$|^realtoken\\\\s*dao$|^realtyam$|^real_rmm$'), 'REALTOKEN',\n      match(lowerUTF8(s7), '^nulladdress$|^burn\\\\s*address$'),                                         'Null/Burn',\n      match(lowerUTF8(s7), '^eoa$'),                                                                   'EOA',\n      match(lowerUTF8(s7), '^proxyadmin$|^transparentupgradeableproxy$|^upgradeablecommunitytoken$|^contractaddressfeehelper$|^controllermodule$'), 'Infrastructure',\n      match(lowerUTF8(s7), '^unnamed$|^oracle\\\\?$|^dex\\\\s*aggregator\\\\?$|^\\\\?$'),                      'Unknown',\n      s7\n    ) AS project_canon\n  FROM tidy\n)\n\nSELECT\n  address,\n  if(\n    lengthUTF8(project_canon) = 0\n    OR positionCaseInsensitive(project_canon, '0x') > 0\n    OR match(label_raw, '_0x[0-9a-fA-F]{40}$')\n    OR match(label_raw, '_0x[0-9a-fA-F]{1,}\u2026[0-9a-fA-F]{1,}$'),\n    'ERC20',\n    project_canon\n  ) AS project,\n  label_raw AS project_raw,\n  introduced_at\nFROM canon", "relation_name": "`dbt`.`stg_crawlers_data__dune_labels`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.724027Z", "completed_at": "2025-10-24T12:23:13.727944Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.728533Z", "completed_at": "2025-10-24T12:23:13.728541Z"}], "thread_id": "Thread-1", "execution_time": 0.005822420120239258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_attestations_daily", "compiled": true, "compiled_code": "\nSELECT\n    date\n    ,inclusion_delay\n    ,cnt\nFROM `dbt`.`int_consensus_attestations_daily`\nORDER BY date, inclusion_delay", "relation_name": "`dbt`.`api_consensus_attestations_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.731117Z", "completed_at": "2025-10-24T12:23:13.734871Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.735450Z", "completed_at": "2025-10-24T12:23:13.735458Z"}], "thread_id": "Thread-1", "execution_time": 0.005600452423095703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_blob_commitments_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,cnt AS value\nFROM `dbt`.`int_consensus_blob_commitments_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_blob_commitments_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.738013Z", "completed_at": "2025-10-24T12:23:13.741843Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.742433Z", "completed_at": "2025-10-24T12:23:13.742440Z"}], "thread_id": "Thread-1", "execution_time": 0.005634307861328125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_graffiti_label_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,SUM(cnt) AS value\nFROM `dbt`.`int_consensus_graffiti_daily`\nGROUP BY date, label\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_graffiti_label_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.744995Z", "completed_at": "2025-10-24T12:23:13.748843Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.749418Z", "completed_at": "2025-10-24T12:23:13.749425Z"}], "thread_id": "Thread-1", "execution_time": 0.0056383609771728516, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_graffiti_cloud", "compiled": true, "compiled_code": "\n\n\nWITH base AS (\n  SELECT\n      graffiti,\n      sumIf(cnt, date >= today() - 7)  AS v_7d,\n      sumIf(cnt, date >= today() - 30) AS v_30d,\n      sumIf(cnt, date >= today() - 90) AS v_90d,\n      sum(cnt)                         AS v_all\n  FROM `dbt`.`int_consensus_graffiti_daily`\n  WHERE graffiti != 'None'\n  GROUP BY graffiti\n)\nSELECT\n  label,\n  graffiti,\n  value\nFROM base\nARRAY JOIN\n  ['7D','30D','90D','All'] AS label,\n  [v_7d, v_30d, v_90d, v_all] AS value\nORDER BY label, value DESC\nLIMIT 50 BY label", "relation_name": "`dbt`.`fct_consensus_graffiti_cloud`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.752051Z", "completed_at": "2025-10-24T12:23:13.755936Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.756510Z", "completed_at": "2025-10-24T12:23:13.756518Z"}], "thread_id": "Thread-1", "execution_time": 0.005690574645996094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_forks", "compiled": true, "compiled_code": "\n\nSELECT\n  fork_name\n  ,fork_version \n  ,fork_digest\n  ,fork_epoch \nFROM `dbt`.`fct_consensus_forks`\nORDER BY fork_version ASC", "relation_name": "`dbt`.`api_consensus_forks`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.759125Z", "completed_at": "2025-10-24T12:23:13.764447Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.764999Z", "completed_at": "2025-10-24T12:23:13.765007Z"}], "thread_id": "Thread-1", "execution_time": 0.00708317756652832, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_blocks_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,label\n    ,value\nFROM (\n    SELECT date, 'produced' AS label, blocks_produced AS value FROM `dbt`.`int_consensus_blocks_daily`\n    UNION ALL \n    SELECT date, 'missed' AS label, blocks_missed AS value FROM `dbt`.`int_consensus_blocks_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_blocks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.767594Z", "completed_at": "2025-10-24T12:23:13.771353Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.771909Z", "completed_at": "2025-10-24T12:23:13.771916Z"}], "thread_id": "Thread-1", "execution_time": 0.005543708801269531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_credentials_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,credentials_type\n    ,cnt\n    ,ROUND(cnt/(SUM(cnt) OVER (PARTITION BY date)) * 100,2) AS pct \nFROM `dbt`.`int_consensus_credentials_daily`\nORDER BY date, credentials_type", "relation_name": "`dbt`.`api_consensus_credentials_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.774491Z", "completed_at": "2025-10-24T12:23:13.778483Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.779036Z", "completed_at": "2025-10-24T12:23:13.779044Z"}], "thread_id": "Thread-1", "execution_time": 0.005771160125732422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_credentials_latest", "compiled": true, "compiled_code": "\n\nSELECT \n    credentials_type\n    ,cnt\nFROM `dbt`.`int_consensus_credentials_daily`\nWHERE date = (SELECT MAX(date) FROM `dbt`.`int_consensus_credentials_daily`)", "relation_name": "`dbt`.`api_consensus_credentials_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.781619Z", "completed_at": "2025-10-24T12:23:13.785468Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.786026Z", "completed_at": "2025-10-24T12:23:13.786034Z"}], "thread_id": "Thread-1", "execution_time": 0.0056226253509521484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_entry_queue_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,validator_count\n    ,q05\n    ,q10\n    ,q25\n    ,q50\n    ,q75\n    ,q90\n    ,q95\n    ,mean\nFROM `dbt`.`int_consensus_entry_queue_daily`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_entry_queue_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.788600Z", "completed_at": "2025-10-24T12:23:13.792396Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.792946Z", "completed_at": "2025-10-24T12:23:13.792954Z"}], "thread_id": "Thread-1", "execution_time": 0.005559444427490234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_staked_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,effective_balance/32 AS value\nFROM `dbt`.`int_consensus_validators_balances_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_staked_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.795530Z", "completed_at": "2025-10-24T12:23:13.799748Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.800329Z", "completed_at": "2025-10-24T12:23:13.800336Z"}], "thread_id": "Thread-1", "execution_time": 0.006012439727783203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_balances_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,value\nFROM (\n    SELECT\n        date\n        ,'balance' AS label\n        ,balance AS value\n    FROM `dbt`.`int_consensus_validators_balances_daily`\n\n    UNION ALL \n\n    SELECT\n        date\n        ,'eff. balance' AS label\n        ,effective_balance AS value\n    FROM `dbt`.`int_consensus_validators_balances_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_validators_balances_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.802888Z", "completed_at": "2025-10-24T12:23:13.808018Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.808599Z", "completed_at": "2025-10-24T12:23:13.808607Z"}], "thread_id": "Thread-1", "execution_time": 0.006924152374267578, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_balances_dist_daily", "compiled": true, "compiled_code": "\n\n-- in GNO\nSELECT\n    date,\n    q05/32 AS q05,\n    q10/32 AS q10,\n    q25/32 AS q25,\n    q50/32 AS q50,\n    q75/32 AS q75,\n    q90/32 AS q90,\n    q95/32 AS q95\nFROM `dbt`.`int_consensus_validators_balances_dist_daily`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_validators_balances_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.811166Z", "completed_at": "2025-10-24T12:23:13.814887Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.815465Z", "completed_at": "2025-10-24T12:23:13.815472Z"}], "thread_id": "Thread-1", "execution_time": 0.005515575408935547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_active_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,cnt\nFROM `dbt`.`int_consensus_validators_status_daily`\nWHERE status = 'active_ongoing'\nORDER BY date", "relation_name": "`dbt`.`api_consensus_validators_active_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.818015Z", "completed_at": "2025-10-24T12:23:13.821796Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.822392Z", "completed_at": "2025-10-24T12:23:13.822400Z"}], "thread_id": "Thread-1", "execution_time": 0.005608081817626953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_status_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,status\n    ,cnt\nFROM `dbt`.`int_consensus_validators_status_daily`\nWHERE status NOT IN ('active_ongoing', 'withdrawal_done')\nORDER BY date, status", "relation_name": "`dbt`.`api_consensus_validators_status_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.824951Z", "completed_at": "2025-10-24T12:23:13.828771Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.829340Z", "completed_at": "2025-10-24T12:23:13.829348Z"}], "thread_id": "Thread-1", "execution_time": 0.005600690841674805, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_apy_dist", "compiled": true, "compiled_code": "\n\nSELECT\n    date,\n    q05,\n    q10,\n    q25,\n    q50,\n    q75,\n    q90,\n    q95 \nFROM `dbt`.`int_consensus_validators_apy_dist`\nORDER BY date ASC", "relation_name": "`dbt`.`api_consensus_validators_apy_dist`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.831868Z", "completed_at": "2025-10-24T12:23:13.835623Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.836171Z", "completed_at": "2025-10-24T12:23:13.836178Z"}], "thread_id": "Thread-1", "execution_time": 0.005521297454833984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_withdrawls_dist_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,q05\n    ,q10\n    ,q25\n    ,q50\n    ,q75\n    ,q90\n    ,q95\nFROM \n    `dbt`.`int_consensus_withdrawls_dist_daily`\nORDER BY date", "relation_name": "`dbt`.`api_consensus_withdrawls_dist_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.838781Z", "completed_at": "2025-10-24T12:23:13.842855Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.843431Z", "completed_at": "2025-10-24T12:23:13.843439Z"}], "thread_id": "Thread-1", "execution_time": 0.005857706069946289, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_deposits_withdrawls_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,'withdrawls' AS label\n    ,cnt\n    ,total_amount\nFROM \n    `dbt`.`int_consensus_withdrawls_dist_daily`\n\nUNION ALL\n\nSELECT\n    date\n    ,'deposits' AS label\n    ,cnt\n    ,total_amount\nFROM \n    `dbt`.`int_consensus_deposits_daily`", "relation_name": "`dbt`.`fct_consensus_deposits_withdrawls_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.846103Z", "completed_at": "2025-10-24T12:23:13.851422Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.851991Z", "completed_at": "2025-10-24T12:23:13.851998Z"}], "thread_id": "Thread-1", "execution_time": 0.0071811676025390625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_blocks_clients_daily", "compiled": true, "compiled_code": "\n\n\nWITH\n\nclients_blocks AS (\n    SELECT\n        date\n        ,client\n        ,SUM(cnt) AS cnt\n    FROM `dbt`.`int_execution_blocks_clients_version_daily`\n    WHERE date < today()\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,client\n    ,cnt\n    ,cnt/(SUM(cnt) OVER (PARTITION BY date)) AS fraq\nFROM \n    clients_blocks", "relation_name": "`dbt`.`fct_execution_blocks_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.854701Z", "completed_at": "2025-10-24T12:23:13.858537Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.859094Z", "completed_at": "2025-10-24T12:23:13.859101Z"}], "thread_id": "Thread-1", "execution_time": 0.00563812255859375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_gas_usage_pct_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  ROUND(gas_used_fraq * 100, 2) AS value\nFROM `dbt`.`int_execution_blocks_gas_usage_daily`\nWHERE date < today()   \nORDER BY date", "relation_name": "`dbt`.`api_execution_blocks_gas_usage_pct_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.861678Z", "completed_at": "2025-10-24T12:23:13.865509Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.866065Z", "completed_at": "2025-10-24T12:23:13.866073Z"}], "thread_id": "Thread-1", "execution_time": 0.005606651306152344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_blocks_gas_usage_monthly", "compiled": true, "compiled_code": "\n\nWITH monthly AS (\n  SELECT\n    date_trunc('month', date) AS month,\n    SUM(gas_used_sum)         AS gas_used_sum_monthly,\n    SUM(gas_limit_sum)        AS gas_limit_sum_monthly\n  FROM `dbt`.`int_execution_blocks_gas_usage_daily`\n  GROUP BY month\n)\nSELECT\n  month,\n  gas_used_sum_monthly,\n  gas_limit_sum_monthly,\n  gas_used_sum_monthly / NULLIF(gas_limit_sum_monthly, 0) AS used\nFROM monthly", "relation_name": "`dbt`.`fct_execution_blocks_gas_usage_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.868735Z", "completed_at": "2025-10-24T12:23:13.872575Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.873131Z", "completed_at": "2025-10-24T12:23:13.873139Z"}], "thread_id": "Thread-1", "execution_time": 0.005658626556396484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_state_full_size_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,SUM(bytes_diff) OVER (ORDER BY date ASC) AS bytes\nFROM `dbt`.`int_execution_state_size_full_diff_daily`\nWHERE date < today()", "relation_name": "`dbt`.`fct_execution_state_full_size_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.875784Z", "completed_at": "2025-10-24T12:23:13.879580Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.880135Z", "completed_at": "2025-10-24T12:23:13.880143Z"}], "thread_id": "Thread-1", "execution_time": 0.005591869354248047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_cnt_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,n_txs AS value\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.882725Z", "completed_at": "2025-10-24T12:23:13.886625Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.887204Z", "completed_at": "2025-10-24T12:23:13.887211Z"}], "thread_id": "Thread-1", "execution_time": 0.005694389343261719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_cnt_total", "compiled": true, "compiled_code": "\n\nSELECT\n    transaction_type\n    ,SUM(n_txs) AS value\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nGROUP BY transaction_type\nORDER BY transaction_type", "relation_name": "`dbt`.`api_execution_transactions_cnt_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.889782Z", "completed_at": "2025-10-24T12:23:13.894847Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.895420Z", "completed_at": "2025-10-24T12:23:13.895428Z"}], "thread_id": "Thread-1", "execution_time": 0.00684809684753418, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_gas_used_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,gas_used\n    ,gas_price_avg\n    ,gas_price_median\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_gas_used_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.897975Z", "completed_at": "2025-10-24T12:23:13.901749Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.902330Z", "completed_at": "2025-10-24T12:23:13.902338Z"}], "thread_id": "Thread-1", "execution_time": 0.005568027496337891, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_value_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,transaction_type\n    ,xdai_value \n    ,xdai_value_avg \n    ,xdai_value_median\nFROM `dbt`.`int_execution_transactions_info_daily`\nWHERE success = 1\nORDER BY date, transaction_type", "relation_name": "`dbt`.`api_execution_transactions_value_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.904904Z", "completed_at": "2025-10-24T12:23:13.910435Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.910991Z", "completed_at": "2025-10-24T12:23:13.910998Z"}], "thread_id": "Thread-1", "execution_time": 0.0073049068450927734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_clients_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,argMax(IF(client='','Unknown',client),visit_ended_at) AS client\n        ,argMax(platform,visit_ended_at) AS platform\n        ,argMax(generic_provider,visit_ended_at) AS generic_provider\n        ,argMax(peer_country,visit_ended_at) AS peer_country\n    FROM `dbt`.`int_p2p_discv4_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_p2p_discv4_clients_daily` AS t\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_p2p_discv4_clients_daily` AS t2\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT date , 'Clients' AS metric, client AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Platform' AS metric, platform AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Provider' AS metric, generic_provider AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Country' AS metric, peer_country AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv4_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.913762Z", "completed_at": "2025-10-24T12:23:13.919122Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.919703Z", "completed_at": "2025-10-24T12:23:13.919710Z"}], "thread_id": "Thread-1", "execution_time": 0.007163047790527344, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv4_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\n-- 1) First CTE: basic peer info\ngnosis_peers AS (\n    SELECT \n        peer_id,\n        ip,\n        any(client) AS client\n    FROM `dbt`.`int_p2p_discv4_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) = today() - INTERVAL 1 DAY\n        AND empty(dial_errors) = 1\n        AND crawl_error IS NULL\n    GROUP BY\n        peer_id,\n        ip\n),\n\n-- 2) Second CTE: attach discovery_id_prefix to each peer\ngnosis_prefixes AS (\n    SELECT \n        d.discovery_id_prefix,\n        d.peer_id,\n        p.ip,\n        IF(p.client='', 'Unknown', p.client) AS client\n    FROM `dbt`.`stg_nebula_discv4__discovery_id_prefixes_x_peer_ids` AS d\n    INNER JOIN gnosis_peers AS p\n      ON p.peer_id = d.peer_id\n)\n\nSELECT\n    t1.date,\n\n    -- Peer columns from the subquery t1\n    t1.peer_ip,\n    t1.peer_discovery_id_prefix,\n    t1.peer_client,\n\n    -- Geographical info for peer (from crawlers_data.ipinfo)\n    peer_info.hostname   AS peer_hostname,\n    peer_info.city       AS peer_city,\n    peer_info.country    AS peer_country,\n    peer_info.org        AS peer_org,\n    peer_info.loc        AS peer_loc,\n\n    -- Neighbor columns from subquery t1\n    t1.neighbor_ip,\n    t1.neighbor_discovery_id_prefix,\n    t1.neighbor_client,\n\n    -- Geographical info for neighbor (from crawlers_data.ipinfo)\n    neighbor_info.city    AS neighbor_city,\n    neighbor_info.country AS neighbor_country,\n    neighbor_info.org     AS neighbor_org,\n    neighbor_info.loc     AS neighbor_loc,\n\n    -- Finally, the count of edges\n    t1.cnt\nFROM (\n    SELECT\n        toStartOfDay(n.crawl_created_at) AS date,\n\n        -- \u201cPeer\u201d side of the edge\n        peer_p.ip                      AS peer_ip,\n        peer_p.discovery_id_prefix     AS peer_discovery_id_prefix,\n        peer_p.client                  AS peer_client,\n\n        -- \u201cNeighbor\u201d side of the edge\n        neighbor_p.ip                      AS neighbor_ip,\n        neighbor_p.discovery_id_prefix     AS neighbor_discovery_id_prefix,\n        neighbor_p.client                  AS neighbor_client,\n\n        COUNT(*) AS cnt\n    FROM `dbt`.`stg_nebula_discv4__neighbors` AS n\n\n    -- join to get the discovery_prefix + client/fork info for \u201cpeer\u201d\n    INNER JOIN gnosis_prefixes AS peer_p\n      ON peer_p.discovery_id_prefix = n.peer_discovery_id_prefix\n\n    -- join to get the discovery_prefix + client/fork info for \u201cneighbor\u201d\n    INNER JOIN gnosis_prefixes AS neighbor_p\n      ON neighbor_p.discovery_id_prefix = n.neighbor_discovery_id_prefix\n\n    WHERE\n        toStartOfDay(n.crawl_created_at) = today() - INTERVAL 1 DAY\n\n    GROUP BY\n        date,\n        peer_p.ip,\n        peer_p.discovery_id_prefix,\n        peer_p.client,\n        neighbor_p.ip,\n        neighbor_p.discovery_id_prefix,\n        neighbor_p.client\n) AS t1\n\n-- LEFT JOIN to ipinfo for \u201cpeer\u201d\nLEFT JOIN  `dbt`.`stg_crawlers_data__ipinfo` AS peer_info\n  ON peer_info.ip = t1.peer_ip\n\n-- LEFT JOIN to ipinfo for \u201cneighbor\u201d\nLEFT JOIN  `dbt`.`stg_crawlers_data__ipinfo` AS neighbor_info\n  ON neighbor_info.ip = t1.neighbor_ip", "relation_name": "`dbt`.`int_p2p_discv4_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.922288Z", "completed_at": "2025-10-24T12:23:13.931743Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.932330Z", "completed_at": "2025-10-24T12:23:13.932338Z"}], "thread_id": "Thread-1", "execution_time": 0.011274576187133789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_population_chao1", "compiled": true, "compiled_code": "\n\nWITH peer_connection_analysis AS (\n    SELECT\n        toDate(visit_ended_at) AS observation_date,\n        peer_id,\n        crawl_id,\n        \n        -- Categorize connection attempts\n        CASE \n            WHEN empty(dial_errors) = 1 AND crawl_error IS NULL THEN 'successful'\n            WHEN empty(dial_errors) = 0 OR crawl_error IS NOT NULL THEN 'failed'\n            ELSE 'unknown'\n        END AS connection_status,\n        \n        -- More granular failure analysis\n        CASE \n            WHEN empty(dial_errors) = 1 AND crawl_error IS NULL THEN 'successful'\n            WHEN crawl_error LIKE '%timeout%' THEN 'timeout'\n            WHEN crawl_error LIKE '%refused%' OR crawl_error LIKE '%connection refused%' THEN 'refused' \n            WHEN crawl_error LIKE '%unreachable%' THEN 'unreachable'\n            WHEN crawl_error LIKE '%protocol%' THEN 'protocol_mismatch'\n            WHEN NOT empty(dial_errors) THEN 'dial_error'\n            ELSE 'other_failure'\n        END AS failure_type\n        \n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(t.observation_date))\n      FROM `dbt`.`int_esg_node_population_chao1` AS t\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(t2.observation_date, 'UTC'))\n      FROM `dbt`.`int_esg_node_population_chao1` AS t2\n    )\n  \n\n),\n\n-- Chao-1 for successful connections only\nsuccessful_chao1 AS (\n    SELECT\n        observation_date,\n        peer_id,\n        COUNT(DISTINCT crawl_id) AS times_observed\n    FROM peer_connection_analysis\n    WHERE connection_status = 'successful'\n    \n        AND observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nsuccessful_stats AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS s_obs_successful,\n        SUM(CASE WHEN times_observed = 1 THEN 1 ELSE 0 END) AS f1_successful,\n        SUM(CASE WHEN times_observed = 2 THEN 1 ELSE 0 END) AS f2_successful\n    FROM successful_chao1\n    GROUP BY observation_date\n),\n\n-- Chao-1 for ALL connection attempts (successful + failed)\nall_attempts_chao1 AS (\n    SELECT\n        observation_date,\n        peer_id,\n        COUNT(DISTINCT crawl_id) AS times_observed\n    FROM peer_connection_analysis\n    \n        WHERE observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nall_attempts_stats AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS s_obs_all,\n        SUM(CASE WHEN times_observed = 1 THEN 1 ELSE 0 END) AS f1_all,\n        SUM(CASE WHEN times_observed = 2 THEN 1 ELSE 0 END) AS f2_all\n    FROM all_attempts_chao1\n    GROUP BY observation_date\n),\n\n-- Additional peers known from failed connections\npeer_status_summary AS (\n    SELECT\n        observation_date,\n        peer_id,\n        MAX(CASE WHEN connection_status = 'successful' THEN 1 ELSE 0 END) AS had_success,\n        MAX(CASE WHEN connection_status = 'failed' THEN 1 ELSE 0 END) AS had_failure\n    FROM peer_connection_analysis\n    \n        WHERE observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, peer_id\n),\n\nfailed_only_peers AS (\n    SELECT\n        observation_date,\n        COUNT(DISTINCT peer_id) AS peers_with_only_failures\n    FROM peer_status_summary\n    WHERE had_failure = 1 AND had_success = 0\n    GROUP BY observation_date\n),\n\n-- Connection success rates by failure type\nfailure_analysis AS (\n    SELECT\n        observation_date,\n        failure_type,\n        COUNT(DISTINCT peer_id) AS peer_count,\n        COUNT(*) AS attempt_count,\n        \n        -- Estimate reachability probability based on failure type\n        CASE failure_type\n            WHEN 'timeout' THEN 0.3      -- Sometimes reachable\n            WHEN 'refused' THEN 0.1      -- Rarely reachable (firewall/NAT)\n            WHEN 'unreachable' THEN 0.05 -- Very rarely reachable\n            WHEN 'protocol_mismatch' THEN 0.8  -- Likely reachable with right protocol\n            WHEN 'dial_error' THEN 0.2   -- Sometimes reachable\n            ELSE 0.1\n        END AS estimated_reachability_prob\n        \n    FROM peer_connection_analysis\n    WHERE connection_status = 'failed'\n    \n        AND observation_date > (SELECT MAX(observation_date) FROM `dbt`.`int_esg_node_population_chao1`)\n    \n    GROUP BY observation_date, failure_type\n),\n\n-- Calculate enhanced estimates\nenhanced_calculations AS (\n    SELECT\n        COALESCE(s.observation_date, a.observation_date) AS observation_date,\n        \n        -- Successful connection metrics\n        COALESCE(s.s_obs_successful, 0) AS observed_successful_nodes,\n        CASE\n            WHEN COALESCE(s.f2_successful, 0) > 0 THEN \n                COALESCE(s.s_obs_successful, 0) + toFloat64(s.f1_successful * (s.f1_successful - 1)) / (2.0 * toFloat64(s.f2_successful + 1))\n            WHEN COALESCE(s.f1_successful, 0) > 0 THEN \n                COALESCE(s.s_obs_successful, 0) + toFloat64(s.f1_successful * (s.f1_successful - 1)) / 2.0\n            ELSE \n                toFloat64(COALESCE(s.s_obs_successful, 0))\n        END AS chao1_successful,\n        \n        -- All attempt metrics  \n        COALESCE(a.s_obs_all, 0) AS observed_total_peers,\n        CASE\n            WHEN COALESCE(a.f2_all, 0) > 0 THEN \n                COALESCE(a.s_obs_all, 0) + toFloat64(a.f1_all * (a.f1_all - 1)) / (2.0 * toFloat64(a.f2_all + 1))\n            WHEN COALESCE(a.f1_all, 0) > 0 THEN \n                COALESCE(a.s_obs_all, 0) + toFloat64(a.f1_all * (a.f1_all - 1)) / 2.0\n            ELSE \n                toFloat64(COALESCE(a.s_obs_all, 0))\n        END AS chao1_all_attempts,\n        \n        -- Failed connection insights\n        COALESCE(f.peers_with_only_failures, 0) AS failed_only_peers,\n        \n        COALESCE(s.f1_successful, 0) AS f1_successful,\n        COALESCE(s.f2_successful, 0) AS f2_successful,\n        COALESCE(a.f1_all, 0) AS f1_all,\n        COALESCE(a.f2_all, 0) AS f2_all\n        \n    FROM successful_stats s\n    FULL OUTER JOIN all_attempts_stats a ON s.observation_date = a.observation_date\n    LEFT JOIN failed_only_peers f ON COALESCE(s.observation_date, a.observation_date) = f.observation_date\n),\n\n-- Separate CTE for failure analysis aggregation\nfailure_reachability AS (\n    SELECT\n        observation_date,\n        SUM(toFloat64(peer_count) * estimated_reachability_prob) AS estimated_reachable_from_failures\n    FROM failure_analysis\n    GROUP BY observation_date\n),\n\n-- Combine all estimates\ncombined_estimates AS (\n    SELECT\n        e.*,\n        COALESCE(fr.estimated_reachable_from_failures, 0.0) AS estimated_reachable_from_failures\n    FROM enhanced_calculations e\n    LEFT JOIN failure_reachability fr ON e.observation_date = fr.observation_date\n),\n\nfinal_estimates AS (\n    SELECT\n        observation_date,\n        observed_successful_nodes,\n        observed_total_peers,\n        failed_only_peers,\n        \n        -- Different estimation approaches\n        toUInt64(round(chao1_successful, 0)) AS chao1_successful_only,\n        toUInt64(round(chao1_all_attempts, 0)) AS chao1_all_discovered,\n        toUInt64(round(estimated_reachable_from_failures, 0)) AS estimated_additional_reachable,\n        \n        -- Enhanced total estimate combining multiple signals\n        toUInt64(round(\n            chao1_successful +  -- Hidden successful nodes\n            estimated_reachable_from_failures  -- Additional reachable from failures\n        , 0)) AS enhanced_total_reachable,\n        \n        -- Network size estimate (includes unreachable nodes)\n        toUInt64(round(chao1_all_attempts, 0)) AS estimated_network_size,\n        \n        -- Success rates\n        CASE WHEN observed_total_peers > 0 THEN \n            round(100.0 * observed_successful_nodes / observed_total_peers, 2)\n        ELSE 0 END AS connection_success_rate_pct,\n        \n        -- Coverage estimates\n        CASE WHEN chao1_all_attempts > 0 THEN\n            round(100.0 * observed_total_peers / chao1_all_attempts, 2)\n        ELSE 100 END AS network_discovery_coverage_pct,\n        \n        CASE WHEN enhanced_total_reachable > 0 THEN\n            round(100.0 * observed_successful_nodes / enhanced_total_reachable, 2) \n        ELSE 100 END AS reachable_discovery_coverage_pct,\n        \n        -- Diagnostic info\n        f1_successful, f2_successful, f1_all, f2_all\n        \n    FROM combined_estimates\n)\n\nSELECT\n    observation_date,\n    \n    -- Core metrics\n    observed_successful_nodes,\n    observed_total_peers, \n    failed_only_peers,\n    \n    -- Population estimates\n    chao1_successful_only,\n    enhanced_total_reachable,\n    estimated_network_size,\n    estimated_additional_reachable,\n    \n    -- Success and coverage rates\n    connection_success_rate_pct,\n    network_discovery_coverage_pct,\n    reachable_discovery_coverage_pct,\n    \n    -- Hidden node estimates\n    chao1_successful_only - observed_successful_nodes AS hidden_successful_nodes,\n    enhanced_total_reachable - observed_successful_nodes AS hidden_reachable_nodes,\n    estimated_network_size - observed_total_peers AS hidden_total_nodes,\n    \n    -- Percentages\n    CASE WHEN chao1_successful_only > 0 THEN\n        round(100.0 * (chao1_successful_only - observed_successful_nodes) / chao1_successful_only, 2)\n    ELSE 0 END AS hidden_successful_pct,\n    \n    CASE WHEN estimated_network_size > 0 THEN\n        round(100.0 * (estimated_network_size - observed_total_peers) / estimated_network_size, 2) \n    ELSE 0 END AS hidden_total_pct,\n    \n    -- Diagnostic information\n    f1_successful AS successful_singletons,\n    f2_successful AS successful_doubletons,\n    f1_all AS all_singletons,\n    f2_all AS all_doubletons,\n    \n    now() AS calculated_at\n\nFROM final_estimates\nORDER BY observation_date DESC", "relation_name": "`dbt`.`int_esg_node_population_chao1`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.935021Z", "completed_at": "2025-10-24T12:23:13.941379Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.941937Z", "completed_at": "2025-10-24T12:23:13.941945Z"}], "thread_id": "Thread-1", "execution_time": 0.008171558380126953, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_clients_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,argMax(IF(client='','Unknown',client),visit_ended_at) AS client\n        ,argMax(platform,visit_ended_at) AS platform\n        ,argMax(generic_provider,visit_ended_at) AS generic_provider\n        ,argMax(peer_country,visit_ended_at) AS peer_country\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_p2p_discv5_clients_daily` AS t\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_p2p_discv5_clients_daily` AS t2\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT date , 'Clients' AS metric, client AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Platform' AS metric, platform AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Provider' AS metric, generic_provider AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL \n\nSELECT date, 'Country' AS metric, peer_country AS label, COUNT(*) AS value FROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv5_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.944595Z", "completed_at": "2025-10-24T12:23:13.949938Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.950530Z", "completed_at": "2025-10-24T12:23:13.950538Z"}], "thread_id": "Thread-1", "execution_time": 0.0073583126068115234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_forks_daily", "compiled": true, "compiled_code": "\n\nWITH\n\npeers AS (\n    SELECT\n        toStartOfDay(visit_ended_at) AS date\n        ,peer_id\n        ,toString(any(cl_fork_name)) AS fork\n        ,toString(any(cl_next_fork_name)) AS next_fork\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) < today()\n        AND\n        empty(dial_errors) = 1 AND crawl_error IS NULL\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(visit_ended_at)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_p2p_discv5_forks_daily` AS t\n    )\n    AND toStartOfDay(visit_ended_at) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_p2p_discv5_forks_daily` AS t2\n    )\n  \n\n    GROUP BY 1, 2\n)\n\nSELECT\n    date\n    ,'Current Fork' AS label\n    ,fork AS fork\n    ,COUNT(*) AS cnt\nFROM peers\nGROUP BY 1, 2, 3\n\nUNION ALL\n\nSELECT\n    date\n    ,'Next Fork' AS label\n    ,next_fork AS fork\n    ,COUNT(*) AS cnt\nFROM peers\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_p2p_discv5_forks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.953397Z", "completed_at": "2025-10-24T12:23:13.958773Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.959350Z", "completed_at": "2025-10-24T12:23:13.959358Z"}], "thread_id": "Thread-1", "execution_time": 0.007200956344604492, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_p2p_discv5_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\n-- 1) First CTE: basic peer info\ngnosis_peers AS (\n    SELECT \n        peer_id,\n        cl_fork_name,\n        cl_next_fork_name,\n        ip,\n        any(splitByChar('/', agent_version)[1]) AS client\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE\n        toStartOfDay(visit_ended_at) = today() - INTERVAL 1 DAY\n        AND empty(dial_errors) = 1\n        AND crawl_error IS NULL\n    GROUP BY\n        peer_id,\n        cl_fork_name,\n        cl_next_fork_name,\n        ip\n),\n\n-- 2) Second CTE: attach discovery_id_prefix to each peer\ngnosis_prefixes AS (\n    SELECT \n        d.discovery_id_prefix,\n        d.peer_id,\n        p.ip,\n        p.cl_fork_name,\n        p.cl_next_fork_name,\n        IF(p.client='', 'Unknown', p.client) AS client\n    FROM `dbt`.`stg_nebula_discv5__discovery_id_prefixes_x_peer_ids` AS d\n    INNER JOIN gnosis_peers AS p\n      ON p.peer_id = d.peer_id\n)\n\nSELECT\n    t1.date,\n\n    -- Peer columns from the subquery t1\n    t1.peer_ip,\n    t1.peer_discovery_id_prefix,\n    t1.peer_cl_fork_name,\n    t1.peer_cl_next_fork_name,\n    t1.peer_client,\n\n    -- Geographical info for peer (from crawlers_data.ipinfo)\n    peer_info.hostname   AS peer_hostname,\n    peer_info.city       AS peer_city,\n    peer_info.country    AS peer_country,\n    peer_info.org        AS peer_org,\n    peer_info.loc        AS peer_loc,\n\n    -- Neighbor columns from subquery t1\n    t1.neighbor_ip,\n    t1.neighbor_discovery_id_prefix,\n    t1.neighbor_cl_fork_name,\n    t1.neighbor_cl_next_fork_name,\n    t1.neighbor_client,\n\n    -- Geographical info for neighbor (from crawlers_data.ipinfo)\n    neighbor_info.city    AS neighbor_city,\n    neighbor_info.country AS neighbor_country,\n    neighbor_info.org     AS neighbor_org,\n    neighbor_info.loc     AS neighbor_loc,\n\n    -- Finally, the count of edges\n    t1.cnt\nFROM (\n    SELECT\n        toStartOfDay(n.crawl_created_at) AS date,\n\n        -- \u201cPeer\u201d side of the edge\n        peer_p.ip                      AS peer_ip,\n        peer_p.discovery_id_prefix     AS peer_discovery_id_prefix,\n        peer_p.cl_fork_name            AS peer_cl_fork_name,\n        peer_p.cl_next_fork_name       AS peer_cl_next_fork_name,\n        peer_p.client                  AS peer_client,\n\n        -- \u201cNeighbor\u201d side of the edge\n        neighbor_p.ip                      AS neighbor_ip,\n        neighbor_p.discovery_id_prefix     AS neighbor_discovery_id_prefix,\n        neighbor_p.cl_fork_name            AS neighbor_cl_fork_name,\n        neighbor_p.cl_next_fork_name       AS neighbor_cl_next_fork_name,\n        neighbor_p.client                  AS neighbor_client,\n\n        COUNT(*) AS cnt\n    FROM `dbt`.`stg_nebula_discv5__neighbors` AS n\n\n    -- join to get the discovery_prefix + client/fork info for \u201cpeer\u201d\n    INNER JOIN gnosis_prefixes AS peer_p\n      ON peer_p.discovery_id_prefix = n.peer_discovery_id_prefix\n\n    -- join to get the discovery_prefix + client/fork info for \u201cneighbor\u201d\n    INNER JOIN gnosis_prefixes AS neighbor_p\n      ON neighbor_p.discovery_id_prefix = n.neighbor_discovery_id_prefix\n\n    WHERE\n        toStartOfDay(n.crawl_created_at) = today() - INTERVAL 1 DAY\n\n    GROUP BY\n        date,\n        peer_p.ip,\n        peer_p.discovery_id_prefix,\n        peer_p.cl_fork_name,\n        peer_p.cl_next_fork_name,\n        peer_p.client,\n        neighbor_p.ip,\n        neighbor_p.discovery_id_prefix,\n        neighbor_p.cl_fork_name,\n        neighbor_p.cl_next_fork_name,\n        neighbor_p.client\n) AS t1\n\n-- LEFT JOIN to ipinfo for \u201cpeer\u201d\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS peer_info\n  ON peer_info.ip = t1.peer_ip\n\n-- LEFT JOIN to ipinfo for \u201cneighbor\u201d\nLEFT JOIN `dbt`.`stg_crawlers_data__ipinfo` AS neighbor_info\n  ON neighbor_info.ip = t1.neighbor_ip", "relation_name": "`dbt`.`int_p2p_discv5_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.961984Z", "completed_at": "2025-10-24T12:23:13.967656Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.968235Z", "completed_at": "2025-10-24T12:23:13.968243Z"}], "thread_id": "Thread-1", "execution_time": 0.007470846176147461, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_visits_latest", "compiled": true, "compiled_code": "\n\nWITH \n\ndiscv4_prev7D AS (\n    SELECT\n        date,\n        crawls\n    FROM `dbt`.`int_p2p_discv4_visits_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_visits_daily`), 7)\n),\n\ndiscv4 AS (\n    SELECT\n        date,\n        total_visits,\n        ROUND(COALESCE(successful_visits / NULLIF(total_visits, 0), 0) * 100, 1) AS pct_successful,\n        crawls\n    FROM `dbt`.`int_p2p_discv4_visits_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_visits_daily`)\n),\n\ndiscv5_prev7D AS (\n    SELECT\n        date,\n        crawls\n    FROM `dbt`.`int_p2p_discv5_visits_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_visits_daily`), 7)\n),\n\ndiscv5 AS (\n    SELECT\n        date,\n        total_visits,\n        ROUND(COALESCE(successful_visits / NULLIF(total_visits, 0), 0) * 100, 1) AS pct_successful,\n        crawls\n    FROM `dbt`.`int_p2p_discv5_visits_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_visits_daily`)\n)\n\nSELECT\n    t2.total_visits AS discv4_total_visits,\n    t2.pct_successful AS discv4_pct_successful,\n    t2.crawls AS discv4_crawls,\n    ROUND((COALESCE(t2.crawls / NULLIF(t1.crawls, 0), 0) - 1) * 100, 1) AS change_discv4_crawls_pct,\n    t4.total_visits AS discv5_total_visits,\n    t4.pct_successful AS discv5_pct_successful,\n    t4.crawls AS discv5_crawls,\n    ROUND((COALESCE(t4.crawls / NULLIF(t3.crawls, 0), 0) - 1) * 100, 1) AS change_discv5_crawls_pct\nFROM discv4_prev7D t1\nCROSS JOIN discv4 t2\nCROSS JOIN discv5_prev7D t3\nCROSS JOIN discv5 t4", "relation_name": "`dbt`.`api_p2p_visits_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.970815Z", "completed_at": "2025-10-24T12:23:13.975558Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.976120Z", "completed_at": "2025-10-24T12:23:13.976128Z"}], "thread_id": "Thread-1", "execution_time": 0.006544351577758789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_GBCDeposit_deposists_daily", "compiled": true, "compiled_code": "\n\n\nSELECT \n    toStartOfDay(block_timestamp) AS date\n    ,decoded_params['withdrawal_credentials'] AS withdrawal_credentials\n    ,SUM(reinterpretAsUInt64(unhex(substring(decoded_params['amount'], 3)))) AS amount\nFROM `dbt`.`contracts_GBCDeposit_events`\nWHERE\n    event_name = 'DepositEvent'\n    \n  \n\nGROUP BY 1, 2", "relation_name": "`dbt`.`int_GBCDeposit_deposists_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.978766Z", "completed_at": "2025-10-24T12:23:13.992955Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:13.993558Z", "completed_at": "2025-10-24T12:23:13.993568Z"}], "thread_id": "Thread-1", "execution_time": 0.01602005958557129, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_rwa_backedfi_prices", "compiled": true, "compiled_code": "\n\n\n\n\n\n\n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n\n\n        SELECT\n            'bC3M' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bC3M_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bCOIN' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bCOIN_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bCSPX' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bCSPX_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bHIGH' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bHIGH_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bIB01' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bIB01_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bIBTA' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bIBTA_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bMSTR' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bMSTR_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'bNVDA' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_bNVDA_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t2\n    )\n  \n\n        GROUP BY 1, 2\n    \nunion all\n\n        SELECT\n            'TSLAx' as bticker\n            ,toStartOfDay(block_timestamp) AS date\n            ,argMax(toUInt256OrNull(decoded_params['current'])/POWER(10,8),block_timestamp) AS price\n        FROM `dbt`.`contracts_backedfi_TSLAx_Oracle_events`\n        WHERE\n            event_name = 'AnswerUpdated'\n            AND block_timestamp < today()\n            \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_rwa_backedfi_prices` AS t2\n    )\n  \n\n        GROUP BY 1, 2\n    ", "relation_name": "`dbt`.`int_execution_rwa_backedfi_prices`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:13.996334Z", "completed_at": "2025-10-24T12:23:14.001885Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.002470Z", "completed_at": "2025-10-24T12:23:14.002479Z"}], "thread_id": "Thread-1", "execution_time": 0.007402658462524414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_backing", "compiled": true, "compiled_code": "\n\n\nSELECT\n    toStartOfDay(block_timestamp) AS date\n    ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_CirclesBackingFactory_events`\nWHERE \n    event_name = 'CirclesBackingCompleted'\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_circles_backing` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_circles_backing` AS t2\n    )\n  \n\nGROUP BY 1", "relation_name": "`dbt`.`int_execution_circles_backing`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.005231Z", "completed_at": "2025-10-24T12:23:14.010650Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.011224Z", "completed_at": "2025-10-24T12:23:14.011232Z"}], "thread_id": "Thread-1", "execution_time": 0.007425785064697266, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_transitive_transfers", "compiled": true, "compiled_code": "\n\n\nSELECT\n  toStartOfDay(block_timestamp) AS date\n  ,decoded_params['from'] AS from_avatar\n  ,decoded_params['to']   AS  to_avatar\n  ,SUM(\n    toUInt256OrZero(\n      arrayJoin(\n        JSONExtract(\n          ifNull(decoded_params['amounts'], '[]'),   -- remove Nullable\n          'Array(String)'                            -- get Array(String)\n        )\n      )\n    )\n  ) AS total_amount\n  ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE\n  event_name = 'StreamCompleted'\n  \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_circles_transitive_transfers` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_circles_transitive_transfers` AS t2\n    )\n  \n\nGROUP BY 1, 2, 3", "relation_name": "`dbt`.`int_execution_circles_transitive_transfers`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.013810Z", "completed_at": "2025-10-24T12:23:14.019144Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.019718Z", "completed_at": "2025-10-24T12:23:14.019726Z"}], "thread_id": "Thread-1", "execution_time": 0.007132053375244141, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_v1_avatars", "compiled": true, "compiled_code": "\n\n\nSELECT\n    block_timestamp\n    ,decoded_params['avatar'] AS user_address\n    ,decoded_params['inviter'] AS inviter_address\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE \n    event_name = 'RegisterHuman'\n    \n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_circles_v1_avatars` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_circles_v1_avatars` AS t2\n    )\n  \n", "relation_name": "`dbt`.`int_execution_circles_v1_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.022297Z", "completed_at": "2025-10-24T12:23:14.027685Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.028256Z", "completed_at": "2025-10-24T12:23:14.028264Z"}], "thread_id": "Thread-1", "execution_time": 0.0071887969970703125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_circles_v2_avatars", "compiled": true, "compiled_code": "\n\n\n\nSELECT\n    toStartOfDay(block_timestamp) AS date\n    ,CASE  \n        WHEN event_name = 'RegisterHuman' THEN 'Human' \n        WHEN event_name = 'RegisterGroup' THEN 'Group' \n        WHEN event_name = 'RegisterOrganization' THEN 'Org'\n        ELSE 'Unknown' \n    END AS avatar_type\n    ,COUNT(*) AS cnt\nFROM `dbt`.`contracts_circles_v2_Hub_events`\nWHERE \n    event_name IN ('RegisterHuman','RegisterGroup','RegisterOrganization')\n    \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_circles_v2_avatars` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_circles_v2_avatars` AS t2\n    )\n  \n\nGROUP BY 1,2", "relation_name": "`dbt`.`int_execution_circles_v2_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.031008Z", "completed_at": "2025-10-24T12:23:14.037994Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.038584Z", "completed_at": "2025-10-24T12:23:14.038595Z"}], "thread_id": "Thread-1", "execution_time": 0.008829355239868164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_yields_sdai_rate_daily", "compiled": true, "compiled_code": "\n\n\nWITH \n\nsdai_rate_sparse_daily AS (\n    SELECT\n        toStartOfDay(block_timestamp) AS date\n        ,argMin(\n          toUInt256OrNull(decoded_params['assets']) / toUInt256OrNull(decoded_params['shares']),\n          block_timestamp\n        ) AS sdai_conversion\n    FROM \n        `dbt`.`contracts_sdai_events`\n    WHERE \n        event_name = 'Deposit'\n        AND toUInt256OrNull(decoded_params['shares']) != 0\n        AND block_timestamp < today()\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_yields_sdai_rate_daily` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_yields_sdai_rate_daily` AS t2\n    )\n  \n\n    GROUP BY 1\n),\n\ncalendar AS (\n    SELECT\n        arrayJoin(\n            arrayMap(\n                x -> toStartOfDay(start_date + x),\n                range(toUInt32(end_date - start_date) + 1)\n            )\n        ) AS date\n    FROM (\n        SELECT \n          min(toDate(date)) AS start_date\n          ,max(toDate(date)) AS end_date\n        FROM sdai_rate_sparse_daily\n    )\n),\n\n\nlast_partition_value AS (\n    SELECT \n        sdai_conversion\n    FROM \n        `dbt`.`int_yields_sdai_rate_daily`\n    WHERE\n        toStartOfMonth(date) = (\n            SELECT addMonths(max(toStartOfMonth(date)), -1)\n            FROM `dbt`.`int_yields_sdai_rate_daily`\n        )\n    ORDER BY date DESC\n    LIMIT 1\n),\n\n\nsdai_daily_rate AS (\n  SELECT\n      date\n      ,sdai_conversion\n      ,floor(\n          sdai_conversion \n          - (\n            \n            COALESCE(\n                lagInFrame(sdai_conversion) OVER (\n                    ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n                ),\n                (SELECT sdai_conversion FROM last_partition_value)\n            )\n            \n            )\n      ,12) AS rate\n  FROM (\n    SELECT \n      t1.date\n      ,last_value(t2.sdai_conversion) ignore nulls OVER (ORDER BY t1.date) AS sdai_conversion\n    FROM calendar t1\n    LEFT JOIN\n      sdai_rate_sparse_daily t2\n      ON t2.date = t1.date\n  )\n)\n\n\nSELECT \n  date\n  ,sdai_conversion\n  ,rate\nFROM sdai_daily_rate\nWHERE rate IS NOT NULL", "relation_name": "`dbt`.`int_yields_sdai_rate_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.041360Z", "completed_at": "2025-10-24T12:23:14.049431Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.049977Z", "completed_at": "2025-10-24T12:23:14.049985Z"}], "thread_id": "Thread-1", "execution_time": 0.009832143783569336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_crawlers_data_labels", "compiled": true, "compiled_code": "\n\n\n\n\nWITH src AS (\n  SELECT\n    lower(address) AS address,\n    project,\n    introduced_at\n  FROM `dbt`.`stg_crawlers_data__dune_labels`\n  \n    \n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(introduced_at)) >= (\n      SELECT max(toStartOfMonth(t.introduced_at))\n      FROM `dbt`.`int_crawlers_data_labels` AS t\n    )\n    AND toStartOfDay(introduced_at) >= (\n      SELECT max(toStartOfDay(t2.introduced_at, 'UTC'))\n      FROM `dbt`.`int_crawlers_data_labels` AS t2\n    )\n  \n\n  \n),\n\nlabeled AS (\n  SELECT\n    address,\n    project,\n    introduced_at,\n\n    multiIf(\n\n      match(project, '(?i)^Unknown$'),           'Unknown',\n      match(project, '(?i)^EOA$'),               'EOAs',\n      match(project, '(?i)^ERC20$'),             'ERC20 Tokens',\n\n      match(project, '(?i)(uniswap|sushi|swapr|balancer|curve|honeyswap|levinswap|openocean|openoceanexchange|1inch|paraswap|cow\\\\s*swap|cowswap|gnosis\\\\s*protocol|xswap|symmetric(\\\\s*finance)?|elk\\\\s*finance|\\\\bdex\\\\b|aggregator|dex\\\\s*aggregator|zerion|kinetex\\\\s*xswap|baoswap)'),\n      'DEX',\n\n      match(project, '(?i)(\\\\baave\\\\b|spark(\\\\s*protocol)?|agave|compound|compoundadapter|\\\\bidle\\\\b|beefy|jarvis(\\\\s*network)?|gyroscope|qidao|powerpool|lending(manager)?|stakewise|aura\\\\s*finance|merkl)'),\n      'Lending & Yield',\n\n      match(project, '(?i)(\\\\bbridge\\\\b|omnibridge|hop(\\\\s*protocol)?|\\\\bbungee\\\\b|\\\\bacross\\\\b|connext|celer|stargate|lifi|li\\\\.?fi|\\\\bamb\\\\b|eth\\\\s*xdai\\\\s*amb|bsc\\\\s*xdai\\\\s*amb|\\\\brelay\\\\b|spokebridge|spokegateway|socket(\\\\b|\\\\s)|rango\\\\s*exchange|rubic(\\\\s*(onchain|crosschain))?|swaps?\\\\s*io|eywa|symbiosis|squid(\\\\s*spoke)?)'),\n      'Bridges',\n\n      match(project, '(?i)(layer\\\\s*zero|hyperlane|zk\\\\s*bridge|zkbridge|polyhedra|zk(light|client)|telepathy|messag(?:ing|e)|everclear|interop)'),\n      'Messaging / Interop',\n\n      match(project, '(?i)(safe(?:\\\\s*l2)?|gnosis\\\\s*safe|ambirewallet|biconomy|erc[- ]?4337|erc\\\\s*4337\\\\s*entry\\\\s*point|entry\\\\s*point|wethgateway|tokenbound|delegatecash|rhinestone|apex\\\\s*smart\\\\s*wallet|zeroexsettlerdeployersafemodule)'),\n      'Wallets & AA',\n\n      match(project, '(?i)(monerium(\\\\s*(iske|usde|blacklist))?|gnosis\\\\s*pay(\\\\s*(vip|spender|eiffel))?|\\\\bgpay\\\\b|request(\\\\s*network)?|\\\\busdc\\\\b|\\\\bsdai\\\\b|\\\\bxdai\\\\b|payments?|invoice|smart\\\\s*invoice|superfluid|sablier|swing\\\\s*xdai\\\\s*single\\\\s*chain)'),\n      'Payments & Stablecoins',\n\n      match(project, '(?i)(chainlink|tellor|pyth|\\\\boracle\\\\b|origin\\\\s*trail|origintrail|marketview|analytics|\\\\bdata\\\\b|\\\\bindex\\\\b|mu\\\\s*exchange\\\\s*pythoracle)'),\n      'Oracles & Data',\n\n      match(project, '(?i)(opensea|seaport|poap|nifty(ink|fair)?|\\\\bnft\\\\b|erc721|erc1155|foundation|eporio|marketplace|creator|mint|mech\\\\s*marketplace|ghost\\\\s*nft\\\\s*faucet|nfts2me|crypto\\\\s*stamp|nondescriptive\\\\s*1155|unlock(\\\\s*protocol)?)'),\n      'NFTs & Marketplaces',\n\n      match(project, '(?i)(dark\\\\s*forest|conquest\\\\.eth|mithraeum|\\\\bgame\\\\b|gaming)'),\n      'Gaming',\n\n      match(project, '(?i)(dao\\\\s*haus|daoh?a?us|daostack|\\\\bdao\\\\b|daosquare|plazadao|zodiac|snapshot|kleros(\\\\s*curate)?|reality\\\\s*eth|vocdoni|proof\\\\s*of\\\\s*humanity|sismo(\\\\s*(badges|roots|attestations\\\\s*registry))?|attestation|identity|omen|ran\\\\s*dao|circles|polkamarkets)'),\n      'DAOs & Governance',\n\n      match(project, '(?i)(tornado(?:\\\\.?\\\\s*cash)?|tornado\\\\s*cash\\\\s*nova|umbra|privacy|\\\\bmix\\\\b)'),\n      'Privacy',\n\n      match(project, '(?i)(autonolas|gnosis\\\\s*ai|autonomous|agent)'),\n      'AI & Agents',\n\n      match(project, '(?i)(real\\\\s*token|realtoken|real\\\\s*rmm|\\\\brmm\\\\b|emblem|backed)'),\n      'RWA & Tokenization',\n\n      match(project, '(?i)(^infrastructure$|gelato|opengsn|obol|ankr|shutter|infra(structure)?|registry|deployer|factory|controller|manager|router|vault|pool|proxy|multisig|gnosis\\\\s*protocol|gnosis\\\\s*chain|xdai\\\\s*posdao|swarm|ethswarm|address\\\\s*tag\\\\s*registry|judicialassetfactory|hopr(\\\\s*(token|network|protocol))?)'),\n      'Infrastructure & DevTools',\n\n      'Others'\n    ) AS sector\n  FROM src\n)\n\nSELECT\n  address,\n  project,\n  sector,\n  introduced_at\nFROM labeled", "relation_name": "`dbt`.`int_crawlers_data_labels`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.052690Z", "completed_at": "2025-10-24T12:23:14.056487Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.057062Z", "completed_at": "2025-10-24T12:23:14.057069Z"}], "thread_id": "Thread-1", "execution_time": 0.0057642459869384766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_graffiti_cloud", "compiled": true, "compiled_code": "\n\n\nSELECT\n    label\n    ,graffiti\n    ,value\nFROM `dbt`.`fct_consensus_graffiti_cloud`\nORDER BY label DESC, value DESC", "relation_name": "`dbt`.`api_consensus_graffiti_cloud`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.059684Z", "completed_at": "2025-10-24T12:23:14.063440Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.063993Z", "completed_at": "2025-10-24T12:23:14.064000Z"}], "thread_id": "Thread-1", "execution_time": 0.005517244338989258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_deposits_withdrawls_cnt_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,cnt AS value\nFROM \n    `dbt`.`fct_consensus_deposits_withdrawls_daily`\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_deposits_withdrawls_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.066586Z", "completed_at": "2025-10-24T12:23:14.070327Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.070886Z", "completed_at": "2025-10-24T12:23:14.070893Z"}], "thread_id": "Thread-1", "execution_time": 0.005515336990356445, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_deposits_withdrawls_volume_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,label\n    ,total_amount AS value\nFROM \n    `dbt`.`fct_consensus_deposits_withdrawls_daily`\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_deposits_withdrawls_volume_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.073476Z", "completed_at": "2025-10-24T12:23:14.077299Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.077854Z", "completed_at": "2025-10-24T12:23:14.077862Z"}], "thread_id": "Thread-1", "execution_time": 0.00559544563293457, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_clients_cnt_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,client\n    ,cnt AS value\nFROM `dbt`.`fct_execution_blocks_clients_daily`\nORDER BY date, client", "relation_name": "`dbt`.`api_execution_blocks_clients_cnt_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.080427Z", "completed_at": "2025-10-24T12:23:14.084175Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.084750Z", "completed_at": "2025-10-24T12:23:14.084758Z"}], "thread_id": "Thread-1", "execution_time": 0.005531787872314453, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_clients_pct_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,client\n    ,ROUND(fraq * 100, 2) AS value\nFROM `dbt`.`fct_execution_blocks_clients_daily`\nORDER BY date, client", "relation_name": "`dbt`.`api_execution_blocks_clients_pct_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.087304Z", "completed_at": "2025-10-24T12:23:14.092304Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.092863Z", "completed_at": "2025-10-24T12:23:14.092871Z"}], "thread_id": "Thread-1", "execution_time": 0.006764411926269531, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_blocks_gas_usage_pct_monthly", "compiled": true, "compiled_code": "\n\nSELECT\n  month AS date,\n  ROUND(used * 100, 2) AS value\nFROM `dbt`.`fct_execution_blocks_gas_usage_monthly`\nORDER BY date", "relation_name": "`dbt`.`api_execution_blocks_gas_usage_pct_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.095442Z", "completed_at": "2025-10-24T12:23:14.099162Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.099735Z", "completed_at": "2025-10-24T12:23:14.099742Z"}], "thread_id": "Thread-1", "execution_time": 0.005549430847167969, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_state_full_size_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,bytes/POWER(10,9) AS value\nFROM `dbt`.`fct_execution_state_full_size_daily`", "relation_name": "`dbt`.`api_execution_state_full_size_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.102285Z", "completed_at": "2025-10-24T12:23:14.106093Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.106669Z", "completed_at": "2025-10-24T12:23:14.106676Z"}], "thread_id": "Thread-1", "execution_time": 0.00560307502746582, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv4_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv4_clients_daily`\nWHERE date < today()\nORDER BY date, metric, label", "relation_name": "`dbt`.`api_p2p_discv4_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.109227Z", "completed_at": "2025-10-24T12:23:14.113263Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.113822Z", "completed_at": "2025-10-24T12:23:14.113831Z"}], "thread_id": "Thread-1", "execution_time": 0.005817413330078125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv4_clients_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv4_clients_daily`\nWHERE date = (SELECT MAX(date) FROM  `dbt`.`int_p2p_discv4_clients_daily` )\nORDER BY metric, label", "relation_name": "`dbt`.`api_p2p_discv4_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.116405Z", "completed_at": "2025-10-24T12:23:14.123384Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.123936Z", "completed_at": "2025-10-24T12:23:14.123944Z"}], "thread_id": "Thread-1", "execution_time": 0.008736610412597656, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_classification", "compiled": true, "compiled_code": "\n\n\nWITH latest_observations AS (\n    SELECT \n        toDate(visit_ended_at) as observation_date,\n        peer_id,\n        argMax(ip, visit_ended_at) AS ip_address,\n        argMax(client, visit_ended_at) AS client_type,\n        argMax(peer_country, visit_ended_at) AS country_code,\n        argMax(generic_provider, visit_ended_at) AS generic_provider,\n        argMax(peer_org, visit_ended_at) AS peer_org,\n        MAX(visit_ended_at) AS last_seen_that_day\n    FROM `dbt`.`int_p2p_discv5_peers`\n    WHERE \n        empty(dial_errors) = 1 \n        AND crawl_error IS NULL\n        AND toStartOfDay(visit_ended_at) < today()\n        \n            AND toDate(visit_ended_at) > (SELECT MAX(date) FROM `dbt`.`int_esg_node_classification`)\n        \n    GROUP BY observation_date, peer_id\n),\n\nnode_categories AS (\n    SELECT\n        observation_date,\n        peer_id,\n        ip_address,\n        client_type,\n        country_code,\n        generic_provider,\n        peer_org,\n        \n        -- Classify nodes into operational archetypes based on generic_provider\n        CASE\n            WHEN generic_provider IN ('AWS', 'Google', 'Azure', 'Oracle Cloud', 'Alibaba Cloud') \n                THEN 'cloud_hosted'\n            WHEN generic_provider IN ('DigitalOcean', 'OVHcloud', 'Hetzner', 'Scaleway', 'Linode', 'Vultr', \n                                    'Equinix Metal', 'Hosting/CDN (Other)') \n                THEN 'cloud_hosted'\n            WHEN generic_provider = 'Carrier/Transit' \n                THEN 'professional_operator'\n            WHEN lower(peer_org) LIKE '%datacenter%' \n                OR lower(peer_org) LIKE '%data center%'\n                OR lower(peer_org) LIKE '%hosting%'\n                OR lower(peer_org) LIKE '%server%'\n                THEN 'professional_operator'\n            WHEN generic_provider = 'Public ISP (Home/Office)' \n                THEN 'home_staker'\n            WHEN lower(peer_org) LIKE '%telecom%'\n                OR lower(peer_org) LIKE '%broadband%'\n                OR lower(peer_org) LIKE '%cable%'\n                OR lower(peer_org) LIKE '%fiber%'\n                OR lower(peer_org) LIKE '%residential%'\n                THEN 'home_staker'\n            ELSE 'unknown'\n        END AS node_category,\n        \n        CASE\n            WHEN generic_provider IN ('AWS', 'Google', 'Azure', 'Oracle Cloud', 'Alibaba Cloud') THEN 0.95\n            WHEN generic_provider IN ('DigitalOcean', 'OVHcloud', 'Hetzner', 'Scaleway', 'Linode', 'Vultr') THEN 0.90\n            WHEN generic_provider = 'Public ISP (Home/Office)' THEN 0.80\n            WHEN generic_provider = 'Hosting/CDN (Other)' THEN 0.75\n            WHEN generic_provider = 'Carrier/Transit' THEN 0.70\n            WHEN generic_provider = 'Unknown' THEN 0.30\n            ELSE 0.50\n        END AS classification_confidence\n        \n    FROM latest_observations\n),\n\ndaily_distribution AS (\n    SELECT\n        observation_date AS date,\n        node_category,\n        COUNT(DISTINCT peer_id) AS observed_nodes,\n        AVG(classification_confidence) AS avg_confidence\n    FROM node_categories\n    GROUP BY observation_date, node_category\n),\n\nchao1_data AS (\n    SELECT\n        p.observation_date,\n        p.observed_successful_nodes,\n        p.enhanced_total_reachable,\n        p.connection_success_rate_pct\n    FROM `dbt`.`int_esg_node_population_chao1` p\n    WHERE 1=1\n        \n            AND p.observation_date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_classification`)\n        \n),\n\nscaled_distribution AS (\n    SELECT\n        d.date,\n        d.node_category,\n        d.observed_nodes,\n        d.avg_confidence,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(greatest(toFloat64(d.observed_nodes), \n                    toFloat64(d.observed_nodes) * c.enhanced_total_reachable / c.observed_successful_nodes))\n            ELSE d.observed_nodes\n        END AS estimated_total_nodes,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(greatest(toFloat64(d.observed_nodes), \n                    toFloat64(d.observed_nodes) * c.enhanced_total_reachable * 0.85 / c.observed_successful_nodes))\n            ELSE toUInt64(d.observed_nodes * 0.85)\n        END AS nodes_lower_95,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                toUInt64(toFloat64(d.observed_nodes) * c.enhanced_total_reachable * 1.15 / c.observed_successful_nodes)\n            ELSE toUInt64(d.observed_nodes * 1.15)\n        END AS nodes_upper_95,\n        \n        COALESCE(c.connection_success_rate_pct / 100.0, 0.75) AS sample_coverage,\n        \n        CASE \n            WHEN c.observed_successful_nodes > 0 AND c.enhanced_total_reachable > 0 THEN\n                round(toFloat64(c.enhanced_total_reachable) / c.observed_successful_nodes, 3)\n            ELSE 1.0\n        END AS scaling_factor\n        \n    FROM daily_distribution d\n    LEFT JOIN chao1_data c ON d.date = c.observation_date\n),\n\ngeographic_distribution AS (\n    SELECT\n        observation_date AS date,\n        node_category,\n        country_code,\n        COUNT(DISTINCT peer_id) AS country_observed_nodes\n    FROM node_categories\n    WHERE country_code IS NOT NULL AND country_code != '' AND country_code != 'Unknown'\n    GROUP BY observation_date, node_category, country_code\n),\n\ngeographic_scaled AS (\n    SELECT\n        g.date,\n        g.node_category,\n        g.country_code,\n        g.country_observed_nodes,\n        \n        CASE \n            WHEN s.scaling_factor > 0 THEN\n                toUInt64(toFloat64(g.country_observed_nodes) * s.scaling_factor)\n            ELSE g.country_observed_nodes\n        END AS country_estimated_nodes\n        \n    FROM geographic_distribution g\n    JOIN scaled_distribution s\n        ON g.date = s.date AND g.node_category = s.node_category\n)\n\nSELECT\n    s.date,\n    s.node_category,\n    s.observed_nodes,\n    s.estimated_total_nodes,\n    s.nodes_lower_95,\n    s.nodes_upper_95,\n    s.avg_confidence,\n    s.sample_coverage,\n    s.scaling_factor,\n    \n    round(100.0 * s.estimated_total_nodes / \n          SUM(s.estimated_total_nodes) OVER (PARTITION BY s.date), 2) AS category_percentage,\n    \n    s.estimated_total_nodes - s.observed_nodes AS hidden_nodes_estimated,\n    round(100.0 * (s.estimated_total_nodes - s.observed_nodes) / s.estimated_total_nodes, 2) AS hidden_nodes_percentage,\n    \n    CASE \n        WHEN COUNT(g.country_code) > 0 THEN\n            toJSONString(groupArray((g.country_code, g.country_estimated_nodes)))\n        ELSE '[]'\n    END AS geographic_distribution,\n    \n    CASE \n        WHEN COUNT(g.country_code) > 0 THEN\n            arrayStringConcat(\n                arraySlice(\n                    arrayMap(x -> tupleElement(x, 1),\n                        arraySort(x -> -tupleElement(x, 2),\n                            groupArray((g.country_code, g.country_estimated_nodes))\n                        )\n                    ), 1, 5\n                ), ', '\n            )\n        ELSE 'No geographic data'\n    END AS top_countries,\n    \n    now() AS calculated_at\n    \nFROM scaled_distribution s\nLEFT JOIN geographic_scaled g\n    ON s.date = g.date AND s.node_category = g.node_category\n\nGROUP BY \n    s.date, s.node_category, s.observed_nodes, s.estimated_total_nodes,\n    s.nodes_lower_95, s.nodes_upper_95, s.avg_confidence, s.sample_coverage, s.scaling_factor\n\nORDER BY s.date, s.estimated_total_nodes DESC", "relation_name": "`dbt`.`int_esg_node_classification`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.126696Z", "completed_at": "2025-10-24T12:23:14.133500Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.134056Z", "completed_at": "2025-10-24T12:23:14.134064Z"}], "thread_id": "Thread-1", "execution_time": 0.008747577667236328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_clients_latest", "compiled": true, "compiled_code": "\n\nWITH \n\ndiscv4_prev7D AS (\n    SELECT\n        date,\n        SUM(value) AS discv4_count\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`), 7)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv4 AS (\n    SELECT\n        date,\n        SUM(value) AS discv4_count\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv5_prev7D AS (\n    SELECT\n        date,\n        SUM(value) AS discv5_count\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE \n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_clients_daily`), 7)\n        AND metric = 'Clients'\n    GROUP BY date\n),\n\ndiscv5 AS (\n    SELECT\n        date,\n        SUM(value) AS discv5_count\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE \n        date = (SELECT MAX(date) FROM `dbt`.`int_p2p_discv5_clients_daily`)\n        AND metric = 'Clients'\n    GROUP BY date\n)\n\nSELECT\n    t2.discv4_count AS discv4_count,\n    ROUND((COALESCE(t2.discv4_count / NULLIF(t1.discv4_count, 0), 0) - 1) * 100, 1) AS change_discv4_pct,\n    t4.discv5_count AS discv5_count,\n    ROUND((COALESCE(t4.discv5_count / NULLIF(t3.discv5_count, 0), 0) - 1) * 100, 1) AS change_discv5_pct\nFROM discv4_prev7D t1\nCROSS JOIN discv4 t2\nCROSS JOIN discv5_prev7D t3\nCROSS JOIN discv5 t4", "relation_name": "`dbt`.`api_p2p_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.136642Z", "completed_at": "2025-10-24T12:23:14.140446Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.140999Z", "completed_at": "2025-10-24T12:23:14.141007Z"}], "thread_id": "Thread-1", "execution_time": 0.0055599212646484375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_clients_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv5_clients_daily`\nWHERE date < today()\nORDER BY date, metric, label", "relation_name": "`dbt`.`api_p2p_discv5_clients_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.143598Z", "completed_at": "2025-10-24T12:23:14.147623Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.148173Z", "completed_at": "2025-10-24T12:23:14.148181Z"}], "thread_id": "Thread-1", "execution_time": 0.005800724029541016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_clients_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    metric\n    ,label\n    ,value\nFROM `dbt`.`int_p2p_discv5_clients_daily`\nWHERE date = (SELECT MAX(date) FROM  `dbt`.`int_p2p_discv5_clients_daily` )\nORDER BY metric, label", "relation_name": "`dbt`.`api_p2p_discv5_clients_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.150770Z", "completed_at": "2025-10-24T12:23:14.154557Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.155111Z", "completed_at": "2025-10-24T12:23:14.155119Z"}], "thread_id": "Thread-1", "execution_time": 0.005582094192504883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_current_fork_daily", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`\nWHERE label = 'Current Fork' \nORDER BY date ASC, fork ASC", "relation_name": "`dbt`.`api_p2p_discv5_current_fork_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.157944Z", "completed_at": "2025-10-24T12:23:14.161870Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.162472Z", "completed_at": "2025-10-24T12:23:14.162480Z"}], "thread_id": "Thread-1", "execution_time": 0.005903005599975586, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_discv5_next_fork_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`\nWHERE label = 'Next Fork' \nORDER BY date ASC, fork ASC", "relation_name": "`dbt`.`api_p2p_discv5_next_fork_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.165080Z", "completed_at": "2025-10-24T12:23:14.168484Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.169043Z", "completed_at": "2025-10-24T12:23:14.169050Z"}], "thread_id": "Thread-1", "execution_time": 0.0052340030670166016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_p2p_discv5_forks_daily", "compiled": true, "compiled_code": "SELECT\n    date\n    ,label\n    ,fork\n    ,cnt\nFROM `dbt`.`int_p2p_discv5_forks_daily`", "relation_name": "`dbt`.`fct_p2p_discv5_forks_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.171703Z", "completed_at": "2025-10-24T12:23:14.177337Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.177888Z", "completed_at": "2025-10-24T12:23:14.177896Z"}], "thread_id": "Thread-1", "execution_time": 0.007418632507324219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_p2p_topology_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ndiscv4_topology AS (\n    SELECT\n        date,\n        peer_ip,\n        peer_discovery_id_prefix,\n        peer_client,\n        peer_hostname,\n        peer_city,\n        peer_country,\n        peer_org,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(peer_loc, '')), 1)) AS peer_lat,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(peer_loc, '')), 2)) AS peer_lon,\n        neighbor_ip,\n        neighbor_discovery_id_prefix,\n        neighbor_client,\n        neighbor_city,\n        neighbor_country,\n        neighbor_org,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(neighbor_loc, '')), 1)) AS neighbor_lat,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(neighbor_loc, '')), 2)) AS neighbor_lon,\n        cnt\n    FROM `dbt`.`int_p2p_discv4_topology_latest`\n),\n\ndiscv5_topology AS (\n    SELECT\n        date,\n        peer_ip,\n        peer_discovery_id_prefix,\n        peer_client,\n        peer_hostname,\n        peer_city,\n        peer_country,\n        peer_org,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(peer_loc, '')), 1)) AS peer_lat,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(peer_loc, '')), 2)) AS peer_lon,\n        neighbor_ip,\n        neighbor_discovery_id_prefix,\n        neighbor_client,\n        neighbor_city,\n        neighbor_country,\n        neighbor_org,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(neighbor_loc, '')), 1)) AS neighbor_lat,\n        toFloat64OrNull(arrayElement(splitByChar(',', ifNull(neighbor_loc, '')), 2)) AS neighbor_lon,\n        cnt\n    FROM `dbt`.`int_p2p_discv5_topology_latest`\n)\n\nSELECT 'DiscV4' AS protocol, * FROM discv4_topology\nUNION ALL\nSELECT 'DiscV5' AS protocol, * FROM discv5_topology", "relation_name": "`dbt`.`fct_p2p_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.180526Z", "completed_at": "2025-10-24T12:23:14.191729Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.192305Z", "completed_at": "2025-10-24T12:23:14.192313Z"}], "thread_id": "Thread-1", "execution_time": 0.01305699348449707, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_consensus_validators_apy_daily", "compiled": true, "compiled_code": "\n\nWITH\n\ndeposists AS (\n    SELECT \n        toStartOfDay(slot_timestamp) AS date\n        ,SUM(amount) AS amount\n    FROM `dbt`.`stg_consensus__deposits`\n    WHERE \n        slot_timestamp < toDate('2025-04-30')\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_validators_apy_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_apy_daily` AS t2\n    )\n  \n\n    GROUP BY 1\n\n    UNION ALL \n\n    SELECT \n        date\n        ,SUM(amount) AS amount\n    FROM `dbt`.`int_GBCDeposit_deposists_daily`\n    WHERE \n        date >= toDate('2025-04-30')\n        \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_validators_apy_daily` AS t\n    )\n    AND toStartOfDay(date) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_apy_daily` AS t2\n    )\n  \n\n    GROUP BY 1\n),\n\ndeposists_requests AS (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n        SUM(toUInt64(JSONExtractString(deposit, 'amount'))) AS amount\n    FROM `dbt`.`stg_consensus__execution_requests`\n    ARRAY JOIN JSONExtractArrayRaw(payload, 'deposits') AS deposit\n    \n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_validators_apy_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_apy_daily` AS t2\n    )\n  \n\n    GROUP BY 1\n),\n\n\nwithdrawals AS (\n    SELECT \n        toStartOfDay(slot_timestamp) AS date \n        ,SUM(amount) AS amount\n    FROM `dbt`.`stg_consensus__withdrawals`\n    \n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_validators_apy_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_apy_daily` AS t2\n    )\n  \n\n    GROUP BY 1\n),\n\nwithdrawals_requests AS (\n    SELECT\n        toStartOfDay(slot_timestamp) AS date,\n        SUM(toUInt64(JSONExtractString(withdrawals, 'amount'))) AS amount\n    FROM `dbt`.`stg_consensus__execution_requests`\n    ARRAY JOIN JSONExtractArrayRaw(payload, 'withdrawals') AS withdrawals\n    \n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_validators_apy_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_apy_daily` AS t2\n    )\n  \n\n    GROUP BY 1\n),\n\nvalidators AS (\n    SELECT\n        date,\n        balance,\n        lagInFrame(balance, 1, balance) OVER (\n            ORDER BY date\n            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n        ) AS prev_balance,\n        balance - prev_balance AS balance_diff\n    FROM (\n        SELECT\n            toStartOfDay(slot_timestamp) AS date,\n            SUM(balance) AS balance\n        FROM `dbt`.`stg_consensus__validators`\n        \n  \n    \n      \n    \n\n   WHERE \n    toStartOfMonth(toStartOfDay(slot_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_consensus_validators_apy_daily` AS t\n    )\n    AND toStartOfDay(slot_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_consensus_validators_apy_daily` AS t2\n    )\n  \n\n        GROUP BY 1\n    )\n)\n\nSELECT \n    t1.date AS date\n    ,t1.balance AS balance\n    ,t1.balance_diff AS balance_diff_original\n    ,COALESCE(t2.amount,0)  AS deposited_amount\n    ,COALESCE(t3.amount,0)  AS withdrawaled_amount\n    ,COALESCE(t4.amount,0)  AS deposited_amount_request\n    ,COALESCE(t5.amount,0)  AS withdrawaled_amount_request\n    ,t1.balance_diff - COALESCE(t2.amount,0) - COALESCE(t4.amount,0) + COALESCE(t3.amount,0) + COALESCE(t5.amount,0) AS eff_balance_diff\n    ,eff_balance_diff/t1.prev_balance AS rate\n    ,ROUND((POWER((1+rate),365) - 1) * 100,2) AS apy\nFROM validators t1\nLEFT JOIN \n    deposists t2\n    ON t2.date = t1.date\nLEFT JOIN \n    withdrawals t3\n    ON t3.date = t1.date\nLEFT JOIN \n    deposists_requests t4\n    ON t4.date = t1.date\nLEFT JOIN \n    withdrawals_requests t5\n    ON t5.date = t1.date", "relation_name": "`dbt`.`int_consensus_validators_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.195060Z", "completed_at": "2025-10-24T12:23:14.202175Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.202763Z", "completed_at": "2025-10-24T12:23:14.202771Z"}], "thread_id": "Thread-1", "execution_time": 0.009118795394897461, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_rwa_backedfi_prices_daily", "compiled": true, "compiled_code": "\n\n\n\n   -- safely before any token was listed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bC3M'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bC3M'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bCOIN'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bCOIN'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bCSPX'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bCSPX'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bHIGH'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bHIGH'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bIB01'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bIB01'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bIBTA'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bIBTA'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bMSTR'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bMSTR'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'bNVDA'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'bNVDA'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nUNION ALL\n\nSELECT\n  bticker,\n  date,\n  price\nFROM (\n    /* gather sparse rows, fill, forward-fill */\n    SELECT\n      'TSLAx'       AS bticker,\n      date,\n      /* forward-fill price */\n      last_value(price) IGNORE NULLS\n        OVER (\n          ORDER BY date\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS price\n    FROM (\n        /* sparse daily data for this one ticker */\n        SELECT\n          toDate(date)            AS date,\n          max(price)              AS price          -- one value per day\n        FROM `dbt`.`int_execution_rwa_backedfi_prices`\n        WHERE bticker = 'TSLAx'\n        GROUP BY date\n        ORDER BY date\n          WITH FILL\n            FROM toDate('2020-01-01')\n            TO today()\n            STEP 1\n    )\n)\nWHERE price IS NOT NULL AND date < today()       -- drop rows before first real point\n\nORDER BY bticker, date", "relation_name": "`dbt`.`fct_execution_rwa_backedfi_prices_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.205538Z", "completed_at": "2025-10-24T12:23:14.209663Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.210241Z", "completed_at": "2025-10-24T12:23:14.210249Z"}], "thread_id": "Thread-1", "execution_time": 0.006037473678588867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_circles_backing", "compiled": true, "compiled_code": "\n\nWITH dates AS (\n    -- get min/max date \n    SELECT\n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM `dbt`.`int_execution_circles_backing`\n),\ndate_series AS (\n    -- generate dense series of dates\n    SELECT\n        toDate(min_date) + number AS date\n    FROM dates\n    ARRAY JOIN range(dateDiff('day', min_date, max_date) + 1) AS number\n),\n\nfilled AS (\n    SELECT\n        g.date,\n        coalesce(t.cnt, 0) AS cnt\n    FROM date_series g\n    LEFT JOIN `dbt`.`int_execution_circles_backing` t\n        ON g.date = t.date\n)\n\nSELECT\n    date,\n    cnt,\n    SUM(cnt) OVER (ORDER BY date) AS total\nFROM filled\nWHERE date < today()", "relation_name": "`dbt`.`fct_execution_circles_backing`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.212874Z", "completed_at": "2025-10-24T12:23:14.217476Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.218049Z", "completed_at": "2025-10-24T12:23:14.218057Z"}], "thread_id": "Thread-1", "execution_time": 0.006463527679443359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_circles_avatars", "compiled": true, "compiled_code": "\n\nWITH dates AS (\n    -- get min/max date \n    SELECT\n        min(date) AS min_date,\n        max(date) AS max_date\n    FROM `dbt`.`int_execution_circles_v2_avatars`\n),\ndate_series AS (\n    -- generate dense series of dates\n    SELECT\n        toDate(min_date) + number AS date\n    FROM dates\n    ARRAY JOIN range(dateDiff('day', min_date, max_date) + 1) AS number\n),\navatar_types AS (\n    SELECT DISTINCT avatar_type\n    FROM `dbt`.`int_execution_circles_v2_avatars`\n),\ndense_grid AS (\n    SELECT\n        d.date,\n        a.avatar_type\n    FROM date_series d\n    CROSS JOIN avatar_types a\n),\nfilled AS (\n    SELECT\n        g.date,\n        g.avatar_type,\n        coalesce(t.cnt, 0) AS cnt\n    FROM dense_grid g\n    LEFT JOIN `dbt`.`int_execution_circles_v2_avatars` t\n        ON g.date = t.date\n       AND g.avatar_type = t.avatar_type\n)\n\nSELECT\n    date,\n    avatar_type,\n    cnt,\n    SUM(cnt) OVER (PARTITION BY avatar_type ORDER BY date) AS total\nFROM filled", "relation_name": "`dbt`.`fct_execution_circles_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.220901Z", "completed_at": "2025-10-24T12:23:14.225005Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.225590Z", "completed_at": "2025-10-24T12:23:14.225598Z"}], "thread_id": "Thread-1", "execution_time": 0.006167888641357422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_yields_sdai_apy_daily", "compiled": true, "compiled_code": "\n\nWITH\n\nsdai_apy_daily AS (\n    SELECT\n        date,\n        floor(POWER((1+rate),365) - 1,4) * 100 AS apy,\n        floor(\n            avg(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 6  PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_7DMA,\n        floor(\n            avg(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_30DMA,\n         floor(\n            median(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 6  PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_7DMM,\n        floor(\n            median(POWER((1+rate),365) - 1)\n                OVER (ORDER BY date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW)\n            ,4) * 100 AS apy_30DMM\n    FROM `dbt`.`int_yields_sdai_rate_daily`\n)\n\nSELECT date, apy, 'Daily' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_7DMA, '7DMA' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_30DMA, '30DMA' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_7DMM, '7DMM' AS label FROM sdai_apy_daily\nUNION ALL\nSELECT date, apy_30DMM, '30DMM' AS label FROM sdai_apy_daily", "relation_name": "`dbt`.`fct_yields_sdai_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.228276Z", "completed_at": "2025-10-24T12:23:14.237431Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.237988Z", "completed_at": "2025-10-24T12:23:14.237995Z"}], "thread_id": "Thread-1", "execution_time": 0.011050701141357422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_by_project_daily", "compiled": true, "compiled_code": "\n\n\n\n\n\nWITH lbl AS (\n  SELECT address, project, sector\n  FROM `dbt`.`int_crawlers_data_labels`\n),\n\ntx_labeled AS (\n  SELECT\n    toDate(t.block_timestamp)                        AS date,\n    coalesce(nullIf(trim(l.project), ''), 'Unknown') AS project,\n    lower(t.from_address)                            AS from_address,\n    toFloat64(coalesce(t.gas_used, 0))               AS gas_used,\n    toFloat64(coalesce(t.gas_price, 0))              AS gas_price\n  FROM `dbt`.`stg_execution__transactions` t\n  ANY LEFT JOIN lbl l ON lower(t.to_address) = l.address\n  WHERE t.block_timestamp < today()\n    AND t.from_address IS NOT NULL\n    AND t.success = 1\n    \n      \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(block_timestamp)) >= (\n      SELECT max(toStartOfMonth(t.date))\n      FROM `dbt`.`int_execution_transactions_by_project_daily` AS t\n    )\n    AND toStartOfDay(block_timestamp) >= (\n      SELECT max(toStartOfDay(t2.date, 'UTC'))\n      FROM `dbt`.`int_execution_transactions_by_project_daily` AS t2\n    )\n  \n\n    \n),\n\nagg AS (\n  SELECT\n    date,\n    project,\n    count()                                    AS tx_count,\n    groupBitmapState(cityHash64(from_address)) AS ua_bitmap_state,\n    sum(gas_used)                              AS gas_used_sum,\n    sum(gas_used * gas_price) / 1e18           AS fee_native_sum\n  FROM tx_labeled\n  GROUP BY date, project\n),\n\nproj_sector AS (\n  SELECT\n    project,\n    coalesce(nullIf(trim(sector), ''), 'Unknown') AS sector\n  FROM (\n    SELECT project, anyHeavy(sector) AS sector\n    FROM `dbt`.`int_crawlers_data_labels`\n    GROUP BY project\n  )\n)\n\nSELECT\n  a.date                AS date,\n  a.project             AS project,\n  ps.sector             AS sector,\n  a.tx_count            AS tx_count,\n  a.ua_bitmap_state     AS ua_bitmap_state,\n  a.gas_used_sum        AS gas_used_sum,\n  a.fee_native_sum      AS fee_native_sum\nFROM agg a\nLEFT JOIN proj_sector ps ON ps.project = a.project", "relation_name": "`dbt`.`int_execution_transactions_by_project_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.240848Z", "completed_at": "2025-10-24T12:23:14.245912Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.246506Z", "completed_at": "2025-10-24T12:23:14.246514Z"}], "thread_id": "Thread-1", "execution_time": 0.007155656814575195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_by_project_hourly_recent", "compiled": true, "compiled_code": "\n\nWITH lbl AS (\n  SELECT address, project, sector\n  FROM `dbt`.`int_crawlers_data_labels`\n),\n\n\nwm AS (\n  SELECT toStartOfDay(max(block_timestamp), 'UTC') AS max_day\n  FROM `dbt`.`stg_execution__transactions`\n  WHERE toStartOfMonth(block_timestamp) >= toStartOfMonth(today() - INTERVAL 1 MONTH)\n),\n\ntx AS (\n  SELECT\n    toStartOfHour(t.block_timestamp, 'UTC') AS hour,\n    lower(t.from_address)                 AS from_address,\n    lower(t.to_address)                   AS to_address,\n    toFloat64(coalesce(t.gas_used, 0))    AS gas_used,\n    toFloat64(coalesce(t.gas_price, 0))   AS gas_price\n  FROM `dbt`.`stg_execution__transactions` t\n  CROSS JOIN wm\n  WHERE \n    toStartOfMonth(block_timestamp) >= toStartOfMonth(today() - INTERVAL 1 MONTH)\n    AND toStartOfDay(t.block_timestamp, 'UTC') >= subtractDays(max_day, 2)\n    AND toStartOfDay(t.block_timestamp, 'UTC') < max_day\n    AND t.from_address IS NOT NULL\n    AND t.success = 1\n),\n\nclassified AS (\n  SELECT\n    tx.hour,\n    coalesce(nullIf(trim(l.project), ''), 'Unknown') AS project,\n    count()                                          AS tx_count,\n    countDistinct(tx.from_address)                   AS active_accounts,\n    groupBitmapState(cityHash64(tx.from_address))    AS ua_bitmap_state,\n    sum(tx.gas_used * tx.gas_price) / 1e18           AS fee_native_sum\n  FROM tx\n  ANY LEFT JOIN lbl l ON tx.to_address = l.address\n  GROUP BY tx.hour, project\n),\n\nproj_sector AS (\n  SELECT\n    project,\n    coalesce(nullIf(trim(sector), ''), 'Unknown') AS sector\n  FROM (\n    SELECT project, anyHeavy(sector) AS sector\n    FROM `dbt`.`int_crawlers_data_labels`\n    GROUP BY project\n  )\n)\n\nSELECT\n  c.hour,\n  c.project,\n  ps.sector,\n  c.tx_count,\n  c.active_accounts,\n  c.ua_bitmap_state,\n  c.fee_native_sum\nFROM classified c\nLEFT JOIN proj_sector ps ON ps.project = c.project", "relation_name": "`dbt`.`int_execution_transactions_by_project_hourly_recent`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.249167Z", "completed_at": "2025-10-24T12:23:14.257270Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.257851Z", "completed_at": "2025-10-24T12:23:14.257858Z"}], "thread_id": "Thread-1", "execution_time": 0.009976625442504883, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_client_distribution", "compiled": true, "compiled_code": "\n\nWITH node_classification AS (\n    -- Get total nodes per category from classification model\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        scaling_factor\n    FROM `dbt`.`int_esg_node_classification`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`)\n    \n),\n\n-- Combine client data from both DiscV4 (execution) and DiscV5 (consensus)\ncombined_client_data AS (\n    -- DiscV5 Consensus clients\n    SELECT\n        date,\n        'consensus_' || label AS client_type,\n        value AS observed_client_nodes\n    FROM `dbt`.`int_p2p_discv5_clients_daily`\n    WHERE metric = 'Clients' \n        AND value > 0\n        AND label NOT IN ('Unknown', '')\n        \n            AND date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`) - INTERVAL 1 DAY\n        \n    \n    UNION ALL\n    \n    -- DiscV4 Execution clients  \n    SELECT\n        date,\n        'execution_' || label AS client_type,\n        value AS observed_client_nodes\n    FROM `dbt`.`int_p2p_discv4_clients_daily`\n    WHERE metric = 'Clients'\n        AND value > 0  \n        AND label NOT IN ('Unknown', '')\n        \n            AND date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_client_distribution`) - INTERVAL 1 DAY\n        \n),\n\n-- Calculate client distribution percentages\nobserved_client_distribution AS (\n    SELECT\n        date,\n        client_type,\n        observed_client_nodes,\n        round(100.0 * observed_client_nodes / SUM(observed_client_nodes) OVER (PARTITION BY date), 3) AS observed_client_percentage\n    FROM combined_client_data\n),\n\n-- Apply client distribution to each node category\nclient_distribution_by_category AS (\n    SELECT\n        nc.date,\n        nc.node_category, \n        ocd.client_type,\n        ocd.observed_client_nodes,\n        ocd.observed_client_percentage,\n        \n        -- Calculate client nodes for this category\n        -- Each client gets same percentage of each category\n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.estimated_total_nodes\n        )) AS estimated_client_nodes,\n        \n        -- Proportional bounds\n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.nodes_lower_95\n        )) AS client_nodes_lower_95,\n        \n        toUInt64(round(\n            ocd.observed_client_percentage / 100.0 * nc.nodes_upper_95\n        )) AS client_nodes_upper_95,\n        \n        -- Client efficiency factors\n        CASE \n            -- Consensus client efficiency (relative to baseline)\n            WHEN ocd.client_type = 'consensus_Lighthouse' THEN 0.95\n            WHEN ocd.client_type = 'consensus_Nimbus' THEN 0.85  \n            WHEN ocd.client_type = 'consensus_Teku' THEN 1.15\n            WHEN ocd.client_type = 'consensus_Prysm' THEN 1.05\n            WHEN ocd.client_type = 'consensus_Lodestar' THEN 1.10\n            \n            -- Execution client efficiency (relative to baseline)\n            WHEN ocd.client_type = 'execution_Erigon' THEN 0.95\n            WHEN ocd.client_type = 'execution_Nethermind' THEN 1.00\n            WHEN ocd.client_type = 'execution_Besu' THEN 1.02\n            WHEN ocd.client_type = 'execution_Geth' THEN 0.98\n            \n            -- Default for other/unknown clients\n            ELSE 1.0\n        END AS client_efficiency_factor,\n        \n        nc.scaling_factor\n        \n    FROM node_classification nc\n    JOIN observed_client_distribution ocd ON nc.date = ocd.date\n    WHERE nc.estimated_total_nodes > 0\n),\n\n-- Calculate final metrics with rankings\nfinal_client_distribution AS (\n    SELECT\n        date,\n        node_category,\n        client_type,\n        estimated_client_nodes,\n        client_nodes_lower_95,\n        client_nodes_upper_95,\n        client_efficiency_factor,\n        \n        -- Percentage within this node category\n        round(100.0 * estimated_client_nodes / \n              NULLIF(SUM(estimated_client_nodes) OVER (PARTITION BY date, node_category), 0), 2\n        ) AS category_client_percentage,\n        \n        -- Global percentage across all categories  \n        round(100.0 * estimated_client_nodes /\n              NULLIF(SUM(estimated_client_nodes) OVER (PARTITION BY date), 0), 2\n        ) AS global_client_percentage,\n        \n        -- Ranking within category\n        ROW_NUMBER() OVER (\n            PARTITION BY date, node_category \n            ORDER BY estimated_client_nodes DESC, client_type\n        ) AS rank_in_category,\n        \n        -- Global ranking\n        ROW_NUMBER() OVER (\n            PARTITION BY date \n            ORDER BY estimated_client_nodes DESC, node_category, client_type\n        ) AS global_rank\n        \n    FROM client_distribution_by_category\n    WHERE estimated_client_nodes > 0\n)\n\nSELECT\n    date,\n    node_category,\n    client_type,\n    estimated_client_nodes,\n    client_nodes_lower_95,\n    client_nodes_upper_95,\n    client_efficiency_factor,\n    category_client_percentage,\n    global_client_percentage,\n    rank_in_category,\n    global_rank,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM final_client_distribution\nORDER BY date, node_category, estimated_client_nodes DESC", "relation_name": "`dbt`.`int_esg_node_client_distribution`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.260528Z", "completed_at": "2025-10-24T12:23:14.266013Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.266594Z", "completed_at": "2025-10-24T12:23:14.266602Z"}], "thread_id": "Thread-1", "execution_time": 0.007302284240722656, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_node_geographic_distribution", "compiled": true, "compiled_code": "\n\nWITH node_classification AS (\n    -- Get node classification data\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        geographic_distribution\n    FROM `dbt`.`int_esg_node_classification`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`int_esg_node_geographic_distribution`)\n    \n),\n\n-- Parse geographic distribution JSON\ngeographic_parsed AS (\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        \n        -- Parse JSON array of country distributions\n        JSONExtract(geographic_distribution, 'Array(Tuple(String, UInt32))') AS country_array\n    FROM node_classification\n),\n\ngeographic_expanded AS (\n    SELECT\n        date,\n        node_category,\n        estimated_total_nodes,\n        nodes_lower_95, \n        nodes_upper_95,\n        \n        -- Unpack country data\n        arrayJoin(country_array) AS country_tuple,\n        tupleElement(country_tuple, 1) AS country_code,\n        tupleElement(country_tuple, 2) AS estimated_nodes\n        \n    FROM geographic_parsed\n    WHERE length(country_array) > 0\n),\n\n-- Add country metadata from country_codes table\ncountry_enriched AS (\n    SELECT\n        g.date,\n        g.node_category,\n        g.country_code,\n        g.estimated_nodes,\n        \n        -- Calculate bounds proportionally\n        round(toFloat64(g.estimated_nodes) * g.nodes_lower_95 / g.estimated_total_nodes) AS nodes_lower_95,\n        round(toFloat64(g.estimated_nodes) * g.nodes_upper_95 / g.estimated_total_nodes) AS nodes_upper_95,\n        \n        -- Country percentage within this category\n        round(100.0 * g.estimated_nodes / g.estimated_total_nodes, 2) AS category_percentage,\n        \n        -- Get country metadata from reference table\n        COALESCE(cc.name, 'Unknown') AS country_name,\n        COALESCE(cc.region, 'Other') AS region,\n        cc.`sub-region` AS sub_region,\n        cc.`alpha-3` AS country_code_alpha3\n        \n    FROM geographic_expanded g\n    LEFT JOIN `dbt`.`stg_crawlers_data__country_codes` cc\n        ON g.country_code = cc.`alpha-2`\n    WHERE g.estimated_nodes > 0  -- Only include countries with nodes\n)\n\nSELECT\n    date,\n    node_category,\n    country_code,\n    country_name,\n    region,\n    sub_region,\n    country_code_alpha3,\n    estimated_nodes AS estimated_total_nodes,\n    nodes_lower_95,\n    nodes_upper_95,\n    category_percentage,\n    \n    -- Overall percentage across all categories\n    round(100.0 * estimated_nodes / SUM(estimated_nodes) OVER (PARTITION BY date), 2) AS global_percentage,\n    \n    -- Ranking within category\n    ROW_NUMBER() OVER (PARTITION BY date, node_category ORDER BY estimated_nodes DESC) AS rank_in_category,\n    \n    -- Ranking globally\n    ROW_NUMBER() OVER (PARTITION BY date ORDER BY estimated_nodes DESC) AS global_rank,\n    \n    -- Metadata\n    now() AS calculated_at\n    \nFROM country_enriched\nORDER BY date, node_category, estimated_nodes DESC", "relation_name": "`dbt`.`int_esg_node_geographic_distribution`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.269371Z", "completed_at": "2025-10-24T12:23:14.273180Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.273760Z", "completed_at": "2025-10-24T12:23:14.273767Z"}], "thread_id": "Thread-1", "execution_time": 0.005767345428466797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_p2p_topology_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    protocol,\n    date,\n    peer_discovery_id_prefix,\n    peer_client,\n    peer_city,\n    peer_country,\n    peer_org,\n    peer_lat,\n    peer_lon,\n    neighbor_discovery_id_prefix,\n    neighbor_client,\n    neighbor_city,\n    neighbor_country,\n    neighbor_org,\n    neighbor_lat,\n    neighbor_lon,\n    cnt\nFROM `dbt`.`fct_p2p_topology_latest`\nWHERE peer_lat IS NOT NULL AND neighbor_lat IS NOT NULL\nORDER BY protocol DESC", "relation_name": "`dbt`.`api_p2p_topology_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.276421Z", "completed_at": "2025-10-24T12:23:14.281419Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.281982Z", "completed_at": "2025-10-24T12:23:14.281990Z"}], "thread_id": "Thread-1", "execution_time": 0.006871223449707031, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_validators_apy_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,balance\n    ,rate\n    ,avg(rate) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rate_7dma\n    ,apy\n    ,ROUND((POWER((1+rate_7dma),365) - 1) * 100,2) AS apy_7dma\nFROM `dbt`.`int_consensus_validators_apy_daily`\nWHERE date > DATE '2021-12-08'", "relation_name": "`dbt`.`fct_consensus_validators_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.284651Z", "completed_at": "2025-10-24T12:23:14.288718Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.289320Z", "completed_at": "2025-10-24T12:23:14.289328Z"}], "thread_id": "Thread-1", "execution_time": 0.005961418151855469, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_rwa_backedfi_prices_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  bticker,\n  date,\n  price         \nFROM `dbt`.`fct_execution_rwa_backedfi_prices_daily`\nORDER BY\n  bticker,\n  date", "relation_name": "`dbt`.`api_execution_rwa_backedfi_prices_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.291956Z", "completed_at": "2025-10-24T12:23:14.296645Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.297237Z", "completed_at": "2025-10-24T12:23:14.297245Z"}], "thread_id": "Thread-1", "execution_time": 0.006587982177734375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_backers_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nbackers_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_backing`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_backing`)\n),\n\nbackers_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_backing`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_backing`), 7)\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM backers_latest t1\nCROSS JOIN backers_7d t2", "relation_name": "`dbt`.`api_execution_circles_backers_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.299881Z", "completed_at": "2025-10-24T12:23:14.303656Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.304228Z", "completed_at": "2025-10-24T12:23:14.304236Z"}], "thread_id": "Thread-1", "execution_time": 0.005587577819824219, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_avatars", "compiled": true, "compiled_code": "\n\nSELECT\n    date\n    ,avatar_type\n    ,cnt\n    ,total\nFROM `dbt`.`fct_execution_circles_avatars`\nORDER BY date, avatar_type", "relation_name": "`dbt`.`api_execution_circles_avatars`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.306842Z", "completed_at": "2025-10-24T12:23:14.311543Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.312102Z", "completed_at": "2025-10-24T12:23:14.312110Z"}], "thread_id": "Thread-1", "execution_time": 0.006504535675048828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_groups_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ngroups_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Group'\n),\n\ngroups_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Group'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM groups_latest t1\nCROSS JOIN groups_7d t2", "relation_name": "`dbt`.`api_execution_circles_groups_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.314785Z", "completed_at": "2025-10-24T12:23:14.319654Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.320244Z", "completed_at": "2025-10-24T12:23:14.320252Z"}], "thread_id": "Thread-1", "execution_time": 0.0067653656005859375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_humans_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\nhumans_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Human'\n),\n\nhumans_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Human'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM humans_latest t1\nCROSS JOIN humans_7d t2", "relation_name": "`dbt`.`api_execution_circles_humans_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.322871Z", "completed_at": "2025-10-24T12:23:14.328784Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.329360Z", "completed_at": "2025-10-24T12:23:14.329368Z"}], "thread_id": "Thread-1", "execution_time": 0.00771641731262207, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_circles_orgs_cnt_latest", "compiled": true, "compiled_code": "\n\nWITH\n\norgs_latest AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = (SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`)\n        AND avatar_type = 'Org'\n),\n\norgs_7d AS (\n    SELECT \n        total\n    FROM `dbt`.`fct_execution_circles_avatars`\n    WHERE \n        date = subtractDays((SELECT max(date) FROM `dbt`.`fct_execution_circles_avatars`), 7)\n        AND avatar_type = 'Org'\n)\n\nSELECT\n    t1.total AS total\n    ,IF(t1.total=0 AND t2.total=0, 0, ROUND((COALESCE(t1.total / NULLIF(t2.total, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM orgs_latest t1\nCROSS JOIN orgs_7d t2", "relation_name": "`dbt`.`api_execution_circles_orgs_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.332052Z", "completed_at": "2025-10-24T12:23:14.336135Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.336712Z", "completed_at": "2025-10-24T12:23:14.336719Z"}], "thread_id": "Thread-1", "execution_time": 0.005955934524536133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_gas_share_by_project_daily", "compiled": true, "compiled_code": "\n\nWITH tot AS (\n  SELECT\n    date,\n    SUM(gas_used_sum) AS day_gas_used\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  WHERE date < today()     \n  GROUP BY date\n)\nSELECT\n  p.date,\n  p.project AS label,\n  ROUND(p.gas_used_sum / NULLIF(t.day_gas_used, 0) * 100, 2) AS value\nFROM `dbt`.`int_execution_transactions_by_project_daily` p\nJOIN tot t USING (date)\nWHERE p.date < today()\nORDER BY p.date DESC, label", "relation_name": "`dbt`.`api_execution_transactions_gas_share_by_project_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.339342Z", "completed_at": "2025-10-24T12:23:14.343702Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.344277Z", "completed_at": "2025-10-24T12:23:14.344285Z"}], "thread_id": "Thread-1", "execution_time": 0.0061609745025634766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_project_monthly_top5", "compiled": true, "compiled_code": "\n\nWITH base AS (\n  SELECT\n    toStartOfMonth(date)                    AS month,\n    project,\n    sum(tx_count)                           AS txs,\n    sum(fee_native_sum)                     AS fee_native,\n    sum(gas_used_sum)                       AS gas_used,\n    groupBitmapMergeState(ua_bitmap_state)  AS active_state\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  GROUP BY month, project\n),\nranked AS (\n  SELECT\n    month, project, txs, fee_native, gas_used, active_state,\n    row_number() OVER (PARTITION BY month ORDER BY txs DESC, fee_native DESC, project ASC) AS rk\n  FROM base\n),\nbucketed AS (\n  SELECT\n    month,\n    if(rk <= 5, project, 'Others') AS project_label,\n    txs, fee_native, gas_used, active_state\n  FROM ranked\n),\nmonthly AS (\n  SELECT\n    month,\n    project_label AS project,\n    sum(txs)                            AS txs,\n    sum(fee_native)                     AS fee_native,\n    sum(gas_used)                       AS gas_used,\n    groupBitmapMergeState(active_state) AS active_state\n  FROM bucketed\n  GROUP BY month, project_label\n)\n\nSELECT * FROM (\n  SELECT month AS date, project AS label, 'Transactions'  AS metric, toFloat64(txs)                              AS value FROM monthly\n  UNION ALL\n  SELECT month AS date, project AS label, 'FeesNative'    AS metric, round(toFloat64(fee_native), 6)             AS value FROM monthly\n  UNION ALL\n  SELECT month AS date, project AS label, 'GasUsed'       AS metric, toFloat64(gas_used)                         AS value FROM monthly\n  UNION ALL\n  SELECT\n    month AS date,\n    project AS label,\n    'ActiveAccounts' AS metric,\n    toFloat64(finalizeAggregation(active_state)) AS value\n  FROM monthly\n)\nORDER BY date ASC, label ASC, metric ASC", "relation_name": "`dbt`.`fct_execution_transactions_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.347122Z", "completed_at": "2025-10-24T12:23:14.351059Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.351641Z", "completed_at": "2025-10-24T12:23:14.351649Z"}], "thread_id": "Thread-1", "execution_time": 0.005831480026245117, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_sector_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    sector,\n    groupBitmapMerge(ua_bitmap_state)                 AS active_accounts,\n    sum(tx_count)                                     AS txs,\n    sum(gas_used_sum)                                 AS gas_used_sum,\n    round(toFloat64(sum(fee_native_sum)), 6)          AS fee_native_sum\nFROM `dbt`.`int_execution_transactions_by_project_daily`\nGROUP BY\n  date, sector", "relation_name": "`dbt`.`fct_execution_transactions_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.354476Z", "completed_at": "2025-10-24T12:23:14.360868Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.361450Z", "completed_at": "2025-10-24T12:23:14.361458Z"}], "thread_id": "Thread-1", "execution_time": 0.008461236953735352, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_execution_transactions_by_project_alltime_state", "compiled": true, "compiled_code": "\n\n\n\n\nWITH src AS (\n  SELECT\n    toStartOfMonth(date)                   AS month,\n    project,\n    sumState(tx_count)                     AS txs_state,\n    sumState(fee_native_sum)               AS fee_state,\n    groupBitmapMergeState(ua_bitmap_state) AS aa_state\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n  WHERE 1=1\n    \n      \n  \n    \n      \n    \n\n   AND \n    toStartOfMonth(toStartOfDay(date)) >= (\n      SELECT max(toStartOfMonth(t.month))\n      FROM `dbt`.`int_execution_transactions_by_project_alltime_state` AS t\n    )\n    AND toStartOfDay(date) >= (\n      SELECT max(toStartOfDay(t2.month, 'UTC'))\n      FROM `dbt`.`int_execution_transactions_by_project_alltime_state` AS t2\n    )\n  \n\n    \n  GROUP BY month, project\n)\n\nSELECT project, month, txs_state, fee_state, aa_state\nFROM src", "relation_name": "`dbt`.`int_execution_transactions_by_project_alltime_state`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.364129Z", "completed_at": "2025-10-24T12:23:14.368097Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.368701Z", "completed_at": "2025-10-24T12:23:14.368708Z"}], "thread_id": "Thread-1", "execution_time": 0.005921125411987305, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_sector_hourly", "compiled": true, "compiled_code": "\n\nSELECT\n  hour AS date,\n  sector AS label,\n  groupBitmapMerge(ua_bitmap_state) AS value\nFROM `dbt`.`int_execution_transactions_by_project_hourly_recent`\nGROUP BY date, label\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_sector_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.371359Z", "completed_at": "2025-10-24T12:23:14.376542Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.377111Z", "completed_at": "2025-10-24T12:23:14.377118Z"}], "thread_id": "Thread-1", "execution_time": 0.007079362869262695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_sector_hourly", "compiled": true, "compiled_code": "\n\nSELECT\n  hour AS date,\n  sector AS label,\n  sum(tx_count) AS value\nFROM `dbt`.`int_execution_transactions_by_project_hourly_recent`\nGROUP BY date, label\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_sector_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.379776Z", "completed_at": "2025-10-24T12:23:14.383597Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.384157Z", "completed_at": "2025-10-24T12:23:14.384164Z"}], "thread_id": "Thread-1", "execution_time": 0.005631923675537109, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_sector_hourly", "compiled": true, "compiled_code": "\n\nSELECT\n  hour AS date,\n  sector AS label,\n  round(toFloat64(sum(fee_native_sum)), 2) AS value\nFROM `dbt`.`int_execution_transactions_by_project_hourly_recent`\nGROUP BY date, label\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_sector_hourly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.386829Z", "completed_at": "2025-10-24T12:23:14.394615Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.395173Z", "completed_at": "2025-10-24T12:23:14.395181Z"}], "thread_id": "Thread-1", "execution_time": 0.009598255157470703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.int_esg_dynamic_power_consumption", "compiled": true, "compiled_code": "\n\nWITH node_distribution AS (\n    SELECT\n        date,\n        node_category,\n        country_code,\n        country_name,\n        region,\n        sub_region,\n        country_code_alpha3,\n        estimated_total_nodes,  \n        nodes_lower_95,           \n        nodes_upper_95          \n    FROM `dbt`.`int_esg_node_geographic_distribution` n\n    \n        WHERE n.date > (SELECT MAX(date) FROM `dbt`.`int_esg_dynamic_power_consumption`)\n    \n),\n\n-- Get client efficiency from upstream client distribution model\nclient_efficiency_by_category AS (\n    SELECT\n        date,\n        node_category,\n        \n        -- Weighted average client efficiency for this category\n        SUM(category_client_percentage / 100.0 * client_efficiency_factor) AS avg_client_efficiency,\n        \n        -- Client diversity count for resilience bonus\n        COUNT(DISTINCT client_type) AS client_diversity,\n        \n        -- Total estimated client nodes for validation\n        SUM(estimated_client_nodes) AS total_client_nodes,\n        \n        -- Client breakdown for diagnostics\n        groupArray((client_type, category_client_percentage, estimated_client_nodes)) AS client_breakdown\n        \n    FROM `dbt`.`int_esg_node_client_distribution` ncd\n    \n        WHERE ncd.date > (SELECT MAX(date) FROM `dbt`.`int_esg_dynamic_power_consumption`) - INTERVAL 1 DAY\n    \n    GROUP BY date, node_category\n),\n\n-- Base power calculations by hardware tier with CCRI empirical values\npower_per_category AS (\n    SELECT\n        nd.date,\n        nd.node_category,\n        nd.country_code,\n        nd.country_name,\n        nd.region,\n        nd.sub_region,\n        nd.country_code_alpha3,\n        nd.estimated_total_nodes,\n        nd.nodes_lower_95,\n        nd.nodes_upper_95,\n        \n        -- CCRI empirical power consumption (Watts per node)\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 22.0        -- CCRI Tier 4: mean of 16.56-25.97W\n            WHEN 'professional_operator' THEN 48.0  -- CCRI Tier 5: mean of 36.82-59.95W\n            WHEN 'cloud_hosted' THEN 155.0      -- CCRI Tier 6: mean of 139.90-186.76W\n            ELSE 50.0\n        END AS base_power_watts,\n        \n        -- Standard deviation based on CCRI measurement ranges\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 3.3        -- ~15% of 22W (conservative uncertainty)\n            WHEN 'professional_operator' THEN 7.2  -- ~15% of 48W\n            WHEN 'cloud_hosted' THEN 23.0       -- ~15% of 155W\n            ELSE 7.5\n        END AS power_std_watts,\n        \n        -- Data source for traceability\n        CASE nd.node_category\n            WHEN 'home_staker' THEN 'CCRI_Tier4_Empirical'\n            WHEN 'professional_operator' THEN 'CCRI_Tier5_Empirical'\n            WHEN 'cloud_hosted' THEN 'CCRI_Tier6_Empirical'\n            ELSE 'CCRI_Default'\n        END AS power_source,\n        \n        -- Measurement confidence (CCRI empirical data is high quality)\n        0.85 AS measurement_confidence,\n        \n        -- PUE by category  \n        CASE nd.node_category\n            WHEN 'home_staker' THEN 1.0         -- No datacenter overhead\n            WHEN 'professional_operator' THEN 1.58  -- Traditional datacenter\n            WHEN 'cloud_hosted' THEN 1.15       -- Efficient cloud datacenter\n            ELSE 1.1\n        END AS pue_factor,\n        \n        -- Client efficiency from upstream model\n        COALESCE(ce.avg_client_efficiency, 1.0) AS client_efficiency_multiplier,\n        \n        -- Diversity bonus (more client types = better resilience)\n        CASE \n            WHEN ce.client_diversity > 0 THEN 0.95 + 0.05 * least(4, ce.client_diversity) / 4.0\n            ELSE 1.0\n        END AS diversity_bonus,\n        \n        ce.client_breakdown,\n        ce.total_client_nodes\n        \n    FROM node_distribution nd\n    LEFT JOIN client_efficiency_by_category ce ON nd.date = ce.date AND nd.node_category = ce.node_category\n),\n\n-- Apply all efficiency factors\nfinal_power_calculations AS (\n    SELECT\n        p.*,\n        \n        -- Final power per node with all efficiency factors\n        p.base_power_watts * p.client_efficiency_multiplier * p.diversity_bonus AS avg_power_watts_per_node,\n        p.power_std_watts * p.client_efficiency_multiplier * p.diversity_bonus AS power_std_dev_per_node,\n        \n        -- Daily energy consumption (kWh)\n        p.estimated_total_nodes * \n        p.base_power_watts * \n        p.client_efficiency_multiplier * \n        p.diversity_bonus * \n        24.0 / 1000.0 AS daily_energy_kwh_mean\n\n    FROM power_per_category p\n),\n\n-- Carbon intensity lookup with robust fallback\ncarbon_intensity_lookup AS (\n    SELECT DISTINCT\n        p.date,\n        p.country_code_alpha3,\n        \n        -- Robust fallback hierarchy\n        COALESCE(\n            ci_country.carbon_intensity_mean,\n            ci_world.carbon_intensity_mean,\n            450.0\n        ) AS carbon_intensity_gco2_kwh,\n        \n        COALESCE(\n            ci_country.carbon_intensity_std,\n            ci_world.carbon_intensity_std, \n            45.0\n        ) AS carbon_intensity_std_gco2_kwh,\n        \n        CASE \n            WHEN ci_country.carbon_intensity_mean IS NOT NULL THEN 'country_specific'\n            WHEN ci_world.carbon_intensity_mean IS NOT NULL THEN 'world_average'\n            ELSE 'conservative_default'\n        END AS carbon_intensity_source\n        \n    FROM final_power_calculations p\n    LEFT JOIN `dbt`.`int_esg_carbon_intensity_ensemble` ci_country\n        ON p.country_code_alpha3 = ci_country.country_code\n        AND ci_country.month_date = toStartOfMonth(p.date)\n        AND p.country_code_alpha3 IS NOT NULL\n        AND p.country_code_alpha3 != ''\n    LEFT JOIN `dbt`.`int_esg_carbon_intensity_ensemble` ci_world\n        ON ci_world.country_code = 'WORLD'\n        AND ci_world.month_date = toStartOfMonth(p.date)\n    WHERE ci_country.month_date != DATE '1970-01-01' OR ci_world.month_date != DATE '1970-01-01' -- nu;;s ghet repl;ace by date...\n),\n\n-- Final calculations with carbon emissions\nfinal_calculations AS (\n    SELECT\n        p.date AS date,\n        p.node_category AS node_category,\n        p.country_code AS country_code,\n        p.country_code_alpha3 AS country_code_alpha3,\n        p.country_name AS country_name,\n        p.region AS region,\n        p.sub_region AS sub_region,\n        p.estimated_total_nodes AS estimated_total_nodes,\n        p.nodes_lower_95 AS nodes_lower_95,\n        p.nodes_upper_95 AS nodes_upper_95,\n        p.avg_power_watts_per_node AS avg_power_watts_per_node,\n        p.power_std_dev_per_node AS power_std_dev_per_node,\n        p.daily_energy_kwh_mean AS daily_energy_kwh_mean,\n        p.pue_factor AS pue_factor,\n        p.client_efficiency_multiplier AS client_efficiency,\n        p.diversity_bonus,\n        \n        -- CCRI source tracking\n        p.power_source,\n        p.measurement_confidence,\n        p.base_power_watts AS ccri_base_power_watts,\n        \n        -- Carbon intensity from lookup\n        ci.carbon_intensity_gco2_kwh,\n        ci.carbon_intensity_std_gco2_kwh,\n        ci.carbon_intensity_source,\n        \n        -- CO2 calculations\n        p.daily_energy_kwh_mean * p.pue_factor * ci.carbon_intensity_gco2_kwh / 1000.0 AS daily_co2_kg_mean,\n        \n        -- CO2 standard deviation\n        sqrt(\n            pow(p.daily_energy_kwh_mean * p.pue_factor * ci.carbon_intensity_std_gco2_kwh / 1000.0, 2) +\n            pow(p.power_std_dev_per_node * 24 / 1000.0 * p.pue_factor * ci.carbon_intensity_gco2_kwh / 1000.0, 2)\n        ) AS daily_co2_kg_std,\n        \n        -- Diagnostics\n        p.client_breakdown,\n        p.total_client_nodes\n        \n    FROM final_power_calculations p\n    INNER JOIN carbon_intensity_lookup ci\n        ON p.date = ci.date\n        AND COALESCE(p.country_code_alpha3, '') = COALESCE(ci.country_code_alpha3, '')\n)\n\nSELECT\n    date,\n    node_category,\n    country_code,\n    country_name,\n    region,\n    estimated_total_nodes,\n    nodes_lower_95,\n    nodes_upper_95,\n    \n    -- Power consumption metrics\n    round(avg_power_watts_per_node, 2) AS avg_power_watts_per_node,\n    round(power_std_dev_per_node, 2) AS power_std_dev_per_node,\n    round(daily_energy_kwh_mean, 2) AS daily_energy_kwh_mean,\n    round(pue_factor, 3) AS pue_mean,\n    round(client_efficiency, 3) AS client_efficiency_factor,\n    round(diversity_bonus, 3) AS diversity_bonus,\n    \n    -- Carbon emissions\n    round(daily_co2_kg_mean, 4) AS daily_co2_kg_mean,\n    round(daily_co2_kg_std, 4) AS daily_co2_kg_std,\n    round(carbon_intensity_gco2_kwh, 2) AS carbon_intensity_gco2_kwh,\n    round(carbon_intensity_std_gco2_kwh, 2) AS carbon_intensity_std_gco2_kwh,\n    \n    -- Confidence intervals\n    round(greatest(0, daily_co2_kg_mean - 1.96 * daily_co2_kg_std), 4) AS daily_co2_kg_lower_95,\n    round(daily_co2_kg_mean + 1.96 * daily_co2_kg_std, 4) AS daily_co2_kg_upper_95,\n    \n    -- CCRI data quality and source tracking\n    carbon_intensity_source,\n    round(ccri_base_power_watts, 2) AS ccri_base_power_watts,\n    power_source,\n    round(measurement_confidence, 3) AS measurement_confidence,\n    \n    -- Performance comparison with previous estimates\n    round(\n        100.0 * (avg_power_watts_per_node - CASE node_category\n            WHEN 'home_staker' THEN 75.0\n            WHEN 'professional_operator' THEN 200.0  \n            WHEN 'cloud_hosted' THEN 110.0\n            ELSE 100.0\n        END) / CASE node_category\n            WHEN 'home_staker' THEN 75.0\n            WHEN 'professional_operator' THEN 200.0\n            WHEN 'cloud_hosted' THEN 110.0  \n            ELSE 100.0\n        END, 1\n    ) AS power_reduction_vs_previous_pct,\n    \n    -- Diagnostics\n    toJSONString(client_breakdown) AS client_breakdown_json,\n    total_client_nodes AS debug_total_clients,\n    \n    -- Metadata\n    now() AS calculated_at\n\nFROM final_calculations\nWHERE estimated_total_nodes > 0", "relation_name": "`dbt`.`int_esg_dynamic_power_consumption`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.397861Z", "completed_at": "2025-10-24T12:23:14.401921Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.402510Z", "completed_at": "2025-10-24T12:23:14.402518Z"}], "thread_id": "Thread-1", "execution_time": 0.006002664566040039, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_validators_apy_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,label\n    ,apy\nFROM (\n    SELECT date, 'Daily' AS label, apy AS apy FROM `dbt`.`fct_consensus_validators_apy_daily`\n    UNION ALL \n    SELECT date, '7DMA' AS label, apy_7dma AS apy FROM `dbt`.`fct_consensus_validators_apy_daily`\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_consensus_validators_apy_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.405085Z", "completed_at": "2025-10-24T12:23:14.412955Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.413530Z", "completed_at": "2025-10-24T12:23:14.413538Z"}], "thread_id": "Thread-1", "execution_time": 0.00972437858581543, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_consensus_info_latest", "compiled": true, "compiled_code": "\n\nWITH\n\ndeposits_withdrawls_latest AS (\n    SELECT\n        label\n        ,cnt\n        ,total_amount\n    FROM \n        `dbt`.`fct_consensus_deposits_withdrawls_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`fct_consensus_deposits_withdrawls_daily`)\n),\n\ndeposits_withdrawls_7d AS (\n    SELECT\n        label\n        ,cnt\n        ,total_amount\n    FROM \n        `dbt`.`fct_consensus_deposits_withdrawls_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_p2p_discv4_clients_daily`), 7)\n),\n\napy_latest AS (\n    SELECT\n        apy_7dma\n    FROM \n        `dbt`.`fct_consensus_validators_apy_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`fct_consensus_validators_apy_daily`)\n),\n\napy_7d AS (\n    SELECT\n       apy_7dma\n    FROM \n        `dbt`.`fct_consensus_validators_apy_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`fct_consensus_validators_apy_daily`), 7)\n),\n\nstatus_latest AS (\n    SELECT\n        status AS label\n        ,CAST(COALESCE(cnt,0) AS Float64) AS value\n    FROM \n        `dbt`.`int_consensus_validators_status_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_validators_status_daily`)\n),\n\nstatus_7d AS (\n    SELECT\n        status AS label\n        ,CAST(COALESCE(cnt,0) AS Float64) AS value\n    FROM \n        `dbt`.`int_consensus_validators_status_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_validators_status_daily`), 7)\n),\n\n\nstaked_latest AS (\n    SELECT\n        'Staked' AS label\n        ,effective_balance/32 AS value\n    FROM \n        `dbt`.`int_consensus_validators_balances_daily`\n    WHERE\n        date = (SELECT MAX(date) FROM `dbt`.`int_consensus_validators_balances_daily`)\n),\n\nstaked_7d AS (\n    SELECT\n        'Staked' AS label\n        ,effective_balance/32 AS value\n    FROM \n        `dbt`.`int_consensus_validators_balances_daily`\n    WHERE\n        date = subtractDays((SELECT MAX(date) FROM `dbt`.`int_consensus_validators_balances_daily`), 7)\n),\n\n\ninfo_latest AS ( \n    SELECT\n        'deposits_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_latest WHERE label = 'deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_latest WHERE label = 'withdrawls'), 0) AS value\n    UNION ALL\n    SELECT\n        'deposits_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'withdrawls'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_latest WHERE label = 'withdrawls'), 0) AS value\n    UNION ALL\n    SELECT\n        'APY7D' AS label \n    ,COALESCE((SELECT ROUND(apy_7dma,2) FROM apy_latest),0) AS value\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM status_latest\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM staked_latest\n),\n\ninfo_7d AS ( \n    SELECT\n        'deposits_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_7d WHERE label = 'deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'withdrawls_cnt' AS label\n    ,COALESCE( (SELECT CAST(cnt AS Float64) FROM deposits_withdrawls_7d WHERE label = 'withdrawls'), 0) AS value\n    UNION ALL\n    SELECT\n        'deposits_total_amount' AS label \n    ,COALESCE( (SELECT ROUND(total_amount,2) FROM deposits_withdrawls_7d WHERE label = 'deposits'), 0) AS value\n    UNION ALL\n    SELECT\n        'APY7D' AS label \n    ,COALESCE((SELECT ROUND(apy_7dma,2) FROM apy_7d),0) AS value\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM status_7d\n    UNION ALL\n    SELECT\n       label \n    ,  value\n    FROM staked_7d\n)\n\nSELECT\n    t1.label\n    ,t1.value AS value\n    ,IF(t1.value=0 AND t2.value=0, 0, ROUND(( COALESCE(t1.value / NULLIF(t2.value, 0), 0) - 1) * 100, 1)) AS change_pct\nFROM info_latest t1\nINNER JOIN info_7d t2\nON t2.label = t1.label", "relation_name": "`dbt`.`fct_consensus_info_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.416341Z", "completed_at": "2025-10-24T12:23:14.421305Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.421866Z", "completed_at": "2025-10-24T12:23:14.421874Z"}], "thread_id": "Thread-1", "execution_time": 0.007030010223388672, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_project_monthly_top5", "compiled": true, "compiled_code": "\nSELECT\n  date,\n  label,\n  value\nFROM `dbt`.`fct_execution_transactions_by_project_monthly_top5`\nWHERE metric = 'ActiveAccounts'\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.424483Z", "completed_at": "2025-10-24T12:23:14.428207Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.428764Z", "completed_at": "2025-10-24T12:23:14.428772Z"}], "thread_id": "Thread-1", "execution_time": 0.005498170852661133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_project_monthly_top5", "compiled": true, "compiled_code": "\nSELECT\n  date,\n  label,\n  value\nFROM `dbt`.`fct_execution_transactions_by_project_monthly_top5`\nWHERE metric = 'Transactions'\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.431445Z", "completed_at": "2025-10-24T12:23:14.435243Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.435816Z", "completed_at": "2025-10-24T12:23:14.435824Z"}], "thread_id": "Thread-1", "execution_time": 0.005590677261352539, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_project_monthly_top5", "compiled": true, "compiled_code": "\nSELECT\n  date,\n  label,\n  value\nFROM `dbt`.`fct_execution_transactions_by_project_monthly_top5`\nWHERE metric = 'FeesNative'\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_project_monthly_top5`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.438413Z", "completed_at": "2025-10-24T12:23:14.442220Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.442783Z", "completed_at": "2025-10-24T12:23:14.442791Z"}], "thread_id": "Thread-1", "execution_time": 0.005598545074462891, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_sector_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  sector AS label,\n  active_accounts AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_daily`\nWHERE date < today()\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.445379Z", "completed_at": "2025-10-24T12:23:14.449166Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.449750Z", "completed_at": "2025-10-24T12:23:14.449758Z"}], "thread_id": "Thread-1", "execution_time": 0.005584716796875, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_sector_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  sector AS label,\n  txs AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_daily`\nWHERE date < today()\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.452340Z", "completed_at": "2025-10-24T12:23:14.456262Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.456822Z", "completed_at": "2025-10-24T12:23:14.456830Z"}], "thread_id": "Thread-1", "execution_time": 0.005700826644897461, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_sector_daily", "compiled": true, "compiled_code": "\n\nSELECT\n  date,\n  sector AS label,\n  fee_native_sum AS value\nFROM `dbt`.`fct_execution_transactions_by_sector_daily`\nWHERE date < today()\nORDER BY date ASC, label ASC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_sector_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.459424Z", "completed_at": "2025-10-24T12:23:14.465610Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.466169Z", "completed_at": "2025-10-24T12:23:14.466176Z"}], "thread_id": "Thread-1", "execution_time": 0.007995128631591797, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_by_project_snapshots", "compiled": true, "compiled_code": "\n\nWITH wd AS (\n  SELECT max(date) AS max_date\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n),\nrng AS (\n  SELECT '1D'  AS window,  1  AS days UNION ALL\n  SELECT '7D'  AS window,  7  AS days UNION ALL\n  SELECT '30D' AS window,  30 AS days UNION ALL\n  SELECT '90D' AS window,  90 AS days\n),\nbounds AS (\n  SELECT\n    r.window,\n    r.days,\n    w.max_date,\n    subtractDays(w.max_date, r.days)        AS curr_start,\n    w.max_date                              AS curr_end,\n    subtractDays(w.max_date, 2 * r.days)    AS prev_start,\n    subtractDays(w.max_date, r.days)        AS prev_end\n  FROM rng r\n  CROSS JOIN wd w\n),\n\ncurr_win AS (\n  SELECT\n    b.window,\n    d.project,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.curr_start\n   AND d.date <= b.curr_end\n  GROUP BY b.window, d.project\n),\nprev_win AS (\n  SELECT\n    b.window,\n    d.project,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.prev_start\n   AND d.date <= b.prev_end\n  GROUP BY b.window, d.project\n),\n\n/* all-time from AMT */\ncurr_all AS (\n  SELECT\n    'All' AS window,\n    a.project,\n    sumMerge(a.txs_state)             AS txs,\n    sumMerge(a.fee_state)             AS fee_native,\n    groupBitmapMerge(a.aa_state)      AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_alltime_state` a\n  GROUP BY a.project\n),\n\njoined AS (\n  SELECT\n    c.window,\n    c.project,\n    c.txs        AS txs_curr,\n    p.txs        AS txs_prev,\n    c.fee_native AS fee_curr,\n    p.fee_native AS fee_prev,\n    c.aa_uniques AS aa_curr,\n    p.aa_uniques AS aa_prev\n  FROM curr_win c\n  LEFT JOIN prev_win p\n    ON p.window = c.window AND p.project = c.project\n),\n\nall_windows AS (\n  SELECT window, project, txs, fee_native, aa_uniques FROM curr_win\n  UNION ALL\n  SELECT window, project, txs, fee_native, aa_uniques FROM curr_all\n)\n\nSELECT\n  'Transactions'            AS label,\n  w.window                  AS window,\n  w.project                 AS bucket,\n  toFloat64(w.txs)          AS value,\n  multiIf(\n    w.window = 'All', NULL,\n    round((coalesce(j.txs_curr / nullIf(j.txs_prev, 0), 0) - 1) * 100, 1)\n  )                         AS change_pct\nFROM all_windows w\nLEFT JOIN joined j\n  ON j.window = w.window AND j.project = w.project\n\nUNION ALL\nSELECT\n  'FeesNative',\n  w.window,\n  w.project,\n  round(toFloat64(w.fee_native), 6),\n  multiIf(\n    w.window = 'All', NULL,\n    round((coalesce(j.fee_curr / nullIf(j.fee_prev, 0), 0) - 1) * 100, 1)\n  )\nFROM all_windows w\nLEFT JOIN joined j\n  ON j.window = w.window AND j.project = w.project\n\nUNION ALL\nSELECT\n  'ActiveAccounts',\n  w.window,\n  w.project,\n  toFloat64(w.aa_uniques),\n  multiIf(\n    w.window = 'All', NULL,\n    round((coalesce(j.aa_curr / nullIf(j.aa_prev, 0), 0) - 1) * 100, 1)\n  )\nFROM all_windows w\nLEFT JOIN joined j\n  ON j.window = w.window AND j.project = w.project", "relation_name": "`dbt`.`fct_execution_transactions_by_project_snapshots`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.468956Z", "completed_at": "2025-10-24T12:23:14.473852Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.474429Z", "completed_at": "2025-10-24T12:23:14.474437Z"}], "thread_id": "Thread-1", "execution_time": 0.0067234039306640625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_execution_transactions_snapshots", "compiled": true, "compiled_code": "\n\nWITH wd AS (\n  SELECT max(date) AS max_date\n  FROM `dbt`.`int_execution_transactions_by_project_daily`\n),\nrng AS (\n  SELECT '1D'  AS window,  1  AS days UNION ALL\n  SELECT '7D'  AS window,  7  AS days UNION ALL\n  SELECT '30D' AS window,  30 AS days UNION ALL\n  SELECT '90D' AS window,  90 AS days\n),\nbounds AS (\n  SELECT\n    r.window,\n    r.days,\n    w.max_date,\n    subtractDays(w.max_date, r.days)        AS curr_start,\n    w.max_date                              AS curr_end,\n    subtractDays(w.max_date, 2 * r.days)    AS prev_start,\n    subtractDays(w.max_date, r.days)        AS prev_end\n  FROM rng r\n  CROSS JOIN wd w\n),\n\ncurr_win AS (\n  SELECT\n    b.window,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.curr_start\n   AND d.date <= b.curr_end\n  GROUP BY b.window\n),\nprev_win AS (\n  SELECT\n    b.window,\n    sum(d.tx_count)                     AS txs,\n    sum(d.fee_native_sum)               AS fee_native,\n    groupBitmapMerge(d.ua_bitmap_state) AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_daily` d\n  INNER JOIN bounds b\n    ON d.date >  b.prev_start\n   AND d.date <= b.prev_end\n  GROUP BY b.window\n),\n\ncurr_all AS (\n  SELECT\n    'All' AS window,\n    sumMerge(a.txs_state)           AS txs,\n    sumMerge(a.fee_state)           AS fee_native,\n    groupBitmapMerge(a.aa_state)    AS aa_uniques\n  FROM `dbt`.`int_execution_transactions_by_project_alltime_state` a\n),\n\ncurr AS (\n  SELECT * FROM curr_win\n  UNION ALL\n  SELECT * FROM curr_all\n)\n\nSELECT\n  'Transactions'            AS label,\n  c.window                  AS window,\n  toFloat64(c.txs)          AS value,\n  CASE\n    WHEN c.window = 'All' THEN NULL\n    ELSE round((coalesce(c.txs / nullIf(p.txs, 0), 0) - 1) * 100, 1)\n  END AS change_pct\nFROM curr c\nLEFT JOIN prev_win p ON p.window = c.window\n\nUNION ALL\nSELECT\n  'FeesNative',\n  c.window,\n  round(toFloat64(c.fee_native), 6),\n  CASE\n    WHEN c.window = 'All' THEN NULL\n    ELSE round((coalesce(c.fee_native / nullIf(p.fee_native, 0), 0) - 1) * 100, 1)\n  END\nFROM curr c\nLEFT JOIN prev_win p ON p.window = c.window\n\nUNION ALL\nSELECT\n  'ActiveAccounts',\n  c.window,\n  toFloat64(c.aa_uniques),\n  CASE\n    WHEN c.window = 'All' THEN NULL\n    ELSE round((coalesce(c.aa_uniques / nullIf(p.aa_uniques, 0), 0) - 1) * 100, 1)\n  END\nFROM curr c\nLEFT JOIN prev_win p ON p.window = c.window", "relation_name": "`dbt`.`fct_execution_transactions_snapshots`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.477127Z", "completed_at": "2025-10-24T12:23:14.485450Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.486018Z", "completed_at": "2025-10-24T12:23:14.486026Z"}], "thread_id": "Thread-1", "execution_time": 0.010187387466430664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.fct_esg_carbon_footprint_uncertainty", "compiled": true, "compiled_code": "\n\nWITH node_country_distribution AS (\n    -- Get node distribution by country and category with their carbon intensities\n    SELECT\n        date,\n        node_category,\n        country_code,\n        estimated_total_nodes,\n        nodes_lower_95,\n        nodes_upper_95,\n        carbon_intensity_gco2_kwh,\n        daily_energy_kwh_mean,\n        avg_power_watts_per_node,\n        power_std_dev_per_node,\n        daily_co2_kg_mean,\n        daily_co2_kg_std\n    FROM `dbt`.`int_esg_dynamic_power_consumption`\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`)\n    \n),\n\n-- Calculate network effective CIF from geographic distribution\nnetwork_effective_cif AS (\n    SELECT\n        date,\n        -- Network Effective CIF = \u03a3(nodes_in_country \u00d7 country_CIF) / total_nodes\n        SUM(estimated_total_nodes * carbon_intensity_gco2_kwh) / \n        NULLIF(SUM(estimated_total_nodes), 0) AS network_weighted_cif,\n        \n        -- Weighted standard deviation of network CIF\n        -- Using variance formula: Var = \u03a3(w_i * (x_i - mean)\u00b2) / \u03a3(w_i)\n        -- Then std = sqrt(var)\n        SQRT(\n            SUM(estimated_total_nodes * pow(carbon_intensity_gco2_kwh, 2)) / NULLIF(SUM(estimated_total_nodes), 0) -\n            pow(SUM(estimated_total_nodes * carbon_intensity_gco2_kwh) / NULLIF(SUM(estimated_total_nodes), 0), 2)\n        ) AS network_cif_std\n    FROM node_country_distribution\n    GROUP BY date\n),\n\ndaily_power_data AS (\n    -- Aggregate power consumption across all categories and countries\n    SELECT\n        date,\n        node_category,\n        \n        -- Node counts with uncertainty\n        SUM(estimated_total_nodes) AS category_nodes,\n        SUM(nodes_lower_95) AS category_nodes_lower_95,\n        SUM(nodes_upper_95) AS category_nodes_upper_95,\n        \n        -- Energy totals with uncertainty calculation\n        SUM(daily_energy_kwh_mean) AS category_energy_kwh_mean,\n        \n        -- Energy standard deviation (propagate uncertainty from power and node count)\n        SQRT(SUM(\n            pow(power_std_dev_per_node * estimated_total_nodes * 24 / 1000.0, 2) + \n            pow(avg_power_watts_per_node * (nodes_upper_95 - nodes_lower_95) / 3.92 * 24 / 1000.0, 2)\n        )) AS category_energy_kwh_std,\n        \n        -- Carbon totals\n        SUM(daily_co2_kg_mean) AS category_co2_kg,\n        SQRT(SUM(pow(daily_co2_kg_std, 2))) AS category_co2_kg_std,\n        \n        -- Weighted averages\n        SUM(daily_energy_kwh_mean * estimated_total_nodes) / NULLIF(SUM(estimated_total_nodes), 0) AS weighted_avg_energy_per_node,\n        SUM(daily_co2_kg_mean * estimated_total_nodes) / NULLIF(SUM(estimated_total_nodes), 0) AS weighted_avg_co2_per_node,\n        \n        -- Country count for this category\n        COUNT(DISTINCT country_code) AS countries_represented\n        \n    FROM node_country_distribution\n    \n        WHERE date > (SELECT MAX(date) FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`)\n    \n    GROUP BY date, node_category\n),\n\nnetwork_totals AS (\n    -- Calculate network-wide totals with full uncertainty propagation\n    SELECT\n        date,\n        \n        -- Total network size with bounds\n        SUM(category_nodes) AS total_estimated_nodes,\n        SUM(category_nodes_lower_95) AS total_nodes_lower_95,\n        SUM(category_nodes_upper_95) AS total_nodes_upper_95,\n        \n        -- Total energy consumption with uncertainty\n        SUM(category_energy_kwh_mean) AS total_energy_kwh_mean,\n        SQRT(SUM(pow(category_energy_kwh_std, 2))) AS total_energy_kwh_std,\n        \n        -- Total emissions with error propagation\n        SUM(category_co2_kg) AS total_co2_kg_mean,\n        SQRT(SUM(pow(category_co2_kg_std, 2))) AS total_co2_kg_std,\n        \n        -- Category breakdown for energy\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_energy_kwh_mean ELSE 0 END) AS home_staker_energy_kwh,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_energy_kwh_mean ELSE 0 END) AS professional_energy_kwh,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_energy_kwh_mean ELSE 0 END) AS cloud_energy_kwh,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_energy_kwh_mean ELSE 0 END) AS unknown_energy_kwh,\n        \n        -- Category breakdown for carbon\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_co2_kg ELSE 0 END) AS home_staker_co2_kg,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_co2_kg ELSE 0 END) AS professional_co2_kg,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_co2_kg ELSE 0 END) AS cloud_co2_kg,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_co2_kg ELSE 0 END) AS unknown_co2_kg,\n        \n        -- Node breakdown\n        SUM(CASE WHEN node_category = 'home_staker' THEN category_nodes ELSE 0 END) AS home_staker_nodes,\n        SUM(CASE WHEN node_category = 'professional_operator' THEN category_nodes ELSE 0 END) AS professional_nodes,\n        SUM(CASE WHEN node_category = 'cloud_hosted' THEN category_nodes ELSE 0 END) AS cloud_nodes,\n        SUM(CASE WHEN node_category = 'unknown' THEN category_nodes ELSE 0 END) AS unknown_nodes,\n        \n        -- Quality metrics\n        COUNT(DISTINCT CASE WHEN category_nodes > 0 THEN node_category END) AS active_categories,\n        MAX(countries_represented) AS max_countries_in_category\n        \n    FROM daily_power_data\n    GROUP BY date\n),\n\n-- Add Chao-1 population estimates for comparison\nchao1_comparison AS (\n    SELECT\n        nt.date AS date,\n        nt.*,\n        necif.network_weighted_cif,\n        necif.network_cif_std,\n        \n        -- Link to Chao-1 estimates\n        c.observed_successful_nodes AS chao1_observed,\n        c.enhanced_total_reachable AS chao1_estimated,\n        c.connection_success_rate_pct AS chao1_success_rate,\n        c.reachable_discovery_coverage_pct AS chao1_coverage,\n        \n        -- Compare our estimates to Chao-1\n        round(100.0 * nt.total_estimated_nodes / NULLIF(c.enhanced_total_reachable, 0), 1) AS node_estimate_vs_chao1_pct,\n        \n        -- Calculate scaling factor applied\n        round(toFloat64(nt.total_estimated_nodes) / NULLIF(c.observed_successful_nodes, 0), 2) AS applied_scaling_factor\n        \n    FROM network_totals nt\n    JOIN network_effective_cif necif ON nt.date = necif.date\n    LEFT JOIN `dbt`.`int_esg_node_population_chao1` c\n        ON c.observation_date = nt.date\n),\n\nenhanced_statistics AS (\n    SELECT\n        date,\n        \n        -- Node population metrics with bounds\n        total_estimated_nodes,\n        total_nodes_lower_95,\n        total_nodes_upper_95,\n        chao1_observed,\n        chao1_estimated,\n        chao1_success_rate,\n        chao1_coverage,\n        node_estimate_vs_chao1_pct,\n        applied_scaling_factor,\n        \n        -- Network carbon intensity with uncertainty\n        round(network_weighted_cif, 2) AS network_carbon_intensity_gco2_kwh,\n        round(network_cif_std, 2) AS network_carbon_intensity_std,\n        \n        -- Daily energy metrics with full uncertainty bands\n        round(total_energy_kwh_mean, 2) AS daily_energy_kwh_mean,\n        round(total_energy_kwh_std, 2) AS daily_energy_kwh_std,\n        \n        -- Daily energy confidence intervals (95%)\n        round(greatest(0, total_energy_kwh_mean - 1.96 * total_energy_kwh_std), 2) AS daily_energy_kwh_lower_95,\n        round(total_energy_kwh_mean + 1.96 * total_energy_kwh_std, 2) AS daily_energy_kwh_upper_95,\n        \n        -- Daily energy confidence intervals (90%)\n        round(greatest(0, total_energy_kwh_mean - 1.645 * total_energy_kwh_std), 2) AS daily_energy_kwh_lower_90,\n        round(total_energy_kwh_mean + 1.645 * total_energy_kwh_std, 2) AS daily_energy_kwh_upper_90,\n        \n        -- Annual energy projections with uncertainty\n        round(total_energy_kwh_mean * 365 / 1000, 2) AS annual_energy_mwh_mean,\n        round(total_energy_kwh_std * sqrt(365) / 1000, 2) AS annual_energy_mwh_std,\n        \n        -- Annual energy confidence intervals (95%)\n        round(greatest(0, (total_energy_kwh_mean * 365 / 1000) - 1.96 * (total_energy_kwh_std * sqrt(365) / 1000)), 2) AS annual_energy_mwh_lower_95,\n        round((total_energy_kwh_mean * 365 / 1000) + 1.96 * (total_energy_kwh_std * sqrt(365) / 1000), 2) AS annual_energy_mwh_upper_95,\n        \n        -- Annual energy confidence intervals (90%)\n        round(greatest(0, (total_energy_kwh_mean * 365 / 1000) - 1.645 * (total_energy_kwh_std * sqrt(365) / 1000)), 2) AS annual_energy_mwh_lower_90,\n        round((total_energy_kwh_mean * 365 / 1000) + 1.645 * (total_energy_kwh_std * sqrt(365) / 1000), 2) AS annual_energy_mwh_upper_90,\n        \n        -- Carbon emissions (primary metrics)\n        round(total_co2_kg_mean, 2) AS daily_co2_kg_mean,\n        round(total_co2_kg_std, 2) AS daily_co2_kg_std,\n        \n        -- Daily CO2 confidence intervals (95%)\n        round(greatest(0, total_co2_kg_mean - 1.96 * total_co2_kg_std), 2) AS daily_co2_kg_lower_95,\n        round(total_co2_kg_mean + 1.96 * total_co2_kg_std, 2) AS daily_co2_kg_upper_95,\n        \n        -- Daily CO2 confidence intervals (90%)\n        round(greatest(0, total_co2_kg_mean - 1.645 * total_co2_kg_std), 2) AS daily_co2_kg_lower_90,\n        round(total_co2_kg_mean + 1.645 * total_co2_kg_std, 2) AS daily_co2_kg_upper_90,\n        \n        -- Annual CO2 projections\n        round(total_co2_kg_mean * 365 / 1000, 2) AS annual_co2_tonnes_mean,\n        round(total_co2_kg_std * sqrt(365) / 1000, 2) AS annual_co2_tonnes_std,\n        \n        -- Category breakdowns for energy\n        round(home_staker_energy_kwh, 2) AS home_staker_energy_kwh_daily,\n        round(professional_energy_kwh, 2) AS professional_energy_kwh_daily,\n        round(cloud_energy_kwh, 2) AS cloud_energy_kwh_daily,\n        round(unknown_energy_kwh, 2) AS unknown_energy_kwh_daily,\n        \n        -- Category breakdowns for carbon\n        round(home_staker_co2_kg, 2) AS home_staker_co2_kg_daily,\n        round(professional_co2_kg, 2) AS professional_co2_kg_daily,\n        round(cloud_co2_kg, 2) AS cloud_co2_kg_daily,\n        round(unknown_co2_kg, 2) AS unknown_co2_kg_daily,\n        \n        -- Category percentages\n        round(100.0 * home_staker_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS home_staker_pct,\n        round(100.0 * professional_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS professional_pct,\n        round(100.0 * cloud_co2_kg / NULLIF(total_co2_kg_mean, 0), 1) AS cloud_pct,\n        \n        -- Node distribution\n        home_staker_nodes,\n        professional_nodes,\n        cloud_nodes,\n        unknown_nodes,\n        \n        -- Relative uncertainties\n        round(100.0 * total_energy_kwh_std / NULLIF(total_energy_kwh_mean, 0), 1) AS energy_relative_uncertainty_pct,\n        round(100.0 * total_co2_kg_std / NULLIF(total_co2_kg_mean, 0), 1) AS carbon_relative_uncertainty_pct,\n        \n        -- Quality metrics\n        active_categories,\n        max_countries_in_category AS countries_with_nodes\n        \n    FROM chao1_comparison\n)\n\nSELECT\n    date,\n    \n    -- PRIMARY CARBON FOOTPRINT METRICS WITH BANDS\n    daily_co2_kg_mean,\n    daily_co2_kg_std,\n    daily_co2_kg_lower_95,\n    daily_co2_kg_upper_95,\n    daily_co2_kg_lower_90,\n    daily_co2_kg_upper_90,\n    \n    -- Annual CO2 projections with uncertainty bands\n    annual_co2_tonnes_mean AS annual_co2_tonnes_projected,\n    annual_co2_tonnes_std,\n    round(greatest(0, annual_co2_tonnes_mean - 1.96 * annual_co2_tonnes_std), 2) AS annual_co2_tonnes_lower_95,\n    round(annual_co2_tonnes_mean + 1.96 * annual_co2_tonnes_std, 2) AS annual_co2_tonnes_upper_95,\n    round(greatest(0, annual_co2_tonnes_mean - 1.645 * annual_co2_tonnes_std), 2) AS annual_co2_tonnes_lower_90,\n    round(annual_co2_tonnes_mean + 1.645 * annual_co2_tonnes_std, 2) AS annual_co2_tonnes_upper_90,\n    \n    -- PRIMARY ENERGY METRICS WITH BANDS\n    daily_energy_kwh_mean AS daily_energy_kwh_total,\n    daily_energy_kwh_std,\n    daily_energy_kwh_lower_95,\n    daily_energy_kwh_upper_95,\n    daily_energy_kwh_lower_90,\n    daily_energy_kwh_upper_90,\n    \n    -- Annual energy projections with uncertainty bands\n    annual_energy_mwh_mean AS annual_energy_Mwh_projected,\n    annual_energy_mwh_std,\n    annual_energy_mwh_lower_95,\n    annual_energy_mwh_upper_95,\n    annual_energy_mwh_lower_90,\n    annual_energy_mwh_upper_90,\n    \n    -- NETWORK CARBON INTENSITY WITH UNCERTAINTY\n    network_carbon_intensity_gco2_kwh AS effective_carbon_intensity,\n    network_carbon_intensity_std AS effective_carbon_intensity_std,\n    round(greatest(0, network_carbon_intensity_gco2_kwh - 1.96 * network_carbon_intensity_std), 2) AS effective_carbon_intensity_lower_95,\n    round(network_carbon_intensity_gco2_kwh + 1.96 * network_carbon_intensity_std, 2) AS effective_carbon_intensity_upper_95,\n    \n    -- NODE POPULATION WITH BOUNDS\n    total_estimated_nodes AS estimated_nodes,\n    total_nodes_lower_95 AS nodes_lower_95,\n    total_nodes_upper_95 AS nodes_upper_95,\n    \n    -- Category breakdown for energy (daily)\n    home_staker_energy_kwh_daily,\n    professional_energy_kwh_daily,\n    cloud_energy_kwh_daily,\n    unknown_energy_kwh_daily,\n    \n    -- Category breakdown for emissions (daily)\n    home_staker_co2_kg_daily,\n    professional_co2_kg_daily,\n    cloud_co2_kg_daily,\n    unknown_co2_kg_daily,\n    \n    -- Category percentages\n    home_staker_pct,\n    professional_pct,\n    cloud_pct,\n    \n    -- Node distribution by category\n    home_staker_nodes,\n    professional_nodes,\n    cloud_nodes,\n    unknown_nodes,\n    \n    -- UNCERTAINTY METRICS\n    energy_relative_uncertainty_pct,\n    carbon_relative_uncertainty_pct,\n    \n    -- Quality metrics\n    active_categories AS node_categories_active,\n    countries_with_nodes,\n    \n    -- Comparison with Chao-1 estimates\n    chao1_observed AS baseline_observed_nodes,\n    chao1_estimated AS chao1_total_estimated,\n    node_estimate_vs_chao1_pct,\n    applied_scaling_factor,\n    round(chao1_success_rate, 1) AS network_reachability_pct,\n    round(chao1_coverage, 1) AS discovery_completeness_pct,\n    \n    -- PER-NODE METRICS WITH BOUNDS\n    round(daily_co2_kg_mean / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS grams_co2_per_node_daily,\n    round(daily_energy_kwh_mean / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS wh_per_node_daily,\n    \n    -- Per-node uncertainty bands\n    round(greatest(0, (daily_co2_kg_mean - 1.96 * daily_co2_kg_std) / NULLIF(total_estimated_nodes, 0) * 1000), 1) AS grams_co2_per_node_lower_95,\n    round((daily_co2_kg_mean + 1.96 * daily_co2_kg_std) / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS grams_co2_per_node_upper_95,\n    \n    round(greatest(0, (daily_energy_kwh_mean - 1.96 * daily_energy_kwh_std) / NULLIF(total_estimated_nodes, 0) * 1000), 1) AS wh_per_node_lower_95,\n    round((daily_energy_kwh_mean + 1.96 * daily_energy_kwh_std) / NULLIF(total_estimated_nodes, 0) * 1000, 1) AS wh_per_node_upper_95\n    \nFROM enhanced_statistics\nORDER BY date DESC", "relation_name": "`dbt`.`fct_esg_carbon_footprint_uncertainty`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.488920Z", "completed_at": "2025-10-24T12:23:14.492713Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.493297Z", "completed_at": "2025-10-24T12:23:14.493305Z"}], "thread_id": "Thread-1", "execution_time": 0.005847454071044922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_active_ongoing_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'active_ongoing'", "relation_name": "`dbt`.`api_consensus_info_active_ongoing_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.495899Z", "completed_at": "2025-10-24T12:23:14.499666Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.500234Z", "completed_at": "2025-10-24T12:23:14.500242Z"}], "thread_id": "Thread-1", "execution_time": 0.005597829818725586, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_apy_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'APY7D'", "relation_name": "`dbt`.`api_consensus_info_apy_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.502815Z", "completed_at": "2025-10-24T12:23:14.506641Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.507205Z", "completed_at": "2025-10-24T12:23:14.507214Z"}], "thread_id": "Thread-1", "execution_time": 0.005621194839477539, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_deposits_cnt_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'deposits_cnt'", "relation_name": "`dbt`.`api_consensus_info_deposits_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.509765Z", "completed_at": "2025-10-24T12:23:14.514747Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.515324Z", "completed_at": "2025-10-24T12:23:14.515332Z"}], "thread_id": "Thread-1", "execution_time": 0.00677490234375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_staked_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    toUInt32(value) AS value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'Staked'", "relation_name": "`dbt`.`api_consensus_info_staked_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.517919Z", "completed_at": "2025-10-24T12:23:14.521690Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.522274Z", "completed_at": "2025-10-24T12:23:14.522281Z"}], "thread_id": "Thread-1", "execution_time": 0.005614519119262695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_consensus_info_withdrawls_cnt_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    value\n    ,change_pct\nFROM \n    `dbt`.`fct_consensus_info_latest`\nWHERE\n    label = 'withdrawls_cnt'", "relation_name": "`dbt`.`api_consensus_info_withdrawls_cnt_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.524825Z", "completed_at": "2025-10-24T12:23:14.528576Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.529135Z", "completed_at": "2025-10-24T12:23:14.529143Z"}], "thread_id": "Thread-1", "execution_time": 0.005541801452636719, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_project_7d", "compiled": true, "compiled_code": "\nSELECT t.bucket AS label, t.value, t.change_pct\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'ActiveAccounts' AND t.window = '7D'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_project_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.531779Z", "completed_at": "2025-10-24T12:23:14.535538Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.536099Z", "completed_at": "2025-10-24T12:23:14.536107Z"}], "thread_id": "Thread-1", "execution_time": 0.00555109977722168, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_by_project_total", "compiled": true, "compiled_code": "\nSELECT bucket AS label, value\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` t\nWHERE t.label = 'ActiveAccounts' AND window = 'All'\nORDER BY value DESC", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_by_project_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.538771Z", "completed_at": "2025-10-24T12:23:14.542505Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.543053Z", "completed_at": "2025-10-24T12:23:14.543061Z"}], "thread_id": "Thread-1", "execution_time": 0.005591869354248047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_project_7d", "compiled": true, "compiled_code": "\nSELECT t.bucket AS label, t.value, t.change_pct\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'Transactions' AND t.window = '7D'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_by_project_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.545612Z", "completed_at": "2025-10-24T12:23:14.550561Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.551120Z", "completed_at": "2025-10-24T12:23:14.551128Z"}], "thread_id": "Thread-1", "execution_time": 0.0067365169525146484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_by_project_total", "compiled": true, "compiled_code": "\nSELECT t.bucket AS label, t.value\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'Transactions' AND t.window = 'All'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_by_project_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.553701Z", "completed_at": "2025-10-24T12:23:14.633075Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.633675Z", "completed_at": "2025-10-24T12:23:14.633685Z"}], "thread_id": "Thread-1", "execution_time": 0.08122491836547852, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_project_7d", "compiled": true, "compiled_code": "\nSELECT t.bucket AS label, t.value, t.change_pct\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'FeesNative' AND t.window = '7D'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_project_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.636320Z", "completed_at": "2025-10-24T12:23:14.640141Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.640735Z", "completed_at": "2025-10-24T12:23:14.640743Z"}], "thread_id": "Thread-1", "execution_time": 0.005692005157470703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_by_project_total", "compiled": true, "compiled_code": "\nSELECT t.bucket AS label, t.value\nFROM `dbt`.`fct_execution_transactions_by_project_snapshots` AS t\nWHERE t.label = 'FeesNative' AND t.window = 'All'\nORDER BY t.value DESC", "relation_name": "`dbt`.`api_execution_transactions_fees_native_by_project_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.643324Z", "completed_at": "2025-10-24T12:23:14.647017Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.647599Z", "completed_at": "2025-10-24T12:23:14.647608Z"}], "thread_id": "Thread-1", "execution_time": 0.005485057830810547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_7d", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'Transactions' AND window = '7D'", "relation_name": "`dbt`.`api_execution_transactions_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.650151Z", "completed_at": "2025-10-24T12:23:14.653875Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.654459Z", "completed_at": "2025-10-24T12:23:14.654466Z"}], "thread_id": "Thread-1", "execution_time": 0.00551295280456543, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_7d", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'ActiveAccounts' AND window = '7D'", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.656998Z", "completed_at": "2025-10-24T12:23:14.660698Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.661304Z", "completed_at": "2025-10-24T12:23:14.661312Z"}], "thread_id": "Thread-1", "execution_time": 0.005511760711669922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_active_accounts_total", "compiled": true, "compiled_code": "\nSELECT value\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'ActiveAccounts' AND window = 'All'", "relation_name": "`dbt`.`api_execution_transactions_active_accounts_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.663934Z", "completed_at": "2025-10-24T12:23:14.667727Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.668301Z", "completed_at": "2025-10-24T12:23:14.668309Z"}], "thread_id": "Thread-1", "execution_time": 0.005578517913818359, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_7d", "compiled": true, "compiled_code": "\nSELECT value, change_pct\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'FeesNative' AND window = '7D'", "relation_name": "`dbt`.`api_execution_transactions_fees_native_7d`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.670862Z", "completed_at": "2025-10-24T12:23:14.675750Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.676334Z", "completed_at": "2025-10-24T12:23:14.676342Z"}], "thread_id": "Thread-1", "execution_time": 0.0066852569580078125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_fees_native_total", "compiled": true, "compiled_code": "\nSELECT value\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'FeesNative' AND window = 'All'", "relation_name": "`dbt`.`api_execution_transactions_fees_native_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.678893Z", "completed_at": "2025-10-24T12:23:14.682579Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.683133Z", "completed_at": "2025-10-24T12:23:14.683141Z"}], "thread_id": "Thread-1", "execution_time": 0.00547480583190918, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_execution_transactions_total", "compiled": true, "compiled_code": "\nSELECT value\nFROM `dbt`.`fct_execution_transactions_snapshots`\nWHERE label = 'Transactions' AND window = 'All'", "relation_name": "`dbt`.`api_execution_transactions_total`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.685715Z", "completed_at": "2025-10-24T12:23:14.689439Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.689991Z", "completed_at": "2025-10-24T12:23:14.689999Z"}], "thread_id": "Thread-1", "execution_time": 0.0054891109466552734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_emissions_annualised_latest", "compiled": true, "compiled_code": "\n\nSELECT\n    annual_co2_tonnes_projected\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date DESC \nLIMIT 1", "relation_name": "`dbt`.`api_esg_carbon_emissions_annualised_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.692557Z", "completed_at": "2025-10-24T12:23:14.696353Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.696911Z", "completed_at": "2025-10-24T12:23:14.696918Z"}], "thread_id": "Thread-1", "execution_time": 0.005561351776123047, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_emissions_daily", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    AVG(daily_co2_kg_mean) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_value,\n    AVG(daily_co2_kg_lower_90) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_90,\n    AVG(daily_co2_kg_upper_90) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_90,\n    AVG(daily_co2_kg_lower_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_95,\n    AVG(daily_co2_kg_upper_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_95\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date", "relation_name": "`dbt`.`api_esg_carbon_emissions_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.699499Z", "completed_at": "2025-10-24T12:23:14.703297Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.703852Z", "completed_at": "2025-10-24T12:23:14.703860Z"}], "thread_id": "Thread-1", "execution_time": 0.005580902099609375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_carbon_timeseries_bands", "compiled": true, "compiled_code": "\n\n\nSELECT\n    date,\n    daily_co2_kg_mean AS value,\n    daily_co2_kg_lower_95 AS lower_95,\n    daily_co2_kg_upper_95 AS upper_95,\n    daily_co2_kg_lower_90 AS lower_90,\n    daily_co2_kg_upper_90 AS upper_90,\n    \n    -- Moving averages for smoothing\n    AVG(daily_co2_kg_mean) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_value,\n    AVG(daily_co2_kg_lower_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_lower_95,\n    AVG(daily_co2_kg_upper_95) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7_upper_95,\n    \n    -- Month-to-date statistics\n    AVG(daily_co2_kg_mean) OVER (PARTITION BY toStartOfMonth(date) ORDER BY date) AS mtd_avg,\n    SUM(daily_co2_kg_mean) OVER (PARTITION BY toStartOfMonth(date) ORDER BY date) AS mtd_total\n    \nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`", "relation_name": "`dbt`.`api_esg_carbon_timeseries_bands`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.706413Z", "completed_at": "2025-10-24T12:23:14.711720Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.712298Z", "completed_at": "2025-10-24T12:23:14.712306Z"}], "thread_id": "Thread-1", "execution_time": 0.007097959518432617, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_cif_network_vs_countries_daily", "compiled": true, "compiled_code": "\n\n\nWITH network_daily_cif AS (\n    -- Get network's daily effective carbon intensity\n    SELECT\n        date,\n        effective_carbon_intensity AS carbon_intensity,\n        'GNOSIS' AS entity_code\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE effective_carbon_intensity IS NOT NULL\n        AND effective_carbon_intensity > 0\n),\n\ncountry_monthly_cif AS (\n    -- Get all monthly country carbon intensities \n    SELECT\n        ci.country_code,\n        ci.carbon_intensity_mean AS carbon_intensity,\n        ci.month_date\n    FROM `dbt`.`int_esg_carbon_intensity_ensemble` ci\n    WHERE ci.country_code != 'WORLD'\n        AND ci.carbon_intensity_mean IS NOT NULL\n        AND ci.carbon_intensity_mean > 0\n        AND ci.country_code IN (\n            'USA',  -- United States\n            'DEU',  -- Germany  \n            'CHN',  -- China\n            'FRA',  -- France\n            'SWE',  -- Sweden \n            'AUS',  -- Australia\n            'BRA',  -- Brazil\n            'ISL'   -- Iceland\n        )\n),\n\ncountry_timeseries AS (\n    -- Join countries to dates using the correct month's CIF\n    SELECT\n        nd.date,\n        cm.carbon_intensity,\n        cm.country_code AS entity_code\n    FROM network_daily_cif nd\n    JOIN country_monthly_cif cm \n        ON cm.month_date = toStartOfMonth(nd.date)  -- Match date to its month\n),\n\n-- Combine network and country data\ncombined_data AS (\n    SELECT * FROM network_daily_cif\n    UNION ALL\n    SELECT * FROM country_timeseries\n),\n\n-- Add comparison metrics\nwith_comparisons AS (\n    SELECT\n        cd.*,\n        nd.carbon_intensity AS network_cif\n    FROM combined_data cd\n    LEFT JOIN network_daily_cif nd ON cd.date = nd.date\n)\n\nSELECT\n    date,\n    entity_code,\n    round(carbon_intensity, 1) AS carbon_intensity_gco2_kwh\nFROM with_comparisons\nORDER BY date, entity_code, carbon_intensity_gco2_kwh DESC", "relation_name": "`dbt`.`api_esg_cif_network_vs_countries_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.714865Z", "completed_at": "2025-10-24T12:23:14.718643Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.719223Z", "completed_at": "2025-10-24T12:23:14.719231Z"}], "thread_id": "Thread-1", "execution_time": 0.005582571029663086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_energy_consumption_annualised_latest", "compiled": true, "compiled_code": "\n\n\nSELECT\n    annual_energy_Mwh_projected\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nORDER BY date DESC \nLIMIT 1", "relation_name": "`dbt`.`api_esg_energy_consumption_annualised_latest`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.721769Z", "completed_at": "2025-10-24T12:23:14.725514Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.726081Z", "completed_at": "2025-10-24T12:23:14.726089Z"}], "thread_id": "Thread-1", "execution_time": 0.005517244338989258, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_energy_monthly", "compiled": true, "compiled_code": "\n\n\nSELECT toStartOfMonth(date) AS date, SUM(daily_energy_kwh_total) AS value\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nGROUP BY 1\nORDER BY date", "relation_name": "`dbt`.`api_esg_energy_monthly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.728652Z", "completed_at": "2025-10-24T12:23:14.732446Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.733008Z", "completed_at": "2025-10-24T12:23:14.733015Z"}], "thread_id": "Thread-1", "execution_time": 0.005570650100708008, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_estimated_nodes_daily", "compiled": true, "compiled_code": "\n\n\n\nSELECT \n    date\n    ,baseline_observed_nodes\n    ,estimated_nodes\n    ,nodes_lower_95\n    ,nodes_upper_95\nFROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\nWHERE toStartOfMonth(date) < toStartOfMonth(today())\nORDER BY date", "relation_name": "`dbt`.`api_esg_estimated_nodes_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.735559Z", "completed_at": "2025-10-24T12:23:14.739655Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.740233Z", "completed_at": "2025-10-24T12:23:14.740241Z"}], "thread_id": "Thread-1", "execution_time": 0.005873918533325195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_info_annual_daily", "compiled": true, "compiled_code": "\n\nSELECT \n    date\n    ,label\n    ,mean_val\n    ,lower_95\n    ,upper_95\n    ,lower_90\n    ,upper_90\nFROM (\n    SELECT \n        date\n        ,'Energy (MWh)' AS label\n        ,annual_energy_Mwh_projected AS mean_val\n        ,annual_energy_mwh_lower_95 AS lower_95\n        ,annual_energy_mwh_upper_95 AS upper_95\n        ,annual_energy_mwh_lower_90 AS lower_90\n        ,annual_energy_mwh_upper_90 AS upper_90\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT \n        date\n        ,'CO2e (tonnes)' AS label\n        ,annual_co2_tonnes_projected AS mean_val\n        ,annual_co2_tonnes_lower_95 AS lower_95\n        ,annual_co2_tonnes_upper_95 AS upper_95\n        ,annual_co2_tonnes_lower_90 AS lower_90\n        ,annual_co2_tonnes_upper_90 AS upper_90\n    FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n)\nORDER BY date, label", "relation_name": "`dbt`.`api_esg_info_annual_daily`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-10-24T12:23:14.742798Z", "completed_at": "2025-10-24T12:23:14.749433Z"}, {"name": "execute", "started_at": "2025-10-24T12:23:14.749990Z", "completed_at": "2025-10-24T12:23:14.749997Z"}], "thread_id": "Thread-1", "execution_time": 0.00840139389038086, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.gnosis_dbt.api_esg_info_category_daily", "compiled": true, "compiled_code": "\n\n\n\n\nSELECT \n    date\n    ,label\n    ,category\n    ,value\nFROM (\n    SELECT date, 'Home Staker' AS label, 'CO2e (kg)' AS category, home_staker_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'CO2e (kg)' AS category, professional_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'CO2e (kg)' AS category, cloud_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'CO2e (kg)' AS category, unknown_co2_kg_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n\n    UNION ALL \n\n    SELECT date, 'Home Staker' AS label, 'Energy (kWh)' AS category, home_staker_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'Energy (kWh)' AS category, professional_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'Energy (kWh)' AS category, cloud_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'Energy (kWh)' AS category, unknown_energy_kwh_daily AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n\n    UNION ALL \n\n    SELECT date, 'Home Staker' AS label, 'Nodes' AS category, CAST(home_staker_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Professional Validator' AS label, 'Nodes' AS category, CAST(professional_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Cloud Provider' AS label, 'Nodes' AS category, CAST(cloud_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n    UNION ALL\n    SELECT date, 'Unknown' AS label, 'Nodes' AS category, CAST(unknown_nodes AS Float64) AS value FROM `dbt`.`fct_esg_carbon_footprint_uncertainty`\n    WHERE toStartOfMonth(date) < toStartOfMonth(today())\n)\nORDER BY date, label, category", "relation_name": "`dbt`.`api_esg_info_category_daily`", "batch_results": null}], "elapsed_time": 3.1533737182617188, "args": {"log_file_max_bytes": 10485760, "favor_state": false, "introspect": true, "state_modified_compare_more_unrendered_values": false, "warn_error_options": {"include": [], "exclude": []}, "printer_width": 80, "macro_debugging": false, "select": [], "static_parser": true, "log_path": "/home/runner/work/dbt-cerebro/dbt-cerebro/logs", "require_explicit_package_overrides_for_builtin_materializations": true, "require_resource_names_without_spaces": false, "strict_mode": false, "require_batched_execution_for_custom_microbatch_strategy": false, "project_dir": "/home/runner/work/dbt-cerebro/dbt-cerebro", "empty_catalog": false, "show_resource_report": false, "vars": {}, "indirect_selection": "eager", "compile": true, "skip_nodes_if_on_run_start_fails": false, "log_level_file": "debug", "log_level": "info", "which": "generate", "log_format_file": "debug", "static": false, "cache_selected_only": false, "log_format": "default", "require_yaml_configuration_for_mf_time_spines": false, "use_colors": true, "require_nested_cumulative_type_params": false, "version_check": true, "print": true, "quiet": false, "defer": false, "exclude": [], "source_freshness_run_project_hooks": false, "write_json": true, "partial_parse_file_diff": true, "invocation_command": "dbt docs generate", "send_anonymous_usage_stats": true, "populate_cache": true, "profiles_dir": "/home/runner/work/dbt-cerebro/dbt-cerebro", "state_modified_compare_vars": false, "use_colors_file": true, "partial_parse": true}}